propType;
            }
            return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
        }
        function checkPropertyNotUsedBeforeDeclaration(prop, node, right) {
            var valueDeclaration = prop.valueDeclaration;
            if (!valueDeclaration || ts.getSourceFileOfNode(node).isDeclarationFile) {
                return;
            }
            var diagnosticMessage;
            var declarationName = ts.idText(right);
            if (isInPropertyInitializer(node)
                && !(ts.isAccessExpression(node) && ts.isAccessExpression(node.expression))
                && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right)
                && !isPropertyDeclaredInAncestorClass(prop)) {
                diagnosticMessage = error(right, ts.Diagnostics.Property_0_is_used_before_its_initialization, declarationName);
            }
            else if (valueDeclaration.kind === 245 &&
                node.parent.kind !== 169 &&
                !(valueDeclaration.flags & 8388608) &&
                !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right)) {
                diagnosticMessage = error(right, ts.Diagnostics.Class_0_used_before_its_declaration, declarationName);
            }
            if (diagnosticMessage) {
                ts.addRelatedInfo(diagnosticMessage, ts.createDiagnosticForNode(valueDeclaration, ts.Diagnostics._0_is_declared_here, declarationName));
            }
        }
        function isInPropertyInitializer(node) {
            return !!ts.findAncestor(node, function (node) {
                switch (node.kind) {
                    case 159:
                        return true;
                    case 281:
                    case 161:
                    case 163:
                    case 164:
                    case 283:
                    case 154:
                    case 221:
                    case 276:
                    case 273:
                    case 274:
                    case 275:
                    case 268:
                    case 216:
                    case 279:
                        return false;
                    default:
                        return ts.isExpressionNode(node) ? false : "quit";
                }
            });
        }
        function isPropertyDeclaredInAncestorClass(prop) {
            if (!(prop.parent.flags & 32)) {
                return false;
            }
            var classType = getTypeOfSymbol(prop.parent);
            while (true) {
                classType = classType.symbol && getSuperClass(classType);
                if (!classType) {
                    return false;
                }
                var superProperty = getPropertyOfType(classType, prop.escapedName);
                if (superProperty && superProperty.valueDeclaration) {
                    return true;
                }
            }
        }
        function getSuperClass(classType) {
            var x = getBaseTypes(classType);
            if (x.length === 0) {
                return undefined;
            }
            return getIntersectionType(x);
        }
        function reportNonexistentProperty(propNode, containingType) {
            var errorInfo;
            var relatedInfo;
            if (!ts.isPrivateIdentifier(propNode) && containingType.flags & 1048576 && !(containingType.flags & 131068)) {
                for (var _i = 0, _a = containingType.types; _i < _a.length; _i++) {
                    var subtype = _a[_i];
                    if (!getPropertyOfType(subtype, propNode.escapedText) && !getIndexInfoOfType(subtype, 0)) {
                        errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.declarationNameToString(propNode), typeToString(subtype));
                        break;
                    }
                }
            }
            if (typeHasStaticProperty(propNode.escapedText, containingType)) {
                errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_is_a_static_member_of_type_1, ts.declarationNameToString(propNode), typeToString(containingType));
            }
            else {
                var promisedType = getPromisedTypeOfPromise(containingType);
                if (promisedType && getPropertyOfType(promisedType, propNode.escapedText)) {
                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.declarationNameToString(propNode), typeToString(containingType));
                    relatedInfo = ts.createDiagnosticForNode(propNode, ts.Diagnostics.Did_you_forget_to_use_await);
                }
                else {
                    var suggestion = getSuggestedSymbolForNonexistentProperty(propNode, containingType);
                    if (suggestion !== undefined) {
                        var suggestedName = ts.symbolName(suggestion);
                        errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, ts.declarationNameToString(propNode), typeToString(containingType), suggestedName);
                        relatedInfo = suggestion.valueDeclaration && ts.createDiagnosticForNode(suggestion.valueDeclaration, ts.Diagnostics._0_is_declared_here, suggestedName);
                    }
                    else {
                        errorInfo = ts.chainDiagnosticMessages(elaborateNeverIntersection(errorInfo, containingType), ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.declarationNameToString(propNode), typeToString(containingType));
                    }
                }
            }
            var resultDiagnostic = ts.createDiagnosticForNodeFromMessageChain(propNode, errorInfo);
            if (relatedInfo) {
                ts.addRelatedInfo(resultDiagnostic, relatedInfo);
            }
            diagnostics.add(resultDiagnostic);
        }
        function typeHasStaticProperty(propName, containingType) {
            var prop = containingType.symbol && getPropertyOfType(getTypeOfSymbol(containingType.symbol), propName);
            return prop !== undefined && prop.valueDeclaration && ts.hasModifier(prop.valueDeclaration, 32);
        }
        function getSuggestedSymbolForNonexistentProperty(name, containingType) {
            return getSpellingSuggestionForName(ts.isString(name) ? name : ts.idText(name), getPropertiesOfType(containingType), 111551);
        }
        function getSuggestionForNonexistentProperty(name, containingType) {
            var suggestion = getSuggestedSymbolForNonexistentProperty(name, containingType);
            return suggestion && ts.symbolName(suggestion);
        }
        function getSuggestedSymbolForNonexistentSymbol(location, outerName, meaning) {
            ts.Debug.assert(outerName !== undefined, "outername should always be defined");
            var result = resolveNameHelper(location, outerName, meaning, undefined, outerName, false, false, function (symbols, name, meaning) {
                ts.Debug.assertEqual(outerName, name, "name should equal outerName");
                var symbol = getSymbol(symbols, name, meaning);
                return symbol || getSpellingSuggestionForName(ts.unescapeLeadingUnderscores(name), ts.arrayFrom(symbols.values()), meaning);
            });
            return result;
        }
        function getSuggestionForNonexistentSymbol(location, outerName, meaning) {
            var symbolResult = getSuggestedSymbolForNonexistentSymbol(location, outerName, meaning);
            return symbolResult && ts.symbolName(symbolResult);
        }
        function getSuggestedSymbolForNonexistentModule(name, targetModule) {
            return targetModule.exports && getSpellingSuggestionForName(ts.idText(name), getExportsOfModuleAsArray(targetModule), 2623475);
        }
        function getSuggestionForNonexistentExport(name, targetModule) {
            var suggestion = getSuggestedSymbolForNonexistentModule(name, targetModule);
            return suggestion && ts.symbolName(suggestion);
        }
        function getSuggestionForNonexistentIndexSignature(objectType, expr, keyedType) {
            function hasProp(name) {
                var prop = getPropertyOfObjectType(objectType, name);
                if (prop) {
                    var s = getSingleCallSignature(getTypeOfSymbol(prop));
                    return !!s && getMinArgumentCount(s) >= 1 && isTypeAssignableTo(keyedType, getTypeAtPosition(s, 0));
                }
                return false;
            }
            ;
            var suggestedMethod = ts.isAssignmentTarget(expr) ? "set" : "get";
            if (!hasProp(suggestedMethod)) {
                return undefined;
            }
            var suggestion = ts.tryGetPropertyAccessOrIdentifierToString(expr.expression);
            if (suggestion === undefined) {
                suggestion = suggestedMethod;
            }
            else {
                suggestion += "." + suggestedMethod;
            }
            return suggestion;
        }
        function getSpellingSuggestionForName(name, symbols, meaning) {
            return ts.getSpellingSuggestion(name, symbols, getCandidateName);
            function getCandidateName(candidate) {
                var candidateName = ts.symbolName(candidate);
                if (ts.startsWith(candidateName, "\"")) {
                    return undefined;
                }
                if (candidate.flags & meaning) {
                    return candidateName;
                }
                if (candidate.flags & 2097152) {
                    var alias = tryResolveAlias(candidate);
                    if (alias && alias.flags & meaning) {
                        return candidateName;
                    }
                }
                return undefined;
            }
        }
        function markPropertyAsReferenced(prop, nodeForCheckWriteOnly, isThisAccess) {
            var valueDeclaration = prop && (prop.flags & 106500) && prop.valueDeclaration;
            if (!valueDeclaration) {
                return;
            }
            var hasPrivateModifier = ts.hasModifier(valueDeclaration, 8);
            var hasPrivateIdentifier = ts.isNamedDeclaration(prop.valueDeclaration) && ts.isPrivateIdentifier(prop.valueDeclaration.name);
            if (!hasPrivateModifier && !hasPrivateIdentifier) {
                return;
            }
            if (nodeForCheckWriteOnly && ts.isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & 65536)) {
                return;
            }
            if (isThisAccess) {
                var containingMethod = ts.findAncestor(nodeForCheckWriteOnly, ts.isFunctionLikeDeclaration);
                if (containingMethod && containingMethod.symbol === prop) {
                    return;
                }
            }
            (ts.getCheckFlags(prop) & 1 ? getSymbolLinks(prop).target : prop).isReferenced = 67108863;
        }
        function isValidPropertyAccess(node, propertyName) {
            switch (node.kind) {
                case 194:
                    return isValidPropertyAccessWithType(node, node.expression.kind === 102, propertyName, getWidenedType(checkExpression(node.expression)));
                case 153:
                    return isValidPropertyAccessWithType(node, false, propertyName, getWidenedType(checkExpression(node.left)));
                case 188:
                    return isValidPropertyAccessWithType(node, false, propertyName, getTypeFromTypeNode(node));
            }
        }
        function isValidPropertyAccessForCompletions(node, type, property) {
            return isValidPropertyAccessWithType(node, node.kind === 194 && node.expression.kind === 102, property.escapedName, type);
        }
        function isValidPropertyAccessWithType(node, isSuper, propertyName, type) {
            if (type === errorType || isTypeAny(type)) {
                return true;
            }
            var prop = getPropertyOfType(type, propertyName);
            if (prop) {
                if (ts.isPropertyAccessExpression(node) && prop.valueDeclaration && ts.isPrivateIdentifierPropertyDeclaration(prop.valueDeclaration)) {
                    var declClass_1 = ts.getContainingClass(prop.valueDeclaration);
                    return !ts.isOptionalChain(node) && !!ts.findAncestor(node, function (parent) { return parent === declClass_1; });
                }
                return checkPropertyAccessibility(node, isSuper, type, prop);
            }
            return ts.isInJSFile(node) && (type.flags & 1048576) !== 0 && type.types.some(function (elementType) { return isValidPropertyAccessWithType(node, isSuper, propertyName, elementType); });
        }
        function getForInVariableSymbol(node) {
            var initializer = node.initializer;
            if (initializer.kind === 243) {
                var variable = initializer.declarations[0];
                if (variable && !ts.isBindingPattern(variable.name)) {
                    return getSymbolOfNode(variable);
                }
            }
            else if (initializer.kind === 75) {
                return getResolvedSymbol(initializer);
            }
            return undefined;
        }
        function hasNumericPropertyNames(type) {
            return getIndexTypeOfType(type, 1) && !getIndexTypeOfType(type, 0);
        }
        function isForInVariableForNumericPropertyNames(expr) {
            var e = ts.skipParentheses(expr);
            if (e.kind === 75) {
                var symbol = getResolvedSymbol(e);
                if (symbol.flags & 3) {
                    var child = expr;
                    var node = expr.parent;
                    while (node) {
                        if (node.kind === 231 &&
                            child === node.statement &&
                            getForInVariableSymbol(node) === symbol &&
                            hasNumericPropertyNames(getTypeOfExpression(node.expression))) {
                            return true;
                        }
                        child = node;
                        node = node.parent;
                    }
                }
            }
            return false;
        }
        function checkIndexedAccess(node) {
            return node.flags & 32 ? checkElementAccessChain(node) :
                checkElementAccessExpression(node, checkNonNullExpression(node.expression));
        }
        function checkElementAccessChain(node) {
            var exprType = checkExpression(node.expression);
            var nonOptionalType = getOptionalExpressionType(exprType, node.expression);
            return propagateOptionalTypeMarker(checkElementAccessExpression(node, checkNonNullType(nonOptionalType, node.expression)), node, nonOptionalType !== exprType);
        }
        function checkElementAccessExpression(node, exprType) {
            var objectType = ts.getAssignmentTargetKind(node) !== 0 || isMethodAccessForCall(node) ? getWidenedType(exprType) : exprType;
            var indexExpression = node.argumentExpression;
            var indexType = checkExpression(indexExpression);
            if (objectType === errorType || objectType === silentNeverType) {
                return objectType;
            }
            if (isConstEnumObjectType(objectType) && !ts.isStringLiteralLike(indexExpression)) {
                error(indexExpression, ts.Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal);
                return errorType;
            }
            var effectiveIndexType = isForInVariableForNumericPropertyNames(indexExpression) ? numberType : indexType;
            var accessFlags = ts.isAssignmentTarget(node) ?
                2 | (isGenericObjectType(objectType) && !isThisTypeParameter(objectType) ? 1 : 0) :
                0;
            var indexedAccessType = getIndexedAccessTypeOrUndefined(objectType, effectiveIndexType, node, accessFlags) || errorType;
            return checkIndexedAccessIndexType(getFlowTypeOfAccessExpression(node, indexedAccessType.symbol, indexedAccessType, indexExpression), node);
        }
        function checkThatExpressionIsProperSymbolReference(expression, expressionType, reportError) {
            if (expressionType === errorType) {
                return false;
            }
            if (!ts.isWellKnownSymbolSyntactically(expression)) {
                return false;
            }
            if ((expressionType.flags & 12288) === 0) {
                if (reportError) {
                    error(expression, ts.Diagnostics.A_computed_property_name_of_the_form_0_must_be_of_type_symbol, ts.getTextOfNode(expression));
                }
                return false;
            }
            var leftHandSide = expression.expression;
            var leftHandSideSymbol = getResolvedSymbol(leftHandSide);
            if (!leftHandSideSymbol) {
                return false;
            }
            var globalESSymbol = getGlobalESSymbolConstructorSymbol(true);
            if (!globalESSymbol) {
                return false;
            }
            if (leftHandSideSymbol !== globalESSymbol) {
                if (reportError) {
                    error(leftHandSide, ts.Diagnostics.Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object);
                }
                return false;
            }
            return true;
        }
        function callLikeExpressionMayHaveTypeArguments(node) {
            return ts.isCallOrNewExpression(node) || ts.isTaggedTemplateExpression(node) || ts.isJsxOpeningLikeElement(node);
        }
        function resolveUntypedCall(node) {
            if (callLikeExpressionMayHaveTypeArguments(node)) {
                ts.forEach(node.typeArguments, checkSourceElement);
            }
            if (node.kind === 198) {
                checkExpression(node.template);
            }
            else if (ts.isJsxOpeningLikeElement(node)) {
                checkExpression(node.attributes);
            }
            else if (node.kind !== 157) {
                ts.forEach(node.arguments, function (argument) {
                    checkExpression(argument);
                });
            }
            return anySignature;
        }
        function resolveErrorCall(node) {
            resolveUntypedCall(node);
            return unknownSignature;
        }
        function reorderCandidates(signatures, result, callChainFlags) {
            var lastParent;
            var lastSymbol;
            var cutoffIndex = 0;
            var index;
            var specializedIndex = -1;
            var spliceIndex;
            ts.Debug.assert(!result.length);
            for (var _i = 0, signatures_7 = signatures; _i < signatures_7.length; _i++) {
                var signature = signatures_7[_i];
                var symbol = signature.declaration && getSymbolOfNode(signature.declaration);
                var parent = signature.declaration && signature.declaration.parent;
                if (!lastSymbol || symbol === lastSymbol) {
                    if (lastParent && parent === lastParent) {
                        index = index + 1;
                    }
                    else {
                        lastParent = parent;
                        index = cutoffIndex;
                    }
                }
                else {
                    index = cutoffIndex = result.length;
                    lastParent = parent;
                }
                lastSymbol = symbol;
                if (signatureHasLiteralTypes(signature)) {
                    specializedIndex++;
                    spliceIndex = specializedIndex;
                    cutoffIndex++;
                }
                else {
                    spliceIndex = index;
                }
                result.splice(spliceIndex, 0, callChainFlags ? getOptionalCallSignature(signature, callChainFlags) : signature);
            }
        }
        function isSpreadArgument(arg) {
            return !!arg && (arg.kind === 213 || arg.kind === 220 && arg.isSpread);
        }
        function getSpreadArgumentIndex(args) {
            return ts.findIndex(args, isSpreadArgument);
        }
        function acceptsVoid(t) {
            return !!(t.flags & 16384);
        }
        function hasCorrectArity(node, args, signature, signatureHelpTrailingComma) {
            if (signatureHelpTrailingComma === void 0) { signatureHelpTrailingComma = false; }
            var argCount;
            var callIsIncomplete = false;
            var effectiveParameterCount = getParameterCount(signature);
            var effectiveMinimumArguments = getMinArgumentCount(signature);
            if (node.kind === 198) {
                argCount = args.length;
                if (node.template.kind === 211) {
                    var lastSpan = ts.last(node.template.templateSpans);
                    callIsIncomplete = ts.nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated;
                }
                else {
                    var templateLiteral = node.template;
                    ts.Debug.assert(templateLiteral.kind === 14);
                    callIsIncomplete = !!templateLiteral.isUnterminated;
                }
            }
            else if (node.kind === 157) {
                argCount = getDecoratorArgumentCount(node, signature);
            }
            else if (ts.isJsxOpeningLikeElement(node)) {
                callIsIncomplete = node.attributes.end === node.end;
                if (callIsIncomplete) {
                    return true;
                }
                argCount = effectiveMinimumArguments === 0 ? args.length : 1;
                effectiveParameterCount = args.length === 0 ? effectiveParameterCount : 1;
                effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1);
            }
            else {
                if (!node.arguments) {
                    ts.Debug.assert(node.kind === 197);
                    return getMinArgumentCount(signature) === 0;
                }
                argCount = signatureHelpTrailingComma ? args.length + 1 : args.length;
                callIsIncomplete = node.arguments.end === node.end;
                var spreadArgIndex = getSpreadArgumentIndex(args);
                if (spreadArgIndex >= 0) {
                    return spreadArgIndex >= getMinArgumentCount(signature) && (hasEffectiveRestParameter(signature) || spreadArgIndex < getParameterCount(signature));
                }
            }
            if (!hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount) {
                return false;
            }
            if (callIsIncomplete || argCount >= effectiveMinimumArguments) {
                return true;
            }
            for (var i = argCount; i < effectiveMinimumArguments; i++) {
                var type = getTypeAtPosition(signature, i);
                if (filterType(type, acceptsVoid).flags & 131072) {
                    return false;
                }
            }
            return true;
        }
        function hasCorrectTypeArgumentArity(signature, typeArguments) {
            var numTypeParameters = ts.length(signature.typeParameters);
            var minTypeArgumentCount = getMinTypeArgumentCount(signature.typeParameters);
            return !ts.some(typeArguments) ||
                (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters);
        }
        function getSingleCallSignature(type) {
            return getSingleSignature(type, 0, false);
        }
        function getSingleCallOrConstructSignature(type) {
            return getSingleSignature(type, 0, false) ||
                getSingleSignature(type, 1, false);
        }
        function getSingleSignature(type, kind, allowMembers) {
            if (type.flags & 524288) {
                var resolved = resolveStructuredTypeMembers(type);
                if (allowMembers || resolved.properties.length === 0 && !resolved.stringIndexInfo && !resolved.numberIndexInfo) {
                    if (kind === 0 && resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0) {
                        return resolved.callSignatures[0];
                    }
                    if (kind === 1 && resolved.constructSignatures.length === 1 && resolved.callSignatures.length === 0) {
                        return resolved.constructSignatures[0];
                    }
                }
            }
            return undefined;
        }
        function instantiateSignatureInContextOf(signature, contextualSignature, inferenceContext, compareTypes) {
            var context = createInferenceContext(signature.typeParameters, signature, 0, compareTypes);
            var restType = getEffectiveRestType(contextualSignature);
            var mapper = inferenceContext && (restType && restType.flags & 262144 ? inferenceContext.nonFixingMapper : inferenceContext.mapper);
            var sourceSignature = mapper ? instantiateSignature(contextualSignature, mapper) : contextualSignature;
            applyToParameterTypes(sourceSignature, signature, function (source, target) {
                inferTypes(context.inferences, source, target);
            });
            if (!inferenceContext) {
                applyToReturnTypes(contextualSignature, signature, function (source, target) {
                    inferTypes(context.inferences, source, target, 32);
                });
            }
            return getSignatureInstantiation(signature, getInferredTypes(context), ts.isInJSFile(contextualSignature.declaration));
        }
        function inferJsxTypeArguments(node, signature, checkMode, context) {
            var paramType = getEffectiveFirstArgumentForJsxSignature(signature, node);
            var checkAttrType = checkExpressionWithContextualType(node.attributes, paramType, context, checkMode);
            inferTypes(context.inferences, checkAttrType, paramType);
            return getInferredTypes(context);
        }
        function inferTypeArguments(node, signature, args, checkMode, context) {
            if (ts.isJsxOpeningLikeElement(node)) {
                return inferJsxTypeArguments(node, signature, checkMode, context);
            }
            if (node.kind !== 157) {
                var contextualType = getContextualType(node);
                if (contextualType) {
                    var outerContext = getInferenceContext(node);
                    var outerMapper = getMapperFromContext(cloneInferenceContext(outerContext, 1));
                    var instantiatedType = instantiateType(contextualType, outerMapper);
                    var contextualSignature = getSingleCallSignature(instantiatedType);
                    var inferenceSourceType = contextualSignature && contextualSignature.typeParameters ?
                        getOrCreateTypeFromSignature(getSignatureInstantiationWithoutFillingInTypeArguments(contextualSignature, contextualSignature.typeParameters)) :
                        instantiatedType;
                    var inferenceTargetType = getReturnTypeOfSignature(signature);
                    inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, 32);
                    var returnContext = createInferenceContext(signature.typeParameters, signature, context.flags);
                    var returnSourceType = instantiateType(contextualType, outerContext && outerContext.returnMapper);
                    inferTypes(returnContext.inferences, returnSourceType, inferenceTargetType);
                    context.returnMapper = ts.some(returnContext.inferences, hasInferenceCandidates) ? getMapperFromContext(cloneInferredPartOfContext(returnContext)) : undefined;
                }
            }
            var thisType = getThisTypeOfSignature(signature);
            if (thisType) {
                var thisArgumentNode = getThisArgumentOfCall(node);
                var thisArgumentType = thisArgumentNode ? checkExpression(thisArgumentNode) : voidType;
                inferTypes(context.inferences, thisArgumentType, thisType);
            }
            var restType = getNonArrayRestType(signature);
            var argCount = restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length;
            for (var i = 0; i < argCount; i++) {
                var arg = args[i];
                if (arg.kind !== 215) {
                    var paramType = getTypeAtPosition(signature, i);
                    var argType = checkExpressionWithContextualType(arg, paramType, context, checkMode);
                    inferTypes(context.inferences, argType, paramType);
                }
            }
            if (restType) {
                var spreadType = getSpreadArgumentType(args, argCount, args.length, restType, context);
                inferTypes(context.inferences, spreadType, restType);
            }
            return getInferredTypes(context);
        }
        function getArrayifiedType(type) {
            return type.flags & 1048576 ? mapType(type, getArrayifiedType) :
                type.flags & (1 | 63176704) || isMutableArrayOrTuple(type) ? type :
                    isTupleType(type) ? createTupleType(getTypeArguments(type), type.target.minLength, type.target.hasRestElement, false, type.target.associatedNames) :
                        createArrayType(getIndexedAccessType(type, numberType));
        }
        function getSpreadArgumentType(args, index, argCount, restType, context) {
            if (index >= argCount - 1) {
                var arg = args[argCount - 1];
                if (isSpreadArgument(arg)) {
                    return arg.kind === 220 ?
                        createArrayType(arg.type) :
                        getArrayifiedType(checkExpressionWithContextualType(arg.expression, restType, context, 0));
                }
            }
            var types = [];
            var spreadIndex = -1;
            for (var i = index; i < argCount; i++) {
                var contextualType = getIndexedAccessType(restType, getLiteralType(i - index));
                var argType = checkExpressionWithContextualType(args[i], contextualType, context, 0);
                if (spreadIndex < 0 && isSpreadArgument(args[i])) {
                    spreadIndex = i - index;
                }
                var hasPrimitiveContextualType = maybeTypeOfKind(contextualType, 131068 | 4194304);
                types.push(hasPrimitiveContextualType ? getRegularTypeOfLiteralType(argType) : getWidenedLiteralType(argType));
            }
            return spreadIndex < 0 ?
                createTupleType(types) :
                createTupleType(ts.append(types.slice(0, spreadIndex), getUnionType(types.slice(spreadIndex))), spreadIndex, true);
        }
        function checkTypeArguments(signature, typeArgumentNodes, reportErrors, headMessage) {
            var isJavascript = ts.isInJSFile(signature.declaration);
            var typeParameters = signature.typeParameters;
            var typeArgumentTypes = fillMissingTypeArguments(ts.map(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript);
            var mapper;
            for (var i = 0; i < typeArgumentNodes.length; i++) {
                ts.Debug.assert(typeParameters[i] !== undefined, "Should not call checkTypeArguments with too many type arguments");
                var constraint = getConstraintOfTypeParameter(typeParameters[i]);
                if (constraint) {
                    var errorInfo = reportErrors && headMessage ? (function () { return ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1); }) : undefined;
                    var typeArgumentHeadMessage = headMessage || ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1;
                    if (!mapper) {
                        mapper = createTypeMapper(typeParameters, typeArgumentTypes);
                    }
                    var typeArgument = typeArgumentTypes[i];
                    if (!checkTypeAssignableTo(typeArgument, getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument), reportErrors ? typeArgumentNodes[i] : undefined, typeArgumentHeadMessage, errorInfo)) {
                        return undefined;
                    }
                }
            }
            return typeArgumentTypes;
        }
        function getJsxReferenceKind(node) {
            if (isJsxIntrinsicIdentifier(node.tagName)) {
                return 2;
            }
            var tagType = getApparentType(checkExpression(node.tagName));
            if (ts.length(getSignaturesOfType(tagType, 1))) {
                return 0;
            }
            if (ts.length(getSignaturesOfType(tagType, 0))) {
                return 1;
            }
            return 2;
        }
        function checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer) {
            var paramType = getEffectiveFirstArgumentForJsxSignature(signature, node);
            var attributesType = checkExpressionWithContextualType(node.attributes, paramType, undefined, checkMode);
            return checkTagNameDoesNotExpectTooManyArguments() && checkTypeRelatedToAndOptionallyElaborate(attributesType, paramType, relation, reportErrors ? node.tagName : undefined, node.attributes, undefined, containingMessageChain, errorOutputContainer);
            function checkTagNameDoesNotExpectTooManyArguments() {
                var _a;
                var tagType = ts.isJsxOpeningElement(node) || ts.isJsxSelfClosingElement(node) && !isJsxIntrinsicIdentifier(node.tagName) ? checkExpression(node.tagName) : undefined;
                if (!tagType) {
                    return true;
                }
                var tagCallSignatures = getSignaturesOfType(tagType, 0);
                if (!ts.length(tagCallSignatures)) {
                    return true;
                }
                var factory = getJsxFactoryEntity(node);
                if (!factory) {
                    return true;
                }
                var factorySymbol = resolveEntityName(factory, 111551, true, false, node);
                if (!factorySymbol) {
                    return true;
                }
                var factoryType = getTypeOfSymbol(factorySymbol);
                var callSignatures = getSignaturesOfType(factoryType, 0);
                if (!ts.length(callSignatures)) {
                    return true;
                }
                var hasFirstParamSignatures = false;
                var maxParamCount = 0;
                for (var _i = 0, callSignatures_1 = callSignatures; _i < callSignatures_1.length; _i++) {
                    var sig = callSignatures_1[_i];
                    var firstparam = getTypeAtPosition(sig, 0);
                    var signaturesOfParam = getSignaturesOfType(firstparam, 0);
                    if (!ts.length(signaturesOfParam))
                        continue;
                    for (var _b = 0, signaturesOfParam_1 = signaturesOfParam; _b < signaturesOfParam_1.length; _b++) {
                        var paramSig = signaturesOfParam_1[_b];
                        hasFirstParamSignatures = true;
                        if (hasEffectiveRestParameter(paramSig)) {
                            return true;
                        }
                        var paramCount = getParameterCount(paramSig);
                        if (paramCount > maxParamCount) {
                            maxParamCount = paramCount;
                        }
                    }
                }
                if (!hasFirstParamSignatures) {
                    return true;
                }
                var absoluteMinArgCount = Infinity;
                for (var _c = 0, tagCallSignatures_1 = tagCallSignatures; _c < tagCallSignatures_1.length; _c++) {
                    var tagSig = tagCallSignatures_1[_c];
                    var tagRequiredArgCount = getMinArgumentCount(tagSig);
                    if (tagRequiredArgCount < absoluteMinArgCount) {
                        absoluteMinArgCount = tagRequiredArgCount;
                    }
                }
                if (absoluteMinArgCount <= maxParamCount) {
                    return true;
                }
                if (reportErrors) {
                    var diag = ts.createDiagnosticForNode(node.tagName, ts.Diagnostics.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3, ts.entityNameToString(node.tagName), absoluteMinArgCount, ts.entityNameToString(factory), maxParamCount);
                    var tagNameDeclaration = (_a = getSymbolAtLocation(node.tagName)) === null || _a === void 0 ? void 0 : _a.valueDeclaration;
                    if (tagNameDeclaration) {
                        ts.addRelatedInfo(diag, ts.createDiagnosticForNode(tagNameDeclaration, ts.Diagnostics._0_is_declared_here, ts.entityNameToString(node.tagName)));
                    }
                    if (errorOutputContainer && errorOutputContainer.skipLogging) {
                        (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                    }
                    if (!errorOutputContainer.skipLogging) {
                        diagnostics.add(diag);
                    }
                }
                return false;
            }
        }
        function getSignatureApplicabilityError(node, args, signature, relation, checkMode, reportErrors, containingMessageChain) {
            var errorOutputContainer = { errors: undefined, skipLogging: true };
            if (ts.isJsxOpeningLikeElement(node)) {
                if (!checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer)) {
                    ts.Debug.assert(!reportErrors || !!errorOutputContainer.errors, "jsx should have errors when reporting errors");
                    return errorOutputContainer.errors || ts.emptyArray;
                }
                return undefined;
            }
            var thisType = getThisTypeOfSignature(signature);
            if (thisType && thisType !== voidType && node.kind !== 197) {
                var thisArgumentNode = getThisArgumentOfCall(node);
                var thisArgumentType = void 0;
                if (thisArgumentNode) {
                    thisArgumentType = checkExpression(thisArgumentNode);
                    if (ts.isOptionalChainRoot(thisArgumentNode.parent)) {
                        thisArgumentType = getNonNullableType(thisArgumentType);
                    }
                    else if (ts.isOptionalChain(thisArgumentNode.parent)) {
                        thisArgumentType = removeOptionalTypeMarker(thisArgumentType);
                    }
                }
                else {
                    thisArgumentType = voidType;
                }
                var errorNode = reportErrors ? (thisArgumentNode || node) : undefined;
                var headMessage_1 = ts.Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1;
                if (!checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage_1, containingMessageChain, errorOutputContainer)) {
                    ts.Debug.assert(!reportErrors || !!errorOutputContainer.errors, "this parameter should have errors when reporting errors");
                    return errorOutputContainer.errors || ts.emptyArray;
                }
            }
            var headMessage = ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
            var restType = getNonArrayRestType(signature);
            var argCount = restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length;
            for (var i = 0; i < argCount; i++) {
                var arg = args[i];
                if (arg.kind !== 215) {
                    var paramType = getTypeAtPosition(signature, i);
                    var argType = checkExpressionWithContextualType(arg, paramType, undefined, checkMode);
                    var checkArgType = checkMode & 4 ? getRegularTypeOfObjectLiteral(argType) : argType;
                    if (!checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation, reportErrors ? arg : undefined, arg, headMessage, containingMessageChain, errorOutputContainer)) {
                        ts.Debug.assert(!reportErrors || !!errorOutputContainer.errors, "parameter should have errors when reporting errors");
                        maybeAddMissingAwaitInfo(arg, checkArgType, paramType);
                        return errorOutputContainer.errors || ts.emptyArray;
                    }
                }
            }
            if (restType) {
                var spreadType = getSpreadArgumentType(args, argCount, args.length, restType, undefined);
                var errorNode = reportErrors ? argCount < args.length ? args[argCount] : node : undefined;
                if (!checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage, undefined, errorOutputContainer)) {
                    ts.Debug.assert(!reportErrors || !!errorOutputContainer.errors, "rest parameter should have errors when reporting errors");
                    maybeAddMissingAwaitInfo(errorNode, spreadType, restType);
                    return errorOutputContainer.errors || ts.emptyArray;
                }
            }
            return undefined;
            function maybeAddMissingAwaitInfo(errorNode, source, target) {
                if (errorNode && reportErrors && errorOutputContainer.errors && errorOutputContainer.errors.length) {
                    if (getAwaitedTypeOfPromise(target)) {
                        return;
                    }
                    var awaitedTypeOfSource = getAwaitedTypeOfPromise(source);
                    if (awaitedTypeOfSource && isTypeRelatedTo(awaitedTypeOfSource, target, relation)) {
                        ts.addRelatedInfo(errorOutputContainer.errors[0], ts.createDiagnosticForNode(errorNode, ts.Diagnostics.Did_you_forget_to_use_await));
                    }
                }
            }
        }
        function getThisArgumentOfCall(node) {
            if (node.kind === 196) {
                var callee = ts.skipOuterExpressions(node.expression);
                if (ts.isAccessExpression(callee)) {
                    return callee.expression;
                }
            }
        }
        function createSyntheticExpression(parent, type, isSpread) {
            var result = ts.createNode(220, parent.pos, parent.end);
            result.parent = parent;
            result.type = type;
            result.isSpread = isSpread || false;
            return result;
        }
        function getEffectiveCallArguments(node) {
            if (node.kind === 198) {
                var template = node.template;
                var args_3 = [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
                if (template.kind === 211) {
                    ts.forEach(template.templateSpans, function (span) {
                        args_3.push(span.expression);
                    });
                }
                return args_3;
            }
            if (node.kind === 157) {
                return getEffectiveDecoratorArguments(node);
            }
            if (ts.isJsxOpeningLikeElement(node)) {
                return node.attributes.properties.length > 0 || (ts.isJsxOpeningElement(node) && node.parent.children.length > 0) ? [node.attributes] : ts.emptyArray;
            }
            var args = node.arguments || ts.emptyArray;
            var length = args.length;
            if (length && isSpreadArgument(args[length - 1]) && getSpreadArgumentIndex(args) === length - 1) {
                var spreadArgument_1 = args[length - 1];
                var type = flowLoopCount ? checkExpression(spreadArgument_1.expression) : checkExpressionCached(spreadArgument_1.expression);
                if (isTupleType(type)) {
                    var typeArguments = getTypeArguments(type);
                    var restIndex_2 = type.target.hasRestElement ? typeArguments.length - 1 : -1;
                    var syntheticArgs = ts.map(typeArguments, function (t, i) { return createSyntheticExpression(spreadArgument_1, t, i === restIndex_2); });
                    return ts.concatenate(args.slice(0, length - 1), syntheticArgs);
                }
            }
            return args;
        }
        function getEffectiveDecoratorArguments(node) {
            var parent = node.parent;
            var expr = node.expression;
            switch (parent.kind) {
                case 245:
                case 214:
                    return [
                        createSyntheticExpression(expr, getTypeOfSymbol(getSymbolOfNode(parent)))
                    ];
                case 156:
                    var func = parent.parent;
                    return [
                        createSyntheticExpression(expr, parent.parent.kind === 162 ? getTypeOfSymbol(getSymbolOfNode(func)) : errorType),
                        createSyntheticExpression(expr, anyType),
                        createSyntheticExpression(expr, numberType)
                    ];
                case 159:
                case 161:
                case 163:
                case 164:
                    var hasPropDesc = parent.kind !== 159 && languageVersion !== 0;
                    return [
                        createSyntheticExpression(expr, getParentTypeOfClassElement(parent)),
                        createSyntheticExpression(expr, getClassElementPropertyKeyType(parent)),
                        createSyntheticExpression(expr, hasPropDesc ? createTypedPropertyDescriptorType(getTypeOfNode(parent)) : anyType)
                    ];
            }
            return ts.Debug.fail();
        }
        function getDecoratorArgumentCount(node, signature) {
            switch (node.parent.kind) {
                case 245:
                case 214:
                    return 1;
                case 159:
                    return 2;
                case 161:
                case 163:
                case 164:
                    return languageVersion === 0 || signature.parameters.length <= 2 ? 2 : 3;
                case 156:
                    return 3;
                default:
                    return ts.Debug.fail();
            }
        }
        function getDiagnosticSpanForCallNode(node, doNotIncludeArguments) {
            var start;
            var length;
            var sourceFile = ts.getSourceFileOfNode(node);
            if (ts.isPropertyAccessExpression(node.expression)) {
                var nameSpan = ts.getErrorSpanForNode(sourceFile, node.expression.name);
                start = nameSpan.start;
                length = doNotIncludeArguments ? nameSpan.length : node.end - start;
            }
            else {
                var expressionSpan = ts.getErrorSpanForNode(sourceFile, node.expression);
                start = expressionSpan.start;
                length = doNotIncludeArguments ? expressionSpan.length : node.end - start;
            }
            return { start: start, length: length, sourceFile: sourceFile };
        }
        function getDiagnosticForCallNode(node, message, arg0, arg1, arg2, arg3) {
            if (ts.isCallExpression(node)) {
                var _a = getDiagnosticSpanForCallNode(node), sourceFile = _a.sourceFile, start = _a.start, length_5 = _a.length;
                return ts.createFileDiagnostic(sourceFile, start, length_5, message, arg0, arg1, arg2, arg3);
            }
            else {
                return ts.createDiagnosticForNode(node, message, arg0, arg1, arg2, arg3);
            }
        }
        function getArgumentArityError(node, signatures, args) {
            var min = Number.POSITIVE_INFINITY;
            var max = Number.NEGATIVE_INFINITY;
            var belowArgCount = Number.NEGATIVE_INFINITY;
            var aboveArgCount = Number.POSITIVE_INFINITY;
            var argCount = args.length;
            var closestSignature;
            for (var _i = 0, signatures_8 = signatures; _i < signatures_8.length; _i++) {
                var sig = signatures_8[_i];
                var minCount = getMinArgumentCount(sig);
                var maxCount = getParameterCount(sig);
                if (minCount < argCount && minCount > belowArgCount)
                    belowArgCount = minCount;
                if (argCount < maxCount && maxCount < aboveArgCount)
                    aboveArgCount = maxCount;
                if (minCount < min) {
                    min = minCount;
                    closestSignature = sig;
                }
                max = Math.max(max, maxCount);
            }
            var hasRestParameter = ts.some(signatures, hasEffectiveRestParameter);
            var paramRange = hasRestParameter ? min :
                min < max ? min + "-" + max :
                    min;
            var hasSpreadArgument = getSpreadArgumentIndex(args) > -1;
            if (argCount <= max && hasSpreadArgument) {
                argCount--;
            }
            var spanArray;
            var related;
            var error = hasRestParameter || hasSpreadArgument ? hasRestParameter && hasSpreadArgument ? ts.Diagnostics.Expected_at_least_0_arguments_but_got_1_or_more :
                hasRestParameter ? ts.Diagnostics.Expected_at_least_0_arguments_but_got_1 :
                    ts.Diagnostics.Expected_0_arguments_but_got_1_or_more : ts.Diagnostics.Expected_0_arguments_but_got_1;
            if (closestSignature && getMinArgumentCount(closestSignature) > argCount && closestSignature.declaration) {
                var paramDecl = closestSignature.declaration.parameters[closestSignature.thisParameter ? argCount + 1 : argCount];
                if (paramDecl) {
                    related = ts.createDiagnosticForNode(paramDecl, ts.isBindingPattern(paramDecl.name) ? ts.Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided : ts.Diagnostics.An_argument_for_0_was_not_provided, !paramDecl.name ? argCount : !ts.isBindingPattern(paramDecl.name) ? ts.idText(ts.getFirstIdentifier(paramDecl.name)) : undefined);
                }
            }
            if (min < argCount && argCount < max) {
                return getDiagnosticForCallNode(node, ts.Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, argCount, belowArgCount, aboveArgCount);
            }
            if (!hasSpreadArgument && argCount < min) {
                var diagnostic_1 = getDiagnosticForCallNode(node, error, paramRange, argCount);
                return related ? ts.addRelatedInfo(diagnostic_1, related) : diagnostic_1;
            }
            if (hasRestParameter || hasSpreadArgument) {
                spanArray = ts.createNodeArray(args);
                if (hasSpreadArgument && argCount) {
                    var nextArg = ts.elementAt(args, getSpreadArgumentIndex(args) + 1) || undefined;
                    spanArray = ts.createNodeArray(args.slice(max > argCount && nextArg ? args.indexOf(nextArg) : Math.min(max, args.length - 1)));
                }
            }
            else {
                spanArray = ts.createNodeArray(args.slice(max));
            }
            spanArray.pos = ts.first(spanArray).pos;
            spanArray.end = ts.last(spanArray).end;
            if (spanArray.end === spanArray.pos) {
                spanArray.end++;
            }
            var diagnostic = ts.createDiagnosticForNodeArray(ts.getSourceFileOfNode(node), spanArray, error, paramRange, argCount);
            return related ? ts.addRelatedInfo(diagnostic, related) : diagnostic;
        }
        function getTypeArgumentArityError(node, signatures, typeArguments) {
            var argCount = typeArguments.length;
            if (signatures.length === 1) {
                var sig = signatures[0];
                var min_1 = getMinTypeArgumentCount(sig.typeParameters);
                var max = ts.length(sig.typeParameters);
                return ts.createDiagnosticForNodeArray(ts.getSourceFileOfNode(node), typeArguments, ts.Diagnostics.Expected_0_type_arguments_but_got_1, min_1 < max ? min_1 + "-" + max : min_1, argCount);
            }
            var belowArgCount = -Infinity;
            var aboveArgCount = Infinity;
            for (var _i = 0, signatures_9 = signatures; _i < signatures_9.length; _i++) {
                var sig = signatures_9[_i];
                var min_2 = getMinTypeArgumentCount(sig.typeParameters);
                var max = ts.length(sig.typeParameters);
                if (min_2 > argCount) {
                    aboveArgCount = Math.min(aboveArgCount, min_2);
                }
                else if (max < argCount) {
                    belowArgCount = Math.max(belowArgCount, max);
                }
            }
            if (belowArgCount !== -Infinity && aboveArgCount !== Infinity) {
                return ts.createDiagnosticForNodeArray(ts.getSourceFileOfNode(node), typeArguments, ts.Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount);
            }
            return ts.createDiagnosticForNodeArray(ts.getSourceFileOfNode(node), typeArguments, ts.Diagnostics.Expected_0_type_arguments_but_got_1, belowArgCount === -Infinity ? aboveArgCount : belowArgCount, argCount);
        }
        function resolveCall(node, signatures, candidatesOutArray, checkMode, callChainFlags, fallbackError) {
            var isTaggedTemplate = node.kind === 198;
            var isDecorator = node.kind === 157;
            var isJsxOpeningOrSelfClosingElement = ts.isJsxOpeningLikeElement(node);
            var reportErrors = !candidatesOutArray;
            var typeArguments;
            if (!isDecorator) {
                typeArguments = node.typeArguments;
                if (isTaggedTemplate || isJsxOpeningOrSelfClosingElement || node.expression.kind !== 102) {
                    ts.forEach(typeArguments, checkSourceElement);
                }
            }
            var candidates = candidatesOutArray || [];
            reorderCandidates(signatures, candidates, callChainFlags);
            if (!candidates.length) {
                if (reportErrors) {
                    diagnostics.add(getDiagnosticForCallNode(node, ts.Diagnostics.Call_target_does_not_contain_any_signatures));
                }
                return resolveErrorCall(node);
            }
            var args = getEffectiveCallArguments(node);
            var isSingleNonGenericCandidate = candidates.length === 1 && !candidates[0].typeParameters;
            var argCheckMode = !isDecorator && !isSingleNonGenericCandidate && ts.some(args, isContextSensitive) ? 4 : 0;
            var candidatesForArgumentError;
            var candidateForArgumentArityError;
            var candidateForTypeArgumentError;
            var result;
            var signatureHelpTrailingComma = !!(checkMode & 16) && node.kind === 196 && node.arguments.hasTrailingComma;
            if (candidates.length > 1) {
                result = chooseOverload(candidates, subtypeRelation, signatureHelpTrailingComma);
            }
            if (!result) {
                result = chooseOverload(candidates, assignableRelation, signatureHelpTrailingComma);
            }
            if (result) {
                return result;
            }
            if (reportErrors) {
                if (candidatesForArgumentError) {
                    if (candidatesForArgumentError.length === 1 || candidatesForArgumentError.length > 3) {
                        var last_2 = candidatesForArgumentError[candidatesForArgumentError.length - 1];
                        var chain_1;
                        if (candidatesForArgumentError.length > 3) {
                            chain_1 = ts.chainDiagnosticMessages(chain_1, ts.Diagnostics.The_last_overload_gave_the_following_error);
                            chain_1 = ts.chainDiagnosticMessages(chain_1, ts.Diagnostics.No_overload_matches_this_call);
                        }
                        var diags = getSignatureApplicabilityError(node, args, last_2, assignableRelation, 0, true, function () { return chain_1; });
                        if (diags) {
                            for (var _i = 0, diags_1 = diags; _i < diags_1.length; _i++) {
                                var d = diags_1[_i];
                                if (last_2.declaration && candidatesForArgumentError.length > 3) {
                                    ts.addRelatedInfo(d, ts.createDiagnosticForNode(last_2.declaration, ts.Diagnostics.The_last_overload_is_declared_here));
                                }
                                diagnostics.add(d);
                            }
                        }
                        else {
                            ts.Debug.fail("No error for last overload signature");
                        }
                    }
                    else {
                        var allDiagnostics = [];
                        var max = 0;
                        var min_3 = Number.MAX_VALUE;
                        var minIndex = 0;
                        var i_1 = 0;
                        var _loop_17 = function (c) {
                            var chain_2 = function () { return ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Overload_0_of_1_2_gave_the_following_error, i_1 + 1, candidates.length, signatureToString(c)); };
                            var diags_2 = getSignatureApplicabilityError(node, args, c, assignableRelation, 0, true, chain_2);
                            if (diags_2) {
                                if (diags_2.length <= min_3) {
                                    min_3 = diags_2.length;
                                    minIndex = i_1;
                                }
                                max = Math.max(max, diags_2.length);
                                allDiagnostics.push(diags_2);
                            }
                            else {
                                ts.Debug.fail("No error for 3 or fewer overload signatures");
                            }
                            i_1++;
                        };
                        for (var _a = 0, candidatesForArgumentError_1 = candidatesForArgumentError; _a < candidatesForArgumentError_1.length; _a++) {
                            var c = candidatesForArgumentError_1[_a];
                            _loop_17(c);
                        }
                        var diags_3 = max > 1 ? allDiagnostics[minIndex] : ts.flatten(allDiagnostics);
                        ts.Debug.assert(diags_3.length > 0, "No errors reported for 3 or fewer overload signatures");
                        var chain = ts.chainDiagnosticMessages(ts.map(diags_3, function (d) { return typeof d.messageText === "string" ? d : d.messageText; }), ts.Diagnostics.No_overload_matches_this_call);
                        var related = ts.flatMap(diags_3, function (d) { return d.relatedInformation; });
                        if (ts.every(diags_3, function (d) { return d.start === diags_3[0].start && d.length === diags_3[0].length && d.file === diags_3[0].file; })) {
                            var _b = diags_3[0], file = _b.file, start = _b.start, length_6 = _b.length;
                            diagnostics.add({ file: file, start: start, length: length_6, code: chain.code, category: chain.category, messageText: chain, relatedInformation: related });
                        }
                        else {
                            diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(node, chain, related));
                        }
                    }
                }
                else if (candidateForArgumentArityError) {
                    diagnostics.add(getArgumentArityError(node, [candidateForArgumentArityError], args));
                }
                else if (candidateForTypeArgumentError) {
                    checkTypeArguments(candidateForTypeArgumentError, node.typeArguments, true, fallbackError);
                }
                else {
                    var signaturesWithCorrectTypeArgumentArity = ts.filter(signatures, function (s) { return hasCorrectTypeArgumentArity(s, typeArguments); });
                    if (signaturesWithCorrectTypeArgumentArity.length === 0) {
                        diagnostics.add(getTypeArgumentArityError(node, signatures, typeArguments));
                    }
                    else if (!isDecorator) {
                        diagnostics.add(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args));
                    }
                    else if (fallbackError) {
                        diagnostics.add(getDiagnosticForCallNode(node, fallbackError));
                    }
                }
            }
            return getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray);
            function chooseOverload(candidates, relation, signatureHelpTrailingComma) {
                if (signatureHelpTrailingComma === void 0) { signatureHelpTrailingComma = false; }
                candidatesForArgumentError = undefined;
                candidateForArgumentArityError = undefined;
                candidateForTypeArgumentError = undefined;
                if (isSingleNonGenericCandidate) {
                    var candidate = candidates[0];
                    if (ts.some(typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {
                        return undefined;
                    }
                    if (getSignatureApplicabilityError(node, args, candidate, relation, 0, false, undefined)) {
                        candidatesForArgumentError = [candidate];
                        return undefined;
                    }
                    return candidate;
                }
                for (var candidateIndex = 0; candidateIndex < candidates.length; candidateIndex++) {
                    var candidate = candidates[candidateIndex];
                    if (!hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {
                        continue;
                    }
                    var checkCandidate = void 0;
                    var inferenceContext = void 0;
                    if (candidate.typeParameters) {
                        var typeArgumentTypes = void 0;
                        if (ts.some(typeArguments)) {
                            typeArgumentTypes = checkTypeArguments(candidate, typeArguments, false);
                            if (!typeArgumentTypes) {
                                candidateForTypeArgumentError = candidate;
                                continue;
                            }
                        }
                        else {
                            inferenceContext = createInferenceContext(candidate.typeParameters, candidate, ts.isInJSFile(node) ? 2 : 0);
                            typeArgumentTypes = inferTypeArguments(node, candidate, args, argCheckMode | 8, inferenceContext);
                            argCheckMode |= inferenceContext.flags & 4 ? 8 : 0;
                        }
                        checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, ts.isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);
                        if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {
                            candidateForArgumentArityError = checkCandidate;
                            continue;
                        }
                    }
                    else {
                        checkCandidate = candidate;
                    }
                    if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, false, undefined)) {
                        (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
                        continue;
                    }
                    if (argCheckMode) {
                        argCheckMode = 0;
                        if (inferenceContext) {
                            var typeArgumentTypes = inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext);
                            checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, ts.isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);
                            if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {
                                candidateForArgumentArityError = checkCandidate;
                                continue;
                            }
                        }
                        if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, false, undefined)) {
                            (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
                            continue;
                        }
                    }
                    candidates[candidateIndex] = checkCandidate;
                    return checkCandidate;
                }
                return undefined;
            }
        }
        function getCandidateForOverloadFailure(node, candidates, args, hasCandidatesOutArray) {
            ts.Debug.assert(candidates.length > 0);
            checkNodeDeferred(node);
            return hasCandidatesOutArray || candidates.length === 1 || candidates.some(function (c) { return !!c.typeParameters; })
                ? pickLongestCandidateSignature(node, candidates, args)
                : createUnionOfSignaturesForOverloadFailure(candidates);
        }
        function createUnionOfSignaturesForOverloadFailure(candidates) {
            var thisParameters = ts.mapDefined(candidates, function (c) { return c.thisParameter; });
            var thisParameter;
            if (thisParameters.length) {
                thisParameter = createCombinedSymbolFromTypes(thisParameters, thisParameters.map(getTypeOfParameter));
            }
            var _a = ts.minAndMax(candidates, getNumNonRestParameters), minArgumentCount = _a.min, maxNonRestParam = _a.max;
            var parameters = [];
            var _loop_18 = function (i) {
                var symbols = ts.mapDefined(candidates, function (s) { return signatureHasRestParameter(s) ?
                    i < s.parameters.length - 1 ? s.parameters[i] : ts.last(s.parameters) :
                    i < s.parameters.length ? s.parameters[i] : undefined; });
                ts.Debug.assert(symbols.length !== 0);
                parameters.push(createCombinedSymbolFromTypes(symbols, ts.mapDefined(candidates, function (candidate) { return tryGetTypeAtPosition(candidate, i); })));
            };
            for (var i = 0; i < maxNonRestParam; i++) {
                _loop_18(i);
            }
            var restParameterSymbols = ts.mapDefined(candidates, function (c) { return signatureHasRestParameter(c) ? ts.last(c.parameters) : undefined; });
            var flags = 0;
            if (restParameterSymbols.length !== 0) {
                var type = createArrayType(getUnionType(ts.mapDefined(candidates, tryGetRestTypeOfSignature), 2));
                parameters.push(createCombinedSymbolForOverloadFailure(restParameterSymbols, type));
                flags |= 1;
            }
            if (candidates.some(signatureHasLiteralTypes)) {
                flags |= 2;
            }
            return createSignature(candidates[0].declaration, undefined, thisParameter, parameters, getIntersectionType(candidates.map(getReturnTypeOfSignature)), undefined, minArgumentCount, flags);
        }
        function getNumNonRestParameters(signature) {
            var numParams = signature.parameters.length;
            return signatureHasRestParameter(signature) ? numParams - 1 : numParams;
        }
        function createCombinedSymbolFromTypes(sources, types) {
            return createCombinedSymbolForOverloadFailure(sources, getUnionType(types, 2));
        }
        function createCombinedSymbolForOverloadFailure(sources, type) {
            return createSymbolWithType(ts.first(sources), type);
        }
        function pickLongestCandidateSignature(node, candidates, args) {
            var bestIndex = getLongestCandidateIndex(candidates, apparentArgumentCount === undefined ? args.length : apparentArgumentCount);
            var candidate = candidates[bestIndex];
            var typeParameters = candidate.typeParameters;
            if (!typeParameters) {
                return candidate;
            }
            var typeArgumentNodes = callLikeExpressionMayHaveTypeArguments(node) ? node.typeArguments : undefined;
            var instantiated = typeArgumentNodes
                ? createSignatureInstantiation(candidate, getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, ts.isInJSFile(node)))
                : inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args);
            candidates[bestIndex] = instantiated;
            return instantiated;
        }
        function getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isJs) {
            var typeArguments = typeArgumentNodes.map(getTypeOfNode);
            while (typeArguments.length > typeParameters.length) {
                typeArguments.pop();
            }
            while (typeArguments.length < typeParameters.length) {
                typeArguments.push(getConstraintOfTypeParameter(typeParameters[typeArguments.length]) || getDefaultTypeArgumentType(isJs));
            }
            return typeArguments;
        }
        function inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args) {
            var inferenceContext = createInferenceContext(typeParameters, candidate, ts.isInJSFile(node) ? 2 : 0);
            var typeArgumentTypes = inferTypeArguments(node, candidate, args, 4 | 8, inferenceContext);
            return createSignatureInstantiation(candidate, typeArgumentTypes);
        }
        function getLongestCandidateIndex(candidates, argsCount) {
            var maxParamsIndex = -1;
            var maxParams = -1;
            for (var i = 0; i < candidates.length; i++) {
                var candidate = candidates[i];
                var paramCount = getParameterCount(candidate);
                if (hasEffectiveRestParameter(candidate) || paramCount >= argsCount) {
                    return i;
                }
                if (paramCount > maxParams) {
                    maxParams = paramCount;
                    maxParamsIndex = i;
                }
            }
            return maxParamsIndex;
        }
        function resolveCallExpression(node, candidatesOutArray, checkMode) {
            if (node.expression.kind === 102) {
                var superType = checkSuperExpression(node.expression);
                if (isTypeAny(superType)) {
                    for (var _i = 0, _a = node.arguments; _i < _a.length; _i++) {
                        var arg = _a[_i];
                        checkExpression(arg);
                    }
                    return anySignature;
                }
                if (superType !== errorType) {
                    var baseTypeNode = ts.getEffectiveBaseTypeNode(ts.getContainingClass(node));
                    if (baseTypeNode) {
                        var baseConstructors = getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode);
                        return resolveCall(node, baseConstructors, candidatesOutArray, checkMode, 0);
                    }
                }
                return resolveUntypedCall(node);
            }
            var callChainFlags;
            var funcType = checkExpression(node.expression);
            if (ts.isCallChain(node)) {
                var nonOptionalType = getOptionalExpressionType(funcType, node.expression);
                callChainFlags = nonOptionalType === funcType ? 0 :
                    ts.isOutermostOptionalChain(node) ? 8 :
                        4;
                funcType = nonOptionalType;
            }
            else {
                callChainFlags = 0;
            }
            funcType = checkNonNullTypeWithReporter(funcType, node.expression, reportCannotInvokePossiblyNullOrUndefinedError);
            if (funcType === silentNeverType) {
                return silentNeverSignature;
            }
            var apparentType = getApparentType(funcType);
            if (apparentType === errorType) {
                return resolveErrorCall(node);
            }
            var callSignatures = getSignaturesOfType(apparentType, 0);
            var numConstructSignatures = getSignaturesOfType(apparentType, 1).length;
            if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures)) {
                if (funcType !== errorType && node.typeArguments) {
                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
                }
                return resolveUntypedCall(node);
            }
            if (!callSignatures.length) {
                if (numConstructSignatures) {
                    error(node, ts.Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
                }
                else {
                    var relatedInformation = void 0;
                    if (node.arguments.length === 1) {
                        var text = ts.getSourceFileOfNode(node).text;
                        if (ts.isLineBreak(text.charCodeAt(ts.skipTrivia(text, node.expression.end, true) - 1))) {
                            relatedInformation = ts.createDiagnosticForNode(node.expression, ts.Diagnostics.Are_you_missing_a_semicolon);
                        }
                    }
                    invocationError(node.expression, apparentType, 0, relatedInformation);
                }
                return resolveErrorCall(node);
            }
            if (checkMode & 8 && !node.typeArguments && callSignatures.some(isGenericFunctionReturningFunction)) {
                skippedGenericFunction(node, checkMode);
                return resolvingSignature;
            }
            if (callSignatures.some(function (sig) { return ts.isInJSFile(sig.declaration) && !!ts.getJSDocClassTag(sig.declaration); })) {
                error(node, ts.Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
                return resolveErrorCall(node);
            }
            return resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags);
        }
        function isGenericFunctionReturningFunction(signature) {
            return !!(signature.typeParameters && isFunctionType(getReturnTypeOfSignature(signature)));
        }
        function isUntypedFunctionCall(funcType, apparentFuncType, numCallSignatures, numConstructSignatures) {
            return isTypeAny(funcType) || isTypeAny(apparentFuncType) && !!(funcType.flags & 262144) ||
                !numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags & (1048576 | 131072)) && isTypeAssignableTo(funcType, globalFunctionType);
        }
        function resolveNewExpression(node, candidatesOutArray, checkMode) {
            if (node.arguments && languageVersion < 1) {
                var spreadIndex = getSpreadArgumentIndex(node.arguments);
                if (spreadIndex >= 0) {
                    error(node.arguments[spreadIndex], ts.Diagnostics.Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher);
                }
            }
            var expressionType = checkNonNullExpression(node.expression);
            if (expressionType === silentNeverType) {
                return silentNeverSignature;
            }
            expressionType = getApparentType(expressionType);
            if (expressionType === errorType) {
                return resolveErrorCall(node);
            }
            if (isTypeAny(expressionType)) {
                if (node.typeArguments) {
                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
                }
                return resolveUntypedCall(node);
            }
            var constructSignatures = getSignaturesOfType(expressionType, 1);
            if (constructSignatures.length) {
                if (!isConstructorAccessible(node, constructSignatures[0])) {
                    return resolveErrorCall(node);
                }
                var valueDecl = expressionType.symbol && ts.getClassLikeDeclarationOfSymbol(expressionType.symbol);
                if (valueDecl && ts.hasModifier(valueDecl, 128)) {
                    error(node, ts.Diagnostics.Cannot_create_an_instance_of_an_abstract_class);
                    return resolveErrorCall(node);
                }
                return resolveCall(node, constructSignatures, candidatesOutArray, checkMode, 0);
            }
            var callSignatures = getSignaturesOfType(expressionType, 0);
            if (callSignatures.length) {
                var signature = resolveCall(node, callSignatures, candidatesOutArray, checkMode, 0);
                if (!noImplicitAny) {
                    if (signature.declaration && !isJSConstructor(signature.declaration) && getReturnTypeOfSignature(signature) !== voidType) {
                        error(node, ts.Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);
                    }
                    if (getThisTypeOfSignature(signature) === voidType) {
                        error(node, ts.Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void);
                    }
                }
                return signature;
            }
            invocationError(node.expression, expressionType, 1);
            return resolveErrorCall(node);
        }
        function typeHasProtectedAccessibleBase(target, type) {
            var baseTypes = getBaseTypes(type);
            if (!ts.length(baseTypes)) {
                return false;
            }
            var firstBase = baseTypes[0];
            if (firstBase.flags & 2097152) {
                var types = firstBase.types;
                var mixinFlags = findMixins(types);
                var i = 0;
                for (var _i = 0, _a = firstBase.types; _i < _a.length; _i++) {
                    var intersectionMember = _a[_i];
                    if (!mixinFlags[i]) {
                        if (ts.getObjectFlags(intersectionMember) & (1 | 2)) {
                            if (intersectionMember.symbol === target) {
                                return true;
                            }
                            if (typeHasProtectedAccessibleBase(target, intersectionMember)) {
                                return true;
                            }
                        }
                    }
                    i++;
                }
                return false;
            }
            if (firstBase.symbol === target) {
                return true;
            }
            return typeHasProtectedAccessibleBase(target, firstBase);
        }
        function isConstructorAccessible(node, signature) {
            if (!signature || !signature.declaration) {
                return true;
            }
            var declaration = signature.declaration;
            var modifiers = ts.getSelectedModifierFlags(declaration, 24);
            if (!modifiers || declaration.kind !== 162) {
                return true;
            }
            var declaringClassDeclaration = ts.getClassLikeDeclarationOfSymbol(declaration.parent.symbol);
            var declaringClass = getDeclaredTypeOfSymbol(declaration.parent.symbol);
            if (!isNodeWithinClass(node, declaringClassDeclaration)) {
                var containingClass = ts.getContainingClass(node);
                if (containingClass && modifiers & 16) {
                    var containingType = getTypeOfNode(containingClass);
                    if (typeHasProtectedAccessibleBase(declaration.parent.symbol, containingType)) {
                        return true;
                    }
                }
                if (modifiers & 8) {
                    error(node, ts.Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
                }
                if (modifiers & 16) {
                    error(node, ts.Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
                }
                return false;
            }
            return true;
        }
        function invocationErrorDetails(apparentType, kind) {
            var errorInfo;
            var isCall = kind === 0;
            var awaitedType = getAwaitedType(apparentType);
            var maybeMissingAwait = awaitedType && getSignaturesOfType(awaitedType, kind).length > 0;
            if (apparentType.flags & 1048576) {
                var types = apparentType.types;
                var hasSignatures = false;
                for (var _i = 0, types_18 = types; _i < types_18.length; _i++) {
                    var constituent = types_18[_i];
                    var signatures = getSignaturesOfType(constituent, kind);
                    if (signatures.length !== 0) {
                        hasSignatures = true;
                        if (errorInfo) {
                            break;
                        }
                    }
                    else {
                        if (!errorInfo) {
                            errorInfo = ts.chainDiagnosticMessages(errorInfo, isCall ?
                                ts.Diagnostics.Type_0_has_no_call_signatures :
                                ts.Diagnostics.Type_0_has_no_construct_signatures, typeToString(constituent));
                            errorInfo = ts.chainDiagnosticMessages(errorInfo, isCall ?
                                ts.Diagnostics.Not_all_constituents_of_type_0_are_callable :
                                ts.Diagnostics.Not_all_constituents_of_type_0_are_constructable, typeToString(apparentType));
                        }
                        if (hasSignatures) {
                            break;
                        }
                    }
                }
                if (!hasSignatures) {
                    errorInfo = ts.chainDiagnosticMessages(undefined, isCall ?
                        ts.Diagnostics.No_constituent_of_type_0_is_callable :
                        ts.Diagnostics.No_constituent_of_type_0_is_constructable, typeToString(apparentType));
                }
                if (!errorInfo) {
                    errorInfo = ts.chainDiagnosticMessages(errorInfo, isCall ?
                        ts.Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other :
                        ts.Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other, typeToString(apparentType));
                }
            }
            else {
                errorInfo = ts.chainDiagnosticMessages(errorInfo, isCall ?
                    ts.Diagnostics.Type_0_has_no_call_signatures :
                    ts.Diagnostics.Type_0_has_no_construct_signatures, typeToString(apparentType));
            }
            return {
                messageChain: ts.chainDiagnosticMessages(errorInfo, isCall ? ts.Diagnostics.This_expression_is_not_callable : ts.Diagnostics.This_expression_is_not_constructable),
                relatedMessage: maybeMissingAwait ? ts.Diagnostics.Did_you_forget_to_use_await : undefined,
            };
        }
        function invocationError(errorTarget, apparentType, kind, relatedInformation) {
            var _a = invocationErrorDetails(apparentType, kind), messageChain = _a.messageChain, relatedInfo = _a.relatedMessage;
            var diagnostic = ts.createDiagnosticForNodeFromMessageChain(errorTarget, messageChain);
            if (relatedInfo) {
                ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(errorTarget, relatedInfo));
            }
            if (ts.isCallExpression(errorTarget.parent)) {
                var _b = getDiagnosticSpanForCallNode(errorTarget.parent, true), start = _b.start, length_7 = _b.length;
                diagnostic.start = start;
                diagnostic.length = length_7;
            }
            diagnostics.add(diagnostic);
            invocationErrorRecovery(apparentType, kind, relatedInformation ? ts.addRelatedInfo(diagnostic, relatedInformation) : diagnostic);
        }
        function invocationErrorRecovery(apparentType, kind, diagnostic) {
            if (!apparentType.symbol) {
                return;
            }
            var importNode = getSymbolLinks(apparentType.symbol).originatingImport;
            if (importNode && !ts.isImportCall(importNode)) {
                var sigs = getSignaturesOfType(getTypeOfSymbol(getSymbolLinks(apparentType.symbol).target), kind);
                if (!sigs || !sigs.length)
                    return;
                ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(importNode, ts.Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead));
            }
        }
        function resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode) {
            var tagType = checkExpression(node.tag);
            var apparentType = getApparentType(tagType);
            if (apparentType === errorType) {
                return resolveErrorCall(node);
            }
            var callSignatures = getSignaturesOfType(apparentType, 0);
            var numConstructSignatures = getSignaturesOfType(apparentType, 1).length;
            if (isUntypedFunctionCall(tagType, apparentType, callSignatures.length, numConstructSignatures)) {
                return resolveUntypedCall(node);
            }
            if (!callSignatures.length) {
                invocationError(node.tag, apparentType, 0);
                return resolveErrorCall(node);
            }
            return resolveCall(node, callSignatures, candidatesOutArray, checkMode, 0);
        }
        function getDiagnosticHeadMessageForDecoratorResolution(node) {
            switch (node.parent.kind) {
                case 245:
                case 214:
                    return ts.Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;
                case 156:
                    return ts.Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;
                case 159:
                    return ts.Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;
                case 161:
                case 163:
                case 164:
                    return ts.Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;
                default:
                    return ts.Debug.fail();
            }
        }
        function resolveDecorator(node, candidatesOutArray, checkMode) {
            var funcType = checkExpression(node.expression);
            var apparentType = getApparentType(funcType);
            if (apparentType === errorType) {
                return resolveErrorCall(node);
            }
            var callSignatures = getSignaturesOfType(apparentType, 0);
            var numConstructSignatures = getSignaturesOfType(apparentType, 1).length;
            if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures)) {
                return resolveUntypedCall(node);
            }
            if (isPotentiallyUncalledDecorator(node, callSignatures)) {
                var nodeStr = ts.getTextOfNode(node.expression, false);
                error(node, ts.Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0, nodeStr);
                return resolveErrorCall(node);
            }
            var headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
            if (!callSignatures.length) {
                var errorDetails = invocationErrorDetails(apparentType, 0);
                var messageChain = ts.chainDiagnosticMessages(errorDetails.messageChain, headMessage);
                var diag = ts.createDiagnosticForNodeFromMessageChain(node.expression, messageChain);
                if (errorDetails.relatedMessage) {
                    ts.addRelatedInfo(diag, ts.createDiagnosticForNode(node.expression, errorDetails.relatedMessage));
                }
                diagnostics.add(diag);
                invocationErrorRecovery(apparentType, 0, diag);
                return resolveErrorCall(node);
            }
            return resolveCall(node, callSignatures, candidatesOutArray, checkMode, 0, headMessage);
        }
        function createSignatureForJSXIntrinsic(node, result) {
            var namespace = getJsxNamespaceAt(node);
            var exports = namespace && getExportsOfSymbol(namespace);
            var typeSymbol = exports && getSymbol(exports, JsxNames.Element, 788968);
            var returnNode = typeSymbol && nodeBuilder.symbolToEntityName(typeSymbol, 788968, node);
            var declaration = ts.createFunctionTypeNode(undefined, [ts.createParameter(undefined, undefined, undefined, "props", undefined, nodeBuilder.typeToTypeNode(result, node))], returnNode ? ts.createTypeReferenceNode(returnNode, undefined) : ts.createKeywordTypeNode(125));
            var parameterSymbol = createSymbol(1, "props");
            parameterSymbol.type = result;
            return createSignature(declaration, undefined, undefined, [parameterSymbol], typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType, undefined, 1, 0);
        }
        function resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode) {
            if (isJsxIntrinsicIdentifier(node.tagName)) {
                var result = getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node);
                var fakeSignature = createSignatureForJSXIntrinsic(node, result);
                checkTypeAssignableToAndOptionallyElaborate(checkExpressionWithContextualType(node.attributes, getEffectiveFirstArgumentForJsxSignature(fakeSignature, node), undefined, 0), result, node.tagName, node.attributes);
                return fakeSignature;
            }
            var exprTypes = checkExpression(node.tagName);
            var apparentType = getApparentType(exprTypes);
            if (apparentType === errorType) {
                return resolveErrorCall(node);
            }
            var signatures = getUninstantiatedJsxSignaturesOfType(exprTypes, node);
            if (isUntypedFunctionCall(exprTypes, apparentType, signatures.length, 0)) {
                return resolveUntypedCall(node);
            }
            if (signatures.length === 0) {
                error(node.tagName, ts.Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, ts.getTextOfNode(node.tagName));
                return resolveErrorCall(node);
            }
            return resolveCall(node, signatures, candidatesOutArray, checkMode, 0);
        }
        function isPotentiallyUncalledDecorator(decorator, signatures) {
            return signatures.length && ts.every(signatures, function (signature) {
                return signature.minArgumentCount === 0 &&
                    !signatureHasRestParameter(signature) &&
                    signature.parameters.length < getDecoratorArgumentCount(decorator, signature);
            });
        }
        function resolveSignature(node, candidatesOutArray, checkMode) {
            switch (node.kind) {
                case 196:
                    return resolveCallExpression(node, candidatesOutArray, checkMode);
                case 197:
                    return resolveNewExpression(node, candidatesOutArray, checkMode);
                case 198:
                    return resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode);
                case 157:
                    return resolveDecorator(node, candidatesOutArray, checkMode);
                case 268:
                case 267:
                    return resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode);
            }
            throw ts.Debug.assertNever(node, "Branch in 'resolveSignature' should be unreachable.");
        }
        function getResolvedSignature(node, candidatesOutArray, checkMode) {
            var links = getNodeLinks(node);
            var cached = links.resolvedSignature;
            if (cached && cached !== resolvingSignature && !candidatesOutArray) {
                return cached;
            }
            links.resolvedSignature = resolvingSignature;
            var result = resolveSignature(node, candidatesOutArray, checkMode || 0);
            if (result !== resolvingSignature) {
                links.resolvedSignature = flowLoopStart === flowLoopCount ? result : cached;
            }
            return result;
        }
        function isJSConstructor(node) {
            if (!node || !ts.isInJSFile(node)) {
                return false;
            }
            var func = ts.isFunctionDeclaration(node) || ts.isFunctionExpression(node) ? node :
                ts.isVariableDeclaration(node) && node.initializer && ts.isFunctionExpression(node.initializer) ? node.initializer :
                    undefined;
            if (func) {
                if (ts.getJSDocClassTag(node))
                    return true;
                var symbol = getSymbolOfNode(func);
                return !!symbol && ts.hasEntries(symbol.members);
            }
            return false;
        }
        function mergeJSSymbols(target, source) {
            if (source) {
                var links = getSymbolLinks(source);
                if (!links.inferredClassSymbol || !links.inferredClassSymbol.has("" + getSymbolId(target))) {
                    var inferred = ts.isTransientSymbol(target) ? target : cloneSymbol(target);
                    inferred.exports = inferred.exports || ts.createSymbolTable();
                    inferred.members = inferred.members || ts.createSymbolTable();
                    inferred.flags |= source.flags & 32;
                    if (ts.hasEntries(source.exports)) {
                        mergeSymbolTable(inferred.exports, source.exports);
                    }
                    if (ts.hasEntries(source.members)) {
                        mergeSymbolTable(inferred.members, source.members);
                    }
                    (links.inferredClassSymbol || (links.inferredClassSymbol = ts.createMap())).set("" + getSymbolId(inferred), inferred);
                    return inferred;
                }
                return links.inferredClassSymbol.get("" + getSymbolId(target));
            }
        }
        function getAssignedClassSymbol(decl) {
            var assignmentSymbol = decl && decl.parent &&
                (ts.isFunctionDeclaration(decl) && getSymbolOfNode(decl) ||
                    ts.isBinaryExpression(decl.parent) && getSymbolOfNode(decl.parent.left) ||
                    ts.isVariableDeclaration(decl.parent) && getSymbolOfNode(decl.parent));
            var prototype = assignmentSymbol && assignmentSymbol.exports && assignmentSymbol.exports.get("prototype");
            var init = prototype && prototype.valueDeclaration && getAssignedJSPrototype(prototype.valueDeclaration);
            return init ? getSymbolOfNode(init) : undefined;
        }
        function getAssignedJSPrototype(node) {
            if (!node.parent) {
                return false;
            }
            var parent = node.parent;
            while (parent && parent.kind === 194) {
                parent = parent.parent;
            }
            if (parent && ts.isBinaryExpression(parent) && ts.isPrototypeAccess(parent.left) && parent.operatorToken.kind === 62) {
                var right = ts.getInitializerOfBinaryExpression(parent);
                return ts.isObjectLiteralExpression(right) && right;
            }
        }
        function checkCallExpression(node, checkMode) {
            if (!checkGrammarTypeArguments(node, node.typeArguments))
                checkGrammarArguments(node.arguments);
            var signature = getResolvedSignature(node, undefined, checkMode);
            if (signature === resolvingSignature) {
                return nonInferrableType;
            }
            if (node.expression.kind === 102) {
                return voidType;
            }
            if (node.kind === 197) {
                var declaration = signature.declaration;
                if (declaration &&
                    declaration.kind !== 162 &&
                    declaration.kind !== 166 &&
                    declaration.kind !== 171 &&
                    !ts.isJSDocConstructSignature(declaration) &&
                    !isJSConstructor(declaration)) {
                    if (noImplicitAny) {
                        error(node, ts.Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);
                    }
                    return anyType;
                }
            }
            if (ts.isInJSFile(node) && isCommonJsRequire(node)) {
                return resolveExternalModuleTypeByLiteral(node.arguments[0]);
            }
            var returnType = getReturnTypeOfSignature(signature);
            if (returnType.flags & 12288 && isSymbolOrSymbolForCall(node)) {
                return getESSymbolLikeTypeForNode(ts.walkUpParenthesizedExpressions(node.parent));
            }
            if (node.kind === 196 && node.parent.kind === 226 &&
                returnType.flags & 16384 && getTypePredicateOfSignature(signature)) {
                if (!ts.isDottedName(node.expression)) {
                    error(node.expression, ts.Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name);
                }
                else if (!getEffectsSignature(node)) {
                    var diagnostic = error(node.expression, ts.Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation);
                    getTypeOfDottedName(node.expression, diagnostic);
                }
            }
            if (ts.isInJSFile(node)) {
                var decl = ts.getDeclarationOfExpando(node);
                if (decl) {
                    var jsSymbol = getSymbolOfNode(decl);
                    if (jsSymbol && ts.hasEntries(jsSymbol.exports)) {
                        var jsAssignmentType = createAnonymousType(jsSymbol, jsSymbol.exports, ts.emptyArray, ts.emptyArray, undefined, undefined);
                        jsAssignmentType.objectFlags |= 16384;
                        return getIntersectionType([returnType, jsAssignmentType]);
                    }
                }
            }
            return returnType;
        }
        function isSymbolOrSymbolForCall(node) {
            if (!ts.isCallExpression(node))
                return false;
            var left = node.expression;
            if (ts.isPropertyAccessExpression(left) && left.name.escapedText === "for") {
                left = left.expression;
            }
            if (!ts.isIdentifier(left) || left.escapedText !== "Symbol") {
                return false;
            }
            var globalESSymbol = getGlobalESSymbolConstructorSymbol(false);
            if (!globalESSymbol) {
                return false;
            }
            return globalESSymbol === resolveName(left, "Symbol", 111551, undefined, undefined, false);
        }
        function checkImportCallExpression(node) {
            if (!checkGrammarArguments(node.arguments))
                checkGrammarImportCallExpression(node);
            if (node.arguments.length === 0) {
                return createPromiseReturnType(node, anyType);
            }
            var specifier = node.arguments[0];
            var specifierType = checkExpressionCached(specifier);
            for (var i = 1; i < node.arguments.length; ++i) {
                checkExpressionCached(node.arguments[i]);
            }
            if (specifierType.flags & 32768 || specifierType.flags & 65536 || !isTypeAssignableTo(specifierType, stringType)) {
                error(specifier, ts.Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0, typeToString(specifierType));
            }
            var moduleSymbol = resolveExternalModuleName(node, specifier);
            if (moduleSymbol) {
                var esModuleSymbol = resolveESModuleSymbol(moduleSymbol, specifier, true, false);
                if (esModuleSymbol) {
                    return createPromiseReturnType(node, getTypeWithSyntheticDefaultImportType(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol));
                }
            }
            return createPromiseReturnType(node, anyType);
        }
        function getTypeWithSyntheticDefaultImportType(type, symbol, originalSymbol) {
            if (allowSyntheticDefaultImports && type && type !== errorType) {
                var synthType = type;
                if (!synthType.syntheticType) {
                    var file = ts.find(originalSymbol.declarations, ts.isSourceFile);
                    var hasSyntheticDefault = canHaveSyntheticDefault(file, originalSymbol, false);
                    if (hasSyntheticDefault) {
                        var memberTable = ts.createSymbolTable();
                        var newSymbol = createSymbol(2097152, "default");
                        newSymbol.nameType = getLiteralType("default");
                        newSymbol.target = resolveSymbol(symbol);
                        memberTable.set("default", newSymbol);
                        var anonymousSymbol = createSymbol(2048, "__type");
                        var defaultContainingObject = createAnonymousType(anonymousSymbol, memberTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
                        anonymousSymbol.type = defaultContainingObject;
                        synthType.syntheticType = isValidSpreadType(type) ? getSpreadType(type, defaultContainingObject, anonymousSymbol, 0, false) : defaultContainingObject;
                    }
                    else {
                        synthType.syntheticType = type;
                    }
                }
                return synthType.syntheticType;
            }
            return type;
        }
        function isCommonJsRequire(node) {
            if (!ts.isRequireCall(node, true)) {
                return false;
            }
            if (!ts.isIdentifier(node.expression))
                return ts.Debug.fail();
            var resolvedRequire = resolveName(node.expression, node.expression.escapedText, 111551, undefined, undefined, true);
            if (resolvedRequire === requireSymbol) {
                return true;
            }
            if (resolvedRequire.flags & 2097152) {
                return false;
            }
            var targetDeclarationKind = resolvedRequire.flags & 16
                ? 244
                : resolvedRequire.flags & 3
                    ? 242
                    : 0;
            if (targetDeclarationKind !== 0) {
                var decl = ts.getDeclarationOfKind(resolvedRequire, targetDeclarationKind);
                return !!decl && !!(decl.flags & 8388608);
            }
            return false;
        }
        function checkTaggedTemplateExpression(node) {
            if (!checkGrammarTaggedTemplateChain(node))
                checkGrammarTypeArguments(node, node.typeArguments);
            if (languageVersion < 2) {
                checkExternalEmitHelpers(node, 131072);
            }
            return getReturnTypeOfSignature(getResolvedSignature(node));
        }
        function checkAssertion(node) {
            return checkAssertionWorker(node, node.type, node.expression);
        }
        function isValidConstAssertionArgument(node) {
            switch (node.kind) {
                case 10:
                case 14:
                case 8:
                case 9:
                case 106:
                case 91:
                case 192:
                case 193:
                    return true;
                case 200:
                    return isValidConstAssertionArgument(node.expression);
                case 207:
                    var op = node.operator;
                    var arg = node.operand;
                    return op === 40 && (arg.kind === 8 || arg.kind === 9) ||
                        op === 39 && arg.kind === 8;
                case 194:
                case 195:
                    var expr = node.expression;
                    if (ts.isIdentifier(expr)) {
                        var symbol = getSymbolAtLocation(expr);
                        if (symbol && symbol.flags & 2097152) {
                            symbol = resolveAlias(symbol);
                        }
                        return !!(symbol && (symbol.flags & 384) && getEnumKind(symbol) === 1);
                    }
            }
            return false;
        }
        function checkAssertionWorker(errNode, type, expression, checkMode) {
            var exprType = checkExpression(expression, checkMode);
            if (ts.isConstTypeReference(type)) {
                if (!isValidConstAssertionArgument(expression)) {
                    error(expression, ts.Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals);
                }
                return getRegularTypeOfLiteralType(exprType);
            }
            checkSourceElement(type);
            exprType = getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(exprType));
            var targetType = getTypeFromTypeNode(type);
            if (produceDiagnostics && targetType !== errorType) {
                var widenedType = getWidenedType(exprType);
                if (!isTypeComparableTo(targetType, widenedType)) {
                    checkTypeComparableTo(exprType, targetType, errNode, ts.Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first);
                }
            }
            return targetType;
        }
        function checkNonNullChain(node) {
            var leftType = checkExpression(node.expression);
            var nonOptionalType = getOptionalExpressionType(leftType, node.expression);
            return propagateOptionalTypeMarker(getNonNullableType(nonOptionalType), node, nonOptionalType !== leftType);
        }
        function checkNonNullAssertion(node) {
            return node.flags & 32 ? checkNonNullChain(node) :
                getNonNullableType(checkExpression(node.expression));
        }
        function checkMetaProperty(node) {
            checkGrammarMetaProperty(node);
            if (node.keywordToken === 99) {
                return checkNewTargetMetaProperty(node);
            }
            if (node.keywordToken === 96) {
                return checkImportMetaProperty(node);
            }
            return ts.Debug.assertNever(node.keywordToken);
        }
        function checkNewTargetMetaProperty(node) {
            var container = ts.getNewTargetContainer(node);
            if (!container) {
                error(node, ts.Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, "new.target");
                return errorType;
            }
            else if (container.kind === 162) {
                var symbol = getSymbolOfNode(container.parent);
                return getTypeOfSymbol(symbol);
            }
            else {
                var symbol = getSymbolOfNode(container);
                return getTypeOfSymbol(symbol);
            }
        }
        function checkImportMetaProperty(node) {
            if (moduleKind !== ts.ModuleKind.ESNext && moduleKind !== ts.ModuleKind.System) {
                error(node, ts.Diagnostics.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_esnext_or_system);
            }
            var file = ts.getSourceFileOfNode(node);
            ts.Debug.assert(!!(file.flags & 2097152), "Containing file is missing import meta node flag.");
            ts.Debug.assert(!!file.externalModuleIndicator, "Containing file should be a module.");
            return node.name.escapedText === "meta" ? getGlobalImportMetaType() : errorType;
        }
        function getTypeOfParameter(symbol) {
            var type = getTypeOfSymbol(symbol);
            if (strictNullChecks) {
                var declaration = symbol.valueDeclaration;
                if (declaration && ts.hasInitializer(declaration)) {
                    return getOptionalType(type);
                }
            }
            return type;
        }
        function getParameterNameAtPosition(signature, pos) {
            var paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
            if (pos < paramCount) {
                return signature.parameters[pos].escapedName;
            }
            var restParameter = signature.parameters[paramCount] || unknownSymbol;
            var restType = getTypeOfSymbol(restParameter);
            if (isTupleType(restType)) {
                var associatedNames = restType.target.associatedNames;
                var index = pos - paramCount;
                return associatedNames && associatedNames[index] || restParameter.escapedName + "_" + index;
            }
            return restParameter.escapedName;
        }
        function getTypeAtPosition(signature, pos) {
            return tryGetTypeAtPosition(signature, pos) || anyType;
        }
        function tryGetTypeAtPosition(signature, pos) {
            var paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
            if (pos < paramCount) {
                return getTypeOfParameter(signature.parameters[pos]);
            }
            if (signatureHasRestParameter(signature)) {
                var restType = getTypeOfSymbol(signature.parameters[paramCount]);
                var index = pos - paramCount;
                if (!isTupleType(restType) || restType.target.hasRestElement || index < getTypeArguments(restType).length) {
                    return getIndexedAccessType(restType, getLiteralType(index));
                }
            }
            return undefined;
        }
        function getRestTypeAtPosition(source, pos) {
            var paramCount = getParameterCount(source);
            var restType = getEffectiveRestType(source);
            var nonRestCount = paramCount - (restType ? 1 : 0);
            if (restType && pos === nonRestCount) {
                return restType;
            }
            var types = [];
            var names = [];
            for (var i = pos; i < nonRestCount; i++) {
                types.push(getTypeAtPosition(source, i));
                names.push(getParameterNameAtPosition(source, i));
            }
            if (restType) {
                types.push(getIndexedAccessType(restType, numberType));
                names.push(getParameterNameAtPosition(source, nonRestCount));
            }
            var minArgumentCount = getMinArgumentCount(source);
            var minLength = minArgumentCount < pos ? 0 : minArgumentCount - pos;
            return createTupleType(types, minLength, !!restType, false, names);
        }
        function getParameterCount(signature) {
            var length = signature.parameters.length;
            if (signatureHasRestParameter(signature)) {
                var restType = getTypeOfSymbol(signature.parameters[length - 1]);
                if (isTupleType(restType)) {
                    return length + getTypeArguments(restType).length - 1;
                }
            }
            return length;
        }
        function getMinArgumentCount(signature, strongArityForUntypedJS) {
            if (signatureHasRestParameter(signature)) {
                var restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                if (isTupleType(restType)) {
                    var minLength = restType.target.minLength;
                    if (minLength > 0) {
                        return signature.parameters.length - 1 + minLength;
                    }
                }
            }
            if (!strongArityForUntypedJS && signature.flags & 16) {
                return 0;
            }
            return signature.minArgumentCount;
        }
        function hasEffectiveRestParameter(signature) {
            if (signatureHasRestParameter(signature)) {
                var restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                return !isTupleType(restType) || restType.target.hasRestElement;
            }
            return false;
        }
        function getEffectiveRestType(signature) {
            if (signatureHasRestParameter(signature)) {
                var restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                return isTupleType(restType) ? getRestArrayTypeOfTupleType(restType) : restType;
            }
            return undefined;
        }
        function getNonArrayRestType(signature) {
            var restType = getEffectiveRestType(signature);
            return restType && !isArrayType(restType) && !isTypeAny(restType) && (getReducedType(restType).flags & 131072) === 0 ? restType : undefined;
        }
        function getTypeOfFirstParameterOfSignature(signature) {
            return getTypeOfFirstParameterOfSignatureWithFallback(signature, neverType);
        }
        function getTypeOfFirstParameterOfSignatureWithFallback(signature, fallbackType) {
            return signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : fallbackType;
        }
        function inferFromAnnotatedParameters(signature, context, inferenceContext) {
            var len = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
            for (var i = 0; i < len; i++) {
                var declaration = signature.parameters[i].valueDeclaration;
                if (declaration.type) {
                    var typeNode = ts.getEffectiveTypeAnnotationNode(declaration);
                    if (typeNode) {
                        inferTypes(inferenceContext.inferences, getTypeFromTypeNode(typeNode), getTypeAtPosition(context, i));
                    }
                }
            }
            var restType = getEffectiveRestType(context);
            if (restType && restType.flags & 262144) {
                var instantiatedContext = instantiateSignature(context, inferenceContext.nonFixingMapper);
                assignContextualParameterTypes(signature, instantiatedContext);
                var restPos = getParameterCount(context) - 1;
                inferTypes(inferenceContext.inferences, getRestTypeAtPosition(signature, restPos), restType);
            }
        }
        function assignContextualParameterTypes(signature, context) {
            signature.typeParameters = context.typeParameters;
            if (context.thisParameter) {
                var parameter = signature.thisParameter;
                if (!parameter || parameter.valueDeclaration && !parameter.valueDeclaration.type) {
                    if (!parameter) {
                        signature.thisParameter = createSymbolWithType(context.thisParameter, undefined);
                    }
                    assignParameterType(signature.thisParameter, getTypeOfSymbol(context.thisParameter));
                }
            }
            var len = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
            for (var i = 0; i < len; i++) {
                var parameter = signature.parameters[i];
                if (!ts.getEffectiveTypeAnnotationNode(parameter.valueDeclaration)) {
                    var contextualParameterType = tryGetTypeAtPosition(context, i);
                    assignParameterType(parameter, contextualParameterType);
                }
            }
            if (signatureHasRestParameter(signature)) {
                var parameter = ts.last(signature.parameters);
                if (ts.isTransientSymbol(parameter) || !ts.getEffectiveTypeAnnotationNode(parameter.valueDeclaration)) {
                    var contextualParameterType = getRestTypeAtPosition(context, len);
                    assignParameterType(parameter, contextualParameterType);
                }
            }
        }
        function assignNonContextualParameterTypes(signature) {
            if (signature.thisParameter) {
                assignParameterType(signature.thisParameter);
            }
            for (var _i = 0, _a = signature.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                assignParameterType(parameter);
            }
        }
        function assignParameterType(parameter, type) {
            var links = getSymbolLinks(parameter);
            if (!links.type) {
                var declaration = parameter.valueDeclaration;
                links.type = type || getWidenedTypeForVariableLikeDeclaration(declaration, true);
                if (declaration.name.kind !== 75) {
                    if (links.type === unknownType) {
                        links.type = getTypeFromBindingPattern(declaration.name);
                    }
                    assignBindingElementTypes(declaration.name);
                }
            }
        }
        function assignBindingElementTypes(pattern) {
            for (var _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                if (!ts.isOmittedExpression(element)) {
                    if (element.name.kind === 75) {
                        getSymbolLinks(getSymbolOfNode(element)).type = getTypeForBindingElement(element);
                    }
                    else {
                        assignBindingElementTypes(element.name);
                    }
                }
            }
        }
        function createPromiseType(promisedType) {
            var globalPromiseType = getGlobalPromiseType(true);
            if (globalPromiseType !== emptyGenericType) {
                promisedType = getAwaitedType(promisedType) || unknownType;
                return createTypeReference(globalPromiseType, [promisedType]);
            }
            return unknownType;
        }
        function createPromiseLikeType(promisedType) {
            var globalPromiseLikeType = getGlobalPromiseLikeType(true);
            if (globalPromiseLikeType !== emptyGenericType) {
                promisedType = getAwaitedType(promisedType) || unknownType;
                return createTypeReference(globalPromiseLikeType, [promisedType]);
            }
            return unknownType;
        }
        function createPromiseReturnType(func, promisedType) {
            var promiseType = createPromiseType(promisedType);
            if (promiseType === unknownType) {
                error(func, ts.isImportCall(func) ?
                    ts.Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option :
                    ts.Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option);
                return errorType;
            }
            else if (!getGlobalPromiseConstructorSymbol(true)) {
                error(func, ts.isImportCall(func) ?
                    ts.Diagnostics.A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option :
                    ts.Diagnostics.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option);
            }
            return promiseType;
        }
        function getReturnTypeFromBody(func, checkMode) {
            if (!func.body) {
                return errorType;
            }
            var functionFlags = ts.getFunctionFlags(func);
            var isAsync = (functionFlags & 2) !== 0;
            var isGenerator = (functionFlags & 1) !== 0;
            var returnType;
            var yieldType;
            var nextType;
            var fallbackReturnType = voidType;
            if (func.body.kind !== 223) {
                returnType = checkExpressionCached(func.body, checkMode && checkMode & ~8);
                if (isAsync) {
                    returnType = checkAwaitedType(returnType, func, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                }
            }
            else if (isGenerator) {
                var returnTypes = checkAndAggregateReturnExpressionTypes(func, checkMode);
                if (!returnTypes) {
                    fallbackReturnType = neverType;
                }
                else if (returnTypes.length > 0) {
                    returnType = getUnionType(returnTypes, 2);
                }
                var _a = checkAndAggregateYieldOperandTypes(func, checkMode), yieldTypes = _a.yieldTypes, nextTypes = _a.nextTypes;
                yieldType = ts.some(yieldTypes) ? getUnionType(yieldTypes, 2) : undefined;
                nextType = ts.some(nextTypes) ? getIntersectionType(nextTypes) : undefined;
            }
            else {
                var types = checkAndAggregateReturnExpressionTypes(func, checkMode);
                if (!types) {
                    return functionFlags & 2
                        ? createPromiseReturnType(func, neverType)
                        : neverType;
                }
                if (types.length === 0) {
                    return functionFlags & 2
                        ? createPromiseReturnType(func, voidType)
                        : voidType;
                }
                returnType = getUnionType(types, 2);
            }
            if (returnType || yieldType || nextType) {
                if (yieldType)
                    reportErrorsFromWidening(func, yieldType, 3);
                if (returnType)
                    reportErrorsFromWidening(func, returnType, 1);
                if (nextType)
                    reportErrorsFromWidening(func, nextType, 2);
                if (returnType && isUnitType(returnType) ||
                    yieldType && isUnitType(yieldType) ||
                    nextType && isUnitType(nextType)) {
                    var contextualSignature = getContextualSignatureForFunctionLikeDeclaration(func);
                    var contextualType = !contextualSignature ? undefined :
                        contextualSignature === getSignatureFromDeclaration(func) ? isGenerator ? undefined : returnType :
                            instantiateContextualType(getReturnTypeOfSignature(contextualSignature), func);
                    if (isGenerator) {
                        yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, 0, isAsync);
                        returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, 1, isAsync);
                        nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, 2, isAsync);
                    }
                    else {
                        returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync);
                    }
                }
                if (yieldType)
                    yieldType = getWidenedType(yieldType);
                if (returnType)
                    returnType = getWidenedType(returnType);
                if (nextType)
                    nextType = getWidenedType(nextType);
            }
            if (isGenerator) {
                return createGeneratorReturnType(yieldType || neverType, returnType || fallbackReturnType, nextType || getContextualIterationType(2, func) || unknownType, isAsync);
            }
            else {
                return isAsync
                    ? createPromiseType(returnType || fallbackReturnType)
                    : returnType || fallbackReturnType;
            }
        }
        function createGeneratorReturnType(yieldType, returnType, nextType, isAsyncGenerator) {
            var resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
            var globalGeneratorType = resolver.getGlobalGeneratorType(false);
            yieldType = resolver.resolveIterationType(yieldType, undefined) || unknownType;
            returnType = resolver.resolveIterationType(returnType, undefined) || unknownType;
            nextType = resolver.resolveIterationType(nextType, undefined) || unknownType;
            if (globalGeneratorType === emptyGenericType) {
                var globalType = resolver.getGlobalIterableIteratorType(false);
                var iterationTypes = globalType !== emptyGenericType ? getIterationTypesOfGlobalIterableType(globalType, resolver) : undefined;
                var iterableIteratorReturnType = iterationTypes ? iterationTypes.returnType : anyType;
                var iterableIteratorNextType = iterationTypes ? iterationTypes.nextType : undefinedType;
                if (isTypeAssignableTo(returnType, iterableIteratorReturnType) &&
                    isTypeAssignableTo(iterableIteratorNextType, nextType)) {
                    if (globalType !== emptyGenericType) {
                        return createTypeFromGenericGlobalType(globalType, [yieldType]);
                    }
                    resolver.getGlobalIterableIteratorType(true);
                    return emptyObjectType;
                }
                resolver.getGlobalGeneratorType(true);
                return emptyObjectType;
            }
            return createTypeFromGenericGlobalType(globalGeneratorType, [yieldType, returnType, nextType]);
        }
        function checkAndAggregateYieldOperandTypes(func, checkMode) {
            var yieldTypes = [];
            var nextTypes = [];
            var isAsync = (ts.getFunctionFlags(func) & 2) !== 0;
            ts.forEachYieldExpression(func.body, function (yieldExpression) {
                var yieldExpressionType = yieldExpression.expression ? checkExpression(yieldExpression.expression, checkMode) : undefinedWideningType;
                ts.pushIfUnique(yieldTypes, getYieldedTypeOfYieldExpression(yieldExpression, yieldExpressionType, anyType, isAsync));
                var nextType;
                if (yieldExpression.asteriskToken) {
                    var iterationTypes = getIterationTypesOfIterable(yieldExpressionType, isAsync ? 19 : 17, yieldExpression.expression);
                    nextType = iterationTypes && iterationTypes.nextType;
                }
                else {
                    nextType = getContextualType(yieldExpression);
                }
                if (nextType)
                    ts.pushIfUnique(nextTypes, nextType);
            });
            return { yieldTypes: yieldTypes, nextTypes: nextTypes };
        }
        function getYieldedTypeOfYieldExpression(node, expressionType, sentType, isAsync) {
            var errorNode = node.expression || node;
            var yieldedType = node.asteriskToken ? checkIteratedTypeOrElementType(isAsync ? 19 : 17, expressionType, sentType, errorNode) : expressionType;
            return !isAsync ? yieldedType : getAwaitedType(yieldedType, errorNode, node.asteriskToken
                ? ts.Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member
                : ts.Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
        }
        function getFactsFromTypeofSwitch(start, end, witnesses, hasDefault) {
            var facts = 0;
            if (hasDefault) {
                for (var i = end; i < witnesses.length; i++) {
                    facts |= typeofNEFacts.get(witnesses[i]) || 32768;
                }
                for (var i = start; i < end; i++) {
                    facts &= ~(typeofNEFacts.get(witnesses[i]) || 0);
                }
                for (var i = 0; i < start; i++) {
                    facts |= typeofNEFacts.get(witnesses[i]) || 32768;
                }
            }
            else {
                for (var i = start; i < end; i++) {
                    facts |= typeofEQFacts.get(witnesses[i]) || 128;
                }
                for (var i = 0; i < start; i++) {
                    facts &= ~(typeofEQFacts.get(witnesses[i]) || 0);
                }
            }
            return facts;
        }
        function isExhaustiveSwitchStatement(node) {
            var links = getNodeLinks(node);
            return links.isExhaustive !== undefined ? links.isExhaustive : (links.isExhaustive = computeExhaustiveSwitchStatement(node));
        }
        function computeExhaustiveSwitchStatement(node) {
            if (node.expression.kind === 204) {
                var operandType = getTypeOfExpression(node.expression.expression);
                var witnesses = getSwitchClauseTypeOfWitnesses(node, false);
                var notEqualFacts_1 = getFactsFromTypeofSwitch(0, 0, witnesses, true);
                var type_3 = getBaseConstraintOfType(operandType) || operandType;
                return !!(filterType(type_3, function (t) { return (getTypeFacts(t) & notEqualFacts_1) === notEqualFacts_1; }).flags & 131072);
            }
            var type = getTypeOfExpression(node.expression);
            if (!isLiteralType(type)) {
                return false;
            }
            var switchTypes = getSwitchClauseTypes(node);
            if (!switchTypes.length || ts.some(switchTypes, isNeitherUnitTypeNorNever)) {
                return false;
            }
            return eachTypeContainedIn(mapType(type, getRegularTypeOfLiteralType), switchTypes);
        }
        function functionHasImplicitReturn(func) {
            return func.endFlowNode && isReachableFlowNode(func.endFlowNode);
        }
        function checkAndAggregateReturnExpressionTypes(func, checkMode) {
            var functionFlags = ts.getFunctionFlags(func);
            var aggregatedTypes = [];
            var hasReturnWithNoExpression = functionHasImplicitReturn(func);
            var hasReturnOfTypeNever = false;
            ts.forEachReturnStatement(func.body, function (returnStatement) {
                var expr = returnStatement.expression;
                if (expr) {
                    var type = checkExpressionCached(expr, checkMode && checkMode & ~8);
                    if (functionFlags & 2) {
                        type = checkAwaitedType(type, func, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                    }
                    if (type.flags & 131072) {
                        hasReturnOfTypeNever = true;
                    }
                    ts.pushIfUnique(aggregatedTypes, type);
                }
                else {
                    hasReturnWithNoExpression = true;
                }
            });
            if (aggregatedTypes.length === 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || mayReturnNever(func))) {
                return undefined;
            }
            if (strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression &&
                !(isJSConstructor(func) && aggregatedTypes.some(function (t) { return t.symbol === func.symbol; }))) {
                ts.pushIfUnique(aggregatedTypes, undefinedType);
            }
            return aggregatedTypes;
        }
        function mayReturnNever(func) {
            switch (func.kind) {
                case 201:
                case 202:
                    return true;
                case 161:
                    return func.parent.kind === 193;
                default:
                    return false;
            }
        }
        function checkAllCodePathsInNonVoidFunctionReturnOrThrow(func, returnType) {
            if (!produceDiagnostics) {
                return;
            }
            var functionFlags = ts.getFunctionFlags(func);
            var type = returnType && unwrapReturnType(returnType, functionFlags);
            if (type && maybeTypeOfKind(type, 1 | 16384)) {
                return;
            }
            if (func.kind === 160 || ts.nodeIsMissing(func.body) || func.body.kind !== 223 || !functionHasImplicitReturn(func)) {
                return;
            }
            var hasExplicitReturn = func.flags & 512;
            if (type && type.flags & 131072) {
                error(ts.getEffectiveReturnTypeNode(func), ts.Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point);
            }
            else if (type && !hasExplicitReturn) {
                error(ts.getEffectiveReturnTypeNode(func), ts.Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value);
            }
            else if (type && strictNullChecks && !isTypeAssignableTo(undefinedType, type)) {
                error(ts.getEffectiveReturnTypeNode(func) || func, ts.Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined);
            }
            else if (compilerOptions.noImplicitReturns) {
                if (!type) {
                    if (!hasExplicitReturn) {
                        return;
                    }
                    var inferredReturnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                    if (isUnwrappedReturnTypeVoidOrAny(func, inferredReturnType)) {
                        return;
                    }
                }
                error(ts.getEffectiveReturnTypeNode(func) || func, ts.Diagnostics.Not_all_code_paths_return_a_value);
            }
        }
        function checkFunctionExpressionOrObjectLiteralMethod(node, checkMode) {
            ts.Debug.assert(node.kind !== 161 || ts.isObjectLiteralMethod(node));
            checkNodeDeferred(node);
            if (checkMode && checkMode & 4 && isContextSensitive(node)) {
                if (!ts.getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node)) {
                    var contextualSignature = getContextualSignature(node);
                    if (contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature))) {
                        var links = getNodeLinks(node);
                        if (links.contextFreeType) {
                            return links.contextFreeType;
                        }
                        var returnType = getReturnTypeFromBody(node, checkMode);
                        var returnOnlySignature = createSignature(undefined, undefined, undefined, ts.emptyArray, returnType, undefined, 0, 0);
                        var returnOnlyType = createAnonymousType(node.symbol, emptySymbols, [returnOnlySignature], ts.emptyArray, undefined, undefined);
                        returnOnlyType.objectFlags |= 2097152;
                        return links.contextFreeType = returnOnlyType;
                    }
                }
                return anyFunctionType;
            }
            var hasGrammarError = checkGrammarFunctionLikeDeclaration(node);
            if (!hasGrammarError && node.kind === 201) {
                checkGrammarForGenerator(node);
            }
            contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode);
            return getTypeOfSymbol(getSymbolOfNode(node));
        }
        function contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode) {
            var links = getNodeLinks(node);
            if (!(links.flags & 1024)) {
                var contextualSignature = getContextualSignature(node);
                if (!(links.flags & 1024)) {
                    links.flags |= 1024;
                    var signature = ts.firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfNode(node)), 0));
                    if (!signature) {
                        return;
                    }
                    if (isContextSensitive(node)) {
                        if (contextualSignature) {
                            var inferenceContext = getInferenceContext(node);
                            if (checkMode && checkMode & 2) {
                                inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext);
                            }
                            var instantiatedContextualSignature = inferenceContext ?
                                instantiateSignature(contextualSignature, inferenceContext.mapper) : contextualSignature;
                            assignContextualParameterTypes(signature, instantiatedContextualSignature);
                        }
                        else {
                            assignNonContextualParameterTypes(signature);
                        }
                    }
                    if (contextualSignature && !getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType) {
                        var returnType = getReturnTypeFromBody(node, checkMode);
                        if (!signature.resolvedReturnType) {
                            signature.resolvedReturnType = returnType;
                        }
                    }
                    checkSignatureDeclaration(node);
                }
            }
        }
        function checkFunctionExpressionOrObjectLiteralMethodDeferred(node) {
            ts.Debug.assert(node.kind !== 161 || ts.isObjectLiteralMethod(node));
            var functionFlags = ts.getFunctionFlags(node);
            var returnType = getReturnTypeFromAnnotation(node);
            checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
            if (node.body) {
                if (!ts.getEffectiveReturnTypeNode(node)) {
                    getReturnTypeOfSignature(getSignatureFromDeclaration(node));
                }
                if (node.body.kind === 223) {
                    checkSourceElement(node.body);
                }
                else {
                    var exprType = checkExpression(node.body);
                    var returnOrPromisedType = returnType && unwrapReturnType(returnType, functionFlags);
                    if (returnOrPromisedType) {
                        if ((functionFlags & 3) === 2) {
                            var awaitedType = checkAwaitedType(exprType, node.body, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                            checkTypeAssignableToAndOptionallyElaborate(awaitedType, returnOrPromisedType, node.body, node.body);
                        }
                        else {
                            checkTypeAssignableToAndOptionallyElaborate(exprType, returnOrPromisedType, node.body, node.body);
                        }
                    }
                }
            }
        }
        function checkArithmeticOperandType(operand, type, diagnostic, isAwaitValid) {
            if (isAwaitValid === void 0) { isAwaitValid = false; }
            if (!isTypeAssignableTo(type, numberOrBigIntType)) {
                var awaitedType = isAwaitValid && getAwaitedTypeOfPromise(type);
                errorAndMaybeSuggestAwait(operand, !!awaitedType && isTypeAssignableTo(awaitedType, numberOrBigIntType), diagnostic);
                return false;
            }
            return true;
        }
        function isReadonlyAssignmentDeclaration(d) {
            if (!ts.isCallExpression(d)) {
                return false;
            }
            if (!ts.isBindableObjectDefinePropertyCall(d)) {
                return false;
            }
            var objectLitType = checkExpressionCached(d.arguments[2]);
            var valueType = getTypeOfPropertyOfType(objectLitType, "value");
            if (valueType) {
                var writableProp = getPropertyOfType(objectLitType, "writable");
                var writableType = writableProp && getTypeOfSymbol(writableProp);
                if (!writableType || writableType === falseType || writableType === regularFalseType) {
                    return true;
                }
                if (writableProp && writableProp.valueDeclaration && ts.isPropertyAssignment(writableProp.valueDeclaration)) {
                    var initializer = writableProp.valueDeclaration.initializer;
                    var rawOriginalType = checkExpression(initializer);
                    if (rawOriginalType === falseType || rawOriginalType === regularFalseType) {
                        return true;
                    }
                }
                return false;
            }
            var setProp = getPropertyOfType(objectLitType, "set");
            return !setProp;
        }
        function isReadonlySymbol(symbol) {
            return !!(ts.getCheckFlags(symbol) & 8 ||
                symbol.flags & 4 && ts.getDeclarationModifierFlagsFromSymbol(symbol) & 64 ||
                symbol.flags & 3 && getDeclarationNodeFlagsFromSymbol(symbol) & 2 ||
                symbol.flags & 98304 && !(symbol.flags & 65536) ||
                symbol.flags & 8 ||
                ts.some(symbol.declarations, isReadonlyAssignmentDeclaration));
        }
        function isAssignmentToReadonlyEntity(expr, symbol, assignmentKind) {
            var _a, _b;
            if (assignmentKind === 0) {
                return false;
            }
            if (isReadonlySymbol(symbol)) {
                if (symbol.flags & 4 &&
                    ts.isAccessExpression(expr) &&
                    expr.expression.kind === 104) {
                    var ctor = ts.getContainingFunction(expr);
                    if (!(ctor && ctor.kind === 162)) {
                        return true;
                    }
                    if (symbol.valueDeclaration) {
                        var isAssignmentDeclaration_1 = ts.isBinaryExpression(symbol.valueDeclaration);
                        var isLocalPropertyDeclaration = ctor.parent === symbol.valueDeclaration.parent;
                        var isLocalParameterProperty = ctor === symbol.valueDeclaration.parent;
                        var isLocalThisPropertyAssignment = isAssignmentDeclaration_1 && ((_a = symbol.parent) === null || _a === void 0 ? void 0 : _a.valueDeclaration) === ctor.parent;
                        var isLocalThisPropertyAssignmentConstructorFunction = isAssignmentDeclaration_1 && ((_b = symbol.parent) === null || _b === void 0 ? void 0 : _b.valueDeclaration) === ctor;
                        var isWriteableSymbol = isLocalPropertyDeclaration
                            || isLocalParameterProperty
                            || isLocalThisPropertyAssignment
                            || isLocalThisPropertyAssignmentConstructorFunction;
                        return !isWriteableSymbol;
                    }
                }
                return true;
            }
            if (ts.isAccessExpression(expr)) {
                var node = ts.skipParentheses(expr.expression);
                if (node.kind === 75) {
                    var symbol_2 = getNodeLinks(node).resolvedSymbol;
                    if (symbol_2.flags & 2097152) {
                        var declaration = getDeclarationOfAliasSymbol(symbol_2);
                        return !!declaration && declaration.kind === 256;
                    }
                }
            }
            return false;
        }
        function checkReferenceExpression(expr, invalidReferenceMessage, invalidOptionalChainMessage) {
            var node = ts.skipOuterExpressions(expr, 6 | 1);
            if (node.kind !== 75 && !ts.isAccessExpression(node)) {
                error(expr, invalidReferenceMessage);
                return false;
            }
            if (node.flags & 32) {
                error(expr, invalidOptionalChainMessage);
                return false;
            }
            return true;
        }
        function checkDeleteExpression(node) {
            checkExpression(node.expression);
            var expr = ts.skipParentheses(node.expression);
            if (!ts.isAccessExpression(expr)) {
                error(expr, ts.Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference);
                return booleanType;
            }
            if (expr.kind === 194 && ts.isPrivateIdentifier(expr.name)) {
                error(expr, ts.Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_private_identifier);
            }
            var links = getNodeLinks(expr);
            var symbol = getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol);
            if (symbol && isReadonlySymbol(symbol)) {
                error(expr, ts.Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property);
            }
            return booleanType;
        }
        function checkTypeOfExpression(node) {
            checkExpression(node.expression);
            return typeofType;
        }
        function checkVoidExpression(node) {
            checkExpression(node.expression);
            return undefinedWideningType;
        }
        function isTopLevelAwait(node) {
            var container = ts.getThisContainer(node, true);
            return ts.isSourceFile(container);
        }
        function checkAwaitExpression(node) {
            if (produceDiagnostics) {
                if (!(node.flags & 32768)) {
                    if (isTopLevelAwait(node)) {
                        var sourceFile = ts.getSourceFileOfNode(node);
                        if (!hasParseDiagnostics(sourceFile)) {
                            var span = void 0;
                            if (!ts.isEffectiveExternalModule(sourceFile, compilerOptions)) {
                                if (!span)
                                    span = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
                                var diagnostic = ts.createFileDiagnostic(sourceFile, span.start, span.length, ts.Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module);
                                diagnostics.add(diagnostic);
                            }
                            if ((moduleKind !== ts.ModuleKind.ESNext && moduleKind !== ts.ModuleKind.System) || languageVersion < 4) {
                                span = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
                                var diagnostic = ts.createFileDiagnostic(sourceFile, span.start, span.length, ts.Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_esnext_or_system_and_the_target_option_is_set_to_es2017_or_higher);
                                diagnostics.add(diagnostic);
                            }
                        }
                    }
                    else {
                        var sourceFile = ts.getSourceFileOfNode(node);
                        if (!hasParseDiagnostics(sourceFile)) {
                            var span = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
                            var diagnostic = ts.createFileDiagnostic(sourceFile, span.start, span.length, ts.Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules);
                            var func = ts.getContainingFunction(node);
                            if (func && func.kind !== 162 && (ts.getFunctionFlags(func) & 2) === 0) {
                                var relatedInfo = ts.createDiagnosticForNode(func, ts.Diagnostics.Did_you_mean_to_mark_this_function_as_async);
                                ts.addRelatedInfo(diagnostic, relatedInfo);
                            }
                            diagnostics.add(diagnostic);
                        }
                    }
                }
                if (isInParameterInitializerBeforeContainingFunction(node)) {
                    error(node, ts.Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer);
                }
            }
            var operandType = checkExpression(node.expression);
            var awaitedType = checkAwaitedType(operandType, node, ts.Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
            if (awaitedType === operandType && awaitedType !== errorType && !(operandType.flags & 3)) {
                addErrorOrSuggestion(false, ts.createDiagnosticForNode(node, ts.Diagnostics.await_has_no_effect_on_the_type_of_this_expression));
            }
            return awaitedType;
        }
        function checkPrefixUnaryExpression(node) {
            var operandType = checkExpression(node.operand);
            if (operandType === silentNeverType) {
                return silentNeverType;
            }
            switch (node.operand.kind) {
                case 8:
                    switch (node.operator) {
                        case 40:
                            return getFreshTypeOfLiteralType(getLiteralType(-node.operand.text));
                        case 39:
                            return getFreshTypeOfLiteralType(getLiteralType(+node.operand.text));
                    }
                    break;
                case 9:
                    if (node.operator === 40) {
                        return getFreshTypeOfLiteralType(getLiteralType({
                            negative: true,
                            base10Value: ts.parsePseudoBigInt(node.operand.text)
                        }));
                    }
            }
            switch (node.operator) {
                case 39:
                case 40:
                case 54:
                    checkNonNullType(operandType, node.operand);
                    if (maybeTypeOfKind(operandType, 12288)) {
                        error(node.operand, ts.Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, ts.tokenToString(node.operator));
                    }
                    if (node.operator === 39) {
                        if (maybeTypeOfKind(operandType, 2112)) {
                            error(node.operand, ts.Diagnostics.Operator_0_cannot_be_applied_to_type_1, ts.tokenToString(node.operator), typeToString(getBaseTypeOfLiteralType(operandType)));
                        }
                        return numberType;
                    }
                    return getUnaryResultType(operandType);
                case 53:
                    checkTruthinessExpression(node.operand);
                    var facts = getTypeFacts(operandType) & (4194304 | 8388608);
                    return facts === 4194304 ? falseType :
                        facts === 8388608 ? trueType :
                            booleanType;
                case 45:
                case 46:
                    var ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);
                    if (ok) {
                        checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access);
                    }
                    return getUnaryResultType(operandType);
            }
            return errorType;
        }
        function checkPostfixUnaryExpression(node) {
            var operandType = checkExpression(node.operand);
            if (operandType === silentNeverType) {
                return silentNeverType;
            }
            var ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);
            if (ok) {
                checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access);
            }
            return getUnaryResultType(operandType);
        }
        function getUnaryResultType(operandType) {
            if (maybeTypeOfKind(operandType, 2112)) {
                return isTypeAssignableToKind(operandType, 3) || maybeTypeOfKind(operandType, 296)
                    ? numberOrBigIntType
                    : bigintType;
            }
            return numberType;
        }
        function maybeTypeOfKind(type, kind) {
            if (type.flags & kind) {
                return true;
            }
            if (type.flags & 3145728) {
                var types = type.types;
                for (var _i = 0, types_19 = types; _i < types_19.length; _i++) {
                    var t = types_19[_i];
                    if (maybeTypeOfKind(t, kind)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function isTypeAssignableToKind(source, kind, strict) {
            if (source.flags & kind) {
                return true;
            }
            if (strict && source.flags & (3 | 16384 | 32768 | 65536)) {
                return false;
            }
            return !!(kind & 296) && isTypeAssignableTo(source, numberType) ||
                !!(kind & 2112) && isTypeAssignableTo(source, bigintType) ||
                !!(kind & 132) && isTypeAssignableTo(source, stringType) ||
                !!(kind & 528) && isTypeAssignableTo(source, booleanType) ||
                !!(kind & 16384) && isTypeAssignableTo(source, voidType) ||
                !!(kind & 131072) && isTypeAssignableTo(source, neverType) ||
                !!(kind & 65536) && isTypeAssignableTo(source, nullType) ||
                !!(kind & 32768) && isTypeAssignableTo(source, undefinedType) ||
                !!(kind & 4096) && isTypeAssignableTo(source, esSymbolType) ||
                !!(kind & 67108864) && isTypeAssignableTo(source, nonPrimitiveType);
        }
        function allTypesAssignableToKind(source, kind, strict) {
            return source.flags & 1048576 ?
                ts.every(source.types, function (subType) { return allTypesAssignableToKind(subType, kind, strict); }) :
                isTypeAssignableToKind(source, kind, strict);
        }
        function isConstEnumObjectType(type) {
            return !!(ts.getObjectFlags(type) & 16) && !!type.symbol && isConstEnumSymbol(type.symbol);
        }
        function isConstEnumSymbol(symbol) {
            return (symbol.flags & 128) !== 0;
        }
        function checkInstanceOfExpression(left, right, leftType, rightType) {
            if (leftType === silentNeverType || rightType === silentNeverType) {
                return silentNeverType;
            }
            if (!isTypeAny(leftType) &&
                allTypesAssignableToKind(leftType, 131068)) {
                error(left, ts.Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            if (!(isTypeAny(rightType) || typeHasCallOrConstructSignatures(rightType) || isTypeSubtypeOf(rightType, globalFunctionType))) {
                error(right, ts.Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);
            }
            return booleanType;
        }
        function checkInExpression(left, right, leftType, rightType) {
            if (leftType === silentNeverType || rightType === silentNeverType) {
                return silentNeverType;
            }
            leftType = checkNonNullType(leftType, left);
            rightType = checkNonNullType(rightType, right);
            if (!(isTypeComparableTo(leftType, stringType) || isTypeAssignableToKind(leftType, 296 | 12288))) {
                error(left, ts.Diagnostics.The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol);
            }
            if (!allTypesAssignableToKind(rightType, 67108864 | 58982400)) {
                error(right, ts.Diagnostics.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            return booleanType;
        }
        function checkObjectLiteralAssignment(node, sourceType, rightIsThis) {
            var properties = node.properties;
            if (strictNullChecks && properties.length === 0) {
                return checkNonNullType(sourceType, node);
            }
            for (var i = 0; i < properties.length; i++) {
                checkObjectLiteralDestructuringPropertyAssignment(node, sourceType, i, properties, rightIsThis);
            }
            return sourceType;
        }
        function checkObjectLiteralDestructuringPropertyAssignment(node, objectLiteralType, propertyIndex, allProperties, rightIsThis) {
            if (rightIsThis === void 0) { rightIsThis = false; }
            var properties = node.properties;
            var property = properties[propertyIndex];
            if (property.kind === 281 || property.kind === 282) {
                var name = property.name;
                var exprType = getLiteralTypeFromPropertyName(name);
                if (isTypeUsableAsPropertyName(exprType)) {
                    var text = getPropertyNameFromType(exprType);
                    var prop = getPropertyOfType(objectLiteralType, text);
                    if (prop) {
                        markPropertyAsReferenced(prop, property, rightIsThis);
                        checkPropertyAccessibility(property, false, objectLiteralType, prop);
                    }
                }
                var elementType = getIndexedAccessType(objectLiteralType, exprType, name);
                var type = getFlowTypeOfDestructuring(property, elementType);
                return checkDestructuringAssignment(property.kind === 282 ? property : property.initializer, type);
            }
            else if (property.kind === 283) {
                if (propertyIndex < properties.length - 1) {
                    error(property, ts.Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
                }
                else {
                    if (languageVersion < 99) {
                        checkExternalEmitHelpers(property, 4);
                    }
                    var nonRestNames = [];
                    if (allProperties) {
                        for (var _i = 0, allProperties_1 = allProperties; _i < allProperties_1.length; _i++) {
                            var otherProperty = allProperties_1[_i];
                            if (!ts.isSpreadAssignment(otherProperty)) {
                                nonRestNames.push(otherProperty.name);
                            }
                        }
                    }
                    var type = getRestType(objectLiteralType, nonRestNames, objectLiteralType.symbol);
                    checkGrammarForDisallowedTrailingComma(allProperties, ts.Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                    return checkDestructuringAssignment(property.expression, type);
                }
            }
            else {
                error(property, ts.Diagnostics.Property_assignment_expected);
            }
        }
        function checkArrayLiteralAssignment(node, sourceType, checkMode) {
            var elements = node.elements;
            if (languageVersion < 2 && compilerOptions.downlevelIteration) {
                checkExternalEmitHelpers(node, 512);
            }
            var elementType = checkIteratedTypeOrElementType(65, sourceType, undefinedType, node) || errorType;
            for (var i = 0; i < elements.length; i++) {
                checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, elementType, checkMode);
            }
            return sourceType;
        }
        function checkArrayLiteralDestructuringElementAssignment(node, sourceType, elementIndex, elementType, checkMode) {
            var elements = node.elements;
            var element = elements[elementIndex];
            if (element.kind !== 215) {
                if (element.kind !== 213) {
                    var indexType = getLiteralType(elementIndex);
                    if (isArrayLikeType(sourceType)) {
                        var accessFlags = hasDefaultValue(element) ? 8 : 0;
                        var elementType_2 = getIndexedAccessTypeOrUndefined(sourceType, indexType, createSyntheticExpression(element, indexType), accessFlags) || errorType;
                        var assignedType = hasDefaultValue(element) ? getTypeWithFacts(elementType_2, 524288) : elementType_2;
                        var type = getFlowTypeOfDestructuring(element, assignedType);
                        return checkDestructuringAssignment(element, type, checkMode);
                    }
                    return checkDestructuringAssignment(element, elementType, checkMode);
                }
                if (elementIndex < elements.length - 1) {
                    error(element, ts.Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
                }
                else {
                    var restExpression = element.expression;
                    if (restExpression.kind === 209 && restExpression.operatorToken.kind === 62) {
                        error(restExpression.operatorToken, ts.Diagnostics.A_rest_element_cannot_have_an_initializer);
                    }
                    else {
                        checkGrammarForDisallowedTrailingComma(node.elements, ts.Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                        var type = everyType(sourceType, isTupleType) ?
                            mapType(sourceType, function (t) { return sliceTupleType(t, elementIndex); }) :
                            createArrayType(elementType);
                        return checkDestructuringAssignment(restExpression, type, checkMode);
                    }
                }
            }
            return undefined;
        }
        function checkDestructuringAssignment(exprOrAssignment, sourceType, checkMode, rightIsThis) {
            var target;
            if (exprOrAssignment.kind === 282) {
                var prop = exprOrAssignment;
                if (prop.objectAssignmentInitializer) {
                    if (strictNullChecks &&
                        !(getFalsyFlags(checkExpression(prop.objectAssignmentInitializer)) & 32768)) {
                        sourceType = getTypeWithFacts(sourceType, 524288);
                    }
                    checkBinaryLikeExpression(prop.name, prop.equalsToken, prop.objectAssignmentInitializer, checkMode);
                }
                target = exprOrAssignment.name;
            }
            else {
                target = exprOrAssignment;
            }
            if (target.kind === 209 && target.operatorToken.kind === 62) {
                checkBinaryExpression(target, checkMode);
                target = target.left;
            }
            if (target.kind === 193) {
                return checkObjectLiteralAssignment(target, sourceType, rightIsThis);
            }
            if (target.kind === 192) {
                return checkArrayLiteralAssignment(target, sourceType, checkMode);
            }
            return checkReferenceAssignment(target, sourceType, checkMode);
        }
        function checkReferenceAssignment(target, sourceType, checkMode) {
            var targetType = checkExpression(target, checkMode);
            var error = target.parent.kind === 283 ?
                ts.Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access :
                ts.Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access;
            var optionalError = target.parent.kind === 283 ?
                ts.Diagnostics.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access :
                ts.Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access;
            if (checkReferenceExpression(target, error, optionalError)) {
                checkTypeAssignableToAndOptionallyElaborate(sourceType, targetType, target, target);
            }
            if (ts.isPrivateIdentifierPropertyAccessExpression(target)) {
                checkExternalEmitHelpers(target.parent, 524288);
            }
            return sourceType;
        }
        function isSideEffectFree(node) {
            node = ts.skipParentheses(node);
            switch (node.kind) {
                case 75:
                case 10:
                case 13:
                case 198:
                case 211:
                case 14:
                case 8:
                case 9:
                case 106:
                case 91:
                case 100:
                case 146:
                case 201:
                case 214:
                case 202:
                case 192:
                case 193:
                case 204:
                case 218:
                case 267:
                case 266:
                    return true;
                case 210:
                    return isSideEffectFree(node.whenTrue) &&
                        isSideEffectFree(node.whenFalse);
                case 209:
                    if (ts.isAssignmentOperator(node.operatorToken.kind)) {
                        return false;
                    }
                    return isSideEffectFree(node.left) &&
                        isSideEffectFree(node.right);
                case 207:
                case 208:
                    switch (node.operator) {
                        case 53:
                        case 39:
                        case 40:
                        case 54:
                            return true;
                    }
                    return false;
                case 205:
                case 199:
                case 217:
                default:
                    return false;
            }
        }
        function isTypeEqualityComparableTo(source, target) {
            return (target.flags & 98304) !== 0 || isTypeComparableTo(source, target);
        }
        function checkBinaryExpression(node, checkMode) {
            var workStacks = {
                expr: [node],
                state: [0],
                leftType: [undefined]
            };
            var stackIndex = 0;
            var lastResult;
            while (stackIndex >= 0) {
                node = workStacks.expr[stackIndex];
                switch (workStacks.state[stackIndex]) {
                    case 0: {
                        if (ts.isInJSFile(node) && ts.getAssignedExpandoInitializer(node)) {
                            finishInvocation(checkExpression(node.right, checkMode));
                            break;
                        }
                        checkGrammarNullishCoalesceWithLogicalExpression(node);
                        var operator = node.operatorToken.kind;
                        if (operator === 62 && (node.left.kind === 193 || node.left.kind === 192)) {
                            finishInvocation(checkDestructuringAssignment(node.left, checkExpression(node.right, checkMode), checkMode, node.right.kind === 104));
                            break;
                        }
                        advanceState(1);
                        maybeCheckExpression(node.left);
                        break;
                    }
                    case 1: {
                        var leftType = lastResult;
                        workStacks.leftType[stackIndex] = leftType;
                        var operator = node.operatorToken.kind;
                        if (operator === 55 || operator === 56 || operator === 60) {
                            checkTruthinessOfType(leftType, node.left);
                        }
                        advanceState(2);
                        maybeCheckExpression(node.right);
                        break;
                    }
                    case 2: {
                        var leftType = workStacks.leftType[stackIndex];
                        var rightType = lastResult;
                        finishInvocation(checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, node));
                        break;
                    }
                    default: return ts.Debug.fail("Invalid state " + workStacks.state[stackIndex] + " for checkBinaryExpression");
                }
            }
            return lastResult;
            function finishInvocation(result) {
                lastResult = result;
                stackIndex--;
            }
            function advanceState(nextState) {
                workStacks.state[stackIndex] = nextState;
            }
            function maybeCheckExpression(node) {
                if (ts.isBinaryExpression(node)) {
                    stackIndex++;
                    workStacks.expr[stackIndex] = node;
                    workStacks.state[stackIndex] = 0;
                    workStacks.leftType[stackIndex] = undefined;
                }
                else {
                    lastResult = checkExpression(node, checkMode);
                }
            }
        }
        function checkGrammarNullishCoalesceWithLogicalExpression(node) {
            var left = node.left, operatorToken = node.operatorToken, right = node.right;
            if (operatorToken.kind === 60) {
                if (ts.isBinaryExpression(left) && (left.operatorToken.kind === 56 || left.operatorToken.kind === 55)) {
                    grammarErrorOnNode(left, ts.Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, ts.tokenToString(left.operatorToken.kind), ts.tokenToString(operatorToken.kind));
                }
                if (ts.isBinaryExpression(right) && (right.operatorToken.kind === 56 || right.operatorToken.kind === 55)) {
                    grammarErrorOnNode(right, ts.Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, ts.tokenToString(right.operatorToken.kind), ts.tokenToString(operatorToken.kind));
                }
            }
        }
        function checkBinaryLikeExpression(left, operatorToken, right, checkMode, errorNode) {
            var operator = operatorToken.kind;
            if (operator === 62 && (left.kind === 193 || left.kind === 192)) {
                return checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode, right.kind === 104);
            }
            var leftType;
            if (operator === 55 || operator === 56 || operator === 60) {
                leftType = checkTruthinessExpression(left, checkMode);
            }
            else {
                leftType = checkExpression(left, checkMode);
            }
            var rightType = checkExpression(right, checkMode);
            return checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, errorNode);
        }
        function checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, errorNode) {
            var operator = operatorToken.kind;
            switch (operator) {
                case 41:
                case 42:
                case 65:
                case 66:
                case 43:
                case 67:
                case 44:
                case 68:
                case 40:
                case 64:
                case 47:
                case 69:
                case 48:
                case 70:
                case 49:
                case 71:
                case 51:
                case 73:
                case 52:
                case 74:
                case 50:
                case 72:
                    if (leftType === silentNeverType || rightType === silentNeverType) {
                        return silentNeverType;
                    }
                    leftType = checkNonNullType(leftType, left);
                    rightType = checkNonNullType(rightType, right);
                    var suggestedOperator = void 0;
                    if ((leftType.flags & 528) &&
                        (rightType.flags & 528) &&
                        (suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind)) !== undefined) {
                        error(errorNode || operatorToken, ts.Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, ts.tokenToString(operatorToken.kind), ts.tokenToString(suggestedOperator));
                        return numberType;
                    }
                    else {
                        var leftOk = checkArithmeticOperandType(left, leftType, ts.Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, true);
                        var rightOk = checkArithmeticOperandType(right, rightType, ts.Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, true);
                        var resultType_1;
                        if ((isTypeAssignableToKind(leftType, 3) && isTypeAssignableToKind(rightType, 3)) ||
                            !(maybeTypeOfKind(leftType, 2112) || maybeTypeOfKind(rightType, 2112))) {
                            resultType_1 = numberType;
                        }
                        else if (bothAreBigIntLike(leftType, rightType)) {
                            switch (operator) {
                                case 49:
                                case 71:
                                    reportOperatorError();
                            }
                            resultType_1 = bigintType;
                        }
                        else {
                            reportOperatorError(bothAreBigIntLike);
                            resultType_1 = errorType;
                        }
                        if (leftOk && rightOk) {
                            checkAssignmentOperator(resultType_1);
                        }
                        return resultType_1;
                    }
                case 39:
                case 63:
                    if (leftType === silentNeverType || rightType === silentNeverType) {
                        return silentNeverType;
                    }
                    if (!isTypeAssignableToKind(leftType, 132) && !isTypeAssignableToKind(rightType, 132)) {
                        leftType = checkNonNullType(leftType, left);
                        rightType = checkNonNullType(rightType, right);
                    }
                    var resultType = void 0;
                    if (isTypeAssignableToKind(leftType, 296, true) && isTypeAssignableToKind(rightType, 296, true)) {
                        resultType = numberType;
                    }
                    else if (isTypeAssignableToKind(leftType, 2112, true) && isTypeAssignableToKind(rightType, 2112, true)) {
                        resultType = bigintType;
                    }
                    else if (isTypeAssignableToKind(leftType, 132, true) || isTypeAssignableToKind(rightType, 132, true)) {
                        resultType = stringType;
                    }
                    else if (isTypeAny(leftType) || isTypeAny(rightType)) {
                        resultType = leftType === errorType || rightType === errorType ? errorType : anyType;
                    }
                    if (resultType && !checkForDisallowedESSymbolOperand(operator)) {
                        return resultType;
                    }
                    if (!resultType) {
                        var closeEnoughKind_1 = 296 | 2112 | 132 | 3;
                        reportOperatorError(function (left, right) {
                            return isTypeAssignableToKind(left, closeEnoughKind_1) &&
                                isTypeAssignableToKind(right, closeEnoughKind_1);
                        });
                        return anyType;
                    }
                    if (operator === 63) {
                        checkAssignmentOperator(resultType);
                    }
                    return resultType;
                case 29:
                case 31:
                case 32:
                case 33:
                    if (checkForDisallowedESSymbolOperand(operator)) {
                        leftType = getBaseTypeOfLiteralType(checkNonNullType(leftType, left));
                        rightType = getBaseTypeOfLiteralType(checkNonNullType(rightType, right));
                        reportOperatorErrorUnless(function (left, right) {
                            return isTypeComparableTo(left, right) || isTypeComparableTo(right, left) || (isTypeAssignableTo(left, numberOrBigIntType) && isTypeAssignableTo(right, numberOrBigIntType));
                        });
                    }
                    return booleanType;
                case 34:
                case 35:
                case 36:
                case 37:
                    reportOperatorErrorUnless(function (left, right) { return isTypeEqualityComparableTo(left, right) || isTypeEqualityComparableTo(right, left); });
                    return booleanType;
                case 98:
                    return checkInstanceOfExpression(left, right, leftType, rightType);
                case 97:
                    return checkInExpression(left, right, leftType, rightType);
                case 55:
                    return getTypeFacts(leftType) & 4194304 ?
                        getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) :
                        leftType;
                case 56:
                    return getTypeFacts(leftType) & 8388608 ?
                        getUnionType([removeDefinitelyFalsyTypes(leftType), rightType], 2) :
                        leftType;
                case 60:
                    return getTypeFacts(leftType) & 262144 ?
                        getUnionType([getNonNullableType(leftType), rightType], 2) :
                        leftType;
                case 62:
                    var declKind = ts.isBinaryExpression(left.parent) ? ts.getAssignmentDeclarationKind(left.parent) : 0;
                    checkAssignmentDeclaration(declKind, rightType);
                    if (isAssignmentDeclaration(declKind)) {
                        if (!(rightType.flags & 524288) ||
                            declKind !== 2 &&
                                declKind !== 6 &&
                                !isEmptyObjectType(rightType) &&
                                !isFunctionObjectType(rightType) &&
                                !(ts.getObjectFlags(rightType) & 1)) {
                            checkAssignmentOperator(rightType);
                        }
                        return leftType;
                    }
                    else {
                        checkAssignmentOperator(rightType);
                        return getRegularTypeOfObjectLiteral(rightType);
                    }
                case 27:
                    if (!compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isEvalNode(right)) {
                        error(left, ts.Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects);
                    }
                    return rightType;
                default:
                    return ts.Debug.fail();
            }
            function bothAreBigIntLike(left, right) {
                return isTypeAssignableToKind(left, 2112) && isTypeAssignableToKind(right, 2112);
            }
            function checkAssignmentDeclaration(kind, rightType) {
                if (kind === 2) {
                    for (var _i = 0, _a = getPropertiesOfObjectType(rightType); _i < _a.length; _i++) {
                        var prop = _a[_i];
                        var propType = getTypeOfSymbol(prop);
                        if (propType.symbol && propType.symbol.flags & 32) {
                            var name = prop.escapedName;
                            var symbol = resolveName(prop.valueDeclaration, name, 788968, undefined, name, false);
                            if (symbol && symbol.declarations.some(ts.isJSDocTypedefTag)) {
                                addDuplicateDeclarationErrorsForSymbols(symbol, ts.Diagnostics.Duplicate_identifier_0, ts.unescapeLeadingUnderscores(name), prop);
                                addDuplicateDeclarationErrorsForSymbols(prop, ts.Diagnostics.Duplicate_identifier_0, ts.unescapeLeadingUnderscores(name), symbol);
                            }
                        }
                    }
                }
            }
            function isEvalNode(node) {
                return node.kind === 75 && node.escapedText === "eval";
            }
            function checkForDisallowedESSymbolOperand(operator) {
                var offendingSymbolOperand = maybeTypeOfKind(leftType, 12288) ? left :
                    maybeTypeOfKind(rightType, 12288) ? right :
                        undefined;
                if (offendingSymbolOperand) {
                    error(offendingSymbolOperand, ts.Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, ts.tokenToString(operator));
                    return false;
                }
                return true;
            }
            function getSuggestedBooleanOperator(operator) {
                switch (operator) {
                    case 51:
                    case 73:
                        return 56;
                    case 52:
                    case 74:
                        return 37;
                    case 50:
                    case 72:
                        return 55;
                    default:
                        return undefined;
                }
            }
            function checkAssignmentOperator(valueType) {
                if (produceDiagnostics && ts.isAssignmentOperator(operator)) {
                    if (checkReferenceExpression(left, ts.Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access, ts.Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access)
                        && (!ts.isIdentifier(left) || ts.unescapeLeadingUnderscores(left.escapedText) !== "exports")) {
                        checkTypeAssignableToAndOptionallyElaborate(valueType, leftType, left, right);
                    }
                }
            }
            function isAssignmentDeclaration(kind) {
                switch (kind) {
                    case 2:
                        return true;
                    case 1:
                    case 5:
                    case 6:
                    case 3:
                    case 4:
                        var symbol = getSymbolOfNode(left);
                        var init = ts.getAssignedExpandoInitializer(right);
                        return init && ts.isObjectLiteralExpression(init) &&
                            symbol && ts.hasEntries(symbol.exports);
                    default:
                        return false;
                }
            }
            function reportOperatorErrorUnless(typesAreCompatible) {
                if (!typesAreCompatible(leftType, rightType)) {
                    reportOperatorError(typesAreCompatible);
                    return true;
                }
                return false;
            }
            function reportOperatorError(isRelated) {
                var _a;
                var wouldWorkWithAwait = false;
                var errNode = errorNode || operatorToken;
                if (isRelated) {
                    var awaitedLeftType = getAwaitedType(leftType);
                    var awaitedRightType = getAwaitedType(rightType);
                    wouldWorkWithAwait = !(awaitedLeftType === leftType && awaitedRightType === rightType)
                        && !!(awaitedLeftType && awaitedRightType)
                        && isRelated(awaitedLeftType, awaitedRightType);
                }
                var effectiveLeft = leftType;
                var effectiveRight = rightType;
                if (!wouldWorkWithAwait && isRelated) {
                    _a = getBaseTypesIfUnrelated(leftType, rightType, isRelated), effectiveLeft = _a[0], effectiveRight = _a[1];
                }
                var _b = getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight), leftStr = _b[0], rightStr = _b[1];
                if (!tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr)) {
                    errorAndMaybeSuggestAwait(errNode, wouldWorkWithAwait, ts.Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, ts.tokenToString(operatorToken.kind), leftStr, rightStr);
                }
            }
            function tryGiveBetterPrimaryError(errNode, maybeMissingAwait, leftStr, rightStr) {
                var typeName;
                switch (operatorToken.kind) {
                    case 36:
                    case 34:
                        typeName = "false";
                        break;
                    case 37:
                    case 35:
                        typeName = "true";
                }
                if (typeName) {
                    return errorAndMaybeSuggestAwait(errNode, maybeMissingAwait, ts.Diagnostics.This_condition_will_always_return_0_since_the_types_1_and_2_have_no_overlap, typeName, leftStr, rightStr);
                }
                return undefined;
            }
        }
        function getBaseTypesIfUnrelated(leftType, rightType, isRelated) {
            var effectiveLeft = leftType;
            var effectiveRight = rightType;
            var leftBase = getBaseTypeOfLiteralType(leftType);
            var rightBase = getBaseTypeOfLiteralType(rightType);
            if (!isRelated(leftBase, rightBase)) {
                effectiveLeft = leftBase;
                effectiveRight = rightBase;
            }
            return [effectiveLeft, effectiveRight];
        }
        function checkYieldExpression(node) {
            if (produceDiagnostics) {
                if (!(node.flags & 8192)) {
                    grammarErrorOnFirstToken(node, ts.Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body);
                }
                if (isInParameterInitializerBeforeContainingFunction(node)) {
                    error(node, ts.Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer);
                }
            }
            var func = ts.getContainingFunction(node);
            if (!func)
                return anyType;
            var functionFlags = ts.getFunctionFlags(func);
            if (!(functionFlags & 1)) {
                return anyType;
            }
            var isAsync = (functionFlags & 2) !== 0;
            if (node.asteriskToken) {
                if (isAsync && languageVersion < 99) {
                    checkExternalEmitHelpers(node, 53248);
                }
                if (!isAsync && languageVersion < 2 && compilerOptions.downlevelIteration) {
                    checkExternalEmitHelpers(node, 256);
                }
            }
            var returnType = getReturnTypeFromAnnotation(func);
            var iterationTypes = returnType && getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync);
            var signatureYieldType = iterationTypes && iterationTypes.yieldType || anyType;
            var signatureNextType = iterationTypes && iterationTypes.nextType || anyType;
            var resolvedSignatureNextType = isAsync ? getAwaitedType(signatureNextType) || anyType : signatureNextType;
            var yieldExpressionType = node.expression ? checkExpression(node.expression) : undefinedWideningType;
            var yieldedType = getYieldedTypeOfYieldExpression(node, yieldExpressionType, resolvedSignatureNextType, isAsync);
            if (returnType && yieldedType) {
                checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType, node.expression || node, node.expression);
            }
            if (node.asteriskToken) {
                var use = isAsync ? 19 : 17;
                return getIterationTypeOfIterable(use, 1, yieldExpressionType, node.expression)
                    || anyType;
            }
            else if (returnType) {
                return getIterationTypeOfGeneratorFunctionReturnType(2, returnType, isAsync)
                    || anyType;
            }
            return getContextualIterationType(2, func) || anyType;
        }
        function checkConditionalExpression(node, checkMode) {
            var type = checkTruthinessExpression(node.condition);
            checkTestingKnownTruthyCallableType(node.condition, node.whenTrue, type);
            var type1 = checkExpression(node.whenTrue, checkMode);
            var type2 = checkExpression(node.whenFalse, checkMode);
            return getUnionType([type1, type2], 2);
        }
        function checkTemplateExpression(node) {
            ts.forEach(node.templateSpans, function (templateSpan) {
                if (maybeTypeOfKind(checkExpression(templateSpan.expression), 12288)) {
                    error(templateSpan.expression, ts.Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String);
                }
            });
            return stringType;
        }
        function getContextNode(node) {
            if (node.kind === 274 && !ts.isJsxSelfClosingElement(node.parent)) {
                return node.parent.parent;
            }
            return node;
        }
        function checkExpressionWithContextualType(node, contextualType, inferenceContext, checkMode) {
            var context = getContextNode(node);
            var saveContextualType = context.contextualType;
            var saveInferenceContext = context.inferenceContext;
            try {
                context.contextualType = contextualType;
                context.inferenceContext = inferenceContext;
                var type = checkExpression(node, checkMode | 1 | (inferenceContext ? 2 : 0));
                var result = maybeTypeOfKind(type, 2944) && isLiteralOfContextualType(type, instantiateContextualType(contextualType, node)) ?
                    getRegularTypeOfLiteralType(type) : type;
                return result;
            }
            finally {
                context.contextualType = saveContextualType;
                context.inferenceContext = saveInferenceContext;
            }
        }
        function checkExpressionCached(node, checkMode) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                if (checkMode && checkMode !== 0) {
                    return checkExpression(node, checkMode);
                }
                var saveFlowLoopStart = flowLoopStart;
                var saveFlowTypeCache = flowTypeCache;
                flowLoopStart = flowLoopCount;
                flowTypeCache = undefined;
                links.resolvedType = checkExpression(node, checkMode);
                flowTypeCache = saveFlowTypeCache;
                flowLoopStart = saveFlowLoopStart;
            }
            return links.resolvedType;
        }
        function isTypeAssertion(node) {
            node = ts.skipParentheses(node);
            return node.kind === 199 || node.kind === 217;
        }
        function checkDeclarationInitializer(declaration, contextualType) {
            var initializer = ts.getEffectiveInitializer(declaration);
            var type = getQuickTypeOfExpression(initializer) ||
                (contextualType ? checkExpressionWithContextualType(initializer, contextualType, undefined, 0) : checkExpressionCached(initializer));
            return ts.isParameter(declaration) && declaration.name.kind === 190 &&
                isTupleType(type) && !type.target.hasRestElement && getTypeReferenceArity(type) < declaration.name.elements.length ?
                padTupleType(type, declaration.name) : type;
        }
        function padTupleType(type, pattern) {
            var patternElements = pattern.elements;
            var arity = getTypeReferenceArity(type);
            var elementTypes = arity ? getTypeArguments(type).slice() : [];
            for (var i = arity; i < patternElements.length; i++) {
                var e = patternElements[i];
                if (i < patternElements.length - 1 || !(e.kind === 191 && e.dotDotDotToken)) {
                    elementTypes.push(!ts.isOmittedExpression(e) && hasDefaultValue(e) ? getTypeFromBindingElement(e, false, false) : anyType);
                    if (!ts.isOmittedExpression(e) && !hasDefaultValue(e)) {
                        reportImplicitAny(e, anyType);
                    }
                }
            }
            return createTupleType(elementTypes, type.target.minLength, false, type.target.readonly);
        }
        function widenTypeInferredFromInitializer(declaration, type) {
            var widened = ts.getCombinedNodeFlags(declaration) & 2 || ts.isDeclarationReadonly(declaration) ? type : getWidenedLiteralType(type);
            if (ts.isInJSFile(declaration)) {
                if (widened.flags & 98304) {
                    reportImplicitAny(declaration, anyType);
                    return anyType;
                }
                else if (isEmptyArrayLiteralType(widened)) {
                    reportImplicitAny(declaration, anyArrayType);
                    return anyArrayType;
                }
            }
            return widened;
        }
        function isLiteralOfContextualType(candidateType, contextualType) {
            if (contextualType) {
                if (contextualType.flags & 3145728) {
                    var types = contextualType.types;
                    return ts.some(types, function (t) { return isLiteralOfContextualType(candidateType, t); });
                }
                if (contextualType.flags & 58982400) {
                    var constraint = getBaseConstraintOfType(contextualType) || unknownType;
                    return maybeTypeOfKind(constraint, 4) && maybeTypeOfKind(candidateType, 128) ||
                        maybeTypeOfKind(constraint, 8) && maybeTypeOfKind(candidateType, 256) ||
                        maybeTypeOfKind(constraint, 64) && maybeTypeOfKind(candidateType, 2048) ||
                        maybeTypeOfKind(constraint, 4096) && maybeTypeOfKind(candidateType, 8192) ||
                        isLiteralOfContextualType(candidateType, constraint);
                }
                return !!(contextualType.flags & (128 | 4194304) && maybeTypeOfKind(candidateType, 128) ||
                    contextualType.flags & 256 && maybeTypeOfKind(candidateType, 256) ||
                    contextualType.flags & 2048 && maybeTypeOfKind(candidateType, 2048) ||
                    contextualType.flags & 512 && maybeTypeOfKind(candidateType, 512) ||
                    contextualType.flags & 8192 && maybeTypeOfKind(candidateType, 8192));
            }
            return false;
        }
        function isConstContext(node) {
            var parent = node.parent;
            return ts.isAssertionExpression(parent) && ts.isConstTypeReference(parent.type) ||
                (ts.isParenthesizedExpression(parent) || ts.isArrayLiteralExpression(parent) || ts.isSpreadElement(parent)) && isConstContext(parent) ||
                (ts.isPropertyAssignment(parent) || ts.isShorthandPropertyAssignment(parent)) && isConstContext(parent.parent);
        }
        function checkExpressionForMutableLocation(node, checkMode, contextualType, forceTuple) {
            var type = checkExpression(node, checkMode, forceTuple);
            return isConstContext(node) ? getRegularTypeOfLiteralType(type) :
                isTypeAssertion(node) ? type :
                    getWidenedLiteralLikeTypeForContextualType(type, instantiateContextualType(arguments.length === 2 ? getContextualType(node) : contextualType, node));
        }
        function checkPropertyAssignment(node, checkMode) {
            if (node.name.kind === 154) {
                checkComputedPropertyName(node.name);
            }
            return checkExpressionForMutableLocation(node.initializer, checkMode);
        }
        function checkObjectLiteralMethod(node, checkMode) {
            checkGrammarMethod(node);
            if (node.name.kind === 154) {
                checkComputedPropertyName(node.name);
            }
            var uninstantiatedType = checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
            return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
        }
        function instantiateTypeWithSingleGenericCallSignature(node, type, checkMode) {
            if (checkMode && checkMode & (2 | 8)) {
                var callSignature = getSingleSignature(type, 0, true);
                var constructSignature = getSingleSignature(type, 1, true);
                var signature = callSignature || constructSignature;
                if (signature && signature.typeParameters) {
                    var contextualType = getApparentTypeOfContextualType(node, 2);
                    if (contextualType) {
                        var contextualSignature = getSingleSignature(getNonNullableType(contextualType), callSignature ? 0 : 1, false);
                        if (contextualSignature && !contextualSignature.typeParameters) {
                            if (checkMode & 8) {
                                skippedGenericFunction(node, checkMode);
                                return anyFunctionType;
                            }
                            var context = getInferenceContext(node);
                            var returnType = context.signature && getReturnTypeOfSignature(context.signature);
                            var returnSignature = returnType && getSingleCallOrConstructSignature(returnType);
                            if (returnSignature && !returnSignature.typeParameters && !ts.every(context.inferences, hasInferenceCandidates)) {
                                var uniqueTypeParameters = getUniqueTypeParameters(context, signature.typeParameters);
                                var instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters);
                                var inferences_3 = ts.map(context.inferences, function (info) { return createInferenceInfo(info.typeParameter); });
                                applyToParameterTypes(instantiatedSignature, contextualSignature, function (source, target) {
                                    inferTypes(inferences_3, source, target, 0, true);
                                });
                                if (ts.some(inferences_3, hasInferenceCandidates)) {
                                    applyToReturnTypes(instantiatedSignature, contextualSignature, function (source, target) {
                                        inferTypes(inferences_3, source, target);
                                    });
                                    if (!hasOverlappingInferences(context.inferences, inferences_3)) {
                                        mergeInferences(context.inferences, inferences_3);
                                        context.inferredTypeParameters = ts.concatenate(context.inferredTypeParameters, uniqueTypeParameters);
                                        return getOrCreateTypeFromSignature(instantiatedSignature);
                                    }
                                }
                            }
                            return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context));
                        }
                    }
                }
            }
            return type;
        }
        function skippedGenericFunction(node, checkMode) {
            if (checkMode & 2) {
                var context = getInferenceContext(node);
                context.flags |= 4;
            }
        }
        function hasInferenceCandidates(info) {
            return !!(info.candidates || info.contraCandidates);
        }
        function hasOverlappingInferences(a, b) {
            for (var i = 0; i < a.length; i++) {
                if (hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i])) {
                    return true;
                }
            }
            return false;
        }
        function mergeInferences(target, source) {
            for (var i = 0; i < target.length; i++) {
                if (!hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i])) {
                    target[i] = source[i];
                }
            }
        }
        function getUniqueTypeParameters(context, typeParameters) {
            var result = [];
            var oldTypeParameters;
            var newTypeParameters;
            for (var _i = 0, typeParameters_2 = typeParameters; _i < typeParameters_2.length; _i++) {
                var tp = typeParameters_2[_i];
                var name = tp.symbol.escapedName;
                if (hasTypeParameterByName(context.inferredTypeParameters, name) || hasTypeParameterByName(result, name)) {
                    var newName = getUniqueTypeParameterName(ts.concatenate(context.inferredTypeParameters, result), name);
                    var symbol = createSymbol(262144, newName);
                    var newTypeParameter = createTypeParameter(symbol);
                    newTypeParameter.target = tp;
                    oldTypeParameters = ts.append(oldTypeParameters, tp);
                    newTypeParameters = ts.append(newTypeParameters, newTypeParameter);
                    result.push(newTypeParameter);
                }
                else {
                    result.push(tp);
                }
            }
            if (newTypeParameters) {
                var mapper = createTypeMapper(oldTypeParameters, newTypeParameters);
                for (var _a = 0, newTypeParameters_1 = newTypeParameters; _a < newTypeParameters_1.length; _a++) {
                    var tp = newTypeParameters_1[_a];
                    tp.mapper = mapper;
                }
            }
            return result;
        }
        function hasTypeParameterByName(typeParameters, name) {
            return ts.some(typeParameters, function (tp) { return tp.symbol.escapedName === name; });
        }
        function getUniqueTypeParameterName(typeParameters, baseName) {
            var len = baseName.length;
            while (len > 1 && baseName.charCodeAt(len - 1) >= 48 && baseName.charCodeAt(len - 1) <= 57)
                len--;
            var s = baseName.slice(0, len);
            for (var index = 1; true; index++) {
                var augmentedName = (s + index);
                if (!hasTypeParameterByName(typeParameters, augmentedName)) {
                    return augmentedName;
                }
            }
        }
        function getReturnTypeOfSingleNonGenericCallSignature(funcType) {
            var signature = getSingleCallSignature(funcType);
            if (signature && !signature.typeParameters) {
                return getReturnTypeOfSignature(signature);
            }
        }
        function getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) {
            var funcType = checkExpression(expr.expression);
            var nonOptionalType = getOptionalExpressionType(funcType, expr.expression);
            var returnType = getReturnTypeOfSingleNonGenericCallSignature(funcType);
            return returnType && propagateOptionalTypeMarker(returnType, expr, nonOptionalType !== funcType);
        }
        function getTypeOfExpression(node) {
            var quickType = getQuickTypeOfExpression(node);
            if (quickType) {
                return quickType;
            }
            if (node.flags & 67108864 && flowTypeCache) {
                var cachedType = flowTypeCache[getNodeId(node)];
                if (cachedType) {
                    return cachedType;
                }
            }
            var startInvocationCount = flowInvocationCount;
            var type = checkExpression(node);
            if (flowInvocationCount !== startInvocationCount) {
                var cache = flowTypeCache || (flowTypeCache = []);
                cache[getNodeId(node)] = type;
                node.flags |= 67108864;
            }
            return type;
        }
        function getQuickTypeOfExpression(node) {
            var expr = ts.skipParentheses(node);
            if (ts.isCallExpression(expr) && expr.expression.kind !== 102 && !ts.isRequireCall(expr, true) && !isSymbolOrSymbolForCall(expr)) {
                var type = ts.isCallChain(expr) ? getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) :
                    getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression));
                if (type) {
                    return type;
                }
            }
            else if (ts.isAssertionExpression(expr) && !ts.isConstTypeReference(expr.type)) {
                return getTypeFromTypeNode(expr.type);
            }
            else if (node.kind === 8 || node.kind === 10 ||
                node.kind === 106 || node.kind === 91) {
                return checkExpression(node);
            }
            return undefined;
        }
        function getContextFreeTypeOfExpression(node) {
            var links = getNodeLinks(node);
            if (links.contextFreeType) {
                return links.contextFreeType;
            }
            var saveContextualType = node.contextualType;
            node.contextualType = anyType;
            try {
                var type = links.contextFreeType = checkExpression(node, 4);
                return type;
            }
            finally {
                node.contextualType = saveContextualType;
            }
        }
        function checkExpression(node, checkMode, forceTuple) {
            var saveCurrentNode = currentNode;
            currentNode = node;
            instantiationCount = 0;
            var uninstantiatedType = checkExpressionWorker(node, checkMode, forceTuple);
            var type = instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
            if (isConstEnumObjectType(type)) {
                checkConstEnumAccess(node, type);
            }
            currentNode = saveCurrentNode;
            return type;
        }
        function checkConstEnumAccess(node, type) {
            var ok = (node.parent.kind === 194 && node.parent.expression === node) ||
                (node.parent.kind === 195 && node.parent.expression === node) ||
                ((node.kind === 75 || node.kind === 153) && isInRightSideOfImportOrExportAssignment(node) ||
                    (node.parent.kind === 172 && node.parent.exprName === node)) ||
                (node.parent.kind === 263);
            if (!ok) {
                error(node, ts.Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query);
            }
            if (compilerOptions.isolatedModules) {
                ts.Debug.assert(!!(type.symbol.flags & 128));
                var constEnumDeclaration = type.symbol.valueDeclaration;
                if (constEnumDeclaration.flags & 8388608) {
                    error(node, ts.Diagnostics.Cannot_access_ambient_const_enums_when_the_isolatedModules_flag_is_provided);
                }
            }
        }
        function checkParenthesizedExpression(node, checkMode) {
            var tag = ts.isInJSFile(node) ? ts.getJSDocTypeTag(node) : undefined;
            if (tag) {
                return checkAssertionWorker(tag, tag.typeExpression.type, node.expression, checkMode);
            }
            return checkExpression(node.expression, checkMode);
        }
        function checkExpressionWorker(node, checkMode, forceTuple) {
            var kind = node.kind;
            if (cancellationToken) {
                switch (kind) {
                    case 214:
                    case 201:
                    case 202:
                        cancellationToken.throwIfCancellationRequested();
                }
            }
            switch (kind) {
                case 75:
                    return checkIdentifier(node);
                case 104:
                    return checkThisExpression(node);
                case 102:
                    return checkSuperExpression(node);
                case 100:
                    return nullWideningType;
                case 14:
                case 10:
                    return getFreshTypeOfLiteralType(getLiteralType(node.text));
                case 8:
                    checkGrammarNumericLiteral(node);
                    return getFreshTypeOfLiteralType(getLiteralType(+node.text));
                case 9:
                    checkGrammarBigIntLiteral(node);
                    return getFreshTypeOfLiteralType(getBigIntLiteralType(node));
                case 106:
                    return trueType;
                case 91:
                    return falseType;
                case 211:
                    return checkTemplateExpression(node);
                case 13:
                    return globalRegExpType;
                case 192:
                    return checkArrayLiteral(node, checkMode, forceTuple);
                case 193:
                    return checkObjectLiteral(node, checkMode);
                case 194:
                    return checkPropertyAccessExpression(node);
                case 153:
                    return checkQualifiedName(node);
                case 195:
                    return checkIndexedAccess(node);
                case 196:
                    if (node.expression.kind === 96) {
                        return checkImportCallExpression(node);
                    }
                case 197:
                    return checkCallExpression(node, checkMode);
                case 198:
                    return checkTaggedTemplateExpression(node);
                case 200:
                    return checkParenthesizedExpression(node, checkMode);
                case 214:
                    return checkClassExpression(node);
                case 201:
                case 202:
                    return checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
                case 204:
                    return checkTypeOfExpression(node);
                case 199:
                case 217:
                    return checkAssertion(node);
                case 218:
                    return checkNonNullAssertion(node);
                case 219:
                    return checkMetaProperty(node);
                case 203:
                    return checkDeleteExpression(node);
                case 205:
                    return checkVoidExpression(node);
                case 206:
                    return checkAwaitExpression(node);
                case 207:
                    return checkPrefixUnaryExpression(node);
                case 208:
                    return checkPostfixUnaryExpression(node);
                case 209:
                    return checkBinaryExpression(node, checkMode);
                case 210:
                    return checkConditionalExpression(node, checkMode);
                case 213:
                    return checkSpreadExpression(node, checkMode);
                case 215:
                    return undefinedWideningType;
                case 212:
                    return checkYieldExpression(node);
                case 220:
                    return node.type;
                case 276:
                    return checkJsxExpression(node, checkMode);
                case 266:
                    return checkJsxElement(node, checkMode);
                case 267:
                    return checkJsxSelfClosingElement(node, checkMode);
                case 270:
                    return checkJsxFragment(node);
                case 274:
                    return checkJsxAttributes(node, checkMode);
                case 268:
                    ts.Debug.fail("Shouldn't ever directly check a JsxOpeningElement");
            }
            return errorType;
        }
        function checkTypeParameter(node) {
            if (node.expression) {
                grammarErrorOnFirstToken(node.expression, ts.Diagnostics.Type_expected);
            }
            checkSourceElement(node.constraint);
            checkSourceElement(node.default);
            var typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node));
            getBaseConstraintOfType(typeParameter);
            if (!hasNonCircularTypeParameterDefault(typeParameter)) {
                error(node.default, ts.Diagnostics.Type_parameter_0_has_a_circular_default, typeToString(typeParameter));
            }
            var constraintType = getConstraintOfTypeParameter(typeParameter);
            var defaultType = getDefaultFromTypeParameter(typeParameter);
            if (constraintType && defaultType) {
                checkTypeAssignableTo(defaultType, getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType), node.default, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
            }
            if (produceDiagnostics) {
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_parameter_name_cannot_be_0);
            }
        }
        function checkParameter(node) {
            checkGrammarDecoratorsAndModifiers(node);
            checkVariableLikeDeclaration(node);
            var func = ts.getContainingFunction(node);
            if (ts.hasModifier(node, 92)) {
                if (!(func.kind === 162 && ts.nodeIsPresent(func.body))) {
                    error(node, ts.Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
                }
                if (func.kind === 162 && ts.isIdentifier(node.name) && node.name.escapedText === "constructor") {
                    error(node.name, ts.Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name);
                }
            }
            if (node.questionToken && ts.isBindingPattern(node.name) && func.body) {
                error(node, ts.Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature);
            }
            if (node.name && ts.isIdentifier(node.name) && (node.name.escapedText === "this" || node.name.escapedText === "new")) {
                if (func.parameters.indexOf(node) !== 0) {
                    error(node, ts.Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.escapedText);
                }
                if (func.kind === 162 || func.kind === 166 || func.kind === 171) {
                    error(node, ts.Diagnostics.A_constructor_cannot_have_a_this_parameter);
                }
                if (func.kind === 202) {
                    error(node, ts.Diagnostics.An_arrow_function_cannot_have_a_this_parameter);
                }
                if (func.kind === 163 || func.kind === 164) {
                    error(node, ts.Diagnostics.get_and_set_accessors_cannot_declare_this_parameters);
                }
            }
            if (node.dotDotDotToken && !ts.isBindingPattern(node.name) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol(node.symbol)), anyReadonlyArrayType)) {
                error(node, ts.Diagnostics.A_rest_parameter_must_be_of_an_array_type);
            }
        }
        function checkTypePredicate(node) {
            var parent = getTypePredicateParent(node);
            if (!parent) {
                error(node, ts.Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
                return;
            }
            var signature = getSignatureFromDeclaration(parent);
            var typePredicate = getTypePredicateOfSignature(signature);
            if (!typePredicate) {
                return;
            }
            checkSourceElement(node.type);
            var parameterName = node.parameterName;
            if (typePredicate.kind === 0 || typePredicate.kind === 2) {
                getTypeFromThisTypeNode(parameterName);
            }
            else {
                if (typePredicate.parameterIndex >= 0) {
                    if (signatureHasRestParameter(signature) && typePredicate.parameterIndex === signature.parameters.length - 1) {
                        error(parameterName, ts.Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter);
                    }
                    else {
                        if (typePredicate.type) {
                            var leadingError = function () { return ts.chainDiagnosticMessages(undefined, ts.Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type); };
                            checkTypeAssignableTo(typePredicate.type, getTypeOfSymbol(signature.parameters[typePredicate.parameterIndex]), node.type, undefined, leadingError);
                        }
                    }
                }
                else if (parameterName) {
                    var hasReportedError = false;
                    for (var _i = 0, _a = parent.parameters; _i < _a.length; _i++) {
                        var name = _a[_i].name;
                        if (ts.isBindingPattern(name) &&
                            checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName)) {
                            hasReportedError = true;
                            break;
                        }
                    }
                    if (!hasReportedError) {
                        error(node.parameterName, ts.Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName);
                    }
                }
            }
        }
        function getTypePredicateParent(node) {
            switch (node.parent.kind) {
                case 202:
                case 165:
                case 244:
                case 201:
                case 170:
                case 161:
                case 160:
                    var parent = node.parent;
                    if (node === parent.type) {
                        return parent;
                    }
            }
        }
        function checkIfTypePredicateVariableIsDeclaredInBindingPattern(pattern, predicateVariableNode, predicateVariableName) {
            for (var _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                if (ts.isOmittedExpression(element)) {
                    continue;
                }
                var name = element.name;
                if (name.kind === 75 && name.escapedText === predicateVariableName) {
                    error(predicateVariableNode, ts.Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName);
                    return true;
                }
                else if (name.kind === 190 || name.kind === 189) {
                    if (checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, predicateVariableNode, predicateVariableName)) {
                        return true;
                    }
                }
            }
        }
        function checkSignatureDeclaration(node) {
            if (node.kind === 167) {
                checkGrammarIndexSignature(node);
            }
            else if (node.kind === 170 || node.kind === 244 || node.kind === 171 ||
                node.kind === 165 || node.kind === 162 ||
                node.kind === 166) {
                checkGrammarFunctionLikeDeclaration(node);
            }
            var functionFlags = ts.getFunctionFlags(node);
            if (!(functionFlags & 4)) {
                if ((functionFlags & 3) === 3 && languageVersion < 99) {
                    checkExternalEmitHelpers(node, 12288);
                }
                if ((functionFlags & 3) === 2 && languageVersion < 4) {
                    checkExternalEmitHelpers(node, 64);
                }
                if ((functionFlags & 3) !== 0 && languageVersion < 2) {
                    checkExternalEmitHelpers(node, 128);
                }
            }
            checkTypeParameters(node.typeParameters);
            ts.forEach(node.parameters, checkParameter);
            if (node.type) {
                checkSourceElement(node.type);
            }
            if (produceDiagnostics) {
                checkCollisionWithArgumentsInGeneratedCode(node);
                var returnTypeNode = ts.getEffectiveReturnTypeNode(node);
                if (noImplicitAny && !returnTypeNode) {
                    switch (node.kind) {
                        case 166:
                            error(node, ts.Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                        case 165:
                            error(node, ts.Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                    }
                }
                if (returnTypeNode) {
                    var functionFlags_1 = ts.getFunctionFlags(node);
                    if ((functionFlags_1 & (4 | 1)) === 1) {
                        var returnType = getTypeFromTypeNode(returnTypeNode);
                        if (returnType === voidType) {
                            error(returnTypeNode, ts.Diagnostics.A_generator_cannot_have_a_void_type_annotation);
                        }
                        else {
                            var generatorYieldType = getIterationTypeOfGeneratorFunctionReturnType(0, returnType, (functionFlags_1 & 2) !== 0) || anyType;
                            var generatorReturnType = getIterationTypeOfGeneratorFunctionReturnType(1, returnType, (functionFlags_1 & 2) !== 0) || generatorYieldType;
                            var generatorNextType = getIterationTypeOfGeneratorFunctionReturnType(2, returnType, (functionFlags_1 & 2) !== 0) || unknownType;
                            var generatorInstantiation = createGeneratorReturnType(generatorYieldType, generatorReturnType, generatorNextType, !!(functionFlags_1 & 2));
                            checkTypeAssignableTo(generatorInstantiation, returnType, returnTypeNode);
                        }
                    }
                    else if ((functionFlags_1 & 3) === 2) {
                        checkAsyncFunctionReturnType(node, returnTypeNode);
                    }
                }
                if (node.kind !== 167 && node.kind !== 300) {
                    registerForUnusedIdentifiersCheck(node);
                }
            }
        }
        function checkClassForDuplicateDeclarations(node) {
            var instanceNames = ts.createUnderscoreEscapedMap();
            var staticNames = ts.createUnderscoreEscapedMap();
            var privateIdentifiers = ts.createUnderscoreEscapedMap();
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (member.kind === 162) {
                    for (var _b = 0, _c = member.parameters; _b < _c.length; _b++) {
                        var param = _c[_b];
                        if (ts.isParameterPropertyDeclaration(param, member) && !ts.isBindingPattern(param.name)) {
                            addName(instanceNames, param.name, param.name.escapedText, 3);
                        }
                    }
                }
                else {
                    var isStatic = ts.hasModifier(member, 32);
                    var name = member.name;
                    if (!name) {
                        return;
                    }
                    var names = ts.isPrivateIdentifier(name) ? privateIdentifiers :
                        isStatic ? staticNames :
                            instanceNames;
                    var memberName = name && ts.getPropertyNameForPropertyNameNode(name);
                    if (memberName) {
                        switch (member.kind) {
                            case 163:
                                addName(names, name, memberName, 1);
                                break;
                            case 164:
                                addName(names, name, memberName, 2);
                                break;
                            case 159:
                                addName(names, name, memberName, 3);
                                break;
                            case 161:
                                addName(names, name, memberName, 8);
                                break;
                        }
                    }
                }
            }
            function addName(names, location, name, meaning) {
                var prev = names.get(name);
                if (prev) {
                    if (prev & 8) {
                        if (meaning !== 8) {
                            error(location, ts.Diagnostics.Duplicate_identifier_0, ts.getTextOfNode(location));
                        }
                    }
                    else if (prev & meaning) {
                        error(location, ts.Diagnostics.Duplicate_identifier_0, ts.getTextOfNode(location));
                    }
                    else {
                        names.set(name, prev | meaning);
                    }
                }
                else {
                    names.set(name, meaning);
                }
            }
        }
        function checkClassForStaticPropertyNameConflicts(node) {
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                var memberNameNode = member.name;
                var isStatic = ts.hasModifier(member, 32);
                if (isStatic && memberNameNode) {
                    var memberName = ts.getPropertyNameForPropertyNameNode(memberNameNode);
                    switch (memberName) {
                        case "name":
                        case "length":
                        case "caller":
                        case "arguments":
                        case "prototype":
                            var message = ts.Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1;
                            var className = getNameOfSymbolAsWritten(getSymbolOfNode(node));
                            error(memberNameNode, message, memberName, className);
                            break;
                    }
                }
            }
        }
        function checkObjectTypeForDuplicateDeclarations(node) {
            var names = ts.createMap();
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (member.kind === 158) {
                    var memberName = void 0;
                    var name = member.name;
                    switch (name.kind) {
                        case 10:
                        case 8:
                            memberName = name.text;
                            break;
                        case 75:
                            memberName = ts.idText(name);
                            break;
                        default:
                            continue;
                    }
                    if (names.get(memberName)) {
                        error(ts.getNameOfDeclaration(member.symbol.valueDeclaration), ts.Diagnostics.Duplicate_identifier_0, memberName);
                        error(member.name, ts.Diagnostics.Duplicate_identifier_0, memberName);
                    }
                    else {
                        names.set(memberName, true);
                    }
                }
            }
        }
        function checkTypeForDuplicateIndexSignatures(node) {
            if (node.kind === 246) {
                var nodeSymbol = getSymbolOfNode(node);
                if (nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {
                    return;
                }
            }
            var indexSymbol = getIndexSymbol(getSymbolOfNode(node));
            if (indexSymbol) {
                var seenNumericIndexer = false;
                var seenStringIndexer = false;
                for (var _i = 0, _a = indexSymbol.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    var declaration = decl;
                    if (declaration.parameters.length === 1 && declaration.parameters[0].type) {
                        switch (declaration.parameters[0].type.kind) {
                            case 143:
                                if (!seenStringIndexer) {
                                    seenStringIndexer = true;
                                }
                                else {
                                    error(declaration, ts.Diagnostics.Duplicate_string_index_signature);
                                }
                                break;
                            case 140:
                                if (!seenNumericIndexer) {
                                    seenNumericIndexer = true;
                                }
                                else {
                                    error(declaration, ts.Diagnostics.Duplicate_number_index_signature);
                                }
                                break;
                        }
                    }
                }
            }
        }
        function checkPropertyDeclaration(node) {
            if (!checkGrammarDecoratorsAndModifiers(node) && !checkGrammarProperty(node))
                checkGrammarComputedPropertyName(node.name);
            checkVariableLikeDeclaration(node);
            if (ts.isPrivateIdentifier(node.name) && languageVersion < 99) {
                for (var lexicalScope = ts.getEnclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = ts.getEnclosingBlockScopeContainer(lexicalScope)) {
                    getNodeLinks(lexicalScope).flags |= 67108864;
                }
            }
        }
        function checkPropertySignature(node) {
            if (ts.isPrivateIdentifier(node.name)) {
                error(node, ts.Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
            }
            return checkPropertyDeclaration(node);
        }
        function checkMethodDeclaration(node) {
            if (!checkGrammarMethod(node))
                checkGrammarComputedPropertyName(node.name);
            if (ts.isPrivateIdentifier(node.name)) {
                error(node, ts.Diagnostics.A_method_cannot_be_named_with_a_private_identifier);
            }
            checkFunctionOrMethodDeclaration(node);
            if (ts.hasModifier(node, 128) && node.kind === 161 && node.body) {
                error(node, ts.Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, ts.declarationNameToString(node.name));
            }
        }
        function checkConstructorDeclaration(node) {
            checkSignatureDeclaration(node);
            if (!checkGrammarConstructorTypeParameters(node))
                checkGrammarConstructorTypeAnnotation(node);
            checkSourceElement(node.body);
            var symbol = getSymbolOfNode(node);
            var firstDeclaration = ts.getDeclarationOfKind(symbol, node.kind);
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(symbol);
            }
            if (ts.nodeIsMissing(node.body)) {
                return;
            }
            if (!produceDiagnostics) {
                return;
            }
            function isInstancePropertyWithInitializerOrPrivateIdentifierProperty(n) {
                if (ts.isPrivateIdentifierPropertyDeclaration(n)) {
                    return true;
                }
                return n.kind === 159 &&
                    !ts.hasModifier(n, 32) &&
                    !!n.initializer;
            }
            var containingClassDecl = node.parent;
            if (ts.getClassExtendsHeritageElement(containingClassDecl)) {
                captureLexicalThis(node.parent, containingClassDecl);
                var classExtendsNull = classDeclarationExtendsNull(containingClassDecl);
                var superCall = getSuperCallInConstructor(node);
                if (superCall) {
                    if (classExtendsNull) {
                        error(superCall, ts.Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null);
                    }
                    var superCallShouldBeFirst = (compilerOptions.target !== 99 || !compilerOptions.useDefineForClassFields) &&
                        (ts.some(node.parent.members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) ||
                            ts.some(node.parameters, function (p) { return ts.hasModifier(p, 92); }));
                    if (superCallShouldBeFirst) {
                        var statements = node.body.statements;
                        var superCallStatement = void 0;
                        for (var _i = 0, statements_3 = statements; _i < statements_3.length; _i++) {
                            var statement = statements_3[_i];
                            if (statement.kind === 226 && ts.isSuperCall(statement.expression)) {
                                superCallStatement = statement;
                                break;
                            }
                            if (!ts.isPrologueDirective(statement)) {
                                break;
                            }
                        }
                        if (!superCallStatement) {
                            error(node, ts.Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_parameter_properties_or_private_identifiers);
                        }
                    }
                }
                else if (!classExtendsNull) {
                    error(node, ts.Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call);
                }
            }
        }
        function checkAccessorDeclaration(node) {
            if (produceDiagnostics) {
                if (!checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(node))
                    checkGrammarComputedPropertyName(node.name);
                checkDecorators(node);
                checkSignatureDeclaration(node);
                if (node.kind === 163) {
                    if (!(node.flags & 8388608) && ts.nodeIsPresent(node.body) && (node.flags & 256)) {
                        if (!(node.flags & 512)) {
                            error(node.name, ts.Diagnostics.A_get_accessor_must_return_a_value);
                        }
                    }
                }
                if (node.name.kind === 154) {
                    checkComputedPropertyName(node.name);
                }
                if (ts.isPrivateIdentifier(node.name)) {
                    error(node.name, ts.Diagnostics.An_accessor_cannot_be_named_with_a_private_identifier);
                }
                if (!hasNonBindableDynamicName(node)) {
                    var otherKind = node.kind === 163 ? 164 : 163;
                    var otherAccessor = ts.getDeclarationOfKind(getSymbolOfNode(node), otherKind);
                    if (otherAccessor) {
                        var nodeFlags = ts.getModifierFlags(node);
                        var otherFlags = ts.getModifierFlags(otherAccessor);
                        if ((nodeFlags & 28) !== (otherFlags & 28)) {
                            error(node.name, ts.Diagnostics.Getter_and_setter_accessors_do_not_agree_in_visibility);
                        }
                        if ((nodeFlags & 128) !== (otherFlags & 128)) {
                            error(node.name, ts.Diagnostics.Accessors_must_both_be_abstract_or_non_abstract);
                        }
                        checkAccessorDeclarationTypesIdentical(node, otherAccessor, getAnnotatedAccessorType, ts.Diagnostics.get_and_set_accessor_must_have_the_same_type);
                        checkAccessorDeclarationTypesIdentical(node, otherAccessor, getThisTypeOfDeclaration, ts.Diagnostics.get_and_set_accessor_must_have_the_same_this_type);
                    }
                }
                var returnType = getTypeOfAccessors(getSymbolOfNode(node));
                if (node.kind === 163) {
                    checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
                }
            }
            checkSourceElement(node.body);
        }
        function checkAccessorDeclarationTypesIdentical(first, second, getAnnotatedType, message) {
            var firstType = getAnnotatedType(first);
            var secondType = getAnnotatedType(second);
            if (firstType && secondType && !isTypeIdenticalTo(firstType, secondType)) {
                error(first, message);
            }
        }
        function checkMissingDeclaration(node) {
            checkDecorators(node);
        }
        function getEffectiveTypeArguments(node, typeParameters) {
            return fillMissingTypeArguments(ts.map(node.typeArguments, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), ts.isInJSFile(node));
        }
        function checkTypeArgumentConstraints(node, typeParameters) {
            var typeArguments;
            var mapper;
            var result = true;
            for (var i = 0; i < typeParameters.length; i++) {
                var constraint = getConstraintOfTypeParameter(typeParameters[i]);
                if (constraint) {
                    if (!typeArguments) {
                        typeArguments = getEffectiveTypeArguments(node, typeParameters);
                        mapper = createTypeMapper(typeParameters, typeArguments);
                    }
                    result = result && checkTypeAssignableTo(typeArguments[i], instantiateType(constraint, mapper), node.typeArguments[i], ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
                }
            }
            return result;
        }
        function getTypeParametersForTypeReference(node) {
            var type = getTypeFromTypeReference(node);
            if (type !== errorType) {
                var symbol = getNodeLinks(node).resolvedSymbol;
                if (symbol) {
                    return symbol.flags & 524288 && getSymbolLinks(symbol).typeParameters ||
                        (ts.getObjectFlags(type) & 4 ? type.target.localTypeParameters : undefined);
                }
            }
            return undefined;
        }
        function checkTypeReferenceNode(node) {
            checkGrammarTypeArguments(node, node.typeArguments);
            if (node.kind === 169 && node.typeName.jsdocDotPos !== undefined && !ts.isInJSFile(node) && !ts.isInJSDoc(node)) {
                grammarErrorAtPos(node, node.typeName.jsdocDotPos, 1, ts.Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments);
            }
            ts.forEach(node.typeArguments, checkSourceElement);
            var type = getTypeFromTypeReference(node);
            if (type !== errorType) {
                if (node.typeArguments && produceDiagnostics) {
                    var typeParameters = getTypeParametersForTypeReference(node);
                    if (typeParameters) {
                        checkTypeArgumentConstraints(node, typeParameters);
                    }
                }
                if (type.flags & 32 && getNodeLinks(node).resolvedSymbol.flags & 8) {
                    error(node, ts.Diagnostics.Enum_type_0_has_members_with_initializers_that_are_not_literals, typeToString(type));
                }
            }
        }
        function getTypeArgumentConstraint(node) {
            var typeReferenceNode = ts.tryCast(node.parent, ts.isTypeReferenceType);
            if (!typeReferenceNode)
                return undefined;
            var typeParameters = getTypeParametersForTypeReference(typeReferenceNode);
            var constraint = getConstraintOfTypeParameter(typeParameters[typeReferenceNode.typeArguments.indexOf(node)]);
            return constraint && instantiateType(constraint, createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReferenceNode, typeParameters)));
        }
        function checkTypeQuery(node) {
            getTypeFromTypeQueryNode(node);
        }
        function checkTypeLiteral(node) {
            ts.forEach(node.members, checkSourceElement);
            if (produceDiagnostics) {
                var type = getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
                checkIndexConstraints(type);
                checkTypeForDuplicateIndexSignatures(node);
                checkObjectTypeForDuplicateDeclarations(node);
            }
        }
        function checkArrayType(node) {
            checkSourceElement(node.elementType);
        }
        function checkTupleType(node) {
            var elementTypes = node.elementTypes;
            var seenOptionalElement = false;
            for (var i = 0; i < elementTypes.length; i++) {
                var e = elementTypes[i];
                if (e.kind === 177) {
                    if (i !== elementTypes.length - 1) {
                        grammarErrorOnNode(e, ts.Diagnostics.A_rest_element_must_be_last_in_a_tuple_type);
                        break;
                    }
                    if (!isArrayType(getTypeFromTypeNode(e.type))) {
                        error(e, ts.Diagnostics.A_rest_element_type_must_be_an_array_type);
                    }
                }
                else if (e.kind === 176) {
                    seenOptionalElement = true;
                }
                else if (seenOptionalElement) {
                    grammarErrorOnNode(e, ts.Diagnostics.A_required_element_cannot_follow_an_optional_element);
                    break;
                }
            }
            ts.forEach(node.elementTypes, checkSourceElement);
        }
        function checkUnionOrIntersectionType(node) {
            ts.forEach(node.types, checkSourceElement);
        }
        function checkIndexedAccessIndexType(type, accessNode) {
            if (!(type.flags & 8388608)) {
                return type;
            }
            var objectType = type.objectType;
            var indexType = type.indexType;
            if (isTypeAssignableTo(indexType, getIndexType(objectType, false))) {
                if (accessNode.kind === 195 && ts.isAssignmentTarget(accessNode) &&
                    ts.getObjectFlags(objectType) & 32 && getMappedTypeModifiers(objectType) & 1) {
                    error(accessNode, ts.Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
                }
                return type;
            }
            var apparentObjectType = getApparentType(objectType);
            if (getIndexInfoOfType(apparentObjectType, 1) && isTypeAssignableToKind(indexType, 296)) {
                return type;
            }
            if (isGenericObjectType(objectType)) {
                var propertyName_1 = getPropertyNameFromIndex(indexType, accessNode);
                if (propertyName_1) {
                    var propertySymbol = forEachType(apparentObjectType, function (t) { return getPropertyOfType(t, propertyName_1); });
                    if (propertySymbol && ts.getDeclarationModifierFlagsFromSymbol(propertySymbol) & 24) {
                        error(accessNode, ts.Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, ts.unescapeLeadingUnderscores(propertyName_1));
                        return errorType;
                    }
                }
            }
            error(accessNode, ts.Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType));
            return errorType;
        }
        function checkIndexedAccessType(node) {
            checkSourceElement(node.objectType);
            checkSourceElement(node.indexType);
            checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node);
        }
        function checkMappedType(node) {
            checkSourceElement(node.typeParameter);
            checkSourceElement(node.type);
            if (!node.type) {
                reportImplicitAny(node, anyType);
            }
            var type = getTypeFromMappedTypeNode(node);
            var constraintType = getConstraintTypeFromMappedType(type);
            checkTypeAssignableTo(constraintType, keyofConstraintType, ts.getEffectiveConstraintOfTypeParameter(node.typeParameter));
        }
        function checkThisType(node) {
            getTypeFromThisTypeNode(node);
        }
        function checkTypeOperator(node) {
            checkGrammarTypeOperatorNode(node);
            checkSourceElement(node.type);
        }
        function checkConditionalType(node) {
            ts.forEachChild(node, checkSourceElement);
        }
        function checkInferType(node) {
            if (!ts.findAncestor(node, function (n) { return n.parent && n.parent.kind === 180 && n.parent.extendsType === n; })) {
                grammarErrorOnNode(node, ts.Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type);
            }
            checkSourceElement(node.typeParameter);
            registerForUnusedIdentifiersCheck(node);
        }
        function checkImportType(node) {
            checkSourceElement(node.argument);
            getTypeFromTypeNode(node);
        }
        function isPrivateWithinAmbient(node) {
            return (ts.hasModifier(node, 8) || ts.isPrivateIdentifierPropertyDeclaration(node)) && !!(node.flags & 8388608);
        }
        function getEffectiveDeclarationFlags(n, flagsToCheck) {
            var flags = ts.getCombinedModifierFlags(n);
            if (n.parent.kind !== 246 &&
                n.parent.kind !== 245 &&
                n.parent.kind !== 214 &&
                n.flags & 8388608) {
                if (!(flags & 2) && !(ts.isModuleBlock(n.parent) && ts.isModuleDeclaration(n.parent.parent) && ts.isGlobalScopeAugmentation(n.parent.parent))) {
                    flags |= 1;
                }
                flags |= 2;
            }
            return flags & flagsToCheck;
        }
        function checkFunctionOrConstructorSymbol(symbol) {
            if (!produceDiagnostics) {
                return;
            }
            function getCanonicalOverload(overloads, implementation) {
                var implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;
                return implementationSharesContainerWithFirstOverload ? implementation : overloads[0];
            }
            function checkFlagAgreementBetweenOverloads(overloads, implementation, flagsToCheck, someOverloadFlags, allOverloadFlags) {
                var someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
                if (someButNotAllOverloadFlags !== 0) {
                    var canonicalFlags_1 = getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck);
                    ts.forEach(overloads, function (o) {
                        var deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags_1;
                        if (deviation & 1) {
                            error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported);
                        }
                        else if (deviation & 2) {
                            error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);
                        }
                        else if (deviation & (8 | 16)) {
                            error(ts.getNameOfDeclaration(o) || o, ts.Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);
                        }
                        else if (deviation & 128) {
                            error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract);
                        }
                    });
                }
            }
            function checkQuestionTokenAgreementBetweenOverloads(overloads, implementation, someHaveQuestionToken, allHaveQuestionToken) {
                if (someHaveQuestionToken !== allHaveQuestionToken) {
                    var canonicalHasQuestionToken_1 = ts.hasQuestionToken(getCanonicalOverload(overloads, implementation));
                    ts.forEach(overloads, function (o) {
                        var deviation = ts.hasQuestionToken(o) !== canonicalHasQuestionToken_1;
                        if (deviation) {
                            error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_optional_or_required);
                        }
                    });
                }
            }
            var flagsToCheck = 1 | 2 | 8 | 16 | 128;
            var someNodeFlags = 0;
            var allNodeFlags = flagsToCheck;
            var someHaveQuestionToken = false;
            var allHaveQuestionToken = true;
            var hasOverloads = false;
            var bodyDeclaration;
            var lastSeenNonAmbientDeclaration;
            var previousDeclaration;
            var declarations = symbol.declarations;
            var isConstructor = (symbol.flags & 16384) !== 0;
            function reportImplementationExpectedError(node) {
                if (node.name && ts.nodeIsMissing(node.name)) {
                    return;
                }
                var seen = false;
                var subsequentNode = ts.forEachChild(node.parent, function (c) {
                    if (seen) {
                        return c;
                    }
                    else {
                        seen = c === node;
                    }
                });
                if (subsequentNode && subsequentNode.pos === node.end) {
                    if (subsequentNode.kind === node.kind) {
                        var errorNode_1 = subsequentNode.name || subsequentNode;
                        var subsequentName = subsequentNode.name;
                        if (node.name && subsequentName && (ts.isPrivateIdentifier(node.name) && ts.isPrivateIdentifier(subsequentName) && node.name.escapedText === subsequentName.escapedText ||
                            ts.isComputedPropertyName(node.name) && ts.isComputedPropertyName(subsequentName) ||
                            ts.isPropertyNameLiteral(node.name) && ts.isPropertyNameLiteral(subsequentName) &&
                                ts.getEscapedTextOfIdentifierOrLiteral(node.name) === ts.getEscapedTextOfIdentifierOrLiteral(subsequentName))) {
                            var reportError = (node.kind === 161 || node.kind === 160) &&
                                ts.hasModifier(node, 32) !== ts.hasModifier(subsequentNode, 32);
                            if (reportError) {
                                var diagnostic = ts.hasModifier(node, 32) ? ts.Diagnostics.Function_overload_must_be_static : ts.Diagnostics.Function_overload_must_not_be_static;
                                error(errorNode_1, diagnostic);
                            }
                            return;
                        }
                        if (ts.nodeIsPresent(subsequentNode.body)) {
                            error(errorNode_1, ts.Diagnostics.Function_implementation_name_must_be_0, ts.declarationNameToString(node.name));
                            return;
                        }
                    }
                }
                var errorNode = node.name || node;
                if (isConstructor) {
                    error(errorNode, ts.Diagnostics.Constructor_implementation_is_missing);
                }
                else {
                    if (ts.hasModifier(node, 128)) {
                        error(errorNode, ts.Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive);
                    }
                    else {
                        error(errorNode, ts.Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
                    }
                }
            }
            var duplicateFunctionDeclaration = false;
            var multipleConstructorImplementation = false;
            var hasNonAmbientClass = false;
            for (var _i = 0, declarations_4 = declarations; _i < declarations_4.length; _i++) {
                var current = declarations_4[_i];
                var node = current;
                var inAmbientContext = node.flags & 8388608;
                var inAmbientContextOrInterface = node.parent.kind === 246 || node.parent.kind === 173 || inAmbientContext;
                if (inAmbientContextOrInterface) {
                    previousDeclaration = undefined;
                }
                if ((node.kind === 245 || node.kind === 214) && !inAmbientContext) {
                    hasNonAmbientClass = true;
                }
                if (node.kind === 244 || node.kind === 161 || node.kind === 160 || node.kind === 162) {
                    var currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);
                    someNodeFlags |= currentNodeFlags;
                    allNodeFlags &= currentNodeFlags;
                    someHaveQuestionToken = someHaveQuestionToken || ts.hasQuestionToken(node);
                    allHaveQuestionToken = allHaveQuestionToken && ts.hasQuestionToken(node);
                    if (ts.nodeIsPresent(node.body) && bodyDeclaration) {
                        if (isConstructor) {
                            multipleConstructorImplementation = true;
                        }
                        else {
                            duplicateFunctionDeclaration = true;
                        }
                    }
                    else if (previousDeclaration && previousDeclaration.parent === node.parent && previousDeclaration.end !== node.pos) {
                        reportImplementationExpectedError(previousDeclaration);
                    }
                    if (ts.nodeIsPresent(node.body)) {
                        if (!bodyDeclaration) {
                            bodyDeclaration = node;
                        }
                    }
                    else {
                        hasOverloads = true;
                    }
                    previousDeclaration = node;
                    if (!inAmbientContextOrInterface) {
                        lastSeenNonAmbientDeclaration = node;
                    }
                }
            }
            if (multipleConstructorImplementation) {
                ts.forEach(declarations, function (declaration) {
                    error(declaration, ts.Diagnostics.Multiple_constructor_implementations_are_not_allowed);
                });
            }
            if (duplicateFunctionDeclaration) {
                ts.forEach(declarations, function (declaration) {
                    error(ts.getNameOfDeclaration(declaration), ts.Diagnostics.Duplicate_function_implementation);
                });
            }
            if (hasNonAmbientClass && !isConstructor && symbol.flags & 16) {
                ts.forEach(declarations, function (declaration) {
                    addDuplicateDeclarationError(declaration, ts.Diagnostics.Duplicate_identifier_0, ts.symbolName(symbol), declarations);
                });
            }
            if (lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body &&
                !ts.hasModifier(lastSeenNonAmbientDeclaration, 128) && !lastSeenNonAmbientDeclaration.questionToken) {
                reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
            }
            if (hasOverloads) {
                checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
                checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken);
                if (bodyDeclaration) {
                    var signatures = getSignaturesOfSymbol(symbol);
                    var bodySignature = getSignatureFromDeclaration(bodyDeclaration);
                    for (var _a = 0, signatures_10 = signatures; _a < signatures_10.length; _a++) {
                        var signature = signatures_10[_a];
                        if (!isImplementationCompatibleWithOverload(bodySignature, signature)) {
                            ts.addRelatedInfo(error(signature.declaration, ts.Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature), ts.createDiagnosticForNode(bodyDeclaration, ts.Diagnostics.The_implementation_signature_is_declared_here));
                            break;
                        }
                    }
                }
            }
        }
        function checkExportsOnMergedDeclarations(node) {
            if (!produceDiagnostics) {
                return;
            }
            var symbol = node.localSymbol;
            if (!symbol) {
                symbol = getSymbolOfNode(node);
                if (!symbol.exportSymbol) {
                    return;
                }
            }
            if (ts.getDeclarationOfKind(symbol, node.kind) !== node) {
                return;
            }
            var exportedDeclarationSpaces = 0;
            var nonExportedDeclarationSpaces = 0;
            var defaultExportedDeclarationSpaces = 0;
            for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                var d = _a[_i];
                var declarationSpaces = getDeclarationSpaces(d);
                var effectiveDeclarationFlags = getEffectiveDeclarationFlags(d, 1 | 512);
                if (effectiveDeclarationFlags & 1) {
                    if (effectiveDeclarationFlags & 512) {
                        defaultExportedDeclarationSpaces |= declarationSpaces;
                    }
                    else {
                        exportedDeclarationSpaces |= declarationSpaces;
                    }
                }
                else {
                    nonExportedDeclarationSpaces |= declarationSpaces;
                }
            }
            var nonDefaultExportedDeclarationSpaces = exportedDeclarationSpaces | nonExportedDeclarationSpaces;
            var commonDeclarationSpacesForExportsAndLocals = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
            var commonDeclarationSpacesForDefaultAndN