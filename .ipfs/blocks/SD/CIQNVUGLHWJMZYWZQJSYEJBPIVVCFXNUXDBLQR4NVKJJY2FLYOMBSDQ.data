 The rationale is that they are
  // likely to be factories.


  function isFactory(name) {
    return /^[A-Z]|^[_$]+$/.test(name);
  } // In case the Identifier is shorter than tab width, we can keep the
  // first call in a single line, if it's an ExpressionStatement.
  //
  //   d3.scaleLinear()
  //     .domain([0, 100])
  //     .range([0, width]);
  //


  function isShort(name) {
    return name.length <= options.tabWidth;
  }

  function shouldNotWrap(groups) {
    var parent = path.getParentNode();
    var isExpression = parent && parent.type === "ExpressionStatement";
    var hasComputed = groups[1].length && groups[1][0].node.computed;

    if (groups[0].length === 1) {
      var firstNode = groups[0][0].node;
      return firstNode.type === "ThisExpression" || firstNode.type === "Identifier" && (isFactory(firstNode.name) || isExpression && isShort(firstNode.name) || hasComputed);
    }

    var lastNode = getLast$2(groups[0]).node;
    return (lastNode.type === "MemberExpression" || lastNode.type === "OptionalMemberExpression") && lastNode.property.type === "Identifier" && (isFactory(lastNode.property.name) || hasComputed);
  }

  var shouldMerge = groups.length >= 2 && !groups[1][0].node.comments && shouldNotWrap(groups);

  function printGroup(printedGroup) {
    var printed = printedGroup.map(function (tuple) {
      return tuple.printed;
    }); // Checks if the last node (i.e. the parent node) needs parens and print
    // accordingly

    if (printedGroup.length > 0 && printedGroup[printedGroup.length - 1].needsParens) {
      return concat$6(["("].concat(_toConsumableArray$1(printed), [")"]));
    }

    return concat$6(printed);
  }

  function printIndentedGroup(groups) {
    if (groups.length === 0) {
      return "";
    }

    return indent$3(group$2(concat$6([hardline$4, join$4(hardline$4, groups.map(printGroup))])));
  }

  var printedGroups = groups.map(printGroup);
  var oneLine = concat$6(printedGroups);
  var cutoff = shouldMerge ? 3 : 2;
  var flatGroups = groups.slice(0, cutoff).reduce(function (res, group) {
    return res.concat(group);
  }, []);
  var hasComment = flatGroups.slice(1, -1).some(function (node) {
    return hasLeadingComment$3(node.node);
  }) || flatGroups.slice(0, -1).some(function (node) {
    return hasTrailingComment$1(node.node);
  }) || groups[cutoff] && hasLeadingComment$3(groups[cutoff][0].node); // If we only have a single `.`, we shouldn't do anything fancy and just
  // render everything concatenated together.

  if (groups.length <= cutoff && !hasComment) {
    if (isLongCurriedCallExpression$1(path)) {
      return oneLine;
    }

    return group$2(oneLine);
  } // Find out the last node in the first group and check if it has an
  // empty line after


  var lastNodeBeforeIndent = getLast$2(shouldMerge ? groups.slice(1, 2)[0] : groups[0]).node;
  var shouldHaveEmptyLineBeforeIndent = lastNodeBeforeIndent.type !== "CallExpression" && lastNodeBeforeIndent.type !== "OptionalCallExpression" && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);
  var expanded = concat$6([printGroup(groups[0]), shouldMerge ? concat$6(groups.slice(1, 2).map(printGroup)) : "", shouldHaveEmptyLineBeforeIndent ? hardline$4 : "", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))]);
  var callExpressions = printedNodes.map(function (_ref) {
    var node = _ref.node;
    return node;
  }).filter(isCallOrOptionalCallExpression$1); // We don't want to print in one line if there's:
  //  * A comment.
  //  * 3 or more chained calls.
  //  * Any group but the last one has a hard line.
  // If the last group is a function it's okay to inline if it fits.

  if (hasComment || callExpressions.length >= 3 || printedGroups.slice(0, -1).some(willBreak$1) ||
  /**
   *     scopes.filter(scope => scope.value !== '').map((scope, i) => {
   *       // multi line content
   *     })
   */
  function (lastGroupDoc, lastGroupNode) {
    return isCallOrOptionalCallExpression$1(lastGroupNode) && willBreak$1(lastGroupDoc);
  }(getLast$2(printedGroups), getLast$2(getLast$2(groups)).node) && callExpressions.slice(0, -1).some(function (n) {
    return n.arguments.some(isFunctionOrArrowExpression$1);
  })) {
    return group$2(expanded);
  }

  return concat$6([// We only need to check `oneLine` because if `expanded` is chosen
  // that means that the parent group has already been broken
  // naturally
  willBreak$1(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent$2 : "", conditionalGroup$1([oneLine, expanded])]);
}

function separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {
  if (isFacebookTranslationTag) {
    return "";
  }

  if (childNode.type === "JSXElement" && !childNode.closingElement || nextNode && nextNode.type === "JSXElement" && !nextNode.closingElement) {
    return child.length === 1 ? softline$2 : hardline$4;
  }

  return softline$2;
}

function separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {
  if (isFacebookTranslationTag) {
    return hardline$4;
  }

  if (child.length === 1) {
    return childNode.type === "JSXElement" && !childNode.closingElement || nextNode && nextNode.type === "JSXElement" && !nextNode.closingElement ? hardline$4 : softline$2;
  }

  return hardline$4;
} // JSX Children are strange, mostly for two reasons:
// 1. JSX reads newlines into string values, instead of skipping them like JS
// 2. up to one whitespace between elements within a line is significant,
//    but not between lines.
//
// Leading, trailing, and lone whitespace all need to
// turn themselves into the rather ugly `{' '}` when breaking.
//
// We print JSX using the `fill` doc primitive.
// This requires that we give it an array of alternating
// content and whitespace elements.
// To ensure this we add dummy `""` content elements as needed.


function printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag) {
  var n = path.getValue();
  var children = []; // using `map` instead of `each` because it provides `i`

  path.map(function (childPath, i) {
    var child = childPath.getValue();

    if (isLiteral$1(child)) {
      var text = rawText$1(child); // Contains a non-whitespace character

      if (isMeaningfulJSXText$1(child)) {
        var words = text.split(matchJsxWhitespaceRegex$1); // Starts with whitespace

        if (words[0] === "") {
          children.push("");
          words.shift();

          if (/\n/.test(words[0])) {
            var next = n.children[i + 1];
            children.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], child, next));
          } else {
            children.push(jsxWhitespace);
          }

          words.shift();
        }

        var endWhitespace; // Ends with whitespace

        if (getLast$2(words) === "") {
          words.pop();
          endWhitespace = words.pop();
        } // This was whitespace only without a new line.


        if (words.length === 0) {
          return;
        }

        words.forEach(function (word, i) {
          if (i % 2 === 1) {
            children.push(line$2);
          } else {
            children.push(word);
          }
        });

        if (endWhitespace !== undefined) {
          if (/\n/.test(endWhitespace)) {
            var _next = n.children[i + 1];
            children.push(separatorWithWhitespace(isFacebookTranslationTag, getLast$2(children), child, _next));
          } else {
            children.push(jsxWhitespace);
          }
        } else {
          var _next2 = n.children[i + 1];
          children.push(separatorNoWhitespace(isFacebookTranslationTag, getLast$2(children), child, _next2));
        }
      } else if (/\n/.test(text)) {
        // Keep (up to one) blank line between tags/expressions/text.
        // Note: We don't keep blank lines between text elements.
        if (text.match(/\n/g).length > 1) {
          children.push("");
          children.push(hardline$4);
        }
      } else {
        children.push("");
        children.push(jsxWhitespace);
      }
    } else {
      var printedChild = print(childPath);
      children.push(printedChild);
      var _next3 = n.children[i + 1];

      var directlyFollowedByMeaningfulText = _next3 && isMeaningfulJSXText$1(_next3);

      if (directlyFollowedByMeaningfulText) {
        var firstWord = rawText$1(_next3).trim().split(matchJsxWhitespaceRegex$1)[0];
        children.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, child, _next3));
      } else {
        children.push(hardline$4);
      }
    }
  }, "children");
  return children;
} // JSX expands children from the inside-out, instead of the outside-in.
// This is both to break children before attributes,
// and to ensure that when children break, their parents do as well.
//
// Any element that is written without any newlines and fits on a single line
// is left that way.
// Not only that, any user-written-line containing multiple JSX siblings
// should also be kept on one line if possible,
// so each user-written-line is wrapped in its own group.
//
// Elements that contain newlines or don't fit on a single line (recursively)
// are fully-split, using hardline and shouldBreak: true.
//
// To support that case properly, all leading and trailing spaces
// are stripped from the list of children, and replaced with a single hardline.


function printJSXElement(path, options, print) {
  var n = path.getValue();

  if (n.type === "JSXElement" && isEmptyJSXElement$1(n)) {
    return concat$6([path.call(print, "openingElement"), path.call(print, "closingElement")]);
  }

  var openingLines = n.type === "JSXElement" ? path.call(print, "openingElement") : path.call(print, "openingFragment");
  var closingLines = n.type === "JSXElement" ? path.call(print, "closingElement") : path.call(print, "closingFragment");

  if (n.children.length === 1 && n.children[0].type === "JSXExpressionContainer" && (n.children[0].expression.type === "TemplateLiteral" || n.children[0].expression.type === "TaggedTemplateExpression")) {
    return concat$6([openingLines, concat$6(path.map(print, "children")), closingLines]);
  } // Convert `{" "}` to text nodes containing a space.
  // This makes it easy to turn them into `jsxWhitespace` which
  // can then print as either a space or `{" "}` when breaking.


  n.children = n.children.map(function (child) {
    if (isJSXWhitespaceExpression$1(child)) {
      return {
        type: "JSXText",
        value: " ",
        raw: " "
      };
    }

    return child;
  });
  var containsTag = n.children.filter(isJSXNode$1).length > 0;
  var containsMultipleExpressions = n.children.filter(function (child) {
    return child.type === "JSXExpressionContainer";
  }).length > 1;
  var containsMultipleAttributes = n.type === "JSXElement" && n.openingElement.attributes.length > 1; // Record any breaks. Should never go from true to false, only false to true.

  var forcedBreak = willBreak$1(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;
  var rawJsxWhitespace = options.singleQuote ? "{' '}" : '{" "}';
  var jsxWhitespace = ifBreak$1(concat$6([rawJsxWhitespace, softline$2]), " ");
  var isFacebookTranslationTag = n.openingElement && n.openingElement.name && n.openingElement.name.name === "fbt";
  var children = printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag);
  var containsText = n.children.filter(function (child) {
    return isMeaningfulJSXText$1(child);
  }).length > 0; // We can end up we multiple whitespace elements with empty string
  // content between them.
  // We need to remove empty whitespace and softlines before JSX whitespace
  // to get the correct output.

  for (var i = children.length - 2; i >= 0; i--) {
    var isPairOfEmptyStrings = children[i] === "" && children[i + 1] === "";
    var isPairOfHardlines = children[i] === hardline$4 && children[i + 1] === "" && children[i + 2] === hardline$4;
    var isLineFollowedByJSXWhitespace = (children[i] === softline$2 || children[i] === hardline$4) && children[i + 1] === "" && children[i + 2] === jsxWhitespace;
    var isJSXWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === "" && (children[i + 2] === softline$2 || children[i + 2] === hardline$4);
    var isDoubleJSXWhitespace = children[i] === jsxWhitespace && children[i + 1] === "" && children[i + 2] === jsxWhitespace;
    var isPairOfHardOrSoftLines = children[i] === softline$2 && children[i + 1] === "" && children[i + 2] === hardline$4 || children[i] === hardline$4 && children[i + 1] === "" && children[i + 2] === softline$2;

    if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJSXWhitespace || isDoubleJSXWhitespace || isPairOfHardOrSoftLines) {
      children.splice(i, 2);
    } else if (isJSXWhitespaceFollowedByLine) {
      children.splice(i + 1, 2);
    }
  } // Trim trailing lines (or empty strings)


  while (children.length && (isLineNext$1(getLast$2(children)) || isEmpty$1(getLast$2(children)))) {
    children.pop();
  } // Trim leading lines (or empty strings)


  while (children.length && (isLineNext$1(children[0]) || isEmpty$1(children[0])) && (isLineNext$1(children[1]) || isEmpty$1(children[1]))) {
    children.shift();
    children.shift();
  } // Tweak how we format children if outputting this element over multiple lines.
  // Also detect whether we will force this element to output over multiple lines.


  var multilineChildren = [];
  children.forEach(function (child, i) {
    // There are a number of situations where we need to ensure we display
    // whitespace as `{" "}` when outputting this element over multiple lines.
    if (child === jsxWhitespace) {
      if (i === 1 && children[i - 1] === "") {
        if (children.length === 2) {
          // Solitary whitespace
          multilineChildren.push(rawJsxWhitespace);
          return;
        } // Leading whitespace


        multilineChildren.push(concat$6([rawJsxWhitespace, hardline$4]));
        return;
      } else if (i === children.length - 1) {
        // Trailing whitespace
        multilineChildren.push(rawJsxWhitespace);
        return;
      } else if (children[i - 1] === "" && children[i - 2] === hardline$4) {
        // Whitespace after line break
        multilineChildren.push(rawJsxWhitespace);
        return;
      }
    }

    multilineChildren.push(child);

    if (willBreak$1(child)) {
      forcedBreak = true;
    }
  }); // If there is text we use `fill` to fit as much onto each line as possible.
  // When there is no text (just tags and expressions) we use `group`
  // to output each on a separate line.

  var content = containsText ? fill$2(multilineChildren) : group$2(concat$6(multilineChildren), {
    shouldBreak: true
  });
  var multiLineElem = group$2(concat$6([openingLines, indent$3(concat$6([hardline$4, content])), hardline$4, closingLines]));

  if (forcedBreak) {
    return multiLineElem;
  }

  return conditionalGroup$1([group$2(concat$6([openingLines, concat$6(children), closingLines])), multiLineElem]);
}

function maybeWrapJSXElementInParens(path, elem, options) {
  var parent = path.getParentNode();

  if (!parent) {
    return elem;
  }

  var NO_WRAP_PARENTS = {
    ArrayExpression: true,
    JSXAttribute: true,
    JSXElement: true,
    JSXExpressionContainer: true,
    JSXFragment: true,
    ExpressionStatement: true,
    CallExpression: true,
    OptionalCallExpression: true,
    ConditionalExpression: true,
    JsExpressionRoot: true
  };

  if (NO_WRAP_PARENTS[parent.type]) {
    return elem;
  }

  var shouldBreak = matchAncestorTypes$1(path, ["ArrowFunctionExpression", "CallExpression", "JSXExpressionContainer"]) || matchAncestorTypes$1(path, ["ArrowFunctionExpression", "OptionalCallExpression", "JSXExpressionContainer"]);
  var needsParens = needsParens_1(path, options);
  return group$2(concat$6([needsParens ? "" : ifBreak$1("("), indent$3(concat$6([softline$2, elem])), softline$2, needsParens ? "" : ifBreak$1(")")]), {
    shouldBreak
  });
}

function shouldInlineLogicalExpression(node) {
  if (node.type !== "LogicalExpression") {
    return false;
  }

  if (node.right.type === "ObjectExpression" && node.right.properties.length !== 0) {
    return true;
  }

  if (node.right.type === "ArrayExpression" && node.right.elements.length !== 0) {
    return true;
  }

  if (isJSXNode$1(node.right)) {
    return true;
  }

  return false;
} // For binary expressions to be consistent, we need to group
// subsequent operators with the same precedence level under a single
// group. Otherwise they will be nested such that some of them break
// onto new lines but not all. Operators with the same precedence
// level should either all break or not. Because we group them by
// precedence level and the AST is structured based on precedence
// level, things are naturally broken up correctly, i.e. `&&` is
// broken before `+`.


function printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {
  var parts = [];
  var node = path.getValue(); // We treat BinaryExpression and LogicalExpression nodes the same.

  if (isBinaryish$1(node)) {
    // Put all operators with the same precedence level in the same
    // group. The reason we only need to do this with the `left`
    // expression is because given an expression like `1 + 2 - 3`, it
    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side
    // is where the rest of the expression will exist. Binary
    // expressions on the right side mean they have a difference
    // precedence level and should be treated as a separate group, so
    // print them normally. (This doesn't hold for the `**` operator,
    // which is unique in that it is right-associative.)
    if (shouldFlatten$1(node.operator, node.left.operator)) {
      // Flatten them out by recursively calling this function.
      parts = parts.concat(path.call(function (left) {
        return printBinaryishExpressions(left, print, options,
        /* isNested */
        true, isInsideParenthesis);
      }, "left"));
    } else {
      parts.push(path.call(print, "left"));
    }

    var shouldInline = shouldInlineLogicalExpression(node);
    var lineBeforeOperator = (node.operator === "|>" || node.type === "NGPipeExpression" || node.operator === "|" && options.parser === "__vue_expression") && !hasLeadingOwnLineComment$1(options.originalText, node.right, options);
    var operator = node.type === "NGPipeExpression" ? "|" : node.operator;
    var rightSuffix = node.type === "NGPipeExpression" && node.arguments.length !== 0 ? group$2(indent$3(concat$6([softline$2, ": ", join$4(concat$6([softline$2, ":", ifBreak$1(" ")]), path.map(print, "arguments").map(function (arg) {
      return align$1(2, group$2(arg));
    }))]))) : "";
    var right = shouldInline ? concat$6([operator, " ", path.call(print, "right"), rightSuffix]) : concat$6([lineBeforeOperator ? softline$2 : "", operator, lineBeforeOperator ? " " : line$2, path.call(print, "right"), rightSuffix]); // If there's only a single binary expression, we want to create a group
    // in order to avoid having a small right part like -1 be on its own line.

    var parent = path.getParentNode();
    var shouldGroup = !(isInsideParenthesis && node.type === "LogicalExpression") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;
    parts.push(" ", shouldGroup ? group$2(right) : right); // The root comments are already printed, but we need to manually print
    // the other ones since we don't call the normal print on BinaryExpression,
    // only for the left and right parts

    if (isNested && node.comments) {
      parts = comments.printComments(path, function () {
        return concat$6(parts);
      }, options);
    }
  } else {
    // Our stopping case. Simply print the node normally.
    parts.push(path.call(print));
  }

  return parts;
}

function printAssignmentRight(leftNode, rightNode, printedRight, options) {
  if (hasLeadingOwnLineComment$1(options.originalText, rightNode, options)) {
    return indent$3(concat$6([hardline$4, printedRight]));
  }

  var canBreak = isBinaryish$1(rightNode) && !shouldInlineLogicalExpression(rightNode) || rightNode.type === "ConditionalExpression" && isBinaryish$1(rightNode.test) && !shouldInlineLogicalExpression(rightNode.test) || rightNode.type === "StringLiteralTypeAnnotation" || rightNode.type === "ClassExpression" && rightNode.decorators && rightNode.decorators.length || (leftNode.type === "Identifier" || isStringLiteral$1(leftNode) || leftNode.type === "MemberExpression") && (isStringLiteral$1(rightNode) || isMemberExpressionChain$1(rightNode)) && // do not put values on a separate line from the key in json
  options.parser !== "json" && options.parser !== "json5" || rightNode.type === "SequenceExpression";

  if (canBreak) {
    return group$2(indent$3(concat$6([line$2, printedRight])));
  }

  return concat$6([" ", printedRight]);
}

function printAssignment(leftNode, printedLeft, operator, rightNode, printedRight, options) {
  if (!rightNode) {
    return printedLeft;
  }

  var printed = printAssignmentRight(leftNode, rightNode, printedRight, options);
  return group$2(concat$6([printedLeft, operator, printed]));
}

function adjustClause(node, clause, forceSpace) {
  if (node.type === "EmptyStatement") {
    return ";";
  }

  if (node.type === "BlockStatement" || forceSpace) {
    return concat$6([" ", clause]);
  }

  return indent$3(concat$6([line$2, clause]));
}

function nodeStr(node, options, isFlowOrTypeScriptDirectiveLiteral) {
  var raw = rawText$1(node);
  var isDirectiveLiteral = isFlowOrTypeScriptDirectiveLiteral || node.type === "DirectiveLiteral";
  return printString$1(raw, options, isDirectiveLiteral);
}

function printRegex(node) {
  var flags = node.flags.split("").sort().join("");
  return `/${node.pattern}/${flags}`;
}

function exprNeedsASIProtection(path, options) {
  var node = path.getValue();
  var maybeASIProblem = needsParens_1(path, options) || node.type === "ParenthesizedExpression" || node.type === "TypeCastExpression" || node.type === "ArrowFunctionExpression" && !shouldPrintParamsWithoutParens(path, options) || node.type === "ArrayExpression" || node.type === "ArrayPattern" || node.type === "UnaryExpression" && node.prefix && (node.operator === "+" || node.operator === "-") || node.type === "TemplateLiteral" || node.type === "TemplateElement" || isJSXNode$1(node) || node.type === "BindExpression" && !node.object || node.type === "RegExpLiteral" || node.type === "Literal" && node.pattern || node.type === "Literal" && node.regex;

  if (maybeASIProblem) {
    return true;
  }

  if (!hasNakedLeftSide$2(node)) {
    return false;
  }

  return path.call.apply(path, [function (childPath) {
    return exprNeedsASIProtection(childPath, options);
  }].concat(getLeftSidePathName$2(path, node)));
}

function stmtNeedsASIProtection(path, options) {
  var node = path.getNode();

  if (node.type !== "ExpressionStatement") {
    return false;
  }

  return path.call(function (childPath) {
    return exprNeedsASIProtection(childPath, options);
  }, "expression");
}

function shouldHugType(node) {
  if (isSimpleFlowType$1(node) || isObjectType$1(node)) {
    return true;
  }

  if (node.type === "UnionTypeAnnotation" || node.type === "TSUnionType") {
    var voidCount = node.types.filter(function (n) {
      return n.type === "VoidTypeAnnotation" || n.type === "TSVoidKeyword" || n.type === "NullLiteralTypeAnnotation" || n.type === "TSNullKeyword";
    }).length;
    var objectCount = node.types.filter(function (n) {
      return n.type === "ObjectTypeAnnotation" || n.type === "TSTypeLiteral" || // This is a bit aggressive but captures Array<{x}>
      n.type === "GenericTypeAnnotation" || n.type === "TSTypeReference";
    }).length;

    if (node.types.length - 1 === voidCount && objectCount > 0) {
      return true;
    }
  }

  return false;
}

function shouldHugArguments(fun) {
  return fun && fun.params && fun.params.length === 1 && !fun.params[0].comments && (fun.params[0].type === "ObjectPattern" || fun.params[0].type === "ArrayPattern" || fun.params[0].type === "Identifier" && fun.params[0].typeAnnotation && (fun.params[0].typeAnnotation.type === "TypeAnnotation" || fun.params[0].typeAnnotation.type === "TSTypeAnnotation") && isObjectType$1(fun.params[0].typeAnnotation.typeAnnotation) || fun.params[0].type === "FunctionTypeParam" && isObjectType$1(fun.params[0].typeAnnotation) || fun.params[0].type === "AssignmentPattern" && (fun.params[0].left.type === "ObjectPattern" || fun.params[0].left.type === "ArrayPattern") && (fun.params[0].right.type === "Identifier" || fun.params[0].right.type === "ObjectExpression" && fun.params[0].right.properties.length === 0 || fun.params[0].right.type === "ArrayExpression" && fun.params[0].right.elements.length === 0)) && !fun.rest;
}

function printArrayItems(path, options, printPath, print) {
  var printedElements = [];
  var separatorParts = [];
  path.each(function (childPath) {
    printedElements.push(concat$6(separatorParts));
    printedElements.push(group$2(print(childPath)));
    separatorParts = [",", line$2];

    if (childPath.getValue() && isNextLineEmpty$2(options.originalText, childPath.getValue(), options)) {
      separatorParts.push(softline$2);
    }
  }, printPath);
  return concat$6(printedElements);
}

function willPrintOwnComments(path
/*, options */
) {
  var node = path.getValue();
  var parent = path.getParentNode();
  return (node && (isJSXNode$1(node) || hasFlowShorthandAnnotationComment$2(node) || parent && (parent.type === "CallExpression" || parent.type === "OptionalCallExpression") && (hasFlowAnnotationComment$1(node.leadingComments) || hasFlowAnnotationComment$1(node.trailingComments))) || parent && (parent.type === "JSXSpreadAttribute" || parent.type === "JSXSpreadChild" || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType" || (parent.type === "ClassDeclaration" || parent.type === "ClassExpression") && parent.superClass === node)) && !hasIgnoreComment$2(path);
}

function canAttachComment(node) {
  return node.type && node.type !== "CommentBlock" && node.type !== "CommentLine" && node.type !== "Line" && node.type !== "Block" && node.type !== "EmptyStatement" && node.type !== "TemplateElement" && node.type !== "Import";
}

function printComment$1(commentPath, options) {
  var comment = commentPath.getValue();

  switch (comment.type) {
    case "CommentBlock":
    case "Block":
      {
        if (isIndentableBlockComment(comment)) {
          var printed = printIndentableBlockComment(comment); // We need to prevent an edge case of a previous trailing comment
          // printed as a `lineSuffix` which causes the comments to be
          // interleaved. See https://github.com/prettier/prettier/issues/4412

          if (comment.trailing && !hasNewline$3(options.originalText, options.locStart(comment), {
            backwards: true
          })) {
            return concat$6([hardline$4, printed]);
          }

          return printed;
        }

        var isInsideFlowComment = options.originalText.substr(options.locEnd(comment) - 3, 3) === "*-/";
        return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
      }

    case "CommentLine":
    case "Line":
      // Print shebangs with the proper comment characters
      if (options.originalText.slice(options.locStart(comment)).startsWith("#!")) {
        return "#!" + comment.value.trimRight();
      }

      return "//" + comment.value.trimRight();

    default:
      throw new Error("Not a comment: " + JSON.stringify(comment));
  }
}

function isIndentableBlockComment(comment) {
  // If the comment has multiple lines and every line starts with a star
  // we can fix the indentation of each line. The stars in the `/*` and
  // `*/` delimiters are not included in the comment value, so add them
  // back first.
  var lines = `*${comment.value}*`.split("\n");
  return lines.length > 1 && lines.every(function (line) {
    return line.trim()[0] === "*";
  });
}

function printIndentableBlockComment(comment) {
  var lines = comment.value.split("\n");
  return concat$6(["/*", join$4(hardline$4, lines.map(function (line, index) {
    return index === 0 ? line.trimRight() : " " + (index < lines.length - 1 ? line.trim() : line.trimLeft());
  })), "*/"]);
}

var printerEstree = {
  preprocess: preprocess_1,
  print: genericPrint,
  embed: embed_1,
  insertPragma: insertPragma$1,
  massageAstNode: clean_1,
  hasPrettierIgnore: hasPrettierIgnore$1,
  willPrintOwnComments,
  canAttachComment,
  printComment: printComment$1,
  isBlockComment: comments$1.isBlockComment,
  handleComments: {
    ownLine: comments$1.handleOwnLineComment,
    endOfLine: comments$1.handleEndOfLineComment,
    remaining: comments$1.handleRemainingComment
  }
};

var _require$$0$builders$2 = doc.builders,
    concat$7 = _require$$0$builders$2.concat,
    hardline$5 = _require$$0$builders$2.hardline,
    indent$4 = _require$$0$builders$2.indent,
    join$5 = _require$$0$builders$2.join;

function genericPrint$1(path, options, print) {
  var node = path.getValue();

  switch (node.type) {
    case "JsonRoot":
      return concat$7([path.call(print, "node"), hardline$5]);

    case "ArrayExpression":
      return node.elements.length === 0 ? "[]" : concat$7(["[", indent$4(concat$7([hardline$5, join$5(concat$7([",", hardline$5]), path.map(print, "elements"))])), hardline$5, "]"]);

    case "ObjectExpression":
      return node.properties.length === 0 ? "{}" : concat$7(["{", indent$4(concat$7([hardline$5, join$5(concat$7([",", hardline$5]), path.map(print, "properties"))])), hardline$5, "}"]);

    case "ObjectProperty":
      return concat$7([path.call(print, "key"), ": ", path.call(print, "value")]);

    case "UnaryExpression":
      return concat$7([node.operator === "+" ? "" : node.operator, path.call(print, "argument")]);

    case "NullLiteral":
      return "null";

    case "BooleanLiteral":
      return node.value ? "true" : "false";

    case "StringLiteral":
    case "NumericLiteral":
      return JSON.stringify(node.value);

    case "Identifier":
      return JSON.stringify(node.name);

    default:
      /* istanbul ignore next */
      throw new Error("unknown type: " + JSON.stringify(node.type));
  }
}

function clean$1(node, newNode
/*, parent*/
) {
  delete newNode.start;
  delete newNode.end;
  delete newNode.extra;
  delete newNode.loc;
  delete newNode.comments;
  delete newNode.errors;

  if (node.type === "Identifier") {
    return {
      type: "StringLiteral",
      value: node.name
    };
  }

  if (node.type === "UnaryExpression" && node.operator === "+") {
    return newNode.argument;
  }
}

var printerEstreeJson = {
  preprocess: preprocess_1,
  print: genericPrint$1,
  massageAstNode: clean$1
};

var CATEGORY_COMMON = "Common"; // format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js

var commonOptions = {
  bracketSpacing: {
    since: "0.0.0",
    category: CATEGORY_COMMON,
    type: "boolean",
    default: true,
    description: "Print spaces between brackets.",
    oppositeDescription: "Do not print spaces between brackets."
  },
  singleQuote: {
    since: "0.0.0",
    category: CATEGORY_COMMON,
    type: "boolean",
    default: false,
    description: "Use single quotes instead of double quotes."
  },
  proseWrap: {
    since: "1.8.2",
    category: CATEGORY_COMMON,
    type: "choice",
    default: [{
      since: "1.8.2",
      value: true
    }, {
      since: "1.9.0",
      value: "preserve"
    }],
    description: "How to wrap prose.",
    choices: [{
      since: "1.9.0",
      value: "always",
      description: "Wrap prose if it exceeds the print width."
    }, {
      since: "1.9.0",
      value: "never",
      description: "Do not wrap prose."
    }, {
      since: "1.9.0",
      value: "preserve",
      description: "Wrap prose as-is."
    }, {
      value: false,
      deprecated: "1.9.0",
      redirect: "never"
    }, {
      value: true,
      deprecated: "1.9.0",
      redirect: "always"
    }]
  }
};

var CATEGORY_JAVASCRIPT = "JavaScript"; // format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js

var options$2 = {
  arrowParens: {
    since: "1.9.0",
    category: CATEGORY_JAVASCRIPT,
    type: "choice",
    default: "avoid",
    description: "Include parentheses around a sole arrow function parameter.",
    choices: [{
      value: "avoid",
      description: "Omit parens when possible. Example: `x => x`"
    }, {
      value: "always",
      description: "Always include parens. Example: `(x) => x`"
    }]
  },
  bracketSpacing: commonOptions.bracketSpacing,
  jsxBracketSameLine: {
    since: "0.17.0",
    category: CATEGORY_JAVASCRIPT,
    type: "boolean",
    default: false,
    description: "Put > on the last line instead of at a new line."
  },
  semi: {
    since: "1.0.0",
    category: CATEGORY_JAVASCRIPT,
    type: "boolean",
    default: true,
    description: "Print semicolons.",
    oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
  },
  singleQuote: commonOptions.singleQuote,
  jsxSingleQuote: {
    since: "1.15.0",
    category: CATEGORY_JAVASCRIPT,
    type: "boolean",
    default: false,
    description: "Use single quotes in JSX."
  },
  quoteProps: {
    since: "1.17.0",
    category: CATEGORY_JAVASCRIPT,
    type: "choice",
    default: "as-needed",
    description: "Change when properties in objects are quoted.",
    choices: [{
      value: "as-needed",
      description: "Only add quotes around object properties where required."
    }, {
      value: "consistent",
      description: "If at least one property in an object requires quotes, quote all properties."
    }, {
      value: "preserve",
      description: "Respect the input use of quotes in object properties."
    }]
  },
  trailingComma: {
    since: "0.0.0",
    category: CATEGORY_JAVASCRIPT,
    type: "choice",
    default: [{
      since: "0.0.0",
      value: false
    }, {
      since: "0.19.0",
      value: "none"
    }],
    description: "Print trailing commas wherever possible when multi-line.",
    choices: [{
      value: "none",
      description: "No trailing commas."
    }, {
      value: "es5",
      description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
    }, {
      value: "all",
      description: "Trailing commas wherever possible (including function arguments)."
    }, {
      value: true,
      deprecated: "0.19.0",
      redirect: "es5"
    }, {
      value: false,
      deprecated: "0.19.0",
      redirect: "none"
    }]
  }
};

var createLanguage = function createLanguage(linguistData, transform) {
  var language = {};

  for (var key in linguistData) {
    var newKey = key === "languageId" ? "linguistLanguageId" : key;
    language[newKey] = linguistData[key];
  }

  return transform(language);
};

var name$2 = "JavaScript";
var type = "programming";
var tmScope = "source.js";
var aceMode = "javascript";
var codemirrorMode = "javascript";
var codemirrorMimeType = "text/javascript";
var color = "#f1e05a";
var aliases = [
	"js",
	"node"
];
var extensions = [
	".js",
	"._js",
	".bones",
	".es",
	".es6",
	".frag",
	".gs",
	".jake",
	".jsb",
	".jscad",
	".jsfl",
	".jsm",
	".jss",
	".mjs",
	".njs",
	".pac",
	".sjs",
	".ssjs",
	".xsjs",
	".xsjslib"
];
var filenames = [
	"Jakefile"
];
var interpreters = [
	"chakra",
	"d8",
	"js",
	"node",
	"rhino",
	"v8",
	"v8-shell"
];
var languageId = 183;
var JavaScript = {
	name: name$2,
	type: type,
	tmScope: tmScope,
	aceMode: aceMode,
	codemirrorMode: codemirrorMode,
	codemirrorMimeType: codemirrorMimeType,
	color: color,
	aliases: aliases,
	extensions: extensions,
	filenames: filenames,
	interpreters: interpreters,
	languageId: languageId
};

var JavaScript$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$2,
  type: type,
  tmScope: tmScope,
  aceMode: aceMode,
  codemirrorMode: codemirrorMode,
  codemirrorMimeType: codemirrorMimeType,
  color: color,
  aliases: aliases,
  extensions: extensions,
  filenames: filenames,
  interpreters: interpreters,
  languageId: languageId,
  'default': JavaScript
});

var name$3 = "JSX";
var type$1 = "programming";
var group$3 = "JavaScript";
var extensions$1 = [
	".jsx"
];
var tmScope$1 = "source.js.jsx";
var aceMode$1 = "javascript";
var codemirrorMode$1 = "jsx";
var codemirrorMimeType$1 = "text/jsx";
var languageId$1 = 178;
var JSX = {
	name: name$3,
	type: type$1,
	group: group$3,
	extensions: extensions$1,
	tmScope: tmScope$1,
	aceMode: aceMode$1,
	codemirrorMode: codemirrorMode$1,
	codemirrorMimeType: codemirrorMimeType$1,
	languageId: languageId$1
};

var JSX$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$3,
  type: type$1,
  group: group$3,
  extensions: extensions$1,
  tmScope: tmScope$1,
  aceMode: aceMode$1,
  codemirrorMode: codemirrorMode$1,
  codemirrorMimeType: codemirrorMimeType$1,
  languageId: languageId$1,
  'default': JSX
});

var name$4 = "TypeScript";
var type$2 = "programming";
var color$1 = "#2b7489";
var aliases$1 = [
	"ts"
];
var interpreters$1 = [
	"deno",
	"ts-node"
];
var extensions$2 = [
	".ts"
];
var tmScope$2 = "source.ts";
var aceMode$2 = "typescript";
var codemirrorMode$2 = "javascript";
var codemirrorMimeType$2 = "application/typescript";
var languageId$2 = 378;
var TypeScript = {
	name: name$4,
	type: type$2,
	color: color$1,
	aliases: aliases$1,
	interpreters: interpreters$1,
	extensions: extensions$2,
	tmScope: tmScope$2,
	aceMode: aceMode$2,
	codemirrorMode: codemirrorMode$2,
	codemirrorMimeType: codemirrorMimeType$2,
	languageId: languageId$2
};

var TypeScript$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$4,
  type: type$2,
  color: color$1,
  aliases: aliases$1,
  interpreters: interpreters$1,
  extensions: extensions$2,
  tmScope: tmScope$2,
  aceMode: aceMode$2,
  codemirrorMode: codemirrorMode$2,
  codemirrorMimeType: codemirrorMimeType$2,
  languageId: languageId$2,
  'default': TypeScript
});

var name$5 = "TSX";
var type$3 = "programming";
var group$4 = "TypeScript";
var extensions$3 = [
	".tsx"
];
var tmScope$3 = "source.tsx";
var aceMode$3 = "javascript";
var codemirrorMode$3 = "jsx";
var codemirrorMimeType$3 = "text/jsx";
var languageId$3 = 94901924;
var TSX = {
	name: name$5,
	type: type$3,
	group: group$4,
	extensions: extensions$3,
	tmScope: tmScope$3,
	aceMode: aceMode$3,
	codemirrorMode: codemirrorMode$3,
	codemirrorMimeType: codemirrorMimeType$3,
	languageId: languageId$3
};

var TSX$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$5,
  type: type$3,
  group: group$4,
  extensions: extensions$3,
  tmScope: tmScope$3,
  aceMode: aceMode$3,
  codemirrorMode: codemirrorMode$3,
  codemirrorMimeType: codemirrorMimeType$3,
  languageId: languageId$3,
  'default': TSX
});

var name$6 = "JSON";
var type$4 = "data";
var tmScope$4 = "source.json";
var aceMode$4 = "json";
var codemirrorMode$4 = "javascript";
var codemirrorMimeType$4 = "application/json";
var searchable = false;
var extensions$4 = [
	".json",
	".avsc",
	".geojson",
	".gltf",
	".har",
	".ice",
	".JSON-tmLanguage",
	".jsonl",
	".mcmeta",
	".tfstate",
	".tfstate.backup",
	".topojson",
	".webapp",
	".webmanifest",
	".yy",
	".yyp"
];
var filenames$1 = [
	".arcconfig",
	".htmlhintrc",
	".tern-config",
	".tern-project",
	".watchmanconfig",
	"composer.lock",
	"mcmod.info"
];
var languageId$4 = 174;
var _JSON = {
	name: name$6,
	type: type$4,
	tmScope: tmScope$4,
	aceMode: aceMode$4,
	codemirrorMode: codemirrorMode$4,
	codemirrorMimeType: codemirrorMimeType$4,
	searchable: searchable,
	extensions: extensions$4,
	filenames: filenames$1,
	languageId: languageId$4
};

var _JSON$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$6,
  type: type$4,
  tmScope: tmScope$4,
  aceMode: aceMode$4,
  codemirrorMode: codemirrorMode$4,
  codemirrorMimeType: codemirrorMimeType$4,
  searchable: searchable,
  extensions: extensions$4,
  filenames: filenames$1,
  languageId: languageId$4,
  'default': _JSON
});

var name$7 = "JSON with Comments";
var type$5 = "data";
var group$5 = "JSON";
var tmScope$5 = "source.js";
var aceMode$5 = "javascript";
var codemirrorMode$5 = "javascript";
var codemirrorMimeType$5 = "text/javascript";
var aliases$2 = [
	"jsonc"
];
var extensions$5 = [
	".sublime-build",
	".sublime-commands",
	".sublime-completions",
	".sublime-keymap",
	".sublime-macro",
	".sublime-menu",
	".sublime-mousemap",
	".sublime-project",
	".sublime-settings",
	".sublime-theme",
	".sublime-workspace",
	".sublime_metrics",
	".sublime_session"
];
var filenames$2 = [
	".babelrc",
	".eslintrc.json",
	".jscsrc",
	".jshintrc",
	".jslintrc",
	"jsconfig.json",
	"language-configuration.json",
	"tsconfig.json"
];
var languageId$5 = 423;
var JSON_with_Comments = {
	name: name$7,
	type: type$5,
	group: group$5,
	tmScope: tmScope$5,
	aceMode: aceMode$5,
	codemirrorMode: codemirrorMode$5,
	codemirrorMimeType: codemirrorMimeType$5,
	aliases: aliases$2,
	extensions: extensions$5,
	filenames: filenames$2,
	languageId: languageId$5
};

var JSON_with_Comments$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$7,
  type: type$5,
  group: group$5,
  tmScope: tmScope$5,
  aceMode: aceMode$5,
  codemirrorMode: codemirrorMode$5,
  codemirrorMimeType: codemirrorMimeType$5,
  aliases: aliases$2,
  extensions: extensions$5,
  filenames: filenames$2,
  languageId: languageId$5,
  'default': JSON_with_Comments
});

var name$8 = "JSON5";
var type$6 = "data";
var extensions$6 = [
	".json5"
];
var tmScope$6 = "source.js";
var aceMode$6 = "javascript";
var codemirrorMode$6 = "javascript";
var codemirrorMimeType$6 = "application/json";
var languageId$6 = 175;
var JSON5 = {
	name: name$8,
	type: type$6,
	extensions: extensions$6,
	tmScope: tmScope$6,
	aceMode: aceMode$6,
	codemirrorMode: codemirrorMode$6,
	codemirrorMimeType: codemirrorMimeType$6,
	languageId: languageId$6
};

var JSON5$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$8,
  type: type$6,
  extensions: extensions$6,
  tmScope: tmScope$6,
  aceMode: aceMode$6,
  codemirrorMode: codemirrorMode$6,
  codemirrorMimeType: codemirrorMimeType$6,
  languageId: languageId$6,
  'default': JSON5
});

var require$$0$1 = getCjsExportFromNamespace(JavaScript$1);

var require$$1 = getCjsExportFromNamespace(JSX$1);

var require$$2 = getCjsExportFromNamespace(TypeScript$1);

var require$$3 = getCjsExportFromNamespace(TSX$1);

var require$$4$1 = getCjsExportFromNamespace(_JSON$1);

var require$$5 = getCjsExportFromNamespace(JSON_with_Comments$1);

var require$$6 = getCjsExportFromNamespace(JSON5$1);

var languages = [createLanguage(require$$0$1, function (data) {
  return Object.assign(data, {
    since: "0.0.0",
    parsers: ["babel", "flow"],
    vscodeLanguageIds: ["javascript", "mongo"],
    interpreters: data.interpreters.concat(["nodejs"])
  });
}), createLanguage(require$$0$1, function (data) {
  return Object.assign(data, {
    name: "Flow",
    since: "0.0.0",
    parsers: ["babel", "flow"],
    vscodeLanguageIds: ["javascript"],
    aliases: [],
    filenames: [],
    extensions: [".js.flow"]
  });
}), createLanguage(require$$1, function (data) {
  return Object.assign(data, {
    since: "0.0.0",
    parsers: ["babel", "flow"],
    vscodeLanguageIds: ["javascriptreact"]
  });
}), createLanguage(require$$2, function (data) {
  return Object.assign(data, {
    since: "1.4.0",
    parsers: ["typescript"],
    vscodeLanguageIds: ["typescript"]
  });
}), createLanguage(require$$3, function (data) {
  return Object.assign(data, {
    since: "1.4.0",
    parsers: ["typescript"],
    vscodeLanguageIds: ["typescriptreact"]
  });
}), createLanguage(require$$4$1, function (data) {
  return Object.assign(data, {
    name: "JSON.stringify",
    since: "1.13.0",
    parsers: ["json-stringify"],
    vscodeLanguageIds: ["json"],
    extensions: [],
    // .json file defaults to json instead of json-stringify
    filenames: ["package.json", "package-lock.json", "composer.json"]
  });
}), createLanguage(require$$4$1, function (data) {
  return Object.assign(data, {
    since: "1.5.0",
    parsers: ["json"],
    vscodeLanguageIds: ["json"],
    filenames: data.filenames.concat([".prettierrc"])
  });
}), createLanguage(require$$5, function (data) {
  return Object.assign(data, {
    since: "1.5.0",
    parsers: ["json"],
    vscodeLanguageIds: ["jsonc"],
    filenames: data.filenames.concat([".eslintrc"])
  });
}), createLanguage(require$$6, function (data) {
  return Object.assign(data, {
    since: "1.13.0",
    parsers: ["json5"],
    vscodeLanguageIds: ["json5"]
  });
})];
var printers = {
  estree: printerEstree,
  "estree-json": printerEstreeJson
};
var languageJs = {
  languages,
  options: options$2,
  printers
};

var index = [
	"a",
	"abbr",
	"acronym",
	"address",
	"applet",
	"area",
	"article",
	"aside",
	"audio",
	"b",
	"base",
	"basefont",
	"bdi",
	"bdo",
	"bgsound",
	"big",
	"blink",
	"blockquote",
	"body",
	"br",
	"button",
	"canvas",
	"caption",
	"center",
	"cite",
	"code",
	"col",
	"colgroup",
	"command",
	"content",
	"data",
	"datalist",
	"dd",
	"del",
	"details",
	"dfn",
	"dialog",
	"dir",
	"div",
	"dl",
	"dt",
	"element",
	"em",
	"embed",
	"fieldset",
	"figcaption",
	"figure",
	"font",
	"footer",
	"form",
	"frame",
	"frameset",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"head",
	"header",
	"hgroup",
	"hr",
	"html",
	"i",
	"iframe",
	"image",
	"img",
	"input",
	"ins",
	"isindex",
	"kbd",
	"keygen",
	"label",
	"legend",
	"li",
	"link",
	"listing",
	"main",
	"map",
	"mark",
	"marquee",
	"math",
	"menu",
	"menuitem",
	"meta",
	"meter",
	"multicol",
	"nav",
	"nextid",
	"nobr",
	"noembed",
	"noframes",
	"noscript",
	"object",
	"ol",
	"optgroup",
	"option",
	"output",
	"p",
	"param",
	"picture",
	"plaintext",
	"pre",
	"progress",
	"q",
	"rb",
	"rbc",
	"rp",
	"rt",
	"rtc",
	"ruby",
	"s",
	"samp",
	"script",
	"section",
	"select",
	"shadow",
	"slot",
	"small",
	"source",
	"spacer",
	"span",
	"strike",
	"strong",
	"style",
	"sub",
	"summary",
	"sup",
	"svg",
	"table",
	"tbody",
	"td",
	"template",
	"textarea",
	"tfoot",
	"th",
	"thead",
	"time",
	"title",
	"tr",
	"track",
	"tt",
	"u",
	"ul",
	"var",
	"video",
	"wbr",
	"xmp"
];

var htmlTagNames = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': index
});

var htmlTagNames$1 = getCjsExportFromNamespace(htmlTagNames);

function clean$2(ast, newObj, parent) {
  ["raw", // front-matter
  "raws", "sourceIndex", "source", "before", "after", "trailingComma"].forEach(function (name) {
    delete newObj[name];
  });

  if (ast.type === "yaml") {
    delete newObj.value;
  } // --insert-pragma


  if (ast.type === "css-comment" && parent.type === "css-root" && parent.nodes.length !== 0 && ( // first non-front-matter comment
  parent.nodes[0] === ast || (parent.nodes[0].type === "yaml" || parent.nodes[0].type === "toml") && parent.nodes[1] === ast)) {
    /**
     * something
     *
     * @format
     */
    delete newObj.text; // standalone pragma

    if (/^\*\s*@(format|prettier)\s*$/.test(ast.text)) {
      return null;
    }
  }

  if (ast.type === "media-query" || ast.type === "media-query-list" || ast.type === "media-feature-expression") {
    delete newObj.value;
  }

  if (ast.type === "css-rule") {
    delete newObj.params;
  }

  if (ast.type === "selector-combinator") {
    newObj.value = newObj.value.replace(/\s+/g, " ");
  }

  if (ast.type === "media-feature") {
    newObj.value = newObj.value.replace(/ /g, "");
  }

  if (ast.type === "value-word" && (ast.isColor && ast.isHex || ["initial", "inherit", "unset", "revert"].indexOf(newObj.value.replace().toLowerCase()) !== -1) || ast.type === "media-feature" || ast.type === "selector-root-invalid" || ast.type === "selector-pseudo") {
    newObj.value = newObj.value.toLowerCase();
  }

  if (ast.type === "css-decl") {
    newObj.prop = newObj.prop.toLowerCase();
  }

  if (ast.type === "css-atrule" || ast.type === "css-import") {
    newObj.name = newObj.name.toLowerCase();
  }

  if (ast.type === "value-number") {
    newObj.unit = newObj.unit.toLowerCase();
  }

  if ((ast.type === "media-feature" || ast.type === "media-keyword" || ast.type === "media-type" || ast.type === "media-unknown" || ast.type === "media-url" || ast.type === "media-value" || ast.type === "selector-attribute" || ast.type === "selector-string" || ast.type === "selector-class" || ast.type === "selector-combinator" || ast.type === "value-string") && newObj.value) {
    newObj.value = cleanCSSStrings(newObj.value);
  }

  if (ast.type === "selector-attribute") {
    newObj.attribute = newObj.attribute.trim();

    if (newObj.namespace) {
      if (typeof newObj.namespace === "string") {
        newObj.namespace = newObj.namespace.trim();

        if (newObj.namespace.length === 0) {
          newObj.namespace = true;
        }
      }
    }

    if (newObj.value) {
      newObj.value = newObj.value.trim().replace(/^['"]|['"]$/g, "");
      delete newObj.quoted;
    }
  }

  if ((ast.type === "media-value" || ast.type === "media-type" || ast.type === "value-number" || ast.type === "selector-root-invalid" || ast.type === "selector-class" || ast.type === "selector-combinator" || ast.type === "selector-tag") && newObj.value) {
    newObj.value = newObj.value.replace(/([\d.eE+-]+)([a-zA-Z]*)/g, function (match, numStr, unit) {
      var num = Number(numStr);
      return isNaN(num) ? match : num + unit.toLowerCase();
    });
  }

  if (ast.type === "selector-tag") {
    var lowercasedValue = ast.value.toLowerCase();

    if (htmlTagNames$1.indexOf(lowercasedValue) !== -1) {
      newObj.value = lowercasedValue;
    }

    if (["from", "to"].indexOf(lowercasedValue) !== -1) {
      newObj.value = lowercasedValue;
    }
  } // Workaround when `postcss-values-parser` parse `not`, `and` or `or` keywords as `value-func`


  if (ast.type === "css-atrule" && ast.name.toLowerCase() === "supports") {
    delete newObj.value;
  } // Workaround for SCSS nested properties


  if (ast.type === "selector-unknown") {
    delete newObj.value;
  }
}

function cleanCSSStrings(value) {
  return value.replace(/'/g, '"').replace(/\\([^a-fA-F\d])/g, "$1");
}

var clean_1$1 = clean$2;

var _require$$0$builders$3 = doc.builders,
    hardline$6 = _require$$0$builders$3.hardline,
    literalline$3 = _require$$0$builders$3.literalline,
    concat$8 = _require$$0$builders$3.concat,
    markAsRoot$1 = _require$$0$builders$3.markAsRoot,
    mapDoc$4 = doc.utils.mapDoc;

function embed$1(path, print, textToDoc
/*, options */
) {
  var node = path.getValue();

  if (node.type === "yaml") {
    return markAsRoot$1(concat$8(["---", hardline$6, node.value.trim() ? replaceNewlinesWithLiterallines(textToDoc(node.value, {
      parser: "yaml"
    })) : "", "---", hardline$6]));
  }

  return null;

  function replaceNewlinesWithLiterallines(doc) {
    return mapDoc$4(doc, function (currentDoc) {
      return typeof currentDoc === "string" && currentDoc.includes("\n") ? concat$8(currentDoc.split(/(\n)/g).map(function (v, i) {
        return i % 2 === 0 ? v : literalline$3;
      })) : currentDoc;
    });
  }
}

var embed_1$1 = embed$1;

var DELIMITER_MAP = {
  "---": "yaml",
  "+++": "toml"
};

function parse$3(text) {
  var delimiterRegex = Object.keys(DELIMITER_MAP).map(escapeStringRegexp).join("|");
  var match = text.match( // trailing spaces after delimiters are allowed
  new RegExp(`^(${delimiterRegex})[^\\n\\S]*\\n(?:([\\s\\S]*?)\\n)?\\1[^\\n\\S]*(\\n|$)`));

  if (match === null) {
    return {
      frontMatter: null,
      content: text
    };
  }

  var raw = match[0].replace(/\n$/, "");
  var delimiter = match[1];
  var value = match[2];
  return {
    frontMatter: {
      type: DELIMITER_MAP[delimiter],
      value,
      raw
    },
    content: match[0].replace(/[^\n]/g, " ") + text.slice(match[0].length)
  };
}

var frontMatter = parse$3;

function hasPragma$1(text) {
  return pragma.hasPragma(frontMatter(text).content);
}

function insertPragma$2(text) {
  var _parseFrontMatter = frontMatter(text),
      frontMatter$1 = _parseFrontMatter.frontMatter,
      content = _parseFrontMatter.content;

  return (frontMatter$1 ? frontMatter$1.raw + "\n\n" : "") + pragma.insertPragma(content);
}

var pragma$1 = {
  hasPragma: hasPragma$1,
  insertPragma: insertPragma$2
};

var colorAdjusterFunctions = ["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"];

function getAncestorCounter(path, typeOrTypes) {
  var types = [].concat(typeOrTypes);
  var counter = -1;
  var ancestorNode;

  while (ancestorNode = path.getParentNode(++counter)) {
    if (types.indexOf(ancestorNode.type) !== -1) {
      return counter;
    }
  }

  return -1;
}

function getAncestorNode(path, typeOrTypes) {
  var counter = getAncestorCounter(path, typeOrTypes);
  return counter === -1 ? null : path.getParentNode(counter);
}

function getPropOfDeclNode(path) {
  var declAncestorNode = getAncestorNode(path, "css-decl");
  return declAncestorNode && declAncestorNode.prop && declAncestorNode.prop.toLowerCase();
}

function isSCSS(parser, text) {
  var hasExplicitParserChoice = parser === "less" || parser === "scss";
  var IS_POSSIBLY_SCSS = /(\w\s*: [^}:]+|#){|@import[^\n]+(url|,)/;
  return hasExplicitParserChoice ? parser === "scss" : IS_POSSIBLY_SCSS.test(text);
}

function isWideKeywords(value) {
  return ["initial", "inherit", "unset", "revert"].indexOf(value.toLowerCase()) !== -1;
}

function isKeyframeAtRuleKeywords(path, value) {
  var atRuleAncestorNode = getAncestorNode(path, "css-atrule");
  return atRuleAncestorNode && atRuleAncestorNode.name && atRuleAncestorNode.name.toLowerCase().endsWith("keyframes") && ["from", "to"].indexOf(value.toLowerCase()) !== -1;
}

function maybeToLowerCase(value) {
  return value.includes("$") || value.includes("@") || value.includes("#") || value.startsWith("%") || value.startsWith("--") || value.startsWith(":--") || value.includes("(") && value.includes(")") ? value : value.toLowerCase();
}

function insideValueFunctionNode(path, functionName) {
  var funcAncestorNode = getAncestorNode(path, "value-func");
  return funcAncestorNode && funcAncestorNode.value && funcAncestorNode.value.toLowerCase() === functionName;
}

function insideICSSRuleNode(path) {
  var ruleAncestorNode = getAncestorNode(path, "css-rule");
  return ruleAncestorNode && ruleAncestorNode.raws && ruleAncestorNode.raws.selector && (ruleAncestorNode.raws.selector.startsWith(":import") || ruleAncestorNode.raws.selector.startsWith(":export"));
}

function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {
  var atRuleNames = [].concat(atRuleNameOrAtRuleNames);
  var atRuleAncestorNode = getAncestorNode(path, "css-atrule");
  return atRuleAncestorNode && atRuleNames.indexOf(atRuleAncestorNode.name.toLowerCase()) !== -1;
}

function insideURLFunctionInImportAtRuleNode(path) {
  var node = path.getValue();
  var atRuleAncestorNode = getAncestorNode(path, "css-atrule");
  return atRuleAncestorNode && atRuleAncestorNode.name === "import" && node.groups[0].value === "url" && node.groups.length === 2;
}

function isURLFunctionNode(node) {
  return node.type === "value-func" && node.value.toLowerCase() === "url";
}

function isLastNode(path, node) {
  var parentNode = path.getParentNode();

  if (!parentNode) {
    return false;
  }

  var nodes = parentNode.nodes;
  return nodes && nodes.indexOf(node) === nodes.length - 1;
}

function isHTMLTag(value) {
  return htmlTagNames$1.indexOf(value.toLowerCase()) !== -1;
}

function isDetachedRulesetDeclarationNode(node) {
  // If a Less file ends up being parsed with the SCSS parser, Less
  // variable declarations will be parsed as atrules with names ending
  // with a colon, so keep the original case then.
  if (!node.selector) {
    return false;
  }

  return typeof node.selector === "string" && /^@.+:.*$/.test(node.selector) || node.selector.value && /^@.+:.*$/.test(node.selector.value);
}

function isForKeywordNode(node) {
  return node.type === "value-word" && ["from", "through", "end"].indexOf(node.value) !== -1;
}

function isIfElseKeywordNode(node) {
  return node.type === "value-word" && ["and", "or", "not"].indexOf(node.value) !== -1;
}

function isEachKeywordNode(node) {
  return node.type === "value-word" && node.value === "in";
}

function isMultiplicationNode(node) {
  return node.type === "value-operator" && node.value === "*";
}

function isDivisionNode(node) {
  return node.type === "value-operator" && node.value === "/";
}

function isAdditionNode(node) {
  return node.type === "value-operator" && node.value === "+";
}

function isSubtractionNode(node) {
  return node.type === "value-operator" && node.value === "-";
}

function isModuloNode(node) {
  return node.type === "value-operator" && node.value === "%";
}

function isMathOperatorNode(node) {
  return isMultiplicationNode(node) || isDivisionNode(node) || isAdditionNode(node) || isSubtractionNode(node) || isModuloNode(node);
}

function isEqualityOperatorNode(node) {
  return node.type === "value-word" && ["==", "!="].indexOf(node.value) !== -1;
}

function isRelationalOperatorNode(node) {
  return node.type === "value-word" && ["<", ">", "<=", ">="].indexOf(node.value) !== -1;
}

function isSCSSControlDirectiveNode(node) {
  return node.type === "css-atrule" && ["if", "else", "for", "each", "while"].indexOf(node.name) !== -1;
}

function isSCSSNestedPropertyNode(node) {
  if (!node.selector) {
    return false;
  }

  return node.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
}

function isDetachedRulesetCallNode(node) {
  return node.raws && node.raws.params && /^\(\s*\)$/.test(node.raws.params);
}

function isTemplatePlaceholderNode(node) {
  return node.name.startsWith("prettier-placeholder");
}

function isTemplatePropNode(node) {
  return node.prop.startsWith("@prettier-placeholder");
}

function isPostcssSimpleVarNode(currentNode, nextNode) {
  return currentNode.value === "$$" && currentNode.type === "value-func" && nextNode && nextNode.type === "value-word" && !nextNode.raws.before;
}

function hasComposesNode(node) {
  return node.value && node.value.type === "value-root" && node.value.group && node.value.group.type === "value-value" && node.prop.toLowerCase() === "composes";
}

function hasParensAroundNode(node) {
  return node.value && node.value.group && node.value.group.group && node.value.group.group.type === "value-paren_group" && node.value.group.group.open !== null && node.value.group.group.close !== null;
}

function hasEmptyRawBefore(node) {
  return node.raws && node.raws.before === "";
}

function isKeyValuePairNode(node) {
  return node.type === "value-comma_group" && node.groups && node.groups[1] && node.groups[1].type === "value-colon";
}

function isKeyValuePairInParenGroupNode(node) {
  return node.type === "value-paren_group" && node.groups && node.groups[0] && isKeyValuePairNode(node.groups[0]);
}

function isSCSSMapItemNode(path) {
  var node = path.getValue(); // Ignore empty item (i.e. `$key: ()`)

  if (node.groups.length === 0) {
    return false;
  }

  var parentParentNode = path.getParentNode(1); // Check open parens contain key/value pair (i.e. `(key: value)` and `(key: (value, other-value)`)

  if (!isKeyValuePairInParenGroupNode(node) && !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))) {
    return false;
  }

  var declNode = getAncestorNode(path, "css-decl"); // SCSS map declaration (i.e. `$map: (key: value, other-key: other-value)`)

  if (declNode && declNode.prop && declNode.prop.startsWith("$")) {
    return true;
  } // List as value of key inside SCSS map (i.e. `$map: (key: (value other-value other-other-value))`)


  if (isKeyValuePairInParenGroupNode(parentParentNode)) {
    return true;
  } // SCSS Map is argument of function (i.e. `func((key: value, other-key: other-value))`)


  if (parentParentNode.type === "value-func") {
    return true;
  }

  return false;
}

function isInlineValueCommentNode(node) {
  return node.type === "value-comment" && node.inline;
}

function isHashNode(node) {
  return node.type === "value-word" && node.value === "#";
}

function isLeftCurlyBraceNode(node) {
  return node.type === "value-word" && node.value === "{";
}

function isRightCurlyBraceNode(node) {
  return node.type === "value-word" && node.value === "}";
}

function isWordNode(node) {
  return ["value-word", "value-atword"].indexOf(node.type) !== -1;
}

function isColonNode(node) {
  return node.type === "value-colon";
}

function isMediaAndSupportsKeywords(node) {
  return node.value && ["not", "and", "or"].indexOf(node.value.toLowerCase()) !== -1;
}

function isColorAdjusterFuncNode(node) {
  if (node.type !== "value-func") {
    return false;
  }

  return colorAdjusterFunctions.indexOf(node.value.toLowerCase()) !== -1;
}

var utils$3 = {
  getAncestorCounter,
  getAncestorNode,
  getPropOfDeclNode,
  maybeToLowerCase,
  insideValueFunctionNode,
  insideICSSRuleNode,
  insideAtRuleNode,
  insideURLFunctionInImportAtRuleNode,
  isKeyframeAtRuleKeywords,
  isHTMLTag,
  isWideKeywords,
  isSCSS,
  isLastNode,
  isSCSSControlDirectiveNode,
  isDetachedRulesetDeclarationNode,
  isRelationalOperatorNode,
  isEqualityOperatorNode,
  isMultiplicationNode,
  isDivisionNode,
  isAdditionNode,
  isSubtractionNode,
  isModuloNode,
  isMathOperatorNode,
  isEachKeywordNode,
  isForKeywordNode,
  isURLFunctionNode,
  isIfElseKeywordNode,
  hasComposesNode,
  hasParensAroundNode,
  hasEmptyRawBefore,
  isSCSSNestedPropertyNode,
  isDetachedRulesetCallNode,
  isTemplatePlaceholderNode,
  isTemplatePropNode,
  isPostcssSimpleVarNode,
  isKeyValuePairNode,
  isKeyValuePairInParenGroupNode,
  isSCSSMapItemNode,
  isInlineValueCommentNode,
  isHashNode,
  isLeftCurlyBraceNode,
  isRightCurlyBraceNode,
  isWordNode,
  isColonNode,
  isMediaAndSupportsKeywords,
  isColorAdjusterFuncNode
};

var insertPragma$3 = pragma$1.insertPragma;
var printNumber$2 = util.printNumber,
    printString$2 = util.printString,
    hasIgnoreComment$3 = util.hasIgnoreComment,
    hasNewline$4 = util.hasNewline;
var isNextLineEmpty$3 = utilShared.isNextLineEmpty;
var _require$$3$builders = doc.builders,
    concat$9 = _require$$3$builders.concat,
    join$6 = _require$$3$builders.join,
    line$3 = _require$$3$builders.line,
    hardline$7 = _require$$3$builders.hardline,
    softline$3 = _require$$3$builders.softline,
    group$6 = _require$$3$builders.group,
    fill$3 = _require$$3$builders.fill,
    indent$5 = _require$$3$builders.indent,
    dedent$2 = _require$$3$builders.dedent,
    ifBreak$2 = _require$$3$builders.ifBreak,
    removeLines$2 = doc.utils.removeLines;
var getAncestorNode$1 = utils$3.getAncestorNode,
    getPropOfDeclNode$1 = utils$3.getPropOfDeclNode,
    maybeToLowerCase$1 = utils$3.maybeToLowerCase,
    insideValueFunctionNode$1 = utils$3.insideValueFunctionNode,
    insideICSSRuleNode$1 = utils$3.insideICSSRuleNode,
    insideAtRuleNode$1 = utils$3.insideAtRuleNode,
    insideURLFunctionInImportAtRuleNode$1 = utils$3.insideURLFunctionInImportAtRuleNode,
    isKeyframeAtRuleKeywords$1 = utils$3.isKeyframeAtRuleKeywords,
    isHTMLTag$1 = utils$3.isHTMLTag,
    isWideKeywords$1 = utils$3.isWideKeywords,
    isSCSS$1 = utils$3.isSCSS,
    isLastNode$1 = utils$3.isLastNode,
    isSCSSControlDirectiveNode$1 = utils$3.isSCSSControlDirectiveNode,
    isDetachedRulesetDeclarationNode$1 = utils$3.isDetachedRulesetDeclarationNode,
    isRelationalOperatorNode$1 = utils$3.isRelationalOperatorNode,
    isEqualityOperatorNode$1 = utils$3.isEqualityOperatorNode,
    isMultiplicationNode$1 = utils$3.isMultiplicationNode,
    isDivisionNode$1 = utils$3.isDivisionNode,
    isAdditionNode$1 = utils$3.isAdditionNode,
    isSubtractionNode$1 = utils$3.isSubtractionNode,
    isMathOperatorNode$1 = utils$3.isMathOperatorNode,
    isEachKeywordNode$1 = utils$3.isEachKeywordNode,
    isForKeywordNode$1 = utils$3.isForKeywordNode,
    isURLFunctionNode$1 = utils$3.isURLFunctionNode,
    isIfElseKeywordNode$1 = utils$3.isIfElseKeywordNode,
    hasComposesNode$1 = utils$3.hasComposesNode,
    hasParensAroundNode$1 = utils$3.hasParensAroundNode,
    hasEmptyRawBefore$1 = utils$3.hasEmptyRawBefore,
    isKeyValuePairNode$1 = utils$3.isKeyValuePairNode,
    isDetachedRulesetCallNode$1 = utils$3.isDetachedRulesetCallNode,
    isTemplatePlaceholderNode$1 = utils$3.isTemplatePlaceholderNode,
    isTemplatePropNode$1 = utils$3.isTemplatePropNode,
    isPostcssSimpleVarNode$1 = utils$3.isPostcssSimpleVarNode,
    isSCSSMapItemNode$1 = utils$3.isSCSSMapItemNode,
    isInlineValueCommentNode$1 = utils$3.isInlineValueCommentNode,
    isHashNode$1 = utils$3.isHashNode,
    isLeftCurlyBraceNode$1 = utils$3.isLeftCurlyBraceNode,
    isRightCurlyBraceNode$1 = utils$3.isRightCurlyBraceNode,
    isWordNode$1 = utils$3.isWordNode,
    isColonNode$1 = utils$3.isColonNode,
    isMediaAndSupportsKeywords$1 = utils$3.isMediaAndSupportsKeywords,
    isColorAdjusterFuncNode$1 = utils$3.isColorAdjusterFuncNode;

function shouldPrintComma$1(options) {
  switch (options.trailingComma) {
    case "all":
    case "es5":
      return true;

    case "none":
    default:
      return false;
  }
}

function genericPrint$2(path, options, print) {
  var node = path.getValue();
  /* istanbul ignore if */

  if (!node) {
    return "";
  }

  if (typeof node === "string") {
    return node;
  }

  switch (node.type) {
    case "yaml":
    case "toml":
      return concat$9([node.raw, hardline$7]);

    case "css-root":
      {
        var nodes = printNodeSequence(path, options, print);

        if (nodes.parts.length) {
          return concat$9([nodes, hardline$7]);
        }

        return nodes;
      }

    case "css-comment":
      {
        if (node.raws.content) {
          return node.raws.content;
        }

        var text = options.originalText.slice(options.locStart(node), options.locEnd(node));
        var rawText = node.raws.text || node.text; // Workaround a bug where the location is off.
        // https://github.com/postcss/postcss-scss/issues/63

        if (text.indexOf(rawText) === -1) {
          if (node.raws.inline) {
            return concat$9(["// ", rawText]);
          }

          return concat$9(["/* ", rawText, " */"]);
        }

        return text;
      }

    case "css-rule":
      {
        return concat$9([path.call(print, "selector"), node.important ? " !important" : "", node.nodes ? concat$9([" {", node.nodes.length > 0 ? indent$5(concat$9([hardline$7, printNodeSequence(path, options, print)])) : "", hardline$7, "}", isDetachedRulesetDeclarationNode$1(node) ? ";" : ""]) : ";"]);
      }

    case "css-decl":
      {
        var parentNode = path.getParentNode();
        return concat$9([node.raws.before.replace(/[\s;]/g, ""), insideICSSRuleNode$1(path) ? node.prop : maybeToLowerCase$1(node.prop), node.raws.between.trim() === ":" ? ":" : node.raws.between.trim(), node.extend ? "" : " ", hasComposesNode$1(node) ? removeLines$2(path.call(print, "value")) : path.call(print, "value"), node.raws.important ? node.raws.important.replace(/\s*!\s*important/i, " !important") : node.important ? " !important" : "", node.raws.scssDefault ? node.raws.scssDefault.replace(/\s*!default/i, " !default") : node.scssDefault ? " !default" : "", node.raws.scssGlobal ? node.raws.scssGlobal.replace(/\s*!global/i, " !global") : node.scssGlobal ? " !global" : "", node.nodes ? concat$9([" {", indent$5(concat$9([softline$3, printNodeSequence(path, options, print)])), softline$3, "}"]) : isTemplatePropNode$1(node) && !parentNode.raws.semicolon && options.originalText[options.locEnd(node) - 1] !== ";" ? "" : ";"]);
      }

    case "css-atrule":
      {
        var _parentNode = path.getParentNode();

        return concat$9(["@", // If a Less file ends up being parsed with the SCSS parser, Less
        // variable declarations will be parsed as at-rules with names ending
        // with a colon, so keep the original case then.
        isDetachedRulesetCallNode$1(node) || node.name.endsWith(":") ? node.name : maybeToLowerCase$1(node.name), node.params ? concat$9([isDetachedRulesetCallNode$1(node) ? "" : isTemplatePlaceholderNode$1(node) && /^\s*\n/.test(node.raws.afterName) ? /^\s*\n\s*\n/.test(node.raws.afterName) ? concat$9([hardline$7, hardline$7]) : hardline$7 : " ", path.call(print, "params")]) : "", node.selector ? indent$5(concat$9([" ", path.call(print, "selector")])) : "", node.value ? group$6(concat$9([" ", path.call(print, "value"), isSCSSControlDirectiveNode$1(node) ? hasParensAroundNode$1(node) ? " " : line$3 : ""])) : node.name === "else" ? " " : "", node.nodes ? concat$9([isSCSSControlDirectiveNode$1(node) ? "" : " ", "{", indent$5(concat$9([node.nodes.length > 0 ? softline$3 : "", printNodeSequence(path, options, print)])), softline$3, "}"]) : isTemplatePlaceholderNode$1(node) && !_parentNode.raws.semicolon && options.originalText[options.locEnd(node) - 1] !== ";" ? "" : ";"]);
      }
    // postcss-media-query-parser

    case "media-query-list":
      {
        var parts = [];
        path.each(function (childPath) {
          var node = childPath.getValue();

          if (node.type === "media-query" && node.value === "") {
            return;
          }

          parts.push(childPath.call(print));
        }, "nodes");
        return group$6(indent$5(join$6(line$3, parts)));
      }

    case "media-query":
      {
        return concat$9([join$6(" ", path.map(print, "nodes")), isLastNode$1(path, node) ? "" : ","]);
      }

    case "media-type":
      {
        return adjustNumbers(adjustStrings(node.value, options));
      }

    case "media-feature-expression":
      {
        if (!node.nodes) {
          return node.value;
        }

        return concat$9(["(", concat$9(path.map(print, "nodes")), ")"]);
      }

    case "media-feature":
      {
        return maybeToLowerCase$1(adjustStrings(node.value.replace(/ +/g, " "), options));
      }

    case "media-colon":
      {
        return concat$9([node.value, " "]);
      }

    case "media-value":
      {
        return adjustNumbers(adjustStrings(node.value, options));
      }

    case "media-keyword":
      {
        return adjustStrings(node.value, options);
      }

    case "media-url":
      {
        return adjustStrings(node.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/gi, ")"), options);
      }

    case "media-unknown":
      {
        return node.value;
      }
    // postcss-selector-parser

    case "selector-root":
      {
        return group$6(concat$9([insideAtRuleNode$1(path, "custom-selector") ? concat$9([getAncestorNode$1(path, "css-atrule").customSelector, line$3]) : "", join$6(concat$9([",", insideAtRuleNode$1(path, ["extend", "custom-selector", "nest"]) ? line$3 : hardline$7]), path.map(print, "nodes"))]));
      }

    case "selector-selector":
      {
        return group$6(indent$5(concat$9(path.map(print, "nodes"))));
      }

    case "selector-comment":
      {
        return node.value;
      }

    case "selector-string":
      {
        return adjustStrings(node.value, options);
      }

    case "selector-tag":
      {
        var _parentNode2 = path.getParentNode();

        var index = _parentNode2 && _parentNode2.nodes.indexOf(node);

        var prevNode = index && _parentNode2.nodes[index - 1];
        return concat$9([node.namespace ? concat$9([node.namespace === true ? "" : node.namespace.trim(), "|"]) : "", prevNode.type === "selector-nesting" ? node.value : adjustNumbers(isHTMLTag$1(node.value) || isKeyframeAtRuleKeywords$1(path, node.value) ? node.value.toLowerCase() : node.value)]);
      }

    case "selector-id":
      {
        return concat$9(["#", node.value]);
      }

    case "selector-class":
      {
        return concat$9([".", adjustNumbers(adjustStrings(node.value, options))]);
      }

    case "selector-attribute":
      {
        return concat$9(["[", node.namespace ? concat$9([node.namespace === true ? "" : node.namespace.trim(), "|"]) : "", node.attribute.trim(), node.operator ? node.operator : "", node.value ? quoteAttributeValue(adjustStrings(node.value.trim(), options), options) : "", node.insensitive ? " i" : "", "]"]);
      }

    case "selector-combinator":
      {
        if (node.value === "+" || node.value === ">" || node.value === "~" || node.value === ">>>") {
          var _parentNode3 = path.getParentNode();

          var _leading = _parentNode3.type === "selector-selector" && _parentNode3.nodes[0] === node ? "" : line$3;

          return concat$9([_leading, node.value, isLastNode$1(path, node) ? "" : " "]);
        }

        var leading = node.value.trim().startsWith("(") ? line$3 : "";
        var value = adjustNumbers(adjustStrings(node.value.trim(), options)) || line$3;
        return concat$9([leading, value]);
      }

    case "selector-universal":
      {
        return concat$9([node.namespace ? concat$9([node.namespace === true ? "" : node.namespace.trim(), "|"]) : "", node.value]);
      }

    case "selector-pseudo":
      {
        return concat$9([maybeToLowerCase$1(node.value), node.nodes && node.nodes.length > 0 ? concat$9(["(", join$6(", ", path.map(print, "nodes")), ")"]) : ""]);
      }

    case "selector-nesting":
      {
        return node.value;
      }

    case "selector-unknown":
      {
        var ruleAncestorNode = getAncestorNode$1(path, "css-rule"); // Nested SCSS property

        if (ruleAncestorNode && ruleAncestorNode.isSCSSNesterProperty) {
          return adjustNumbers(adjustStrings(maybeToLowerCase$1(node.value), options));
        }

        return node.value;
      }
    // postcss-values-parser

    case "value-value":
    case "value-root":
      {
        return path.call(print, "group");
      }

    case "value-comment":
      {
        return concat$9([node.inline ? "//" : "/*", node.value, node.inline ? "" : "*/"]);
      }

    case "value-comma_group":
      {
        var _parentNode4 = path.getParentNode();

        var parentParentNode = path.getParentNode(1);
        var declAncestorProp = getPropOfDeclNode$1(path);
        var isGridValue = declAncestorProp && _parentNode4.type === "value-value" && (declAncestorProp === "grid" || declAncestorProp.startsWith("grid-template"));
        var atRuleAncestorNode = getAncestorNode$1(path, "css-atrule");
        var isControlDirective = atRuleAncestorNode && isSCSSControlDirectiveNode$1(atRuleAncestorNode);
        var printed = path.map(print, "groups");
        var _parts = [];
        var insideURLFunction = insideValueFunctionNode$1(path, "url");
        var insideSCSSInterpolationInString = false;
        var didBreak = false;

        for (var i = 0; i < node.groups.length; ++i) {
          _parts.push(printed[i]); // Ignore value inside `url()`


          if (insideURLFunction) {
            continue;
          }

          var iPrevNode = node.groups[i - 1];
          var iNode = node.groups[i];
          var iNextNode = node.groups[i + 1];
          var iNextNextNode = node.groups[i + 2]; // Ignore after latest node (i.e. before semicolon)

          if (!iNextNode) {
            continue;
          } // Ignore spaces before/after string interpolation (i.e. `"#{my-fn("_")}"`)


          var isStartSCSSInterpolationInString = iNode.type === "value-string" && iNode.value.startsWith("#{");
          var isEndingSCSSInterpolationInString = insideSCSSInterpolationInString && iNextNode.type === "value-string" && iNextNode.value.endsWith("}");

          if (isStartSCSSInterpolationInString || isEndingSCSSInterpolationInString) {
            insideSCSSInterpolationInString = !insideSCSSInterpolationInString;
            continue;
          }

          if (insideSCSSInterpolationInString) {
            continue;
          } // Ignore colon (i.e. `:`)


          if (isColonNode$1(iNode) || isColonNode$1(iNextNode)) {
            continue;
          } // Ignore `@` in Less (i.e. `@@var;`)


          if (iNode.type === "value-atword" && iNode.value === "") {
            continue;
          } // Ignore `~` in Less (i.e. `content: ~"^//* some horrible but needed css hack";`)


          if (iNode.value === "~") {
            continue;
          } // Ignore escape `\`


          if (iNode.value && iNode.value.indexOf("\\") !== -1 && iNextNode && iNextNode.type !== "value-comment") {
            continue;
          } // Ignore escaped `/`


          if (iPrevNode && iPrevNode.value && iPrevNode.value.indexOf("\\") === iPrevNode.value.length - 1 && iNode.type === "value-operator" && iNode.value === "/") {
            continue;
          } // Ignore `\` (i.e. `$variable: \@small;`)


          if (iNode.value === "\\") {
            continue;
          } // Ignore `$$` (i.e. `background-color: $$(style)Color;`)


          if (isPostcssSimpleVarNode$1(iNode, iNextNode)) {
            continue;
          } // Ignore spaces after `#` and after `{` and before `}` in SCSS interpolation (i.e. `#{variable}`)


          if (isHashNode$1(iNode) || isLeftCurlyBraceNode$1(iNode) || isRightCurlyBraceNode$1(iNextNode) || isLeftCurlyBraceNode$1(iNextNode) && hasEmptyRawBefore$1(iNextNode) || isRightCurlyBraceNode$1(iNode) && hasEmptyRawBefore$1(iNextNode)) {
            continue;
          } // Ignore css variables and interpolation in SCSS (i.e. `--#{$var}`)


          if (iNode.value === "--" && isHashNode$1(iNextNode)) {
            continue;
          } // Formatting math operations


          var isMathOperator = isMathOperatorNode$1(iNode);
          var isNextMathOperator = isMathOperatorNode$1(iNextNode); // Print spaces before and after math operators beside SCSS interpolation as is
          // (i.e. `#{$var}+5`, `#{$var} +5`, `#{$var}+ 5`, `#{$var} + 5`)
          // (i.e. `5+#{$var}`, `5 +#{$var}`, `5+ #{$var}`, `5 + #{$var}`)

          if ((isMathOperator && isHashNode$1(iNextNode) || isNextMathOperator && isRightCurlyBraceNode$1(iNode)) && hasEmptyRawBefore$1(iNextNode)) {
            continue;
          } // Print spaces before and after addition and subtraction math operators as is in `calc` function
          // due to the fact that it is not valid syntax
          // (i.e. `calc(1px+1px)`, `calc(1px+ 1px)`, `calc(1px +1px)`, `calc(1px + 1px)`)


          if (insideValueFunctionNode$1(path, "calc") && (isAdditionNode$1(iNode) || isAdditionNode$1(iNextNode) || isSubtractionNode$1(iNode) || isSubtractionNode$1(iNextNode)) && hasEmptyRawBefore$1(iNextNode)) {
            continue;
          } // Print spaces after `+` and `-` in color adjuster functions as is (e.g. `color(red l(+ 20%))`)
          // Adjusters with signed numbers (e.g. `color(red l(+20%))`) output as-is.


          var isColorAdjusterNode = (isAdditionNode$1(iNode) || isSubtractionNode$1(iNode)) && i === 0 && (iNextNode.type === "value-number" || iNextNode.isHex) && parentParentNode && isColorAdjusterFuncNode$1(parentParentNode) && !hasEmptyRawBefore$1(iNextNode);
          var requireSpaceBeforeOperator = iNextNextNode && iNextNextNode.type === "value-func" || iNextNextNode && isWordNode$1(iNextNextNode) || iNode.type === "value-func" || isWordNode$1(iNode);
          var requireSpaceAfterOperator = iNextNode.type === "value-func" || isWordNode$1(iNextNode) || iPrevNode && iPrevNode.type === "value-func" || iPrevNode && isWordNode$1(iPrevNode); // Formatting `/`, `+`, `-` sign

          if (!(isMultiplicationNode$1(iNextNode) || isMultiplicationNode$1(iNode)) && !insideValueFunctionNode$1(path, "calc") && !isColorAdjusterNode && (isDivisionNode$1(iNextNode) && !requireSpaceBeforeOperator || isDivisionNode$1(iNode) && !requireSpaceAfterOperator || isAdditionNode$1(iNextNode) && !requireSpaceBeforeOperator || isAdditionNode$1(iNode) && !requireSpaceAfterOperator || isSubtractionNode$1(iNextNode) || isSubtractionNode$1(iNode)) && (hasEmptyRawBefore$1(iNextNode) || isMathOperator && (!iPrevNode || iPrevNode && isMathOperatorNode$1(iPrevNode)))) {
            continue;
          } // Add `hardline` after inline comment (i.e. `// comment\n foo: bar;`)


          if (isInlineValueCommentNode$1(iNode)) {
            _parts.push(hardline$7);

            continue;
          } // Handle keywords in SCSS control directive


          if (isControlDirective && (isEqualityOperatorNode$1(iNextNode) || isRelationalOperatorNode$1(iNextNode) || isIfElseKeywordNode$1(iNextNode) || isEachKeywordNode$1(iNode) || isForKeywordNode$1(iNode))) {
            _parts.push(" ");

            continue;
          } // At-rule `namespace` should be in one line


          if (atRuleAncestorNode && atRuleAncestorNode.name.toLowerCase() === "namespace") {
            _parts.push(" ");

            continue;
          } // Formatting `grid` property


          if (isGridValue) {
            if (iNode.source && iNextNode.source && iNode.source.start.line !== iNextNode.source.start.line) {
              _parts.push(hardline$7);

              didBreak = true;
            } else {
              _parts.push(" ");
            }

            continue;
          } // Add `space` before next math operation
          // Note: `grip` property have `/` delimiter and it is not math operation, so
          // `grid` property handles above


          if (isNextMathOperator) {
            _parts.push(" ");

            continue;
          } // Be default all values go through `line`


          _parts.push(line$3);
        }

        if (didBreak) {
          _parts.unshift(hardline$7);
        }

        if (isControlDirective) {
          return group$6(indent$5(concat$9(_parts)));
        } // Indent is not needed for import url when url is very long
        // and node has two groups
        // when type is value-comma_group
        // example @import url("verylongurl") projection,tv


        if (insideURLFunctionInImportAtRuleNode$1(path)) {
          return group$6(fill$3(_parts));
        }

        return group$6(indent$5(fill$3(_parts)));
      }

    case "value-paren_group":
      {
        var _parentNode5 = path.getParentNode();

        if (_parentNode5 && isURLFunctionNode$1(_parentNode5) && (node.groups.length === 1 || node.groups.length > 0 && node.groups[0].type === "value-comma_group" && node.groups[0].groups.length > 0 && node.groups[0].groups[0].type === "value-word" && node.groups[0].groups[0].value.startsWith("data:"))) {
          return concat$9([node.open ? path.call(print, "open") : "", join$6(",", path.map(print, "groups")), node.close ? path.call(print, "close") : ""]);
        }

        if (!node.open) {
          var _printed = path.map(print, "groups");

          var res = [];

          for (var _i = 0; _i < _printed.length; _i++) {
            if (_i !== 0) {
              res.push(concat$9([",", line$3]));
            }

            res.push(_printed[_i]);
          }

          return group$6(indent$5(fill$3(res)));
        }

        var isSCSSMapItem = isSCSSMapItemNode$1(path);
        return group$6(concat$9([node.open ? path.call(print, "open") : "", indent$5(concat$9([softline$3, join$6(concat$9([",", line$3]), path.map(function (childPath) {
          var node = childPath.getValue();
          var printed = print(childPath); // Key/Value pair in open paren already indented

          if (isKeyValuePairNode$1(node) && node.type === "value-comma_group" && node.groups && node.groups[2] && node.groups[2].type === "value-paren_group") {
            printed.contents.contents.parts[1] = group$6(printed.contents.contents.parts[1]);
            return group$6(dedent$2(printed));
          }

          return printed;
        }, "groups"))])), ifBreak$2(isSCSS$1(options.parser, options.originalText) && isSCSSMapItem && shouldPrintComma$1(options) ? "," : ""), softline$3, node.close ? path.call(print, "close") : ""]), {
          shouldBreak: isSCSSMapItem
        });
      }

    case "value-func":
      {
        return concat$9([node.value, insideAtRuleNode$1(path, "supports") && isMediaAndSupportsKeywords$1(node) ? " " : "", path.call(print, "group")]);
      }

    case "value-paren":
      {
        return node.value;
      }

    case "value-number":
      {
        return concat$9([printCssNumber(node.value), maybeToLowerCase$1(node.unit)]);
      }

    case "value-operator":
      {
        return node.value;
      }

    case "value-word":
      {
        if (node.isColor && node.isHex || isWideKeywords$1(node.value)) {
          return node.value.toLowerCase();
        }

        return node.value;
      }

    case "value-colon":
      {
        return concat$9([node.value, // Don't add spaces on `:` in `url` function (i.e. `url(fbglyph: cross-outline, fig-white)`)
        insideValueFunctionNode$1(path, "url") ? "" : line$3]);
      }

    case "value-comma":
      {
        return concat$9([node.value, " "]);
      }

    case "value-string":
      {
        return printString$2(node.raws.quote + node.value + node.raws.quote, options);
      }

    case "value-atword":
      {
        return concat$9(["@", node.value]);
      }

    case "value-unicode-range":
      {
        return node.value;
      }

    case "value-unknown":
      {
        return node.value;
      }

    default:
      /* istanbul ignore next */
      throw new Error(`Unknown postcss type ${JSON.stringify(node.type)}`);
  }
}

function printNodeSequence(path, options, print) {
  var node = path.getValue();
  var parts = [];
  var i = 0;
  path.map(function (pathChild) {
    var prevNode = node.nodes[i - 1];

    if (prevNode && prevNode.type === "css-comment" && prevNode.text.trim() === "prettier-ignore") {
      var childNode = pathChild.getValue();
      parts.push(options.originalText.slice(options.locStart(childNode), options.locEnd(childNode)));
    } else {
      parts.push(pathChild.call(print));
    }

    if (i !== node.nodes.length - 1) {
      if (node.nodes[i + 1].type === "css-comment" && !hasNewline$4(options.originalText, options.locStart(node.nodes[i + 1]), {
        backwards: true
      }) && node.nodes[i].type !== "yaml" && node.nodes[i].type !== "toml" || node.nodes[i + 1].type === "css-atrule" && node.nodes[i + 1].name === "else" && node.nodes[i].type !== "css-comment") {
        parts.push(" ");
      } else {
        parts.push(hardline$7);

        if (isNextLineEmpty$3(options.originalText, pathChild.getValue(), options) && node.nodes[i].type !== "yaml" && node.nodes[i].type !== "toml") {
          parts.push(hardline$7);
        }
      }
    }

    i++;
  }, "nodes");
  return concat$9(parts);
}

var STRING_REGEX$1 = /(['"])(?:(?!\1)[^\\]|\\[\s\S])*\1/g;
var NUMBER_REGEX = /(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g;
var STANDARD_UNIT_REGEX = /[a-zA-Z]+/g;
var WORD_PART_REGEX = /[$@]?[a-zA-Z_\u0080-\uFFFF][\w\-\u0080-\uFFFF]*/g;
var ADJUST_NUMBERS_REGEX = RegExp(STRING_REGEX$1.source + `|` + `(${WORD_PART_REGEX.source})?` + `(${NUMBER_REGEX.source})` + `(${STANDARD_UNIT_REGEX.source})?`, "g");

function adjustStrings(value, options) {
  return value.replace(STRING_REGEX$1, function (match) {
    return printString$2(match, options);
  });
}

function quoteAttributeValue(value, options) {
  var quote = options.singleQuote ? "'" : '"';
  return value.includes('"') || value.includes("'") ? value : quote + value + quote;
}

function adjustNumbers(value) {
  return value.replace(ADJUST_NUMBERS_REGEX, function (match, quote, wordPart, number, unit) {
    return !wordPart && number ? (wordPart || "") + printCssNumber(number) + maybeToLowerCase$1(unit || "") : match;
  });
}

function printCssNumber(rawNumber) {
  return printNumber$2(rawNumber) // Remove trailing `.0`.
  .replace(/\.0(?=$|e)/, "");
}

var printerPostcss = {
  print: genericPrint$2,
  embed: embed_1$1,
  insertPragma: insertPragma$3,
  hasPrettierIgnore: hasIgnoreComment$3,
  massageAstNode: clean_1$1
};

var options$3 = {
  singleQuote: commonOptions.singleQuote
};

var name$9 = "CSS";
var type$7 = "markup";
var tmScope$7 = "source.css";
var aceMode$7 = "css";
var codemirrorMode$7 = "css";
var codemirrorMimeType$7 = "text/css";
var color$2 = "#563d7c";
var extensions$7 = [
	".css"
];
var languageId$7 = 50;
var CSS = {
	name: name$9,
	type: type$7,
	tmScope: tmScope$7,
	aceMode: aceMode$7,
	codemirrorMode: codemirrorMode$7,
	codemirrorMimeType: codemirrorMimeType$7,
	color: color$2,
	extensions: extensions$7,
	languageId: languageId$7
};

var CSS$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$9,
  type: type$7,
  tmScope: tmScope$7,
  aceMode: aceMode$7,
  codemirrorMode: codemirrorMode$7,
  codemirrorMimeType: codemirrorMimeType$7,
  color: color$2,
  extensions: extensions$7,
  languageId: languageId$7,
  'default': CSS
});

var name$a = "PostCSS";
var type$8 = "markup";
var tmScope$8 = "source.postcss";
var group$7 = "CSS";
var extensions$8 = [
	".pcss"
];
var aceMode$8 = "text";
var languageId$8 = 262764437;
var PostCSS = {
	name: name$a,
	type: type$8,
	tmScope: tmScope$8,
	group: group$7,
	extensions: extensions$8,
	aceMode: aceMode$8,
	languageId: languageId$8
};

var PostCSS$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$a,
  type: type$8,
  tmScope: tmScope$8,
  group: group$7,
  extensions: extensions$8,
  aceMode: aceMode$8,
  languageId: languageId$8,
  'default': PostCSS
});

var name$b = "Less";
var type$9 = "markup";
var group$8 = "CSS";
var extensions$9 = [
	".less"
];
var tmScope$9 = "source.css.less";
var aceMode$9 = "less";
var codemirrorMode$8 = "css";
var codemirrorMimeType$8 = "text/css";
var languageId$9 = 198;
var Less = {
	name: name$b,
	type: type$9,
	group: group$8,
	extensions: extensions$9,
	tmScope: tmScope$9,
	aceMode: aceMode$9,
	codemirrorMode: codemirrorMode$8,
	codemirrorMimeType: codemirrorMimeType$8,
	languageId: languageId$9
};

var Less$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$b,
  type: type$9,
  group: group$8,
  extensions: extensions$9,
  tmScope: tmScope$9,
  aceMode: aceMode$9,
  codemirrorMode: codemirrorMode$8,
  codemirrorMimeType: codemirrorMimeType$8,
  languageId: languageId$9,
  'default': Less
});

var name$c = "SCSS";
var type$a = "markup";
var tmScope$a = "source.css.scss";
var group$9 = "CSS";
var aceMode$a = "scss";
var codemirrorMode$9 = "css";
var codemirrorMimeType$9 = "text/x-scss";
var extensions$a = [
	".scss"
];
var languageId$a = 329;
var SCSS = {
	name: name$c,
	type: type$a,
	tmScope: tmScope$a,
	group: group$9,
	aceMode: aceMode$a,
	codemirrorMode: codemirrorMode$9,
	codemirrorMimeType: codemirrorMimeType$9,
	extensions: extensions$a,
	languageId: languageId$a
};

var SCSS$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$c,
  type: type$a,
  tmScope: tmScope$a,
  group: group$9,
  aceMode: aceMode$a,
  codemirrorMode: codemirrorMode$9,
  codemirrorMimeType: codemirrorMimeType$9,
  extensions: extensions$a,
  languageId: languageId$a,
  'default': SCSS
});

var require$$0$2 = getCjsExportFromNamespace(CSS$1);

var require$$1$1 = getCjsExportFromNamespace(PostCSS$1);

var require$$2$1 = getCjsExportFromNamespace(Less$1);

var require$$3$1 = getCjsExportFromNamespace(SCSS$1);

var languages$1 = [createLanguage(require$$0$2, function (data) {
  return Object.assign(data, {
    since: "1.4.0",
    parsers: ["css"],
    vscodeLanguageIds: ["css"]
  });
}), createLanguage(require$$1$1, function (data) {
  return Object.assign(data, {
    since: "1.4.0",
    parsers: ["css"],
    vscodeLanguageIds: ["postcss"],
    extensions: data.extensions.concat(".postcss")
  });
}), createLanguage(require$$2$1, function (data) {
  return Object.assign(data, {
    since: "1.4.0",
    parsers: ["less"],
    vscodeLanguageIds: ["less"]
  });
}), createLanguage(require$$3$1, function (data) {
  return Object.assign(data, {
    since: "1.4.0",
    parsers: ["scss"],
    vscodeLanguageIds: ["scss"]
  });
})];
var printers$1 = {
  postcss: printerPostcss
};
var languageCss = {
  languages: languages$1,
  options: options$3,
  printers: printers$1
};

var _require$$0$builders$4 = doc.builders,
    concat$a = _require$$0$builders$4.concat,
    join$7 = _require$$0$builders$4.join,
    softline$4 = _require$$0$builders$4.softline,
    hardline$8 = _require$$0$builders$4.hardline,
    line$4 = _require$$0$builders$4.line,
    group$a = _require$$0$builders$4.group,
    indent$6 = _require$$0$builders$4.indent,
    ifBreak$3 = _require$$0$builders$4.ifBreak; // http://w3c.github.io/html/single-page.html#void-elements

var voidTags = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"]; // Formatter based on @glimmerjs/syntax's built-in test formatter:
// https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/syntax/lib/generation/print.ts

function printChildren(path, options, print) {
  return concat$a(path.map(function (childPath, childIndex) {
    var childNode = path.getValue();
    var isFirstNode = childIndex === 0;
    var isLastNode = childIndex == path.getParentNode(0).children.length - 1;
    var isLastNodeInMultiNodeList = isLastNode && !isFirstNode;
    var isWhitespace = isWhitespaceNode(childNode);

    if (isWhitespace && isLastNodeInMultiNodeList) {
      return print(childPath, options, print);
    } else if (isFirstNode) {
      return concat$a([softline$4, print(childPath, options, print)]);
    }

    return print(childPath, options, print);
  }, "children"));
}

function print(path, options, print) {
  var n = path.getValue();
  /* istanbul ignore if*/

  if (!n) {
    return "";
  }

  switch (n.type) {
    case "Block":
    case "Program":
    case "Template":
      {
        return group$a(concat$a(path.map(print, "body").filter(function (text) {
          return text !== "";
        })));
      }

    case "ElementNode":
      {
        var tagFirstChar = n.tag[0];
        var isLocal = n.tag.indexOf(".") !== -1;
        var isGlimmerComponent = tagFirstChar.toUpperCase() === tagFirstChar || isLocal;
        var hasChildren = n.children.length > 0;
        var hasNonWhitespaceChildren = n.children.some(function (n) {
          return !isWhitespaceNode(n);
        });
        var isVoid = isGlimmerComponent && (!hasChildren || !hasNonWhitespaceChildren) || voidTags.indexOf(n.tag) !== -1;
        var closeTagForNoBreak = isVoid ? concat$a([" />", softline$4]) : ">";
        var closeTagForBreak = isVoid ? "/>" : ">";

        var _getParams = function _getParams(path, print) {
          return indent$6(concat$a([n.attributes.length ? line$4 : "", join$7(line$4, path.map(print, "attributes")), n.modifiers.length ? line$4 : "", join$7(line$4, path.map(print, "modifiers")), n.comments.length ? line$4 : "", join$7(line$4, path.map(print, "comments"))]));
        };

        var nextNode = getNextNode(path);
        return concat$a([group$a(concat$a(["<", n.tag, _getParams(path, print), n.blockParams.length ? ` as |${n.blockParams.join(" ")}|` : "", ifBreak$3(softline$4, ""), ifBreak$3(closeTagForBreak, closeTagForNoBreak)])), !isVoid ? group$a(concat$a([hasNonWhitespaceChildren ? indent$6(printChildren(path, options, print)) : "", ifBreak$3(hasChildren ? hardline$8 : "", ""), concat$a(["</", n.tag, ">"])])) : "", nextNode && nextNode.type === "ElementNode" ? hardline$8 : ""]);
      }

    case "BlockStatement":
      {
        var pp = path.getParentNode(1);
        var isElseIf = pp && pp.inverse && pp.inverse.body.length === 1 && pp.inverse.body[0] === n && pp.inverse.body[0].path.parts[0] === "if";
        var hasElseIf = n.inverse && n.inverse.body.length === 1 && n.inverse.body[0].type === "BlockStatement" && n.inverse.body[0].path.parts[0] === "if";
        var indentElse = hasElseIf ? function (a) {
          return a;
        } : indent$6;

        if (n.inverse) {
          return concat$a([isElseIf ? concat$a(["{{else ", printPathParams(path, print), "}}"]) : printOpenBlock(path, print), indent$6(concat$a([hardline$8, path.call(print, "program")])), n.inverse && !hasElseIf ? concat$a([hardline$8, "{{else}}"]) : "", n.inverse ? indentElse(concat$a([hardline$8, path.call(print, "inverse")])) : "", isElseIf ? "" : concat$a([hardline$8, printCloseBlock(path, print)])]);
        } else if (isElseIf) {
          return concat$a([concat$a(["{{else ", printPathParams(path, print), "}}"]), indent$6(concat$a([hardline$8, path.call(print, "program")]))]);
        }

        var _hasNonWhitespaceChildren = n.program.body.some(function (n) {
          return !isWhitespaceNode(n);
        });

        return concat$a([printOpenBlock(path, print), group$a(concat$a([indent$6(concat$a([softline$4, path.call(print, "program")])), _hasNonWhitespaceChildren ? hardline$8 : softline$4, printCloseBlock(path, print)]))]);
      }

    case "ElementModifierStatement":
    case "MustacheStatement":
      {
        var _pp = path.getParentNode(1);

        var isConcat = _pp && _pp.type === "ConcatStatement";
        return group$a(concat$a([n.escaped === false ? "{{{" : "{{", printPathParams(path, print, {
          group: false
        }), isConcat ? "" : softline$4, n.escaped === false ? "}}}" : "}}"]));
      }

    case "SubExpression":
      {
        var params = getParams(path, print);
        var printedParams = params.length > 0 ? indent$6(concat$a([line$4, group$a(join$7(line$4, params))])) : "";
        return group$a(concat$a(["(", printPath(path, print), printedParams, softline$4, ")"]));
      }

    case "AttrNode":
      {
        var isText = n.value.type === "TextNode";

        if (isText && n.value.loc.start.column === n.value.loc.end.column) {
          return concat$a([n.name]);
        }

        var value = path.call(print, "value");
        var quotedValue = isText ? printStringLiteral(value.parts.join(), options) : value;
        return concat$a([n.name, "=", quotedValue]);
      }

    case "ConcatStatement":
      {
        return concat$a(['"', group$a(indent$6(join$7(softline$4, path.map(function (partPath) {
          return print(partPath);
        }, "parts").filter(function (a) {
          return a !== "";
        })))), '"']);
      }

    case "Hash":
      {
        return concat$a([join$7(line$4, path.map(print, "pairs"))]);
      }

    case "HashPair":
      {
        return concat$a([n.key, "=", path.call(print, "value")]);
      }

    case "TextNode":
      {
        var maxLineBreaksToPreserve = 2;
        var isFirstElement = !getPreviousNode(path);
        var isLastElement = !getNextNode(path);
        var isWhitespaceOnly = !/\S/.test(n.chars);
        var lineBreaksCount = countNewLines(n.chars);
        var hasBlockParent = path.getParentNode(0).type === "Block";
        var hasElementParent = path.getParentNode(0).type === "ElementNode";
        var hasTemplateParent = path.getParentNode(0).type === "Template";
        var leadingLineBreaksCount = countLeadingNewLines(n.chars);
        var trailingLineBreaksCount = countTrailingNewLines(n.chars);

        if ((isFirstElement || isLastElement) && isWhitespaceOnly && (hasBlockParent || hasElementParent || hasTemplateParent)) {
          return "";
        }

        if (isWhitespaceOnly && lineBreaksCount) {
          leadingLineBreaksCount = Math.min(lineBreaksCount, maxLineBreaksToPreserve);
          trailingLineBreaksCount = 0;
        } else {
          if (isNextNodeOfType(path, "ElementNode") || isNextNodeOfType(path, "BlockStatement")) {
            trailingLineBreaksCount = Math.max(trailingLineBreaksCount, 1);
          }

          if (isPreviousNodeOfSomeType(path, ["ElementNode"]) || isPreviousNodeOfSomeType(path, ["BlockStatement"])) {
            leadingLineBreaksCount = Math.max(leadingLineBreaksCount, 1);
          }
        }

        var leadingSpace = "";
        var trailingSpace = ""; // preserve a space inside of an attribute node where whitespace present,
        // when next to mustache statement.

        var inAttrNode = path.stack.indexOf("attributes") >= 0;

        if (inAttrNode) {
          var parentNode = path.getParentNode(0);

          var _isConcat = parentNode.type === "ConcatStatement";

          if (_isConcat) {
            var parts = parentNode.parts;
            var partIndex = parts.indexOf(n);

            if (partIndex > 0) {
              var partType = parts[partIndex - 1].type;
              var isMustache = partType === "MustacheStatement";

              if (isMustache) {
                leadingSpace = " ";
              }
            }

            if (partIndex < parts.length - 1) {
              var _partType = parts[partIndex + 1].type;

              var _isMustache = _partType === "MustacheStatement";

              if (_isMustache) {
                trailingSpace = " ";
              }
            }
          }
        } else {
          if (trailingLineBreaksCount === 0 && isNextNodeOfType(path, "MustacheStatement")) {
            trailingSpace = " ";
          }

          if (leadingLineBreaksCount === 0 && isPreviousNodeOfSomeType(path, ["MustacheStatement"])) {
            leadingSpace = " ";
          }

          if (isFirstElement) {
            leadingLineBreaksCount = 0;
            leadingSpace = "";
          }

          if (isLastElement) {
            trailingLineBreaksCount = 0;
            trailingSpace = "";
          }
        }

        return concat$a([].concat(_toConsumableArray$1(generateHardlines(leadingLineBreaksCount, maxLineBreaksToPreserve)), [n.chars.replace(/^[\s ]+/g, leadingSpace).replace(/[\s ]+$/, trailingSpace)], _toConsumableArray$1(generateHardlines(trailingLineBreaksCount, maxLineBreaksToPreserve))).filter(Boolean));
      }

    case "MustacheCommentStatement":
      {
        var dashes = n.value.indexOf("}}") > -1 ? "--" : "";
        return concat$a(["{{!", dashes, n.value, dashes, "}}"]);
      }

    case "PathExpression":
      {
        return n.original;
      }

    case "BooleanLiteral":
      {
        return String(n.value);
      }

    case "CommentStatement":
      {
        return concat$a(["<!--", n.value, "-->"]);
      }

    case "StringLiteral":
      {
        return printStringLiteral(n.value, options);
      }

    case "NumberLiteral":
      {
        return String(n.value);
      }

    case "UndefinedLiteral":
      {
        return "undefined";
      }

    case "NullLiteral":
      {
        return "null";
      }

    /* istanbul ignore next */

    default:
      throw new Error("unknown glimmer type: " + JSON.stringify(n.type));
  }
}
/**
 * Prints a string literal with the correct surrounding quotes based on
 * `options.singleQuote` and the number of escaped quotes contained in
 * the string literal. This function is the glimmer equivalent of `printString`
 * in `common/util`, but has differences because of the way escaped characters
 * are treated in hbs string literals.
 * @param {string} stringLiteral - the string literal value
 * @param {object} options - the prettier options object
 */


function printStringLiteral(stringLiteral, options) {
  var double = {
    quote: '"',
    regex: /"/g
  };
  var single = {
    quote: "'",
    regex: /'/g
  };
  var preferred = options.singleQuote ? single : double;
  var alternate = preferred === single ? double : single;
  var shouldUseAlternateQuote = false; // If `stringLiteral` contains at least one of the quote preferred for
  // enclosing the string, we might want to enclose with the alternate quote
  // instead, to minimize the number of escaped quotes.

  if (stringLiteral.includes(preferred.quote) || stringLiteral.includes(alternate.quote)) {
    var numPreferredQuotes = (stringLiteral.match(preferred.regex) || []).length;
    var numAlternateQuotes = (stringLiteral.match(alternate.regex) || []).length;
    shouldUseAlternateQuote = numPreferredQuotes > numAlternateQuotes;
  }

  var enclosingQuote = shouldUseAlternateQuote ? alternate : preferred;
  var escapedStringLiteral = stringLiteral.replace(enclosingQuote.regex, `\\${enclosingQuote.quote}`);
  return `${enclosingQuote.quote}${escapedStringLiteral}${enclosingQuote.quote}`;
}

function printPath(path, print) {
  return path.call(print, "path");
}

function getParams(path, print) {
  var node = path.getValue();
  var parts = [];

  if (node.params.length > 0) {
    parts = parts.concat(path.map(print, "params"));
  }

  if (node.hash && node.hash.pairs.length > 0) {
    parts.push(path.call(print, "hash"));
  }

  return parts;
}

function printPathParams(path, print, options) {
  var parts = [];
  options = Object.assign({
    group: true
  }, options || {});
  parts.push(printPath(path, print));
  parts = parts.concat(getParams(path, print));

  if (!options.group) {
    return indent$6(join$7(line$4, parts));
  }

  return indent$6(group$a(join$7(line$4, parts)));
}

function printBlockParams(path) {
  var block = path.getValue();

  if (!block.program || !block.program.blockParams.length) {
    return "";
  }

  return concat$a([" as |", block.program.blockParams.join(" "), "|"]);
}

function printOpenBlock(path, print) {
  return group$a(concat$a(["{{#", printPathParams(path, print), printBlockParams(path), softline$4, "}}"]));
}

function printCloseBlock(path, print) {
  return concat$a(["{{/", path.call(print, "path"), "}}"]);
}

function isWhitespaceNode(node) {
  return node.type === "TextNode" && !/\S/.test(node.chars);
}

function getPreviousNode(path) {
  var node = path.getValue();
  var parentNode = path.getParentNode(0);
  var children = parentNode.children || parentNode.body;

  if (children) {
    var nodeIndex = children.indexOf(node);

    if (nodeIndex > 0) {
      var previousNode = children[nodeIndex - 1];
      return previousNode;
    }
  }
}

function getNextNode(path) {
  var node = path.getValue();
  var parentNode = path.getParentNode(0);
  var children = parentNode.children || parentNode.body;

  if (children) {
    var nodeIndex = children.indexOf(node);

    if (nodeIndex < children.length) {
      var nextNode = children[nodeIndex + 1];
      return nextNode;
    }
  }
}

function isPreviousNodeOfSomeType(path, types) {
  var previousNode = getPreviousNode(path);

  if (previousNode) {
    return types.some(function (type) {
      return previousNode.type === type;
    });
  }

  return false;
}

function isNextNodeOfType(path, type) {
  var nextNode = getNextNode(path);
  return nextNode && nextNode.type === type;
}

function clean$3(ast, newObj) {
  delete newObj.loc;
  delete newObj.selfClosing; // (Glimmer/HTML) ignore TextNode whitespace

  if (ast.type === "TextNode") {
    if (ast.chars.replace(/\s+/, "") === "") {
      return null;
    }

    newObj.chars = ast.chars.replace(/^\s+/, "").replace(/\s+$/, "");
  }
}

function countNewLines(string) {
  /* istanbul ignore next */
  string = typeof string === "string" ? string : "";
  return string.split("\n").length - 1;
}

function countLeadingNewLines(string) {
  /* istanbul ignore next */
  string = typeof string === "string" ? string : "";
  var newLines = (string.match(/^([^\S\r\n]*[\r\n])+/g) || [])[0] || "";
  return countNewLines(newLines);
}

function countTrailingNewLines(string) {
  /* istanbul ignore next */
  string = typeof string === "string" ? string : "";
  var newLines = (string.match(/([\r\n][^\S\r\n]*)+$/g) || [])[0] || "";
  return countNewLines(newLines);
}

function generateHardlines() {
  var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return new Array(Math.min(number, max)).fill(hardline$8);
}

var printerGlimmer = {
  print,
  massageAstNode: clean$3
};

var name$d = "Handlebars";
var type$b = "markup";
var group$b = "HTML";
var aliases$3 = [
	"hbs",
	"htmlbars"
];
var extensions$b = [
	".handlebars",
	".hbs"
];
var tmScope$b = "text.html.handlebars";
var aceMode$b = "handlebars";
var languageId$b = 155;
var Handlebars = {
	name: name$d,
	type: type$b,
	group: group$b,
	aliases: aliases$3,
	extensions: extensions$b,
	tmScope: tmScope$b,
	aceMode: aceMode$b,
	languageId: languageId$b
};

var Handlebars$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$d,
  type: type$b,
  group: group$b,
  aliases: aliases$3,
  extensions: extensions$b,
  tmScope: tmScope$b,
  aceMode: aceMode$b,
  languageId: languageId$b,
  'default': Handlebars
});

var require$$0$3 = getCjsExportFromNamespace(Handlebars$1);

var languages$2 = [createLanguage(require$$0$3, function (data) {
  return Object.assign(data, {
    since: null,
    // unreleased
    parsers: ["glimmer"],
    vscodeLanguageIds: ["handlebars"]
  });
})];
var printers$2 = {
  glimmer: printerGlimmer
};
var languageHandlebars = {
  languages: languages$2,
  printers: printers$2
};

function hasPragma$2(text) {
  return /^\s*#[^\n\S]*@(format|prettier)\s*(\n|$)/.test(text);
}

function insertPragma$4(text) {
  return "# @format\n\n" + text;
}

var pragma$2 = {
  hasPragma: hasPragma$2,
  insertPragma: insertPragma$4
};

var _require$$0$builders$5 = doc.builders,
    concat$b = _require$$0$builders$5.concat,
    join$8 = _require$$0$builders$5.join,
    hardline$9 = _require$$0$builders$5.hardline,
    line$5 = _require$$0$builders$5.line,
    softline$5 = _require$$0$builders$5.softline,
    group$c = _require$$0$builders$5.group,
    indent$7 = _require$$0$builders$5.indent,
    ifBreak$4 = _require$$0$builders$5.ifBreak;
var hasIgnoreComment$4 = util.hasIgnoreComment;
var isNextLineEmpty$4 = utilShared.isNextLineEmpty;
var insertPragma$5 = pragma$2.insertPragma;

function genericPrint$3(path, options, print) {
  var n = path.getValue();

  if (!n) {
    return "";
  }

  if (typeof n === "string") {
    return n;
  }

  switch (n.kind) {
    case "Document":
      {
        var parts = [];
        path.map(function (pathChild, index) {
          parts.push(concat$b([pathChild.call(print)]));

          if (index !== n.definitions.length - 1) {
            parts.push(hardline$9);

            if (isNextLineEmpty$4(options.originalText, pathChild.getValue(), options)) {
              parts.push(hardline$9);
            }
          }
        }, "definitions");
        return concat$b([concat$b(parts), hardline$9]);
      }

    case "OperationDefinition":
      {
        var hasOperation = options.originalText[options.locStart(n)] !== "{";
        var hasName = !!n.name;
        return concat$b([hasOperation ? n.operation : "", hasOperation && hasName ? concat$b([" ", path.call(print, "name")]) : "", n.variableDefinitions && n.variableDefinitions.length ? group$c(concat$b(["(", indent$7(concat$b([softline$5, join$8(concat$b([ifBreak$4("", ", "), softline$5]), path.map(print, "variableDefinitions"))])), softline$5, ")"])) : "", printDirectives(path, print, n), n.selectionSet ? !hasOperation && !hasName ? "" : " " : "", path.call(print, "selectionSet")]);
      }

    case "FragmentDefinition":
      {
        return concat$b(["fragment ", path.call(print, "name"), n.variableDefinitions && n.variableDefinitions.length ? group$c(concat$b(["(", indent$7(concat$b([softline$5, join$8(concat$b([ifBreak$4("", ", "), softline$5]), path.map(print, "variableDefinitions"))])), softline$5, ")"])) : "", " on ", path.call(print, "typeCondition"), printDirectives(path, print, n), " ", path.call(print, "selectionSet")]);
      }

    case "SelectionSet":
      {
        return concat$b(["{", indent$7(concat$b([hardline$9, join$8(hardline$9, path.call(function (selectionsPath) {
          return printSequence(selectionsPath, options, print);
        }, "selections"))])), hardline$9, "}"]);
      }

    case "Field":
      {
        return group$c(concat$b([n.alias ? concat$b([path.call(print, "alias"), ": "]) : "", path.call(print, "name"), n.arguments.length > 0 ? group$c(concat$b(["(", indent$7(concat$b([softline$5, join$8(concat$b([ifBreak$4("", ", "), softline$5]), path.call(function (argsPath) {
          return printSequence(argsPath, options, print);
        }, "arguments"))])), softline$5, ")"])) : "", printDirectives(path, print, n), n.selectionSet ? " " : "", path.call(print, "selectionSet")]));
      }

    case "Name":
      {
        return n.value;
      }

    case "StringValue":
      {
        if (n.block) {
          return concat$b(['"""', hardline$9, join$8(hardline$9, n.value.replace(/"""/g, "\\$&").split("\n")), hardline$9, '"""']);
        }

        return concat$b(['"', n.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"']);
      }

    case "IntValue":
    case "FloatValue":
    case "EnumValue":
      {
        return n.value;
      }

    case "BooleanValue":
      {
        return n.value ? "true" : "false";
      }

    case "NullValue":
      {
        return "null";
      }

    case "Variable":
      {
        return concat$b(["$", path.call(print, "name")]);
      }

    case "ListValue":
      {
        return group$c(concat$b(["[", indent$7(concat$b([softline$5, join$8(concat$b([ifBreak$4("", ", "), softline$5]), path.map(print, "values"))])), softline$5, "]"]));
      }

    case "ObjectValue":
      {
        return group$c(concat$b(["{", options.bracketSpacing && n.fields.length > 0 ? " " : "", indent$7(concat$b([softline$5, join$8(concat$b([ifBreak$4("", ", "), softline$5]), path.map(print, "fields"))])), softline$5, ifBreak$4("", options.bracketSpacing && n.fields.length > 0 ? " " : ""), "}"]));
      }

    case "ObjectField":
    case "Argument":
      {
        return concat$b([path.call(print, "name"), ": ", path.call(print, "value")]);
      }

    case "Directive":
      {
        return concat$b(["@", path.call(print, "name"), n.arguments.length > 0 ? group$c(concat$b(["(", indent$7(concat$b([softline$5, join$8(concat$b([ifBreak$4("", ", "), softline$5]), path.call(function (argsPath) {
          return printSequence(argsPath, options, print);
        }, "arguments"))])), softline$5, ")"])) : ""]);
      }

    case "NamedType":
      {
        return path.call(print, "name");
      }

    case "VariableDefinition":
      {
        return concat$b([path.call(print, "variable"), ": ", path.call(print, "type"), n.defaultValue ? concat$b([" = ", path.call(print, "defaultValue")]) : "", printDirectives(path, print, n)]);
      }

    case "TypeExtensionDefinition":
      {
        return concat$b(["extend ", path.call(print, "definition")]);
      }

    case "ObjectTypeExtension":
    case "ObjectTypeDefinition":
      {
        return concat$b([path.call(print, "description"), n.description ? hardline$9 : "", n.kind === "ObjectTypeExtension" ? "extend " : "", "type ", path.call(print, "name"), n.interfaces.length > 0 ? concat$b([" implements ", join$8(determineInterfaceSeparator(options.originalText.substr(options.locStart(n), options.locEnd(n))), path.map(print, "interfaces"))]) : "", printDirectives(path, print, n), n.fields.length > 0 ? concat$b([" {", indent$7(concat$b([hardline$9, join$8(hardline$9, path.call(function (fieldsPath) {
          return printSequence(fieldsPath, options, print);
        }, "fields"))])), hardline$9, "}"]) : ""]);
      }

    case "FieldDefinition":
      {
        return concat$b([path.call(print, "description"), n.description ? hardline$9 : "", path.call(print, "name"), n.arguments.length > 0 ? group$c(concat$b(["(", indent$7(concat$b([softline$5, join$8(concat$b([ifBreak$4("", ", "), softline$5]), path.call(function (argsPath) {
          return printSequence(argsPath, options, print);
        }, "arguments"))])), softline$5, ")"])) : "", ": ", path.call(print, "type"), printDirectives(path, print, n)]);
      }

    case "DirectiveDefinition":
      {
        return concat$b([path.call(print, "description"), n.description ? hardline$9 : "", "directive ", "@", path.call(print, "name"), n.arguments.length > 0 ? group$c(concat$b(["(", indent$7(concat$b([softline$5, join$8(concat$b([ifBreak$4("", ", "), softline$5]), path.call(function (argsPath) {
          return printSequence(argsPath, options, print);
        }, "arguments"))])), softline$5, ")"])) : "", concat$b([" on ", join$8(" | ", path.map(print, "locations"))])]);
      }

    case "EnumTypeExtension":
    case "EnumTypeDefinition":
      {
        return concat$b([path.call(print, "description"), n.description ? hardline$9 : "", n.kind === "EnumTypeExtension" ? "extend " : "", "enum ", path.call(print, "name"), printDirectives(path, print, n), n.values.length > 0 ? concat$b([" {", indent$7(concat$b([hardline$9, join$8(hardline$9, path.call(function (valuesPath) {
          return printSequence(valuesPath, options, print);
        }, "values"))])), hardline$9, "}"]) : ""]);
      }

    case "EnumValueDefinition":
      {
        return concat$b([path.call(print, "description"), n.description ? hardline$9 : "", path.call(print, "name"), printDirectives(path, print, n)]);
      }

    case "InputValueDefinition":
      {
        return concat$b([path.call(print, "description"), n.description ? n.description.block ? hardline$9 : line$5 : "", path.call(print, "name"), ": ", path.call(print, "type"), n.defaultValue ? concat$b([" = ", path.call(print, "defaultValue")]) : "", printDirectives(path, print, n)]);
      }

    case "InputObjectTypeExtension":
    case "InputObjectTypeDefinition":
      {
        return concat$b([path.call(print, "description"), n.description ? hardline$9 : "", n.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", path.call(print, "name"), printDirectives(path, print, n), n.fields.length > 0 ? concat$b([" {", indent$7(concat$b([hardline$9, join$8(hardline$9, path.call(function (fieldsPath) {
          return printSequence(fieldsPath, options, print);
        }, "fields"))])), hardline$9, "}"]) : ""]);
      }

    case "SchemaDefinition":
      {
        return concat$b(["schema", printDirectives(path, print, n), " {", n.operationTypes.length > 0 ? indent$7(concat$b([hardline$9, join$8(hardline$9, path.call(function (opsPath) {
          return printSequence(opsPath, options, print);
        }, "operationTypes"))])) : "", hardline$9, "}"]);
      }

    case "OperationTypeDefinition":
      {
        return concat$b([path.call(print, "operation"), ": ", path.call(print, "type")]);
      }

    case "InterfaceTypeExtension":
    case "InterfaceTypeDefinition":
      {
        return concat$b([path.call(print, "description"), n.description ? hardline$9 : "", n.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", path.call(print, "name"), printDirectives(path, print, n), n.fields.length > 0 ? concat$b([" {", indent$7(concat$b([hardline$9, join$8(hardline$9, path.call(function (fieldsPath) {
          return printSequence(fieldsPath, options, print);
        }, "fields"))])), hardline$9, "}"]) : ""]);
      }

    case "FragmentSpread":
      {
        return concat$b(["...", path.call(print, "name"), printDirectives(path, print, n)]);
      }

    case "InlineFragment":
      {
        return concat$b(["...", n.typeCondition ? concat$b([" on ", path.call(print, "typeCondition")]) : "", printDirectives(path, print, n), " ", path.call(print, "selectionSet")]);
      }

    case "UnionTypeExtension":
    case "UnionTypeDefinition":
      {
        return group$c(concat$b([path.call(print, "description"), n.description ? hardline$9 : "", group$c(concat$b([n.kind === "UnionTypeExtension" ? "extend " : "", "union ", path.call(print, "name"), printDirectives(path, print, n), n.types.length > 0 ? concat$b([" =", ifBreak$4("", " "), indent$7(concat$b([ifBreak$4(concat$b([line$5, "  "])), join$8(concat$b([line$5, "| "]), path.map(print, "types"))]))]) : ""]))]));
      }

    case "ScalarTypeExtension":
    case "ScalarTypeDefinition":
      {
        return concat$b([path.call(print, "description"), n.description ? hardline$9 : "", n.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", path.call(print, "name"), printDirectives(path, print, n)]);
      }

    case "NonNullType":
      {
        return concat$b([path.call(print, "type"), "!"]);
      }

    case "ListType":
      {
        return concat$b(["[", path.call(print, "type"), "]"]);
      }

    default:
      /* istanbul ignore next */
      throw new Error("unknown graphql type: " + JSON.stringify(n.kind));
  }
}

function printDirectives(path, print, n) {
  if (n.directives.length === 0) {
    return "";
  }

  return concat$b([" ", group$c(indent$7(concat$b([softline$5, join$8(concat$b([ifBreak$4("", " "), softline$5]), path.map(print, "directives"))])))]);
}

function printSequence(sequencePath, options, print) {
  var count = sequencePath.getValue().length;
  return sequencePath.map(function (path, i) {
    var printed = print(path);

    if (isNextLineEmpty$4(options.originalText, path.getValue(), options) && i < count - 1) {
      return concat$b([printed, hardline$9]);
    }

    return printed;
  });
}

function canAttachComment$1(node) {
  return node.kind && node.kind !== "Comment";
}

function printComment$2(commentPath) {
  var comment = commentPath.getValue();

  if (comment.kind === "Comment") {
    return "#" + comment.value.trimRight();
  }

  throw new Error("Not a comment: " + JSON.stringify(comment));
}

function determineInterfaceSeparator(originalSource) {
  var start = originalSource.indexOf("implements");

  if (start === -1) {
    throw new Error("Must implement interfaces: " + originalSource);
  }

  var end = originalSource.indexOf("{");

  if (end === -1) {
    end = originalSource.length;
  }

  return originalSource.substr(start, end).includes("&") ? " & " : ", ";
}

function clean$4(node, newNode
/*, parent*/
) {
  delete newNode.loc;
  delete newNode.comments;
}

var printerGraphql = {
  print: genericPrint$3,
  massageAstNode: clean$4,
  hasPrettierIgnore: hasIgnoreComment$4,
  insertPragma: insertPragma$5,
  printComment: printComment$2,
  canAttachComment: canAttachComment$1
};

var options$4 = {
  bracketSpacing: commonOptions.bracketSpacing
};

var name$e = "GraphQL";
var type$c = "data";
var extensions$c = [
	".graphql",
	".gql",
	".graphqls"
];
var tmScope$c = "source.graphql";
var aceMode$c = "text";
var languageId$c = 139;
var GraphQL = {
	name: name$e,
	type: type$c,
	extensions: extensions$c,
	tmScope: tmScope$c,
	aceMode: aceMode$c,
	languageId: languageId$c
};

var GraphQL$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$e,
  type: type$c,
  extensions: extensions$c,
  tmScope: tmScope$c,
  aceMode: aceMode$c,
  languageId: languageId$c,
  'default': GraphQL
});

var require$$0$4 = getCjsExportFromNamespace(GraphQL$1);

var languages$3 = [createLanguage(require$$0$4, function (data) {
  return Object.assign(data, {
    since: "1.5.0",
    parsers: ["graphql"],
    vscodeLanguageIds: ["graphql"]
  });
})];
var printers$3 = {
  graphql: printerGraphql
};
var languageGraphql = {
  languages: languages$3,
  options: options$4,
  printers: printers$3
};

var json = {
  "cjkPattern": "[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u3000-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d]",
  "kPattern": "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",
  "punctuationPattern": "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"
};

var cjkPattern = json.cjkPattern,
    kPattern = json.kPattern,
    punctuationPattern = json.punctuationPattern;
var getLast$3 = util.getLast;
var INLINE_NODE_TYPES = ["liquidNode", "inlineCode", "emphasis", "strong", "delete", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"];
var INLINE_NODE_WRAPPER_TYPES = INLINE_NODE_TYPES.concat(["tableCell", "paragraph", "heading"]);
var kRegex = new RegExp(kPattern);
var punctuationRegex = new RegExp(punctuationPattern);
/**
 * split text into whitespaces and words
 * @param {string} text
 * @return {Array<{ type: "whitespace", value: " " | "\n" | "" } | { type: "word", value: string }>}
 */

function splitText(text, options) {
  var KIND_NON_CJK = "non-cjk";
  var KIND_CJ_LETTER = "cj-letter";
  var KIND_K_LETTER = "k-letter";
  var KIND_CJK_PUNCTUATION = "cjk-punctuation";
  var nodes = [];
  (options.proseWrap === "preserve" ? text : text.replace(new RegExp(`(${cjkPattern})\n(${cjkPattern})`, "g"), "$1$2")).split(/([ \t\n]+)/).forEach(function (token, index, tokens) {
    // whitespace
    if (index % 2 === 1) {
      nodes.push({
        type: "whitespace",
        value: /\n/.test(token) ? "\n" : " "
      });
      return;
    } // word separated by whitespace


    if ((index === 0 || index === tokens.length - 1) && token === "") {
      return;
    }

    token.split(new RegExp(`(${cjkPattern})`)).forEach(function (innerToken, innerIndex, innerTokens) {
      if ((innerIndex === 0 || innerIndex === innerTokens.length - 1) && innerToken === "") {
        return;
      } // non-CJK word


      if (innerIndex % 2 === 0) {
        if (innerToken !== "") {
          appendNode({
            type: "word",
            value: innerToken,
            kind: KIND_NON_CJK,
            hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),
            hasTrailingPunctuation: punctuationRegex.test(getLast$3(innerToken))
          });
        }

        return;
      } // CJK character


      appendNode(punctuationRegex.test(innerToken) ? {
        type: "word",
        value: innerToken,
        kind: KIND_CJK_PUNCTUATION,
        hasLeadingPunctuation: true,
        hasTrailingPunctuation: true
      } : {
        type: "word",
        value: innerToken,
        kind: kRegex.test(innerToken) ? KIND_K_LETTER : KIND_CJ_LETTER,
        hasLeadingPunctuation: false,
        hasTrailingPunctuation: false
      });
    });
  });
  return nodes;

  function appendNode(node) {
    var lastNode = getLast$3(nodes);

    if (lastNode && lastNode.type === "word") {
      if (lastNode.kind === KIND_NON_CJK && node.kind === KIND_CJ_LETTER && !lastNode.hasTrailingPunctuation || lastNode.kind === KIND_CJ_LETTER && node.kind === KIND_NON_CJK && !node.hasLeadingPunctuation) {
        nodes.push({
          type: "whitespace",
          value: " "
        });
      } else if (!isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) && // disallow leading/trailing full-width whitespace
      ![lastNode.value, node.value].some(function (value) {
        return /\u3000/.test(value);
      })) {
        nodes.push({
          type: "whitespace",
          value: ""
        });
      }
    }

    nodes.push(node);

    function isBetween(kind1, kind2) {
      return lastNode.kind === kind1 && node.kind === kind2 || lastNode.kind === kind2 && node.kind === kind1;
    }
  }
}

function getOrderedListItemInfo(orderListItem, originalText) {
  var _originalText$slice$m = originalText.slice(orderListItem.position.start.offset, orderListItem.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/),
      _originalText$slice$m2 = _slicedToArray(_originalText$slice$m, 4),
      numberText = _originalText$slice$m2[1],
      marker = _originalText$slice$m2[2],
      leadingSpaces = _originalText$slice$m2[3];

  return {
    numberText,
    marker,
    leadingSpaces
  };
} // workaround for https://github.com/remarkjs/remark/issues/351
// leading and trailing newlines are stripped by remark


function getFencedCodeBlockValue(node, originalText) {
  var text = originalText.slice(node.position.start.offset, node.position.end.offset);
  var leadingSpaceCount = text.match(/^\s*/)[0].length;
  var replaceRegex = new RegExp(`^\\s{0,${leadingSpaceCount}}`);
  var lineContents = text.split("\n");
  var markerStyle = text[leadingSpaceCount]; // ` or ~

  var marker = text.slice(leadingSpaceCount).match(new RegExp(`^[${markerStyle}]+`))[0]; // https://spec.commonmark.org/0.28/#example-104: Closing fences may be indented by 0-3 spaces
  // https://spec.commonmark.org/0.28/#example-93: The closing code fence must be at least as long as the opening fence

  var hasEndMarker = new RegExp(`^\\s{0,3}${marker}`).test(lineContents[lineContents.length - 1].slice(getIndent(lineContents.length - 1)));
  return lineContents.slice(1, hasEndMarker ? -1 : undefined).map(function (x, i) {
    return x.slice(getIndent(i + 1)).replace(replaceRegex, "");
  }).join("\n");

  function getIndent(lineIndex) {
    return node.position.indent[lineIndex - 1] - 1;
  }
}

function mapAst(ast, handler) {
  return function preorder(node, index, parentStack) {
    parentStack = parentStack || [];
    var newNode = handler(node, index, parentStack);

    if (Array.isArray(newNode)) {
      return newNode;
    }

    newNode = Object.assign({}, newNode);

    if (newNode.children) {
      newNode.children = newNode.children.reduce(function (nodes, child, index) {
        var newNodes = preorder(child, index, [newNode].concat(parentStack));

        if (!Array.isArray(newNodes)) {
          newNodes = [newNodes];
        }

        nodes.push.apply(nodes, newNodes);
        return nodes;
      }, []);
    }

    return newNode;
  }(ast, null, null);
}

var utils$4 = {
  mapAst,
  splitText,
  punctuationPattern,
  getFencedCodeBlockValue,
  getOrderedListItemInfo,
  INLINE_NODE_TYPES,
  INLINE_NODE_WRAPPER_TYPES
};

var _require$$0$builders$6 = doc.builders,
    hardline$a = _require$$0$builders$6.hardline,
    literalline$4 = _require$$0$builders$6.literalline,
    concat$c = _require$$0$builders$6.concat,
    markAsRoot$2 = _require$$0$builders$6.markAsRoot,
    mapDoc$5 = doc.utils.mapDoc;
var getFencedCodeBlockValue$1 = utils$4.getFencedCodeBlockValue;

function embed$2(path, print, textToDoc, options) {
  var node = path.getValue();

  if (node.type === "code" && node.lang !== null) {
    // only look for the first string so as to support [markdown-preview-enhanced](https://shd101wyy.github.io/markdown-preview-enhanced/#/code-chunk)
    var langMatch = node.lang.match(/^[A-Za-z0-9_-]+/);
    var lang = langMatch ? langMatch[0] : "";
    var parser = getParserName(lang);

    if (parser) {
      var styleUnit = options.__inJsTemplate ? "~" : "`";
      var style = styleUnit.repeat(Math.max(3, util.getMaxContinuousCount(node.value, styleUnit) + 1));
      var doc = textToDoc(getFencedCodeBlockValue$1(node, options.originalText), {
        parser
      });
      return markAsRoot$2(concat$c([style, node.lang, hardline$a, replaceNewlinesWithLiterallines(doc), style]));
    }
  }

  if (node.type === "yaml") {
    return markAsRoot$2(concat$c(["---", hardline$a, node.value && node.value.trim() ? replaceNewlinesWithLiterallines(textToDoc(node.value, {
      parser: "yaml"
    })) : "", "---"]));
  } // MDX


  switch (node.type) {
    case "importExport":
      return textToDoc(node.value, {
        parser: "babel"
      });

    case "jsx":
      return textToDoc(node.value, {
        parser: "__js_expression"
      });
  }

  return null;

  function getParserName(lang) {
    var supportInfo = support.getSupportInfo(null, {
      plugins: options.plugins
    });
    var language = supportInfo.languages.find(function (language) {
      return language.name.toLowerCase() === lang || language.aliases && language.aliases.indexOf(lang) !== -1 || language.extensions && language.extensions.find(function (ext) {
        return ext.substring(1) === lang;
      });
    });

    if (language) {
      return language.parsers[0];
    }

    return null;
  }

  function replaceNewlinesWithLiterallines(doc) {
    return mapDoc$5(doc, function (currentDoc) {
      return typeof currentDoc === "string" && currentDoc.includes("\n") ? concat$c(currentDoc.split(/(\n)/g).map(function (v, i) {
        return i % 2 === 0 ? v : literalline$4;
      })) : currentDoc;
    });
  }
}

var embed_1$2 = embed$2;

var pragmas = ["format", "prettier"];

function startWithPragma(text) {
  var pragma = `@(${pragmas.join("|")})`;
  var regex = new RegExp([`<!--\\s*${pragma}\\s*-->`, `<!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*${pragma}[^\\S\n]*($|\n)[\\s\\S]*\n.*-->`].join("|"), "m");
  var matched = text.match(regex);
  return matched && matched.index === 0;
}

var pragma$3 = {
  startWithPragma,
  hasPragma: function hasPragma(text) {
    return startWithPragma(frontMatter(text).content.trimLeft());
  },
  insertPragma: function insertPragma(text) {
    var extracted = frontMatter(text);
    var pragma = `<!-- @${pragmas[0]} -->`;
    return extracted.frontMatter ? `${extracted.frontMatter.raw}\n\n${pragma}\n\n${extracted.content}` : `${pragma}\n\n${extracted.content}`;
  }
};

var getOrderedListItemInfo$1 = utils$4.getOrderedListItemInfo,
    mapAst$1 = utils$4.mapAst,
    splitText$1 = utils$4.splitText; // 0x0 ~ 0x10ffff
// eslint-disable-next-line no-control-regex

var isSingleCharRegex = /^([\u0000-\uffff]|[\ud800-\udbff][\udc00-\udfff])$/;

function preprocess$1(ast, options) {
  ast = restoreUnescapedCharacter(ast, options);
  ast = mergeContinuousTexts(ast);
  ast = transformInlineCode(ast);
  ast = transformIndentedCodeblockAndMarkItsParentList(ast, options);
  ast = markAlignedList(ast, options);
  ast = splitTextIntoSentences(ast, options);
  ast = transformImportExport(ast);
  ast = mergeContinuousImportExport(ast);
  return ast;
}

function transformImportExport(ast) {
  return mapAst$1(ast, function (node) {
    if (node.type !== "import" && node.type !== "export") {
      return node;
    }

    return Object.assign({}, node, {
      type: "importExport"
    });
  });
}

function transformInlineCode(ast) {
  return mapAst$1(ast, function (node) {
    if (node.type !== "inlineCode") {
      return node;
    }

    return Object.assign({}, node, {
      value: node.value.replace(/\s+/g, " ")
    });
  });
}

function restoreUnescapedCharacter(ast, options) {
  return mapAst$1(ast, function (node) {
    return node.type !== "text" ? node : Object.assign({}, node, {
      value: node.value !== "*" && node.value !== "_" && node.value !== "$" && // handle these cases in printer
      isSingleCharRegex.test(node.value) && node.position.end.offset - node.position.start.offset !== node.value.length ? options.originalText.slice(node.position.start.offset, node.position.end.offset) : node.value
    });
  });
}

function mergeContinuousImportExport(ast) {
  return mergeChildren(ast, function (prevNode, node) {
    return prevNode.type === "importExport" && node.type === "importExport";
  }, function (prevNode, node) {
    return {
      type: "importExport",
      value: prevNode.value + "\n\n" + node.value,
      position: {
        start: prevNode.position.start,
        end: node.position.end
      }
    };
  });
}

function mergeChildren(ast, shouldMerge, mergeNode) {
  return mapAst$1(ast, function (node) {
    if (!node.children) {
      return node;
    }

    var children = node.children.reduce(function (current, child) {
      var lastChild = current[current.length - 1];

      if (lastChild && shouldMerge(lastChild, child)) {
        current.splice(-1, 1, mergeNode(lastChild, child));
      } else {
        current.push(child);
      }

      return current;
    }, []);
    return Object.assign({}, node, {
      children
    });
  });
}

function mergeContinuousTexts(ast) {
  return mergeChildren(ast, function (prevNode, node) {
    return prevNode.type === "text" && node.type === "text";
  }, function (prevNode, node) {
    return {
      type: "text",
      value: prevNode.value + node.value,
      position: {
        start: prevNode.position.start,
        end: node.position.end
      }
    };
  });
}

function splitTextIntoSentences(ast, options) {
  return mapAst$1(ast, function (node, index, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        parentNode = _ref2[0];

    if (node.type !== "text") {
      return node;
    }

    var value = node.value;

    if (parentNode.type === "paragraph") {
      if (index === 0) {
        value = value.trimLeft();
      }

      if (index === parentNode.children.length - 1) {
        value = value.trimRight();
      }
    }

    return {
      type: "sentence",
      position: node.position,
      children: splitText$1(value, options)
    };
  });
}

function transformIndentedCodeblockAndMarkItsParentList(ast, options) {
  return mapAst$1(ast, function (node, index, parentStack) {
    if (node.type === "code") {
      // the first char may point to `\n`, e.g. `\n\t\tbar`, just ignore it
      var isIndented = /^\n?( {4,}|\t)/.test(options.originalText.slice(node.position.start.offset, node.position.end.offset));
      node.isIndented = isIndented;

      if (isIndented) {
        for (var i = 0; i < parentStack.length; i++) {
          var parent = parentStack[i]; // no need to check checked items

          if (parent.hasIndentedCodeblock) {
            break;
          }

          if (parent.type === "list") {
            parent.hasIndentedCodeblock = true;
          }
        }
      }
    }

    return node;
  });
}

function markAlignedList(ast, options) {
  return mapAst$1(ast, function (node, index, parentStack) {
    if (node.type === "list" && node.children.length !== 0) {
      // if one of its parents is not aligned, it's not possible to be aligned in sub-lists
      for (var i = 0; i < parentStack.length; i++) {
        var parent = parentStack[i];

        if (parent.type === "list" && !parent.isAligned) {
          node.isAligned = false;
          return node;
        }
      }

      node.isAligned = isAligned(node);
    }

    return node;
  });

  function getListItemStart(listItem) {
    return listItem.children.length === 0 ? -1 : listItem.children[0].position.start.column - 1;
  }

  function isAligned(list) {
    if (!list.ordered) {
      /**
       * - 123
       * - 123
       */
      return true;
    }

    var _list$children = _slicedToArray(list.children, 2),
        firstItem = _list$children[0],
        secondItem = _list$children[1];

    var firstInfo = getOrderedListItemInfo$1(firstItem, options.originalText);

    if (firstInfo.leadingSpaces.length > 1) {
      /**
       * 1.   123
       *
       * 1.   123
       * 1. 123
       */
      return true;
    }

    var firstStart = getListItemStart(firstItem);

    if (firstStart === -1) {
      /**
       * 1.
       *
       * 1.
       * 1.
       */
      return false;
    }

    if (list.children.length === 1) {
      /**
       * aligned:
       *
       * 11. 123
       *
       * not aligned:
       *
       * 1. 123
       */
      return firstStart % options.tabWidth === 0;
    }

    var secondStart = getListItemStart(secondItem);

    if (firstStart !== secondStart) {
      /**
       * 11. 123
       * 1. 123
       *
       * 1. 123
       * 11. 123
       */
      return false;
    }

    if (firstStart % options.tabWidth === 0) {
      /**
       * 11. 123
       * 12. 123
       */
      return true;
    }
    /**
     * aligned:
     *
     * 11. 123
     * 1.  123
     *
     * not aligned:
     *
     * 1. 123
     * 2. 123
     */


    var secondInfo = getOrderedListItemInfo$1(secondItem, options.originalText);
    return secondInfo.leadingSpaces.length > 1;
  }
}

var preprocess_1$1 = preprocess$1;

var _require$$0$builders$7 = doc.builders,
    breakParent$3 = _require$$0$builders$7.breakParent,
    concat$d = _require$$0$builders$7.concat,
    join$9 = _require$$0$builders$7.join,
    line$6 = _require$$0$builders$7.line,
    literalline$5 = _require$$0$builders$7.literalline,
    markAsRoot$3 = _require$$0$builders$7.markAsRoot,
    hardline$b = _require$$0$builders$7.hardline,
    softline$6 = _require$$0$builders$7.softline,
    ifBreak$5 = _require$$0$builders$7.ifBreak,
    fill$4 = _require$$0$builders$7.fill,
    align$2 = _require$$0$builders$7.align,
    indent$8 = _require$$0$builders$7.indent,
    group$d = _require$$0$builders$7.group,
    mapDoc$6 = doc.utils.mapDoc,
    printDocToString$3 = doc.printer.printDocToString;
var getFencedCodeBlockValue$2 = utils$4.getFencedCodeBlockValue,
    getOrderedListItemInfo$2 = utils$4.getOrderedListItemInfo,
    splitText$2 = utils$4.splitText,
    punctuationPattern$1 = utils$4.punctuationPattern,
    INLINE_NODE_TYPES$1 = utils$4.INLINE_NODE_TYPES,
    INLINE_NODE_WRAPPER_TYPES$1 = utils$4.INLINE_NODE_WRAPPER_TYPES;
var replaceEndOfLineWith$1 = util.replaceEndOfLineWith;
var TRAILING_HARDLINE_NODES = ["importExport"];
var SINGLE_LINE_NODE_TYPES = ["heading", "tableCell", "link"];
var SIBLING_NODE_TYPES = ["listItem", "definition", "footnoteDefinition", "jsx"];

function genericPrint$4(path, options, print) {
  var node = path.getValue();

  if (shouldRemainTheSameContent(path)) {
    return concat$d(splitText$2(options.originalText.slice(node.position.start.offset, node.position.end.offset), options).map(function (node) {
      return node.type === "word" ? node.value : node.value === "" ? "" : printLine(path, node.value, options);
    }));
  }

  switch (node.type) {
    case "root":
      if (node.children.length === 0) {
        return "";
      }

      return concat$d([normalizeDoc(printRoot(path, options, print)), TRAILING_HARDLINE_NODES.indexOf(getLastDescendantNode(node).type) === -1 ? hardline$b : ""]);

    case "paragraph":
      return printChildren$1(path, options, print, {
        postprocessor: fill$4
      });

    case "sentence":
      return printChildren$1(path, options, print);

    case "word":
      return node.value.replace(/[*$]/g, "\\$&") // escape all `*` and `$` (math)
      .replace(new RegExp([`(^|${punctuationPattern$1})(_+)`, `(_+)(${punctuationPattern$1}|$)`].join("|"), "g"), function (_, text1, underscore1, underscore2, text2) {
        return (underscore1 ? `${text1}${underscore1}` : `${underscore2}${text2}`).replace(/_/g, "\\_");
      });
    // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis

    case "whitespace":
      {
        var parentNode = path.getParentNode();
        var index = parentNode.children.indexOf(node);
        var nextNode = parentNode.children[index + 1];
        var proseWrap = // leading char that may cause different syntax
        nextNode && /^>|^([-+*]|#{1,6}|[0-9]+[.)])$/.test(nextNode.value) ? "never" : options.proseWrap;
        return printLine(path, node.value, {
          proseWrap
        });
      }

    case "emphasis":
      {
        var _parentNode = path.getParentNode();

        var _index = _parentNode.children.indexOf(node);

        var prevNode = _parentNode.children[_index - 1];
        var _nextNode = _parentNode.children[_index + 1];
        var hasPrevOrNextWord = // `1*2*3` is considered emphasis but `1_2_3` is not
        prevNode && prevNode.type === "sentence" && prevNode.children.length > 0 && util.getLast(prevNode.children).type === "word" && !util.getLast(prevNode.children).hasTrailingPunctuation || _nextNode && _nextNode.type === "sentence" && _nextNode.children.length > 0 && _nextNode.children[0].type === "word" && !_nextNode.children[0].hasLeadingPunctuation;
        var style = hasPrevOrNextWord || getAncestorNode$2(path, "emphasis") ? "*" : "_";
        return concat$d([style, printChildren$1(path, options, print), style]);
      }

    case "strong":
      return concat$d(["**", printChildren$1(path, options, print), "**"]);

    case "delete":
      return concat$d(["~~", printChildren$1(path, options, print), "~~"]);

    case "inlineCode":
      {
        var backtickCount = util.getMinNotPresentContinuousCount(node.value, "`");

        var _style = "`".repeat(backtickCount || 1);

        var gap = backtickCount ? " " : "";
        return concat$d([_style, gap, node.value, gap, _style]);
      }

    case "link":
      switch (options.originalText[node.position.start.offset]) {
        case "<":
          {
            var mailto = "mailto:";
            var url = // <hello@example.com> is parsed as { url: "mailto:hello@example.com" }
            node.url.startsWith(mailto) && options.originalText.slice(node.position.start.offset + 1, node.position.start.offset + 1 + mailto.length) !== mailto ? node.url.slice(mailto.length) : node.url;
            return concat$d(["<", url, ">"]);
          }

        case "[":
          return concat$d(["[", printChildren$1(path, options, print), "](", printUrl(node.url, ")"), printTitle(node.title, options), ")"]);

        default:
          return options.originalText.slice(node.position.start.offset, node.position.end.offset);
      }

    case "image":
      return concat$d(["![", node.alt || "", "](", printUrl(node.url, ")"), printTitle(node.title, options), ")"]);

    case "blockquote":
      return concat$d(["> ", align$2("> ", printChildren$1(path, options, print))]);

    case "heading":
      return concat$d(["#".repeat(node.depth) + " ", printChildren$1(path, options, print)]);

    case "code":
      {
        if (node.isIndented) {
          // indented code block
          var alignment = " ".repeat(4);
          return align$2(alignment, concat$d([alignment, concat$d(replaceEndOfLineWith$1(node.value, hardline$b))]));
        } // fenced code block


        var styleUnit = options.__inJsTemplate ? "~" : "`";

        var _style2 = styleUnit.repeat(Math.max(3, util.getMaxContinuousCount(node.value, styleUnit) + 1));

        return concat$d([_style2, node.lang || "", hardline$b, concat$d(replaceEndOfLineWith$1(getFencedCodeBlockValue$2(node, options.originalText), hardline$b)), hardline$b, _style2]);
      }

    case "yaml":
    case "toml":
      return options.originalText.slice(node.position.start.offset, node.position.end.offset);

    case "html":
      {
        var _parentNode2 = path.getParentNode();

        var value = _parentNode2.type === "root" && util.getLast(_parentNode2.children) === node ? node.value.trimRight() : node.value;
        var isHtmlComment = /^<!--[\s\S]*-->$/.test(value);
        return concat$d(replaceEndOfLineWith$1(value, isHtmlComment ? hardline$b : markAsRoot$3(literalline$5)));
      }

    case "list":
      {
        var nthSiblingIndex = getNthListSiblingIndex(node, path.getParentNode());
        var isGitDiffFriendlyOrderedList = node.ordered && node.children.length > 1 && +getOrderedListItemInfo$2(node.children[1], options.originalText).numberText === 1;
        return printChildren$1(path, options, print, {
          processor: function processor(childPath, index) {
            var prefix = getPrefix();
            return concat$d([prefix, align$2(" ".repeat(prefix.length), printListItem(childPath, options, print, prefix))]);

            function getPrefix() {
              var rawPrefix = node.ordered ? (index === 0 ? node.start : isGitDiffFriendlyOrderedList ? 1 : node.start + index) + (nthSiblingIndex % 2 === 0 ? ". " : ") ") : nthSiblingIndex % 2 === 0 ? "- " : "* ";
              return node.isAligned ||
              /* workaround for https://github.com/remarkjs/remark/issues/315 */
              node.hasIndentedCodeblock ? alignListPrefix(rawPrefix, options) : rawPrefix;
            }
          }
        });
      }

    case "thematicBreak":
      {
        var counter = getAncestorCounter$1(path, "list");

        if (counter === -1) {
          return "---";
        }

        var _nthSiblingIndex = getNthListSiblingIndex(path.getParentNode(counter), path.getParentNode(counter + 1));

        return _nthSiblingIndex % 2 === 0 ? "***" : "---";
      }

    case "linkReference":
      return concat$d(["[", printChildren$1(path, options, print), "]", node.referenceType === "full" ? concat$d(["[", node.identifier, "]"]) : node.referenceType === "collapsed" ? "[]" : ""]);

    case "imageReference":
      switch (node.referenceType) {
        case "full":
          return concat$d(["![", node.alt || "", "][", node.identifier, "]"]);

        default:
          return concat$d(["![", node.alt, "]", node.referenceType === "collapsed" ? "[]" : ""]);
      }

    case "definition":
      {
        var lineOrSpace = options.proseWrap === "always" ? line$6 : " ";
        return group$d(concat$d([concat$d(["[", node.identifier, "]:"]), indent$8(concat$d([lineOrSpace, printUrl(node.url), node.title === null ? "" : concat$d([lineOrSpace, printTitle(node.title, options, false)])]))]));
      }

    case "footnote":
      return concat$d(["[^", printChildren$1(path, options, print), "]"]);

    case "footnoteReference":
      return concat$d(["[^", node.identifier, "]"]);

    case "footnoteDefinition":
      {
        var _nextNode2 = path.getParentNode().children[path.getName() + 1];
        var shouldInlineFootnote = node.children.length === 1 && node.children[0].type === "paragraph" && (options.proseWrap === "never" || options.proseWrap === "preserve" && node.children[0].position.start.line === node.children[0].position.end.line);
        return concat$d(["[^", node.identifier, "]: ", shouldInlineFootnote ? printChildren$1(path, options, print) : group$d(concat$d([align$2(" ".repeat(options.tabWidth), printChildren$1(path, options, print, {
          processor: function processor(childPath, index) {
            return index === 0 ? group$d(concat$d([softline$6, softline$6, childPath.call(print)])) : childPath.call(print);
          }
        })), _nextNode2 && _nextNode2.type === "footnoteDefinition" ? softline$6 : ""]))]);
      }

    case "table":
      return printTable(path, options, print);

    case "tableCell":
      return printChildren$1(path, options, print);

    case "break":
      return /\s/.test(options.originalText[node.position.start.offset]) ? concat$d(["  ", markAsRoot$3(literalline$5)]) : concat$d(["\\", hardline$b]);

    case "liquidNode":
      return concat$d(replaceEndOfLineWith$1(node.value, hardline$b));
    // MDX

    case "importExport":
    case "jsx":
      return node.value;
    // fallback to the original text if multiparser failed

    case "math":
      return concat$d(["$$", hardline$b, node.value ? concat$d([concat$d(replaceEndOfLineWith$1(node.value, hardline$b)), hardline$b]) : "", "$$"]);

    case "inlineMath":
      {
        // remark-math trims content but we don't want to remove whitespaces
        // since it's very possible that it's recognized as math accidentally
        return options.originalText.slice(options.locStart(node), options.locEnd(node));
      }

    case "tableRow": // handled in "table"

    case "listItem": // handled in "list"

    default:
      throw new Error(`Unknown markdown type ${JSON.stringify(node.type)}`);
  }
}

function printListItem(path, options, print, listPrefix) {
  var node = path.getValue();
  var prefix = node.checked === null ? "" : node.checked ? "[x] " : "[ ] ";
  return concat$d([prefix, printChildren$1(path, options, print, {
    processor: function processor(childPath, index) {
      if (index === 0 && childPath.getValue().type !== "list") {
        return align$2(" ".repeat(prefix.length), childPath.call(print));
      }

      var alignment = " ".repeat(clamp(options.tabWidth - listPrefix.length, 0, 3) // 4+ will cause indented code block
      );
      return concat$d([alignment, align$2(alignment, childPath.call(print))]);
    }
  })]);
}

function alignListPrefix(prefix, options) {
  var additionalSpaces = getAdditionalSpaces();
  return prefix + " ".repeat(additionalSpaces >= 4 ? 0 : additionalSpaces // 4+ will cause indented code block
  );

  function getAdditionalSpaces() {
    var restSpaces = prefix.length % options.tabWidth;
    return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;
  }
}

function getNthListSiblingIndex(node, parentNode) {
  return getNthSiblingIndex(node, parentNode, function (siblingNode) {
    return siblingNode.ordered === node.ordered;
  });
}

function getNthSiblingIndex(node, parentNode, condition) {
  condition = condition || function () {
    return true;
  };

  var index = -1;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = parentNode.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var childNode = _step.value;

      if (childNode.type === node.type && condition(childNode)) {
        index++;
      } else {
        index = -1;
      }

      if (childNode === node) {
        return index;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function getAncestorCounter$1(path, typeOrTypes) {
  var types = [].concat(typeOrTypes);
  var counter = -1;
  var ancestorNode;

  while (ancestorNode = path.getParentNode(++counter)) {
    if (types.indexOf(ancestorNode.type) !== -1) {
      return counter;
    }
  }

  return -1;
}

function getAncestorNode$2(path, typeOrTypes) {
  var counter = getAncestorCounter$1(path, typeOrTypes);
  return counter === -1 ? null : path.getParentNode(counter);
}

function printLine(path, value, options) {
  if (options.proseWrap === "preserve" && value === "\n") {
    return hardline$b;
  }

  var isBreakable = options.proseWrap === "always" && !getAncestorNode$2(path, SINGLE_LINE_NODE_TYPES);
  return value !== "" ? isBreakable ? line$6 : " " : isBreakable ? softline$6 : "";
}

function printTable(path, options, print) {
  var hardlineWithoutBreakParent = hardline$b.parts[0];
  var node = path.getValue();
  var contents = []; // { [rowIndex: number]: { [columnIndex: number]: string } }

  path.map(function (rowPath) {
    var rowContents = [];
    rowPath.map(function (cellPath) {
      rowContents.push(printDocToString$3(cellPath.call(print), options).formatted);
    }, "children");
    contents.push(rowContents);
  }, "children"); // Get the width of each column

  var columnMaxWidths = contents.reduce(function (currentWidths, rowContents) {
    return currentWidths.map(function (width, columnIndex) {
      return Math.max(width, util.getStringWidth(rowContents[columnIndex]));
    });
  }, contents[0].map(function () {
    return 3;
  }) // minimum width = 3 (---, :--, :-:, --:)
  );
  var alignedTable = join$9(hardlineWithoutBreakParent, [printRow(contents[0]), printSeparator(), join$9(hardlineWithoutBreakParent, contents.slice(1).map(function (rowContents) {
    return printRow(rowContents);
  }))]);

  if (options.proseWrap !== "never") {
    return concat$d([breakParent$3, alignedTable]);
  } // Only if the --prose-wrap never is set and it exceeds the print width.


  var compactTable = join$9(hardlineWithoutBreakParent, [printRow(contents[0],
  /* isCompact */
  true), printSeparator(
  /* isCompact */
  true), join$9(hardlineWithoutBreakParent, contents.slice(1).map(function (rowContents) {
    return printRow(rowContents,
    /* isCompact */
    true);
  }))]);
  return concat$d([breakParent$3, group$d(ifBreak$5(compactTable, alignedTable))]);

  function printSeparator(isCompact) {
    return concat$d(["| ", join$9(" | ", columnMaxWidths.map(function (width, index) {
      var spaces = isCompact ? 3 : width;

      switch (node.align[index]) {
        case "left":
          return ":" + "-".repeat(spaces - 1);

        case "right":
          return "-".repeat(spaces - 1) + ":";

        case "center":
          return ":" + "-".repeat(spaces - 2) + ":";

        default:
          return "-".repeat(spaces);
      }
    })), " |"]);
  }

  function printRow(rowContents, isCompact) {
    return concat$d(["| ", join$9(" | ", isCompact ? rowContents : rowContents.map(function (rowContent, columnIndex) {
      switch (node.align[columnIndex]) {
        case "right":
          return alignRight(rowContent, columnMaxWidths[columnIndex]);

        case "center":
          return alignCenter(rowContent, columnMaxWidths[columnIndex]);

        default:
          return alignLeft(rowContent, columnMaxWidths[columnIndex]);
      }
    })), " |"]);
  }

  function alignLeft(text, width) {
    var spaces = width - util.getStringWidth(text);
    return concat$d([text, " ".repeat(spaces)]);
  }

  function alignRight(text, width) {
    var spaces = width - util.getStringWidth(text);
    return concat$d([" ".repeat(spaces), text]);
  }

  function alignCenter(text, width) {
    var spaces = width - util.getStringWidth(text);
    var left = Math.floor(spaces / 2);
    var right = spaces - left;
    return concat$d([" ".repeat(left), text, " ".repeat(right)]);
  }
}

function printRoot(path, options, print) {
  /** @typedef {{ index: number, offset: number }} IgnorePosition */

  /** @type {Array<{start: IgnorePosition, end: IgnorePosition}>} */
  var ignoreRanges = [];
  /** @type {IgnorePosition | null} */

  var ignoreStart = null;
  var children = path.getValue().children;
  children.forEach(function (childNode, index) {
    switch (isPrettierIgnore(childNode)) {
      case "start":
        if (ignoreStart === null) {
          ignoreStart = {
            index,
            offset: childNode.position.end.offset
          };
        }

        break;

      case "end":
        if (ignoreStart !== null) {
          ignoreRanges.push({
            start: ignoreStart,
            end: {
              index,
              offset: childNode.position.start.offset
            }
          });
          ignoreStart = null;
        }

        break;
    }
  });
  return printChildren$1(path, options, print, {
    processor: function processor(childPath, index) {
      if (ignoreRanges.length !== 0) {
        var ignoreRange = ignoreRanges[0];

        if (index === ignoreRange.start.index) {
          return concat$d([children[ignoreRange.start.index].value, options.originalText.slice(ignoreRange.start.offset, ignoreRange.end.offset), children[ignoreRange.end.index].value]);
        }

        if (ignoreRange.start.index < index && index < ignoreRange.end.index) {
          return false;
        }

        if (index === ignoreRange.end.index) {
          ignoreRanges.shift();
          return false;
        }
      }

      return childPath.call(print);
    }
  });
}

function printChildren$1(path, options, print, events) {
  events = events || {};
  var postprocessor = events.postprocessor || concat$d;

  var processor = events.processor || function (childPath) {
    return childPath.call(print);
  };

  var node = path.getValue();
  var parts = [];
  var lastChildNode;
  path.map(function (childPath, index) {
    var childNode = childPath.getValue();
    var result = processor(childPath, index);

    if (result !== false) {
      var data = {
        parts,
        prevNode: lastChildNode,
        parentNode: node,
        options
      };

      if (!shouldNotPrePrintHardline(childNode, data)) {
        parts.push(hardline$b);

        if (lastChildNode && TRAILING_HARDLINE_NODES.indexOf(lastChildNode.type) !== -1) {
          if (shouldPrePrintTripleHardline(childNode, data)) {
            parts.push(hardline$b);
          }
        } else {
          if (shouldPrePrintDoubleHardline(childNode, data) || shouldPrePrintTripleHardline(childNode, data)) {
            parts.push(hardline$b);
          }

          if (shouldPrePrintTripleHardline(childNode, data)) {
            parts.push(hardline$b);
          }
        }
      }

      parts.push(result);
      lastChildNode = childNode;
    }
  }, "children");
  return postprocessor(parts);
}

function getLastDescendantNode(node) {
  var current = node;

  while (current.children && current.children.length !== 0) {
    current = current.children[current.children.length - 1];
  }

  return current;
}
/** @return {false | 'next' | 'start' | 'end'} */


function isPrettierIgnore(node) {
  if (node.type !== "html") {
    return false;
  }

  var match = node.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
  return match === null ? false : match[1] ? match[1] : "next";
}

function isInlineNode(node) {
  return node && INLINE_NODE_TYPES$1.indexOf(node.type) !== -1;
}

function isEndsWithHardLine(node) {
  return node && /\n+$/.test(node.value);
}

function last(nodes) {
  return nodes && nodes[nodes.length - 1];
}

function shouldNotPrePrintHardline(node, _ref) {
  var parentNode = _ref.parentNode,
      parts = _ref.parts,
      prevNode = _ref.prevNode;
  var isFirstNode = parts.length === 0;
  var isInlineHTML = node.type === "html" && INLINE_NODE_WRAPPER_TYPES$1.indexOf(parentNode.type) !== -1;
  var isAfterHardlineNode = prevNode && (isEndsWithHardLine(prevNode) || isEndsWithHardLine(last(prevNode.children)));
  return isFirstNode || isInlineNode(node) || isInlineHTML || isAfterHardlineNode;
}

function shouldPrePrintDoubleHardline(node, _ref2) {
  var parentNode = _ref2.parentNode,
      prevNode = _ref2.prevNode;
  var prevNodeType = prevNode && prevNode.type;
  var nodeType = node.type;
  var isSequence = prevNodeType === nodeType;
  var isSiblingNode = isSequence && SIBLING_NODE_TYPES.indexOf(nodeType) !== -1;
  var isInTightListItem = parentNode.type === "listItem" && !parentNode.loose;
  var isPrevNodeLooseListItem = prevNodeType === "listItem" && prevNode.loose;
  var isPrevNodePrettierIgnore = isPrettierIgnore(prevNode) === "next";
  var isBlockHtmlWithoutBlankLineBetweenPrevHtml = nodeType === "html" && prevNodeType === "html" && prevNode.position.end.line + 1 === node.position.start.line;
  var isJsxInlineSibling = prevNodeType === "jsx" && isInlineNode(node) || nodeType === "jsx" && isInlineNode(prevNode);
  return isPrevNodeLooseListItem || !(isSiblingNode || isInTightListItem || isPrevNodePrettierIgnore || isBlockHtmlWithoutBlankLineBetweenPrevHtml || isJsxInlineSibling);
}

function shouldPrePrintTripleHardline(node, data) {
  var isPrevNodeList = data.prevNode && data.prevNode.type === "list";
  var isIndentedCode = node.type === "code" && node.isIndented;
  return isPrevNodeList && isIndentedCode;
}

function shouldRemainTheSameContent(path) {
  var ancestorNode = getAncestorNode$2(path, ["linkReference", "imageReference"]);
  return ancestorNode && (ancestorNode.type !== "linkReference" || ancestorNode.referenceType !== "full");
}

function normalizeDoc(doc) {
  return mapDoc$6(doc, function (currentDoc) {
    if (!currentDoc.parts) {
      return currentDoc;
    }

    if (currentDoc.type === "concat" && currentDoc.parts.length === 1) {
      return currentDoc.parts[0];
    }

    var parts = [];
    currentDoc.parts.forEach(function (part) {
      if (part.type === "concat") {
        parts.push.apply(parts, part.parts);
      } else if (part !== "") {
        parts.push(part);
      }
    });
    return Object.assign({}, currentDoc, {
      parts: normalizeParts(parts)
    });
  });
}

function printUrl(url, dangerousCharOrChars) {
  var dangerousChars = [" "].concat(dangerousCharOrChars || []);
  return new RegExp(dangerousChars.map(function (x) {
    return `\\${x}`;
  }).join("|")).test(url) ? `<${url}>` : url;
}

function printTitle(title, options, printSpace) {
  if (printSpace == null) {
    printSpace = true;
  }

  if (!title) {
    return "";
  }

  if (printSpace) {
    return " " + printTitle(title, options, false);
  }

  if (title.includes('"') && title.includes("'") && !title.includes(")")) {
    return `(${title})`; // avoid escaped quotes
  } // faster than using RegExps: https://jsperf.com/performance-of-match-vs-split


  var singleCount = title.split("'").length - 1;
  var doubleCount = title.split('"').length - 1;
  var quote = singleCount > doubleCount ? '"' : doubleCount > singleCount ? "'" : options.singleQuote ? "'" : '"';
  title = title.replace(new RegExp(`(${quote})`, "g"), "\\$1");
  return `${quote}${title}${quote}`;
}

function normalizeParts(parts) {
  return parts.reduce(function (current, part) {
    var lastPart = util.getLast(current);

    if (typeof lastPart === "string" && typeof part === "string") {
      current.splice(-1, 1, lastPart + part);
    } else {
      current.push(part);
    }

    return current;
  }, []);
}

function clamp(value, min, max) {
  return value < min ? min : value > max ? max : value;
}

function clean$5(ast, newObj, parent) {
  delete newObj.position;
  delete newObj.raw; // front-matter
  // for codeblock

  if (ast.type === "code" || ast.type === "yaml" || ast.type === "import" || ast.type === "export" || ast.type === "jsx") {
    delete newObj.value;
  }

  if (ast.type === "list") {
    delete newObj.isAligned;
  } // texts can be splitted or merged


  if (ast.type === "text") {
    return null;
  }

  if (ast.type === "inlineCode") {
    newObj.value = ast.value.replace(/[ \t\n]+/g, " ");
  } // for insert pragma


  if (parent && parent.type === "root" && parent.children.length > 0 && (parent.children[0] === ast || (parent.children[0].type === "yaml" || parent.children[0].type === "toml") && parent.children[1] === ast) && ast.type === "html" && pragma$3.startWithPragma(ast.value)) {
    return null;
  }
}

function hasPrettierIgnore$2(path) {
  var index = +path.getName();

  if (index === 0) {
    return false;
  }

  var prevNode = path.getParentNode().children[index - 1];
  return isPrettierIgnore(prevNode) === "next";
}

var printerMarkdown = {
  preprocess: preprocess_1$1,
  print: genericPrint$4,
  embed: embed_1$2,
  massageAstNode: clean$5,
  hasPrettierIgnore: hasPrettierIgnore$2,
  insertPragma: pragma$3.insertPragma
};

var options$5 = {
  proseWrap: commonOptions.proseWrap,
  singleQuote: commonOptions.singleQuote
};

var name$f = "Markdown";
var type$d = "prose";
var aliases$4 = [
	"pandoc"
];
var aceMode$d = "markdown";
var codemirrorMode$a = "gfm";
var codemirrorMimeType$a = "text/x-gfm";
var wrap = true;
var extensions$d = [
	".md",
	".markdown",
	".mdown",
	".mdwn",
	".mdx",
	".mkd",
	".mkdn",
	".mkdown",
	".ronn",
	".workbook"
];
var filenames$3 = [
	"contents.lr"
];
var tmScope$d = "source.gfm";
var languageId$d = 222;
var Markdown = {
	name: name$f,
	type: type$d,
	aliases: aliases$4,
	aceMode: aceMode$d,
	codemirrorMode: codemirrorMode$a,
	codemirrorMimeType: codemirrorMimeType$a,
	wrap: wrap,
	extensions: extensions$d,
	filenames: filenames$3,
	tmScope: tmScope$d,
	languageId: languageId$d
};

var Markdown$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$f,
  type: type$d,
  aliases: aliases$4,
  aceMode: aceMode$d,
  codemirrorMode: codemirrorMode$a,
  codemirrorMimeType: codemirrorMimeType$a,
  wrap: wrap,
  extensions: extensions$d,
  filenames: filenames$3,
  tmScope: tmScope$d,
  languageId: languageId$d,
  'default': Markdown
});

var require$$0$5 = getCjsExportFromNamespace(Markdown$1);

var languages$4 = [createLanguage(require$$0$5, function (data) {
  return Object.assign(data, {
    since: "1.8.0",
    parsers: ["remark"],
    vscodeLanguageIds: ["markdown"],
    filenames: data.filenames.concat(["README"]),
    extensions: data.extensions.filter(function (extension) {
      return extension !== ".mdx";
    })
  });
}), createLanguage(require$$0$5, function (data) {
  return Object.assign(data, {
    name: "MDX",
    since: "1.15.0",
    parsers: ["mdx"],
    vscodeLanguageIds: ["mdx"],
    filenames: [],
    extensions: [".mdx"]
  });
})];
var printers$4 = {
  mdast: printerMarkdown
};
var languageMarkdown = {
  languages: languages$4,
  options: options$5,
  printers: printers$4
};

var clean$6 = function clean(ast, newNode) {
  delete newNode.sourceSpan;
  delete newNode.startSourceSpan;
  delete newNode.endSourceSpan;
  delete newNode.nameSpan;
  delete newNode.valueSpan;

  if (ast.type === "text" || ast.type === "comment") {
    return null;
  } // may be formatted by multiparser


  if (ast.type === "yaml" || ast.type === "toml") {
    return null;
  }

  if (ast.type === "attribute") {
    delete newNode.value;
  }

  if (ast.type === "docType") {
    delete newNode.value;
  }
};

var json$1 = {
  "CSS_DISPLAY_TAGS": {
    "area": "none",
    "base": "none",
    "basefont": "none",
    "datalist": "none",
    "head": "none",
    "link": "none",
    "meta": "none",
    "noembed": "none",
    "noframes": "none",
    "param": "none",
    "rp": "none",
    "script": "block",
    "source": "block",
    "style": "none",
    "template": "inline",
    "track": "block",
    "title": "none",
    "html": "block",
    "body": "block",
    "address": "block",
    "blockquote": "block",
    "center": "block",
    "div": "block",
    "figure": "block",
    "figcaption": "block",
    "footer": "block",
    "form": "block",
    "header": "block",
    "hr": "block",
    "legend": "block",
    "listing": "block",
    "main": "block",
    "p": "block",
    "plaintext": "block",
    "pre": "block",
    "xmp": "block",
    "slot": "contents",
    "ruby": "ruby",
    "rt": "ruby-text",
    "article": "block",
    "aside": "block",
    "h1": "block",
    "h2": "block",
    "h3": "block",
    "h4": "block",
    "h5": "block",
    "h6": "block",
    "hgroup": "block",
    "nav": "block",
    "section": "block",
    "dir": "block",
    "dd": "block",
    "dl": "block",
    "dt": "block",
    "ol": "block",
    "ul": "block",
    "li": "list-item",
    "table": "table",
    "caption": "table-caption",
    "colgroup": "table-column-group",
    "col": "table-column",
    "thead": "table-header-group",
    "tbody": "table-row-group",
    "tfoot": "table-footer-group",
    "tr": "table-row",
    "td": "table-cell",
    "th": "table-cell",
    "fieldset": "block",
    "button": "inline-block",
    "video": "inline-block",
    "audio": "inline-block"
  },
  "CSS_DISPLAY_DEFAULT": "inline",
  "CSS_WHITE_SPACE_TAGS": {
    "listing": "pre",
    "plaintext": "pre",
    "pre": "pre",
    "xmp": "pre",
    "nobr": "nowrap",
    "table": "initial",
    "textarea": "pre-wrap"
  },
  "CSS_WHITE_SPACE_DEFAULT": "normal"
};

var a = [
	"accesskey",
	"charset",
	"coords",
	"download",
	"href",
	"hreflang",
	"name",
	"ping",
	"referrerpolicy",
	"rel",
	"rev",
	"shape",
	"tabindex",
	"target",
	"type"
];
var abbr = [
	"title"
];
var applet = [
	"align",
	"alt",
	"archive",
	"code",
	"codebase",
	"height",
	"hspace",
	"name",
	"object",
	"vspace",
	"width"
];
var area = [
	"accesskey",
	"alt",
	"coords",
	"download",
	"href",
	"hreflang",
	"nohref",
	"ping",
	"referrerpolicy",
	"rel",
	"shape",
	"tabindex",
	"target",
	"type"
];
var audio = [
	"autoplay",
	"controls",
	"crossorigin",
	"loop",
	"muted",
	"preload",
	"src"
];
var base = [
	"href",
	"target"
];
var basefont = [
	"color",
	"face",
	"size"
];
var bdo = [
	"dir"
];
var blockquote = [
	"cite"
];
var body = [
	"alink",
	"background",
	"bgcolor",
	"link",
	"text",
	"vlink"
];
var br = [
	"clear"
];
var button = [
	"accesskey",
	"autofocus",
	"disabled",
	"form",
	"formaction",
	"formenctype",
	"formmethod",
	"formnovalidate",
	"formtarget",
	"name",
	"tabindex",
	"type",
	"value"
];
var canvas = [
	"height",
	"width"
];
var caption = [
	"align"
];
var col = [
	"align",
	"char",
	"charoff",
	"span",
	"valign",
	"width"
];
var colgroup = [
	"align",
	"char",
	"charoff",
	"span",
	"valign",
	"width"
];
var data$1 = [
	"value"
];
var del$1 = [
	"cite",
	"datetime"
];
var details = [
	"open"
];
var dfn = [
	"title"
];
var dialog = [
	"open"
];
var dir = [
	"compact"
];
var div = [
	"align"
];
var dl = [
	"compact"
];
var embed$3 = [
	"height",
	"src",
	"type",
	"width"
];
var fieldset = [
	"disabled",
	"form",
	"name"
];
var font = [
	"color",
	"face",
	"size"
];
var form = [
	"accept",
	"accept-charset",
	"action",
	"autocomplete",
	"enctype",
	"method",
	"name",
	"novalidate",
	"target"
];
var frame = [
	"frameborder",
	"longdesc",
	"marginheight",
	"marginwidth",
	"name",
	"noresize",
	"scrolling",
	"src"
];
var frameset = [
	"cols",
	"rows"
];
var h1 = [
	"align"
];
var h2 = [
	"align"
];
var h3 = [
	"align"
];
var h4 = [
	"align"
];
var h5 = [
	"align"
];
var h6 = [
	"align"
];
var head = [
	"profile"
];
var hr = [
	"align",
	"noshade",
	"size",
	"width"
];
var html = [
	"manifest",
	"version"
];
var iframe = [
	"align",
	"allow",
	"allowfullscreen",
	"allowpaymentrequest",
	"allowusermedia",
	"frameborder",
	"height",
	"longdesc",
	"marginheight",
	"marginwidth",
	"name",
	"referrerpolicy",
	"sandbox",
	"scrolling",
	"src",
	"srcdoc",
	"width"
];
var img = [
	"align",
	"alt",
	"border",
	"crossorigin",
	"decoding",
	"height",
	"hspace",
	"ismap",
	"longdesc",
	"name",
	"referrerpolicy",
	"sizes",
	"src",
	"srcset",
	"usemap",
	"vspace",
	"width"
];
var input = [
	"accept",
	"accesskey",
	"align",
	"alt",
	"autocomplete",
	"autofocus",
	"checked",
	"dirname",
	"disabled",
	"form",
	"formaction",
	"formenctype",
	"formmethod",
	"formnovalidate",
	"formtarget",
	"height",
	"ismap",
	"list",
	"max",
	"maxlength",
	"min",
	"minlength",
	"multiple",
	"name",
	"pattern",
	"placeholder",
	"readonly",
	"required",
	"size",
	"src",
	"step",
	"tabindex",
	"title",
	"type",
	"usemap",
	"value",
	"width"
];
var ins = [
	"cite",
	"datetime"
];
var isindex = [
	"prompt"
];
var label = [
	"accesskey",
	"for",
	"form"
];
var legend = [
	"accesskey",
	"align"
];
var li = [
	"type",
	"value"
];
var link$1 = [
	"as",
	"charset",
	"color",
	"crossorigin",
	"href",
	"hreflang",
	"imagesizes",
	"imagesrcset",
	"integrity",
	"media",
	"nonce",
	"referrerpolicy",
	"rel",
	"rev",
	"sizes",
	"target",
	"title",
	"type"
];
var map$1 = [
	"name"
];
var menu = [
	"compact"
];
var meta = [
	"charset",
	"content",
	"http-equiv",
	"name",
	"scheme"
];
var meter = [
	"high",
	"low",
	"max",
	"min",
	"optimum",
	"value"
];
var object = [
	"align",
	"archive",
	"border",
	"classid",
	"codebase",
	"codetype",
	"data",
	"declare",
	"form",
	"height",
	"hspace",
	"name",
	"standby",
	"tabindex",
	"type",
	"typemustmatch",
	"usemap",
	"vspace",
	"width"
];
var ol = [
	"compact",
	"reversed",
	"start",
	"type"
];
var optgroup = [
	"disabled",
	"label"
];
var option = [
	"disabled",
	"label",
	"selected",
	"value"
];
var output = [
	"for",
	"form",
	"name"
];
var p = [
	"align"
];
var param = [
	"name",
	"type",
	"value",
	"valuetype"
];
var pre = [
	"width"
];
var progress = [
	"max",
	"value"
];
var q = [
	"cite"
];
var script = [
	"async",
	"charset",
	"crossorigin",
	"defer",
	"integrity",
	"language",
	"nomodule",
	"nonce",
	"referrerpolicy",
	"src",
	"type"
];
var select = [
	"autocomplete",
	"autofocus",
	"disabled",
	"form",
	"multiple",
	"name",
	"required",
	"size",
	"tabindex"
];
var slot = [
	"name"
];
var source = [
	"media",
	"sizes",
	"src",
	"srcset",
	"type"
];
var style = [
	"media",
	"nonce",
	"title",
	"type"
];
var table = [
	"align",
	"bgcolor",
	"border",
	"cellpadding",
	"cellspacing",
	"frame",
	"rules",
	"summary",
	"width"
];
var tbody = [
	"align",
	"char",
	"charoff",
	"valign"
];
var td = [
	"abbr",
	"align",
	"axis",
	"bgcolor",
	"char",
	"charoff",
	"colspan",
	"headers",
	"height",
	"nowrap",
	"rowspan",
	"scope",
	"valign",
	"width"
];
var textarea = [
	"accesskey",
	"autocomplete",
	"autofocus",
	"cols",
	"dirname",
	"disabled",
	"form",
	"maxlength",
	"minlength",
	"name",
	"placeholder",
	"readonly",
	"required",
	"rows",
	"tabindex",
	"wrap"
];
var tfoot = [
	"align",
	"char",
	"charoff",
	"valign"
];
var th = [
	"abbr",
	"align",
	"axis",
	"bgcolor",
	"char",
	"charoff",
	"colspan",
	"headers",
	"height",
	"nowrap",
	"rowspan",
	"scope",
	"valign",
	"width"
];
var thead = [
	"align",
	"char",
	"charoff",
	"valign"
];
var time = [
	"datetime"
];
var tr = [
	"align",
	"bgcolor",
	"char",
	"charoff",
	"valign"
];
var track = [
	"default",
	"kind",
	"label",
	"src",
	"srclang"
];
var ul = [
	"compact",
	"type"
];
var video = [
	"autoplay",
	"controls",
	"crossorigin",
	"height",
	"loop",
	"muted",
	"playsinline",
	"poster",
	"preload",
	"src",
	"width"
];
var index$1 = {
	"*": [
	"accesskey",
	"autocapitalize",
	"autofocus",
	"class",
	"contenteditable",
	"dir",
	"draggable",
	"enterkeyhint",
	"hidden",
	"id",
	"inputmode",
	"is",
	"itemid",
	"itemprop",
	"itemref",
	"itemscope",
	"itemtype",
	"lang",
	"nonce",
	"slot",
	"spellcheck",
	"style",
	"tabindex",
	"title",
	"translate"
],
	a: a,
	abbr: abbr,
	applet: applet,
	area: area,
	audio: audio,
	base: base,
	basefont: basefont,
	bdo: bdo,
	blockquote: blockquote,
	body: body,
	br: br,
	button: button,
	canvas: canvas,
	caption: caption,
	col: col,
	colgroup: colgroup,
	data: data$1,
	del: del$1,
	details: details,
	dfn: dfn,
	dialog: dialog,
	dir: dir,
	div: div,
	dl: dl,
	embed: embed$3,
	fieldset: fieldset,
	font: font,
	form: form,
	frame: frame,
	frameset: frameset,
	h1: h1,
	h2: h2,
	h3: h3,
	h4: h4,
	h5: h5,
	h6: h6,
	head: head,
	hr: hr,
	html: html,
	iframe: iframe,
	img: img,
	input: input,
	ins: ins,
	isindex: isindex,
	label: label,
	legend: legend,
	li: li,
	link: link$1,
	map: map$1,
	menu: menu,
	meta: meta,
	meter: meter,
	object: object,
	ol: ol,
	optgroup: optgroup,
	option: option,
	output: output,
	p: p,
	param: param,
	pre: pre,
	progress: progress,
	q: q,
	script: script,
	select: select,
	slot: slot,
	source: source,
	style: style,
	table: table,
	tbody: tbody,
	td: td,
	textarea: textarea,
	tfoot: tfoot,
	th: th,
	thead: thead,
	time: time,
	tr: tr,
	track: track,
	ul: ul,
	video: video
};

var htmlElementAttributes = /*#__PURE__*/Object.freeze({
  __proto__: null,
  a: a,
  abbr: abbr,
  applet: applet,
  area: area,
  audio: audio,
  base: base,
  basefont: basefont,
  bdo: bdo,
  blockquote: blockquote,
  body: body,
  br: br,
  button: button,
  canvas: canvas,
  caption: caption,
  col: col,
  colgroup: colgroup,
  data: data$1,
  del: del$1,
  details: details,
  dfn: dfn,
  dialog: dialog,
  dir: dir,
  div: div,
  dl: dl,
  embed: embed$3,
  fieldset: fieldset,
  font: font,
  form: form,
  frame: frame,
  frameset: frameset,
  h1: h1,
  h2: h2,
  h3: h3,
  h4: h4,
  h5: h5,
  h6: h6,
  head: head,
  hr: hr,
  html: html,
  iframe: iframe,
  img: img,
  input: input,
  ins: ins,
  isindex: isindex,
  label: label,
  legend: legend,
  li: li,
  link: link$1,
  map: map$1,
  menu: menu,
  meta: meta,
  meter: meter,
  object: object,
  ol: ol,
  optgroup: optgroup,
  option: option,
  output: output,
  p: p,
  param: param,
  pre: pre,
  progress: progress,
  q: q,
  script: script,
  select: select,
  slot: slot,
  source: source,
  style: style,
  table: table,
  tbody: tbody,
  td: td,
  textarea: textarea,
  tfoot: tfoot,
  th: th,
  thead: thead,
  time: time,
  tr: tr,
  track: track,
  ul: ul,
  video: video,
  'default': index$1
});

var htmlElementAttributes$1 = getCjsExportFromNamespace(htmlElementAttributes);

var CSS_DISPLAY_TAGS = json$1.CSS_DISPLAY_TAGS,
    CSS_DISPLAY_DEFAULT = json$1.CSS_DISPLAY_DEFAULT,
    CSS_WHITE_SPACE_TAGS = json$1.CSS_WHITE_SPACE_TAGS,
    CSS_WHITE_SPACE_DEFAULT = json$1.CSS_WHITE_SPACE_DEFAULT;
var HTML_TAGS = arrayToMap(htmlTagNames$1);
var HTML_ELEMENT_ATTRIBUTES = mapObject(htmlElementAttributes$1, arrayToMap);

function arrayToMap(array) {
  var map = Object.create(null);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;
      map[value] = true;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return map;
}

function mapObject(object, fn) {
  var newObject = Object.create(null);

  for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    newObject[key] = fn(object[key], key);
  }

  return newObject;
}

function shouldPreserveContent(node, options) {
  if (node.type === "element" && node.fullName === "template" && node.attrMap.lang && node.attrMap.lang !== "html") {
    return true;
  } // unterminated node in ie conditional comment
  // e.g. <!--[if lt IE 9]><html><![endif]-->


  if (node.type === "ieConditionalComment" && node.lastChild && !node.lastChild.isSelfClosing && !node.lastChild.endSourceSpan) {
    return true;
  } // incomplete html in ie conditional comment
  // e.g. <!--[if lt IE 9]></div><![endif]-->


  if (node.type === "ieConditionalComment" && !node.complete) {
    return true;
  } // top-level elements (excluding <template>, <style> and <script>) in Vue SFC are considered custom block
  // custom blocks can be written in other languages so we should preserve them to not break the code


  if (options.parser === "vue" && node.type === "element" && node.parent.type === "root" && ["template", "style", "script", // vue parser can be used for vue dom template as well, so we should still format top-level <html>
  "html"].indexOf(node.fullName) === -1) {
    return true;
  } // TODO: handle non-text children in <pre>


  if (isPreLikeNode(node) && node.children.some(function (child) {
    return child.type !== "text" && child.type !== "interpolation";
  })) {
    return true;
  }

  return false;
}

function hasPrettierIgnore$3(node) {
  if (node.type === "attribute" || isTextLikeNode(node)) {
    return false;
  }

  if (!node.parent) {
    return false;
  }

  if (typeof node.index !== "number" || node.index === 0) {
    return false;
  }

  var prevNode = node.parent.children[node.index - 1];
  return isPrettierIgnore$1(prevNode);
}

function isPrettierIgnore$1(node) {
  return node.type === "comment" && node.value.trim() === "prettier-ignore";
}

function getPrettierIgnoreAttributeCommentData(value) {
  var match = value.trim().match(/^prettier-ignore-attribute(?:\s+([^]+))?$/);

  if (!match) {
    return false;
  }

  if (!match[1]) {
    return true;
  }

  return match[1].split(/\s+/);
}
/** there's no opening/closing tag or it's considered not breakable */


function isTextLikeNode(node) {
  return node.type === "text" || node.type === "comment";
}

function isScriptLikeTag(node) {
  return node.type === "element" && (node.fullName === "script" || node.fullName === "style" || node.fullName === "svg:style");
}

function isFrontMatterNode(node) {
  return node.type === "yaml" || node.type === "toml";
}

function canHaveInterpolation(node) {
  return node.children && !isScriptLikeTag(node);
}

function isWhitespaceSensitiveNode(node) {
  return isScriptLikeTag(node) || node.type === "interpolation" || isIndentationSensitiveNode(node);
}

function isIndentationSensitiveNode(node) {
  return getNodeCssStyleWhiteSpace(node).startsWith("pre");
}

function isLeadingSpaceSensitiveNode(node) {
  var isLeadingSpaceSensitive = _isLeadingSpaceSensitiveNode();

  if (isLeadingSpaceSensitive && !node.prev && node.parent && node.parent.tagDefinition && node.parent.tagDefinition.ignoreFirstLf) {
    return node.type === "interpolation";
  }

  return isLeadingSpaceSensitive;

  function _isLeadingSpaceSensitiveNode() {
    if (isFrontMatterNode(node)) {
      return false;
    }

    if ((node.type === "text" || node.type === "interpolation") && node.prev && (node.prev.type === "text" || node.prev.type === "interpolation")) {
      return true;
    }

    if (!node.parent || node.parent.cssDisplay === "none") {
      return false;
    }

    if (isPreLikeNode(node.parent)) {
      return true;
    }

    if (!node.prev && (node.parent.type === "root" || isScriptLikeTag(node.parent) || !isFirstChildLeadingSpaceSensitiveCssDisplay(node.parent.cssDisplay))) {
      return false;
    }

    if (node.prev && !isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)) {
      return false;
    }

    return true;
  }
}

function isTrailingSpaceSensitiveNode(node) {
  if (isFrontMatterNode(node)) {
    return false;
  }

  if ((node.type === "text" || node.type === "interpolation") && node.next && (node.next.type === "text" || node.next.type === "interpolation")) {
    return true;
  }

  if (!node.parent || node.parent.cssDisplay === "none") {
    return false;
  }

  if (isPreLikeNode(node.parent)) {
    return true;
  }

  if (!node.next && (node.parent.type === "root" || isScriptLikeTag(node.parent) || !isLastChildTrailingSpaceSensitiveCssDisplay(node.parent.cssDisplay))) {
    return false;
  }

  if (node.next && !isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)) {
    return false;
  }

  return true;
}

function isDanglingSpaceSensitiveNode(node) {
  return isDanglingSpaceSensitiveCssDisplay(node.cssDisplay) && !isScriptLikeTag(node);
}

function forceNextEmptyLine(node) {
  return isFrontMatterNode(node) || node.next && node.sourceSpan.end.line + 1 < node.next.sourceSpan.start.line;
}
/** firstChild leadingSpaces and lastChild trailingSpaces */


function forceBreakContent(node) {
  return forceBreakChildren(node) || node.type === "element" && node.children.length !== 0 && (["body", "script", "style"].indexOf(node.name) !== -1 || node.children.some(function (child) {
    return hasNonTextChild(child);
  })) || node.firstChild && node.firstChild === node.lastChild && hasLeadingLineBreak(node.firstChild) && (!node.lastChild.isTrailingSpaceSensitive || hasTrailingLineBreak(node.lastChild));
}
/** spaces between children */


function forceBreakChildren(node) {
  return node.type === "element" && node.children.length !== 0 && (["html", "head", "ul", "ol", "select"].indexOf(node.name) !== -1 || node.cssDisplay.startsWith("table") && node.cssDisplay !== "table-cell");
}

function preferHardlineAsLeadingSpaces(node) {
  return preferHardlineAsSurroundingSpaces(node) || node.prev && preferHardlineAsTrailingSpaces(node.prev) || hasSurroundingLineBreak(node);
}

function preferHardlineAsTrailingSpaces(node) {
  return preferHardlineAsSurroundingSpaces(node) || node.type === "element" && node.fullName === "br" || hasSurroundingLineBreak(node);
}

function hasSurroundingLineBreak(node) {
  return hasLeadingLineBreak(node) && hasTrailingLineBreak(node);
}

function hasLeadingLineBreak(node) {
  return node.hasLeadingSpaces && (node.prev ? node.prev.sourceSpan.end.line < node.sourceSpan.start.line : node.parent.type === "root" || node.parent.startSourceSpan.end.line < node.sourceSpan.start.line);
}

function hasTrailingLineBreak(node) {
  return node.hasTrailingSpaces && (node.next ? node.next.sourceSpan.start.line > node.sourceSpan.end.line : node.parent.type === "root" || node.parent.endSourceSpan.start.line > node.sourceSpan.end.line);
}

function preferHardlineAsSurroundingSpaces(node) {
  switch (node.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return true;

    case "element":
      return ["script", "select"].indexOf(node.name) !== -1;
  }

  return false;
}

function getLastDescendant(node) {
  return node.lastChild ? getLastDescendant(node.lastChild) : node;
}

function hasNonTextChild(node) {
  return node.children && node.children.some(function (child) {
    return child.type !== "text";
  });
}

function inferScriptParser(node) {
  if (node.name === "script" && !node.attrMap.src) {
    if (!node.attrMap.lang && !node.attrMap.type || node.attrMap.type === "module" || node.attrMap.type === "text/javascript" || node.attrMap.type === "text/babel" || node.attrMap.type === "application/javascript") {
      return "babel";
    }

    if (node.attrMap.type === "application/x-typescript" || node.attrMap.lang === "ts" || node.attrMap.lang === "tsx") {
      return "typescript";
    }

    if (node.attrMap.type === "text/markdown") {
      return "markdown";
    }

    if (node.attrMap.type.endsWith("json") || node.attrMap.type.endsWith("importmap")) {
      return "json";
    }
  }

  if (node.name === "style") {
    if (!node.attrMap.lang || node.attrMap.lang === "postcss" || node.attrMap.lang === "css") {
      return "css";
    }

    if (node.attrMap.lang === "scss") {
      return "scss";
    }

    if (node.attrMap.lang === "less") {
      return "less";
    }
  }

  return null;
}

function isBlockLikeCssDisplay(cssDisplay) {
  return cssDisplay === "block" || cssDisplay === "list-item" || cssDisplay.startsWith("table");
}

function isFirstChildLeadingSpaceSensitiveCssDisplay(cssDisplay) {
  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
}

function isLastChildTrailingSpaceSensitiveCssDisplay(cssDisplay) {
  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
}

function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay) {
  return !isBlockLikeCssDisplay(cssDisplay);
}

function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay) {
  return !isBlockLikeCssDisplay(cssDisplay);
}

function isDanglingSpaceSensitiveCssDisplay(cssDisplay) {
  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
}

function isPreLikeNode(node) {
  return getNodeCssStyleWhiteSpace(node).startsWith("pre");
}

function countParents(path) {
  var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
    return true;
  };
  var counter = 0;

  for (var i = path.stack.length - 1; i >= 0; i--) {
    var value = path.stack[i];

    if (value && typeof value === "object" && !Array.isArray(value) && predicate(value)) {
      counter++;
    }
  }

  return counter;
}

function hasParent(node, fn) {
  var current = node;

  while (current) {
    if (fn(current)) {
      return true;
    }

    current = current.parent;
  }

  return false;
}

function getNodeCssStyleDisplay(node, options) {
  if (node.prev && node.prev.type === "comment") {
    // <!-- display: block -->
    var match = node.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);

    if (match) {
      return match[1];
    }
  }

  var isInSvgForeignObject = false;

  if (node.type === "element" && node.namespace === "svg") {
    if (hasParent(node, function (parent) {
      return parent.fullName === "svg:foreignObject";
    })) {
      isInSvgForeignObject = true;
    } else {
      return node.name === "svg" ? "inline-block" : "block";
    }
  }

  switch (options.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";

    case "ignore":
      return "block";

    default:
      return node.type === "element" && (!node.namespace || isInSvgForeignObject) && CSS_DISPLAY_TAGS[node.name] || CSS_DISPLAY_DEFAULT;
  }
}

function getNodeCssStyleWhiteSpace(node) {
  return node.type === "element" && !node.namespace && CSS_WHITE_SPACE_TAGS[node.name] || CSS_WHITE_SPACE_DEFAULT;
}

function getMinIndentation(text) {
  var minIndentation = Infinity;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = text.split("\n")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var lineText = _step2.value;

      if (lineText.length === 0) {
        continue;
      }

      if (/\S/.test(lineText[0])) {
        return 0;
      }

      var indentation = lineText.match(/^\s*/)[0].length;

      if (lineText.length === indentation) {
        continue;
      }

      if (indentation < minIndentation) {
        minIndentation = indentation;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return minIndentation === Infinity ? 0 : minIndentation;
}

function dedentString(text) {
  var minIndent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getMinIndentation(text);
  return minIndent === 0 ? text : text.split("\n").map(function (lineText) {
    return lineText.slice(minIndent);
  }).join("\n");
}

function normalizeParts$1(parts) {
  var newParts = [];
  var restParts = parts.slice();

  while (restParts.length !== 0) {
    var part = restParts.shift();

    if (!part) {
      continue;
    }

    if (part.type === "concat") {
      Array.prototype.unshift.apply(restParts, part.parts);
      continue;
    }

    if (newParts.length !== 0 && typeof newParts[newParts.length - 1] === "string" && typeof part === "string") {
      newParts.push(newParts.pop() + part);
      continue;
    }

    newParts.push(part);
  }

  return newParts;
}

function identity$2(x) {
  return x;
}

function shouldNotPrintClosingTag(node, options) {
  return !node.isSelfClosing && !node.endSourceSpan && (hasPrettierIgnore$3(node) || shouldPreserveContent(node.parent, options));
}

function countChars(text, char) {
  var counter = 0;

  for (var i = 0; i < text.length; i++) {
    if (text[i] === char) {
      counter++;
    }
  }

  return counter;
}

function unescapeQuoteEntities(text) {
  return text.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
}

var utils$5 = {
  HTML_ELEMENT_ATTRIBUTES,
  HTML_TAGS,
  canHaveInterpolation,
  countChars,
  countParents,
  dedentString,
  forceBreakChildren,
  forceBreakContent,
  forceNextEmptyLine,
  getLastDescendant,
  getNodeCssStyleDisplay,
  getNodeCssStyleWhiteSpace,
  getPrettierIgnoreAttributeCommentData,
  hasPrettierIgnore: hasPrettierIgnore$3,
  identity: identity$2,
  inferScriptParser,
  isDanglingSpaceSensitiveNode,
  isFrontMatterNode,
  isIndentationSensitiveNode,
  isLeadingSpaceSensitiveNode,
  isPreLikeNode,
  isScriptLikeTag,
  isTextLikeNode,
  isTrailingSpaceSensitiveNode,
  isWhitespaceSensitiveNode,
  normalizeParts: normalizeParts$1,
  preferHardlineAsLeadingSpaces,
  preferHardlineAsTrailingSpaces,
  shouldNotPrintClosingTag,
  shouldPreserveContent,
  unescapeQuoteEntities
};

var canHaveInterpolation$1 = utils$5.canHaveInterpolation,
    getNodeCssStyleDisplay$1 = utils$5.getNodeCssStyleDisplay,
    isDanglingSpaceSensitiveNode$1 = utils$5.isDanglingSpaceSensitiveNode,
    isIndentationSensitiveNode$1 = utils$5.isIndentationSensitiveNode,
    isLeadingSpaceSensitiveNode$1 = utils$5.isLeadingSpaceSensitiveNode,
    isTrailingSpaceSensitiveNode$1 = utils$5.isTrailingSpaceSensitiveNode,
    isWhitespaceSensitiveNode$1 = utils$5.isWhitespaceSensitiveNode;
var PREPROCESS_PIPELINE = [removeIgnorableFirstLf, mergeIeConditonalStartEndCommentIntoElementOpeningTag, mergeCdataIntoText, extractInterpolation, extractWhitespaces, addCssDisplay, addIsSelfClosing, addHasHtmComponentClosingTag, addIsSpaceSensitive, mergeSimpleElementIntoText];

function preprocess$2(ast, options) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = PREPROCESS_PIPELINE[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var fn = _step.value;
      ast = fn(ast, options);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return ast;
}

function removeIgnorableFirstLf(ast
/*, options */
) {
  return ast.map(function (node) {
    if (node.type === "element" && node.tagDefinition.ignoreFirstLf && node.children.length !== 0 && node.children[0].type === "text" && node.children[0].value[0] === "\n") {
      var text = node.children[0];
      return node.clone({
        children: text.value.length === 1 ? node.children.slice(1) : [].concat(text.clone({
          value: text.value.slice(1)
        }), node.children.slice(1))
      });
    }

    return node;
  });
}

function mergeIeConditonalStartEndCommentIntoElementOpeningTag(ast
/*, options */
) {
  /**
   *     <!--[if ...]><!--><target><!--<![endif]-->
   */
  var isTarget = function isTarget(node) {
    return node.type === "element" && node.prev && node.prev.type === "ieConditionalStartComment" && node.prev.sourceSpan.end.offset === node.startSourceSpan.start.offset && node.firstChild && node.firstChild.type === "ieConditionalEndComment" && node.firstChild.sourceSpan.start.offset === node.startSourceSpan.end.offset;
  };

  return ast.map(function (node) {
    if (node.children) {
      var isTargetResults = node.children.map(isTarget);

      if (isTargetResults.some(Boolean)) {
        var newChildren = [];

        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];

          if (isTargetResults[i + 1]) {
            // ieConditionalStartComment
            continue;
          }

          if (isTargetResults[i]) {
            var ieConditionalStartComment = child.prev;
            var ieConditionalEndComment = child.firstChild;
            var ParseSourceSpan = child.sourceSpan.constructor;
            var startSourceSpan = new ParseSourceSpan(ieConditionalStartComment.sourceSpan.start, ieConditionalEndComment.sourceSpan.end);
            var sourceSpan = new ParseSourceSpan(startSourceSpan.start, child.sourceSpan.end);
            newChildren.push(child.clone({
              condition: ieConditionalStartComment.condition,
              sourceSpan,
              startSourceSpan,
              children: child.children.slice(1)
            }));
            continue;
          }

          newChildren.push(child);
        }

        return node.clone({
          children: newChildren
        });
      }
    }

    return node;
  });
}

function mergeNodeIntoText(ast, shouldMerge, getValue) {
  return ast.map(function (node) {
    if (node.children) {
      var shouldMergeResults = node.children.map(shouldMerge);

      if (shouldMergeResults.some(Boolean)) {
        var newChildren = [];

        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];

          if (child.type !== "text" && !shouldMergeResults[i]) {
            newChildren.push(child);
            continue;
          }

          var newChild = child.type === "text" ? child : child.clone({
            type: "text",
            value: getValue(child)
          });

          if (newChildren.length === 0 || newChildren[newChildren.length - 1].type !== "text") {
            newChildren.push(newChild);
            continue;
          }

          var lastChild = newChildren.pop();
          var ParseSourceSpan = lastChild.sourceSpan.constructor;
          newChildren.push(lastChild.clone({
            value: lastChild.value + newChild.value,
            sourceSpan: new ParseSourceSpan(lastChild.sourceSpan.start, newChild.sourceSpan.end)
          }));
        }

        return node.clone({
          children: newChildren
        });
      }
    }

    return node;
  });
}

function mergeCdataIntoText(ast
/*, options */
) {
  return mergeNodeIntoText(ast, function (node) {
    return node.type === "cdata";
  }, function (node) {
    return `<![CDATA[${node.value}]]>`;
  });
}

function mergeSimpleElementIntoText(ast
/*, options */
) {
  var isSimpleElement = function isSimpleElement(node) {
    return node.type === "element" && node.attrs.length === 0 && node.children.length === 1 && node.firstChild.type === "text" && // \xA0: non-breaking whitespace
    !/[^\S\xA0]/.test(node.children[0].value) && !node.firstChild.hasLeadingSpaces && !node.firstChild.hasTrailingSpaces && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces && node.prev && node.prev.type === "text" && node.next && node.next.type === "text";
  };

  return ast.map(function (node) {
    if (node.children) {
      var isSimpleElementResults = node.children.map(isSimpleElement);

      if (isSimpleElementResults.some(Boolean)) {
        var newChildren = [];

        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];

          if (isSimpleElementResults[i]) {
            var lastChild = newChildren.pop();
            var nextChild = node.children[++i];
            var ParseSourceSpan = node.sourceSpan.constructor;
            var isTrailingSpaceSensitive = nextChild.isTrailingSpaceSensitive,
                hasTrailingSpaces = nextChild.hasTrailingSpaces;
            newChildren.push(lastChild.clone({
              value: lastChild.value + `<${child.rawName}>` + child.firstChild.value + `</${child.rawName}>` + nextChild.value,
              sourceSpan: new ParseSourceSpan(lastChild.sourceSpan.start, nextChild.sourceSpan.end),
              isTrailingSpaceSensitive,
              hasTrailingSpaces
            }));
          } else {
            newChildren.push(child);
          }
        }

        return node.clone({
          children: newChildren
        });
      }
    }

    return node;
  });
}

function extractInterpolation(ast, options) {
  if (options.parser === "html") {
    return ast;
  }

  var interpolationRegex = /\{\{([\s\S]+?)\}\}/g;
  return ast.map(function (node) {
    if (!canHaveInterpolation$1(node)) {
      return node;
    }

    var newChildren = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var child = _step2.value;

        if (child.type !== "text") {
          newChildren.push(child);
          continue;
        }

        var ParseSourceSpan = child.sourceSpan.constructor;
        var startSourceSpan = child.sourceSpan.start;
        var endSourceSpan = null;
        var components = child.value.split(interpolationRegex);

        for (var i = 0; i < components.length; i++, startSourceSpan = endSourceSpan) {
          var value = components[i];

          if (i % 2 === 0) {
            endSourceSpan = startSourceSpan.moveBy(value.length);

            if (value.length !== 0) {
              newChildren.push({
                type: "text",
                value,
                sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan)
              });
            }

            continue;
          }

          endSourceSpan = startSourceSpan.moveBy(value.length + 4); // `{{` + `}}`

          newChildren.push({
            type: "interpolation",
            sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),
            children: value.length === 0 ? [] : [{
              type: "text",
              value,
              sourceSpan: new ParseSourceSpan(startSourceSpan.moveBy(2), endSourceSpan.moveBy(-2))
            }]
          });
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return node.clone({
      children: newChildren
    });
  });
}
/**
 * - add `hasLeadingSpaces` field
 * - add `hasTrailingSpaces` field
 * - add `hasDanglingSpaces` field for parent nodes
 * - add `isWhitespaceSensitive`, `isIndentationSensitive` field for text nodes
 * - remove insensitive whitespaces
 */


function extractWhitespaces(ast
/*, options*/
) {
  var TYPE_WHITESPACE = "whitespace";
  return ast.map(function (node) {
    if (!node.children) {
      return node;
    }

    if (node.children.length === 0 || node.children.length === 1 && node.children[0].type === "text" && node.children[0].value.trim().length === 0) {
      return node.clone({
        children: [],
        hasDanglingSpaces: node.children.length !== 0
      });
    }

    var isWhitespaceSensitive = isWhitespaceSensitiveNode$1(node);
    var isIndentationSensitive = isIndentationSensitiveNode$1(node);
    return node.clone({
      isWhitespaceSensitive,
      isIndentationSensitive,
      children: node.children // extract whitespace nodes
      .reduce(function (newChildren, child) {
        if (child.type !== "text" || isWhitespaceSensitive) {
          return newChildren.concat(child);
        }

        var localChildren = [];

        var _child$value$match = child.value.match(/^(\s*)([\s\S]*?)(\s*)$/),
            _child$value$match2 = _slicedToArray(_child$value$match, 4),
            leadingSpaces = _child$value$match2[1],
            text = _child$value$match2[2],
            trailingSpaces = _child$value$match2[3];

        if (leadingSpaces) {
          localChildren.push({
            type: TYPE_WHITESPACE
          });
        }

        var ParseSourceSpan = child.sourceSpan.constructor;

        if (text) {
          localChildren.push({
            type: "text",
            value: text,
            sourceSpan: new ParseSourceSpan(child.sourceSpan.start.moveBy(leadingSpaces.length), child.sourceSpan.end.moveBy(-trailingSpaces.length))
          });
        }

        if (trailingSpaces) {
          localChildren.push({
            type: TYPE_WHITESPACE
          });
        }

        return newChildren.concat(localChildren);
      }, []) // set hasLeadingSpaces/hasTrailingSpaces and filter whitespace nodes
      .reduce(function (newChildren, child, i, children) {
        if (child.type === TYPE_WHITESPACE) {
          return newChildren;
        }

        var hasLeadingSpaces = i !== 0 && children[i - 1].type === TYPE_WHITESPACE;
        var hasTrailingSpaces = i !== children.length - 1 && children[i + 1].type === TYPE_WHITESPACE;
        return newChildren.concat(Object.assign({}, child, {
          hasLeadingSpaces,
          hasTrailingSpaces
        }));
      }, [])
    });
  });
}

function addIsSelfClosing(ast
/*, options */
) {
  return ast.map(function (node) {
    return Object.assign(node, {
      isSelfClosing: !node.children || node.type === "element" && (node.tagDefinition.isVoid || // self-closing
      node.startSourceSpan === node.endSourceSpan)
    });
  });
}

function addHasHtmComponentClosingTag(ast, options) {
  return ast.map(function (node) {
    return node.type !== "element" ? node : Object.assign(node, {
      hasHtmComponentClosingTag: node.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(options.originalText.slice(node.endSourceSpan.start.offset, node.endSourceSpan.end.offset))
    });
  });
}

function addCssDisplay(ast, options) {
  return ast.map(function (node) {
    return Object.assign(node, {
      cssDisplay: getNodeCssStyleDisplay$1(node, options)
    });
  });
}
/**
 * - add `isLeadingSpaceSensitive` field
 * - add `isTrailingSpaceSensitive` field
 * - add `isDanglingSpaceSensitive` field for parent nodes
 */


function addIsSpaceSensitive(ast
/*, options */
) {
  return ast.map(function (node) {
    if (!node.children) {
      return node;
    }

    if (node.children.length === 0) {
      return node.clone({
        isDanglingSpaceSensitive: isDanglingSpaceSensitiveNode$1(node)
      });
    }

    return node.clone({
      children: node.children.map(function (child) {
        return Object.assign({}, child, {
          isLeadingSpaceSensitive: isLeadingSpaceSensitiveNode$1(child),
          isTrailingSpaceSensitive: isTrailingSpaceSensitiveNode$1(child)
        });
      }).map(function (child, index, children) {
        return Object.assign({}, child, {
          isLeadingSpaceSensitive: index === 0 ? child.isLeadingSpaceSensitive : children[index - 1].isTrailingSpaceSensitive && child.isLeadingSpaceSensitive,
          isTrailingSpaceSensitive: index === children.length - 1 ? child.isTrailingSpaceSensitive : children[index + 1].isLeadingSpaceSensitive && child.isTrailingSpaceSensitive
        });
      })
    });
  });
}

var preprocess_1$2 = preprocess$2;

function hasPragma$3(text) {
  return /^\s*<!--\s*@(format|prettier)\s*-->/.test(text);
}

function insertPragma$6(text) {
  return "<!-- @format -->\n\n" + text.replace(/^\s*\n/, "");
}

var pragma$4 = {
  hasPragma: hasPragma$3,
  insertPragma: insertPragma$6
};

var _require$$0$builders$8 = doc.builders,
    concat$e = _require$$0$builders$8.concat,
    group$e = _require$$0$builders$8.group;
/**
 *     v-for="... in ..."
 *     v-for="... of ..."
 *     v-for="(..., ...) in ..."
 *     v-for="(..., ...) of ..."
 */

function printVueFor(value, textToDoc) {
  var _parseVueFor = parseVueFor(value),
      left = _parseVueFor.left,
      operator = _parseVueFor.operator,
      right = _parseVueFor.right;

  return concat$e([group$e(textToDoc(`function _(${left}) {}`, {
    parser: "babel",
    __isVueForBindingLeft: true
  })), " ", operator, " ", textToDoc(right, {
    parser: "__js_expression"
  })]);
} // modified from https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/parser/index.js#L370-L387


function parseVueFor(value) {
  var forAliasRE = /([^]*?)\s+(in|of)\s+([^]*)/;
  var forIteratorRE = /,([^,}\]]*)(?:,([^,}\]]*))?$/;
  var stripParensRE = /^\(|\)$/g;
  var inMatch = value.match(forAliasRE);

  if (!inMatch) {
    return;
  }

  var res = {};
  res.for = inMatch[3].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, "");
  var iteratorMatch = alias.match(forIteratorRE);

  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, "");
    res.iterator1 = iteratorMatch[1].trim();

    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }

  return {
    left: `${[res.alias, res.iterator1, res.iterator2].filter(Boolean).join(",")}`,
    operator: inMatch[2],
    right: res.for
  };
}

function printVueSlotScope(value, textToDoc) {
  return textToDoc(`function _(${value}) {}`, {
    parser: "babel",
    __isVueSlotScope: true
  });
}

function isVueEventBindingExpression$2(eventBindingValue) {
  // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/codegen/events.js#L3-L4
  // arrow function or anonymous function
  var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/; // simple member expression chain (a, a.b, a['b'], a["b"], a[0], a[b])

  var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/helpers.js#L104

  var value = eventBindingValue.trim();
  return fnExpRE.test(value) || simplePathRE.test(value);
}

var syntaxVue = {
  isVueEventBindingExpression: isVueEventBindingExpression$2,
  printVueFor,
  printVueSlotScope
};

var parseSrcset = createCommonjsModule(function (module) {
  /**
   * Srcset Parser
   *
   * By Alex Bell |  MIT License
   *
   * JS Parser for the string value that appears in markup <img srcset="here">
   *
   * @returns Array [{url: _, d: _, w: _, h:_}, ...]
   *
   * Based super duper closely on the reference algorithm at:
   * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute
   *
   * Most comments are copied in directly from the spec
   * (except for comments in parens).
   */
  (function (root, factory) {
    if ( module.exports) {
      // Node. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like Node.
      module.exports = factory();
    } else {
      // Browser globals (root is window)
      root.parseSrcset = factory();
    }
  })(this, function () {
    // 1. Let input be the value passed to this algorithm.
    return function (input, options) {
      var logger = options && options.logger || console; // UTILITY FUNCTIONS
      // Manual is faster than RegEx
      // http://bjorn.tipling.com/state-and-regular-expressions-in-javascript
      // http://jsperf.com/whitespace-character/5

      function isSpace(c) {
        return c === "\u0020" || // space
        c === "\u0009" || // horizontal tab
        c === "\u000A" || // new line
        c === "\u000C" || // form feed
        c === "\u000D"; // carriage return
      }

      function collectCharacters(regEx) {
        var chars,
            match = regEx.exec(input.substring(pos));

        if (match) {
          chars = match[0];
          pos += chars.length;
          return chars;
        }
      }

      var inputLength = input.length,
          // (Don't use \s, to avoid matching non-breaking space)
      regexLeadingSpaces = /^[ \t\n\r\u000c]+/,
          regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/,
          regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/,
          regexTrailingCommas = /[,]+$/,
          regexNonNegativeInteger = /^\d+$/,
          // ( Positive or negative or unsigned integers or decimals, without or without exponents.
      // Must include at least one digit.
      // According to spec tests any decimal point must be followed by a digit.
      // No leading plus sign is allowed.)
      // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number
      regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,
          url,
          descriptors,
          currentDescriptor,
          state,
          c,
          // 2. Let position be a pointer into input, initially pointing at the start
      //    of the string.
      pos = 0,
          // 3. Let candidates be an initially empty source set.
      candidates = []; // 4. Splitting loop: Collect a sequence of characters that are space
      //    characters or U+002C COMMA characters. If any U+002C COMMA characters
      //    were collected, that is a parse error.

      while (true) {
        collectCharacters(regexLeadingCommasOrSpaces); // 5. If position is past the end of input, return candidates and abort these steps.

        if (pos >= inputLength) {
          return candidates; // (we're done, this is the sole return path)
        } // 6. Collect a sequence of characters that are not space characters,
        //    and let that be url.


        url = collectCharacters(regexLeadingNotSpaces); // 7. Let descriptors be a new empty list.

        descriptors = []; // 8. If url ends with a U+002C COMMA character (,), follow these substeps:
        //		(1). Remove all trailing U+002C COMMA characters from url. If this removed
        //         more than one character, that is a parse error.

        if (url.slice(-1) === ",") {
          url = url.replace(regexTrailingCommas, ""); // (Jump ahead to step 9 to skip tokenization and just push the candidate).

          parseDescriptors(); //	Otherwise, follow these substeps:
        } else {
          tokenize();
        } // (close else of step 8)
        // 16. Return to the step labeled splitting loop.

      } // (Close of big while loop.)

      /**
       * Tokenizes descriptor properties prior to parsing
       * Returns undefined.
       */


      function tokenize() {
        // 8.1. Descriptor tokeniser: Skip whitespace
        collectCharacters(regexLeadingSpaces); // 8.2. Let current descriptor be the empty string.

        currentDescriptor = ""; // 8.3. Let state be in descriptor.

        state = "in descriptor";

        while (true) {
          // 8.4. Let c be the character at position.
          c = input.charAt(pos); //  Do the following depending on the value of state.
          //  For the purpose of this step, "EOF" is a special character representing
          //  that position is past the end of input.
          // In descriptor

          if (state === "in descriptor") {
            // Do the following, depending on the value of c:
            // Space character
            // If current descriptor is not empty, append current descriptor to
            // descriptors and let current descriptor be the empty string.
            // Set state to after descriptor.
            if (isSpace(c)) {
              if (currentDescriptor) {
                descriptors.push(currentDescriptor);
                currentDescriptor = "";
                state = "after descriptor";
              } // U+002C COMMA (,)
              // Advance position to the next character in input. If current descriptor
              // is not empty, append current descriptor to descriptors. Jump to the step
              // labeled descriptor parser.

            } else if (c === ",") {
              pos += 1;

              if (currentDescriptor) {
                descriptors.push(currentDescriptor);
              }

              parseDescriptors();
              return; // U+0028 LEFT PARENTHESIS (()
              // Append c to current descriptor. Set state to in parens.
            } else if (c === "\u0028") {
              currentDescriptor = currentDescriptor + c;
              state = "in parens"; // EOF
              // If current descriptor is not empty, append current descriptor to
              // descriptors. Jump to the step labeled descriptor parser.
            } else if (c === "") {
              if (currentDescriptor) {
                descriptors.push(currentDescriptor);
              }

              parseDescriptors();
              return; // Anything else
              // Append c to current descriptor.
            } else {
              currentDescriptor = currentDescriptor + c;
            } // (end "in descriptor"
            // In parens

          } else if (state === "in parens") {
            // U+0029 RIGHT PARENTHESIS ())
            // Append c to current descriptor. Set state to in descriptor.
            if (c === ")") {
              currentDescriptor = currentDescriptor + c;
              state = "in descriptor"; // EOF
              // Append current descriptor to descriptors. Jump to the step labeled
              // descriptor parser.
            } else if (c === "") {
              descriptors.push(currentDescriptor);
              parseDescriptors();
              return; // Anything else
              // Append c to current descriptor.
            } else {
              currentDescriptor = currentDescriptor + c;
            } // After descriptor

          } else if (state === "after descriptor") {
            // Do the following, depending on the value of c:
            // Space character: Stay in this state.
            if (isSpace(c)) ; else if (c === "") {
              parseDescriptors();
              return; // Anything else
              // Set state to in descriptor. Set position to the previous character in input.
            } else {
              state = "in descriptor";
              pos -= 1;
            }
          } // Advance position to the next character in input.


          pos += 1; // Repeat this step.
        } // (close while true loop)

      }
      /**
       * Adds descriptor properties to a candidate, pushes to the candidates array
       * @return undefined
       */
      // Declared outside of the while loop so that it's only created once.


      function parseDescriptors() {
        // 9. Descriptor parser: Let error be no.
        var pError = false,
            // 10. Let width be absent.
        // 11. Let density be absent.
        // 12. Let future-compat-h be absent. (We're implementing it now as h)
        w,
            d,
            h,
            i,
            candidate = {},
            desc,
            lastChar,
            value,
            intVal,
            floatVal; // 13. For each descriptor in descriptors, run the appropriate set of steps
        // from the following list:

        for (i = 0; i < descriptors.length; i++) {
          desc = descriptors[i];
          lastChar = desc[desc.length - 1];
          value = desc.substring(0, desc.length - 1);
          intVal = parseInt(value, 10);
          floatVal = parseFloat(value); // If the descriptor consists of a valid non-negative integer followed by
          // a U+0077 LATIN SMALL LETTER W character

          if (regexNonNegativeInteger.test(value) && lastChar === "w") {
            // If width and density are not both absent, then let error be yes.
            if (w || d) {
              pError = true;
            } // Apply the rules for parsing non-negative integers to the descriptor.
            // If the result is zero, let error be yes.
            // Otherwise, let width be the result.


            if (intVal === 0) {
              pError = true;
            } else {
              w = intVal;
            } // If the descriptor consists of a valid floating-point number followed by
            // a U+0078 LATIN SMALL LETTER X character

          } else if (regexFloatingPoint.test(value) && lastChar === "x") {
            // If width, density and future-compat-h are not all absent, then let error
            // be yes.
            if (w || d || h) {
              pError = true;
            } // Apply the rules for parsing floating-point number values to the descriptor.
            // If the result is less than zero, let error be yes. Otherwise, let density
            // be the result.


            if (floatVal < 0) {
              pError = true;
            } else {
              d = floatVal;
            } // If the descriptor consists of a valid non-negative integer followed by
            // a U+0068 LATIN SMALL LETTER H character

          } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
            // If height and density are not both absent, then let error be yes.
            if (h || d) {
              pError = true;
            } // Apply the rules for parsing non-negative integers to the descriptor.
            // If the result is zero, let error be yes. Otherwise, let future-compat-h
            // be the result.


            if (intVal === 0) {
              pError = true;
            } else {
              h = intVal;
            } // Anything else, Let error be yes.

          } else {
            pError = true;
          }
        } // (close step 13 for loop)
        // 15. If error is still no, then append a new image source to candidates whose
        // URL is url, associated with a width width if not absent and a pixel
        // density density if not absent. Otherwise, there is a parse error.


        if (!pError) {
          candidate.url = url;

          if (w) {
            candidate.w = w;
          }

          if (d) {
            candidate.d = d;
          }

          if (h) {
            candidate.h = h;
          }

          candidates.push(candidate);
        } else if (logger && logger.error) {
          logger.error("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
        }
      } // (close parseDescriptors fn)

    };
  });
});

var _require$$0$builders$9 = doc.builders,
    concat$f = _require$$0$builders$9.concat,
    ifBreak$6 = _require$$0$builders$9.ifBreak,
    join$a = _require$$0$builders$9.join,
    line$7 = _require$$0$builders$9.line;

function printImgSrcset(value) {
  var srcset = parseSrcset(value, {
    logger: {
      error(message) {
        throw new Error(message);
      }

    }
  });
  var hasW = srcset.some(function (src) {
    return src.w;
  });
  var hasH = srcset.some(function (src) {
    return src.h;
  });
  var hasX = srcset.some(function (src) {
    return src.d;
  });

  if (hasW + hasH + hasX !== 1) {
    throw new Error(`Mixed descriptor in srcset is not supported`);
  }

  var key = hasW ? "w" : hasH ? "h" : "d";
  var unit = hasW ? "w" : hasH ? "h" : "x";

  var getMax = function getMax(values) {
    return Math.max.apply(Math, values);
  };

  var urls = srcset.map(function (src) {
    return src.url;
  });
  var maxUrlLength = getMax(urls.map(function (url) {
    return url.length;
  }));
  var descriptors = srcset.map(function (src) {
    return src[key];
  }).map(function (descriptor) {
    return descriptor ? descriptor.toString() : "";
  });
  var descriptorLeftLengths = descriptors.map(function (descriptor) {
    var index = descriptor.indexOf(".");
    return index === -1 ? descriptor.length : index;
  });
  var maxDescriptorLeftLength = getMax(descriptorLeftLengths);
  return join$a(concat$f([",", line$7]), urls.map(function (url, index) {
    var parts = [url];
    var descriptor = descriptors[index];

    if (descriptor) {
      var urlPadding = maxUrlLength - url.length + 1;
      var descriptorPadding = maxDescriptorLeftLength - descriptorLeftLengths[index];
      var alignment = " ".repeat(urlPadding + descriptorPadding);
      parts.push(ifBreak$6(alignment, " "), descriptor + unit);
    }

    return concat$f(parts);
  }));
}

var syntaxAttribute = {
  printImgSrcset
};

var builders = doc.builders,
    _require$$0$utils = doc.utils,
    stripTrailingHardline$2 = _require$$0$utils.stripTrailingHardline,
    mapDoc$7 = _require$$0$utils.mapDoc;
var breakParent$4 = builders.breakParent,
    dedentToRoot$2 = builders.dedentToRoot,
    fill$5 = builders.fill,
    group$f = builders.group,
    hardline$c = builders.hardline,
    ifBreak$7 = builders.ifBreak,
    indent$9 = builders.indent,
    join$b = builders.join,
    line$8 = builders.line,
    literalline$6 = builders.literalline,
    markAsRoot$4 = builders.markAsRoot,
    softline$7 = builders.softline;
var countChars$1 = utils$5.countChars,
    countParents$1 = utils$5.countParents,
    dedentString$1 = utils$5.dedentString,
    forceBreakChildren$1 = utils$5.forceBreakChildren,
    forceBreakContent$1 = utils$5.forceBreakContent,
    forceNextEmptyLine$1 = utils$5.forceNextEmptyLine,
    getLastDescendant$1 = utils$5.getLastDescendant,
    getPrettierIgnoreAttributeCommentData$1 = utils$5.getPrettierIgnoreAttributeCommentData,
    hasPrettierIgnore$4 = utils$5.hasPrettierIgnore,
    inferScriptParser$1 = utils$5.inferScriptParser,
    isScriptLikeTag$1 = utils$5.isScriptLikeTag,
    isTextLikeNode$1 = utils$5.isTextLikeNode,
    normalizeParts$2 = utils$5.normalizeParts,
    preferHardlineAsLeadingSpaces$1 = utils$5.preferHardlineAsLeadingSpaces,
    shouldNotPrintClosingTag$1 = utils$5.shouldNotPrintClosingTag,
    shouldPreserveContent$1 = utils$5.shouldPreserveContent,
    unescapeQuoteEntities$1 = utils$5.unescapeQuoteEntities;
var replaceEndOfLineWith$2 = util.replaceEndOfLineWith;
var insertPragma$7 = pragma$4.insertPragma;
var printVueFor$1 = syntaxVue.printVueFor,
    printVueSlotScope$1 = syntaxVue.printVueSlotScope,
    isVueEventBindingExpression$3 = syntaxVue.isVueEventBindingExpression;
var printImgSrcset$1 = syntaxAttribute.printImgSrcset;

function concat$g(parts) {
  var newParts = normalizeParts$2(parts);
  return newParts.length === 0 ? "" : newParts.length === 1 ? newParts[0] : builders.concat(newParts);
}

function embed$4(path, print, textToDoc, options) {
  var node = path.getValue();

  switch (node.type) {
    case "text":
      {
        if (isScriptLikeTag$1(node.parent)) {
          var parser = inferScriptParser$1(node.parent);

          if (parser) {
            var value = parser === "markdown" ? dedentString$1(node.value.replace(/^[^\S\n]*?\n/, "")) : node.value;
            return builders.concat([concat$g([breakParent$4, printOpeningTagPrefix(node, options), stripTrailingHardline$2(textToDoc(value, {
              parser
            })), printClosingTagSuffix(node, options)])]);
          }
        } else if (node.parent.type === "interpolation") {
          return concat$g([indent$9(concat$g([line$8, textToDoc(node.value, Object.assign({
            __isInHtmlInterpolation: true // to avoid unexpected `}}`

          }, options.parser === "angular" ? {
            parser: "__ng_interpolation",
            trailingComma: "none"
          } : options.parser === "vue" ? {
            parser: "__vue_expression"
          } : {
            parser: "__js_expression"
          }))])), node.parent.next && needsToBorrowPrevClosingTagEndMarker(node.parent.next) ? " " : line$8]);
        }

        break;
      }

    case "attribute":
      {
        if (!node.value) {
          break;
        } // lit-html: html`<my-element obj=${obj}></my-element>`


        if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(options.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {
          return concat$g([node.rawName, "=", node.value]);
        } // lwc: html`<my-element data-for={value}></my-element>`


        if (options.parser === "lwc") {
          var interpolationRegex = /^\{[\s\S]*\}$/;

          if (interpolationRegex.test(options.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {
            return concat$g([node.rawName, "=", node.value]);
          }
        }

        var embeddedAttributeValueDoc = printEmbeddedAttributeValue(node, function (code, opts) {
          return (// strictly prefer single quote to avoid unnecessary html entity escape
            textToDoc(code, Object.assign({
              __isInHtmlAttribute: true
            }, opts))
          );
        }, options);

        if (embeddedAttributeValueDoc) {
          return concat$g([node.rawName, '="', group$f(mapDoc$7(embeddedAttributeValueDoc, function (doc) {
            return typeof doc === "string" ? doc.replace(/"/g, "&quot;") : doc;
          })), '"']);
        }

        break;
      }

    case "yaml":
      return markAsRoot$4(concat$g(["---", hardline$c, node.value.trim().length === 0 ? "" : textToDoc(node.value, {
        parser: "yaml"
      }), "---"]));
  }
}

function genericPrint$5(path, options, print) {
  var node = path.getValue();

  switch (node.type) {
    case "root":
      // use original concat to not break stripTrailingHardline
      return builders.concat([group$f(printChildren$2(path, options, print)), hardline$c]);

    case "element":
    case "ieConditionalComment":
      {
        /**
         * do not break:
         *
         *     <div>{{
         *         ~
         *       interpolation
         *     }}</div>
         *            ~
         *
         * exception: break if the opening tag breaks
         *
         *     <div
         *       long
         *           ~
         *       >{{
         *         interpolation
         *       }}</div
         *              ~
         *     >
         */
        var shouldHugContent = node.children.length === 1 && node.firstChild.type === "interpolation" && node.firstChild.isLeadingSpaceSensitive && !node.firstChild.hasLeadingSpaces && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces;
        var attrGroupId = Symbol("element-attr-group-id");
        return concat$g([group$f(concat$g([group$f(printOpeningTag(path, options, print), {
          id: attrGroupId
        }), node.children.length === 0 ? node.hasDanglingSpaces && node.isDanglingSpaceSensitive ? line$8 : "" : concat$g([forceBreakContent$1(node) ? breakParent$4 : "", function (childrenDoc) {
          return shouldHugContent ? ifBreak$7(indent$9(childrenDoc), childrenDoc, {
            groupId: attrGroupId
          }) : isScriptLikeTag$1(node) && node.parent.type === "root" && options.parser === "vue" && !options.vueIndentScriptAndStyle ? childrenDoc : indent$9(childrenDoc);
        }(concat$g([shouldHugContent ? ifBreak$7(softline$7, "", {
          groupId: attrGroupId
        }) : node.firstChild.hasLeadingSpaces && node.firstChild.isLeadingSpaceSensitive ? line$8 : node.firstChild.type === "text" && node.isWhitespaceSensitive && node.isIndentationSensitive ? dedentToRoot$2(softline$7) : softline$7, printChildren$2(path, options, print)])), (node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : needsToBorrowLastChildClosingTagEndMarker(node.parent)) ? node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive ? " " : "" : shouldHugContent ? ifBreak$7(softline$7, "", {
          groupId: attrGroupId
        }) : node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive ? line$8 : (node.lastChild.type === "comment" || node.lastChild.type === "text" && node.isWhitespaceSensitive && node.isIndentationSensitive) && new RegExp(`\\n\\s{${options.tabWidth * countParents$1(path, function (n) {
          return n.parent && n.parent.type !== "root";
        })}}$`).test(node.lastChild.value) ?
        /**
         *     <div>
         *       <pre>
         *         something
         *       </pre>
         *            ~
         *     </div>
         */
        "" : softline$7])])), printClosingTag(node, options)]);
      }

    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return concat$g([printOpeningTagStart(node), printClosingTagEnd(node)]);

    case "interpolation":
      return concat$g([printOpeningTagStart(node, options), concat$g(path.map(print, "children")), printClosingTagEnd(node, options)]);

    case "text":
      {
        if (node.parent.type === "interpolation") {
          // replace the trailing literalline with hardline for better readability
          var trailingNewlineRegex = /\n[^\S\n]*?$/;
          var hasTrailingNewline = trailingNewlineRegex.test(node.value);
          var value = hasTrailingNewline ? node.value.replace(trailingNewlineRegex, "") : node.value;
          return concat$g([concat$g(replaceEndOfLineWith$2(value, literalline$6)), hasTrailingNewline ? hardline$c : ""]);
        }

        return fill$5(normalizeParts$2([].concat(printOpeningTagPrefix(node, options), getTextValueParts(node), printClosingTagSuffix(node, options))));
      }

    case "docType":
      return concat$g([group$f(concat$g([printOpeningTagStart(node, options), " ", node.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")])), printClosingTagEnd(node, options)]);

    case "comment":
      {
        return concat$g([printOpeningTagPrefix(node, options), concat$g(replaceEndOfLineWith$2(options.originalText.slice(options.locStart(node), options.locEnd(node)), literalline$6)), printClosingTagSuffix(node, options)]);
      }

    case "attribute":
      {
        if (node.value === null) {
          return node.rawName;
        }

        var _value = unescapeQuoteEntities$1(node.value);

        var singleQuoteCount = countChars$1(_value, "'");
        var doubleQuoteCount = countChars$1(_value, '"');
        var quote = singleQuoteCount < doubleQuoteCount ? "'" : '"';
        return concat$g([node.rawName, concat$g(["=", quote, concat$g(replaceEndOfLineWith$2(quote === '"' ? _value.replace(/"/g, "&quot;") : _value.replace(/'/g, "&apos;"), literalline$6)), quote])]);
      }

    case "yaml":
    case "toml":
      return concat$g(replaceEndOfLineWith$2(node.raw, literalline$6));

    default:
      throw new Error(`Unexpected node type ${node.type}`);
  }
}

function printChildren$2(path, options, print) {
  var node = path.getValue();

  if (forceBreakChildren$1(node)) {
    return concat$g([breakParent$4, concat$g(path.map(function (childPath) {
      var childNode = childPath.getValue();
      var prevBetweenLine = !childNode.prev ? "" : printBetweenLine(childNode.prev, childNode);
      return concat$g([!prevBetweenLine ? "" : concat$g([prevBetweenLine, forceNextEmptyLine$1(childNode.prev) ? hardline$c : ""]), printChild(childPath)]);
    }, "children"))]);
  }

  var groupIds = node.children.map(function () {
    return Symbol("");
  });
  return concat$g(path.map(function (childPath, childIndex) {
    var childNode = childPath.getValue();

    if (isTextLikeNode$1(childNode)) {
      if (childNode.prev && isTextLikeNode$1(childNode.prev)) {
        var _prevBetweenLine = printBetweenLine(childNode.prev, childNode);

        if (_prevBetweenLine) {
          if (forceNextEmptyLine$1(childNode.prev)) {
            return concat$g([hardline$c, hardline$c, printChild(childPath)]);
          }

          return concat$g([_prevBetweenLine, printChild(childPath)]);
        }
      }

      return printChild(childPath);
    }

    var prevParts = [];
    var leadingParts = [];
    var trailingParts = [];
    var nextParts = [];
    var prevBetweenLine = childNode.prev ? printBetweenLine(childNode.prev, childNode) : "";
    var nextBetweenLine = childNode.next ? printBetweenLine(childNode, childNode.next) : "";

    if (prevBetweenLine) {
      if (forceNextEmptyLine$1(childNode.prev)) {
        prevParts.push(hardline$c, hardline$c);
      } else if (prevBetweenLine === hardline$c) {
        prevParts.push(hardline$c);
      } else {
        if (isTextLikeNode$1(childNode.prev)) {
          leadingParts.push(prevBetweenLine);
        } else {
          leadingParts.push(ifBreak$7("", softline$7, {
            groupId: groupIds[childIndex - 1]
          }));
        }
      }
    }

    if (nextBetweenLine) {
      if (forceNextEmptyLine$1(childNode)) {
        if (isTextLikeNode$1(childNode.next)) {
          nextParts.push(hardline$c, hardline$c);
        }
      } else if (nextBetweenLine === hardline$c) {
        if (isTextLikeNode$1(childNode.next)) {
          nextParts.push(hardline$c);
        }
      } else {
        trailingParts.push(nextBetweenLine);
      }
    }

    return concat$g([].concat(prevParts, group$f(concat$g([concat$g(leadingParts), group$f(concat$g([printChild(childPath), concat$g(trailingParts)]), {
      id: groupIds[childIndex]
    })])), nextParts));
  }, "children"));

  function printChild(childPath) {
    var child = childPath.getValue();

    if (hasPrettierIgnore$4(child)) {
      return concat$g([].concat(printOpeningTagPrefix(child, options), replaceEndOfLineWith$2(options.originalText.slice(options.locStart(child) + (child.prev && needsToBorrowNextOpeningTagStartMarker(child.prev) ? printOpeningTagStartMarker(child).length : 0), options.locEnd(child) - (child.next && needsToBorrowPrevClosingTagEndMarker(child.next) ? printClosingTagEndMarker(child, options).length : 0)), literalline$6), printClosingTagSuffix(child, options)));
    }

    if (shouldPreserveContent$1(child, options)) {
      return concat$g([].concat(printOpeningTagPrefix(child, options), group$f(printOpeningTag(childPath, options, print)), replaceEndOfLineWith$2(options.originalText.slice(child.startSourceSpan.end.offset + (child.firstChild && needsToBorrowParentOpeningTagEndMarker(child.firstChild) ? -printOpeningTagEndMarker(child).length : 0), child.endSourceSpan.start.offset + (child.lastChild && needsToBorrowParentClosingTagStartMarker(child.lastChild) ? printClosingTagStartMarker(child, options).length : needsToBorrowLastChildClosingTagEndMarker(child) ? -printClosingTagEndMarker(child.lastChild, options).length : 0)), literalline$6), printClosingTag(child, options), printClosingTagSuffix(child, options)));
    }

    return print(childPath);
  }

  function printBetweenLine(prevNode, nextNode) {
    return isTextLikeNode$1(prevNode) && isTextLikeNode$1(nextNode) ? prevNode.isTrailingSpaceSensitive ? prevNode.hasTrailingSpaces ? preferHardlineAsLeadingSpaces$1(nextNode) ? hardline$c : line$8 : "" : preferHardlineAsLeadingSpaces$1(nextNode) ? hardline$c : softline$7 : needsToBorrowNextOpeningTagStartMarker(prevNode) && (
    /**
     *     123<a
     *          ~
     *       ><b>
     */
    nextNode.firstChild ||
    /**
     *     123<!--
     *            ~
     *     -->
     */
    nextNode.isSelfClosing ||
    /**
     *     123<span
     *             ~
     *       attr
     */
    nextNode.type === "element" && nextNode.attrs.length !== 0) ||
    /**
     *     <img
     *       src="long"
     *                 ~
     *     />123
     */
    prevNode.type === "element" && prevNode.isSelfClosing && needsToBorrowPrevClosingTagEndMarker(nextNode) ? "" : !nextNode.isLeadingSpaceSensitive || preferHardlineAsLeadingSpaces$1(nextNode) ||
    /**
     *       Want to write us a letter? Use our<a
     *         ><b><a>mailing address</a></b></a
     *                                          ~
     *       >.
     */
    needsToBorrowPrevClosingTagEndMarker(nextNode) && prevNode.lastChild && needsToBorrowParentClosingTagStartMarker(prevNode.lastChild) && prevNode.lastChild.lastChild && needsToBorrowParentClosingTagStartMarker(prevNode.lastChild.lastChild) ? hardline$c : nextNode.hasLeadingSpaces ? line$8 : softline$7;
  }
}

function printOpeningTag(path, options, print) {
  var node = path.getValue();
  var forceNotToBreakAttrContent = node.type === "element" && node.fullName === "script" && node.attrs.length === 1 && node.attrs[0].fullName === "src" && node.children.length === 0;
  return concat$g([printOpeningTagStart(node, options), !node.attrs || node.attrs.length === 0 ? node.isSelfClosing ?
  /**
   *     <br />
   *        ^
   */
  " " : "" : concat$g([indent$9(concat$g([forceNotToBreakAttrContent ? " " : line$8, join$b(line$8, function (ignoreAttributeData) {
    var hasPrettierIgnoreAttribute = typeof ignoreAttributeData === "boolean" ? function () {
      return ignoreAttributeData;
    } : Array.isArray(ignoreAttributeData) ? function (attr) {
      return ignoreAttributeData.indexOf(attr.rawName) !== -1;
    } : function () {
      return false;
    };
    return path.map(function (attrPath) {
      var attr = attrPath.getValue();
      return hasPrettierIgnoreAttribute(attr) ? concat$g(replaceEndOfLineWith$2(options.originalText.slice(options.locStart(attr), options.locEnd(attr)), literalline$6)) : print(attrPath);
    }, "attrs");
  }(node.prev && node.prev.type === "comment" && getPrettierIgnoreAttributeCommentData$1(node.prev.value)))])),
  /**
   *     123<a
   *       attr
   *           ~
   *       >456
   */
  node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) ||
  /**
   *     <span
   *       >123<meta
   *                ~
   *     /></span>
   */
  node.isSelfClosing && needsToBorrowLastChildClosingTagEndMarker(node.parent) ? "" : node.isSelfClosing ? forceNotToBreakAttrContent ? " " : line$8 : forceNotToBreakAttrContent ? "" : softline$7]), node.isSelfClosing ? "" : printOpeningTagEnd(node)]);
}

function printOpeningTagStart(node, options) {
  return node.prev && needsToBorrowNextOpeningTagStartMarker(node.prev) ? "" : concat$g([printOpeningTagPrefix(node, options), printOpeningTagStartMarker(node)]);
}

function printOpeningTagEnd(node) {
  return node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) ? "" : printOpeningTagEndMarker(node);
}

function printClosingTag(node, options) {
  return concat$g([node.isSelfClosing ? "" : printClosingTagStart(node, options), printClosingTagEnd(node, options)]);
}

function printClosingTagStart(node, options) {
  return node.lastChild && needsToBorrowParentClosingTagStartMarker(node.lastChild) ? "" : concat$g([printClosingTagPrefix(node, options), printClosingTagStartMarker(node, options)]);
}

function printClosingTagEnd(node, options) {
  return (node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : needsToBorrowLastChildClosingTagEndMarker(node.parent)) ? "" : concat$g([printClosingTagEndMarker(node, options), printClosingTagSuffix(node, options)]);
}

function needsToBorrowNextOpeningTagStartMarker(node) {
  /**
   *     123<p
   *        ^^
   *     >
   */
  return node.next && !isTextLikeNode$1(node.next) && isTextLikeNode$1(node) && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces;
}

function needsToBorrowParentOpeningTagEndMarker(node) {
  /**
   *     <p
   *       >123
   *       ^
   *
   *     <p
   *       ><a
   *       ^
   */
  return !node.prev && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;
}

function needsToBorrowPrevClosingTagEndMarker(node) {
  /**
   *     <p></p
   *     >123
   *     ^
   *
   *     <p></p
   *     ><a
   *     ^
   */
  return node.prev && !isTextLikeNode$1(node.prev) && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;
}

function needsToBorrowLastChildClosingTagEndMarker(node) {
  /**
   *     <p
   *       ><a></a
   *       ></p
   *       ^
   *     >
   */
  return node.lastChild && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces && !isTextLikeNode$1(getLastDescendant$1(node.lastChild));
}

function needsToBorrowParentClosingTagStartMarker(node) {
  /**
   *     <p>
   *       123</p
   *          ^^^
   *     >
   *
   *         123</b
   *       ></a
   *        ^^^
   *     >
   */
  return !node.next && !node.hasTrailingSpaces && node.isTrailingSpaceSensitive && isTextLikeNode$1(getLastDescendant$1(node));
}

function printOpeningTagPrefix(node, options) {
  return needsToBorrowParentOpeningTagEndMarker(node) ? printOpeningTagEndMarker(node.parent) : needsToBorrowPrevClosingTagEndMarker(node) ? printClosingTagEndMarker(node.prev, options) : "";
}

function printClosingTagPrefix(node, options) {
  return needsToBorrowLastChildClosingTagEndMarker(node) ? printClosingTagEndMarker(node.lastChild, options) : "";
}

function printClosingTagSuffix(node, options) {
  return needsToBorrowParentClosingTagStartMarker(node) ? printClosingTagStartMarker(node.parent, options) : needsToBorrowNextOpeningTagStartMarker(node) ? printOpeningTagStartMarker(node.next) : "";
}

function printOpeningTagStartMarker(node) {
  switch (node.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${node.condition}`;

    case "ieConditionalEndComment":
      return `<!--<!`;

    case "interpolation":
      return "{{";

    case "docType":
      return "<!DOCTYPE";

    case "element":
      if (node.condition) {
        return `<!--[if ${node.condition}]><!--><${node.rawName}`;
      }

    // fall through

    default:
      return `<${node.rawName}`;
  }
}

function printOpeningTagEndMarker(node) {
  assert$1(!node.isSelfClosing);

  switch (node.type) {
    case "ieConditionalComment":
      return "]>";

    case "element":
      if (node.condition) {
        return `><!--<![endif]-->`;
      }

    // fall through

    default:
      return `>`;
  }
}

function printClosingTagStartMarker(node, options) {
  assert$1(!node.isSelfClosing);

  if (shouldNotPrintClosingTag$1(node, options)) {
    return "";
  }

  switch (node.type) {
    case "ieConditionalComment":
      return "<!";

    case "element":
      if (node.hasHtmComponentClosingTag) {
        return "<//";
      }

    // fall through

    default:
      return `</${node.rawName}`;
  }
}

function printClosingTagEndMarker(node, options) {
  if (shouldNotPrintClosingTag$1(node, options)) {
    return "";
  }

  switch (node.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return `[endif]-->`;

    case "ieConditionalStartComment":
      return `]><!-->`;

    case "interpolation":
      return "}}";

    case "element":
      if (node.isSelfClosing) {
        return "/>";
      }

    // fall through

    default:
      return ">";
  }
}

function getTextValueParts(node) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.value;
  return node.parent.isWhitespaceSensitive ? node.parent.isIndentationSensitive ? replaceEndOfLineWith$2(value, literalline$6) : replaceEndOfLineWith$2(dedentString$1(value.replace(/^\s*?\n|\n\s*?$/g, "")), hardline$c) : // https://infra.spec.whatwg.org/#ascii-whitespace
  join$b(line$8, value.split(/[\t\n\f\r ]+/)).parts;
}

function printEmbeddedAttributeValue(node, originalTextToDoc, options) {
  var isKeyMatched = function isKeyMatched(patterns) {
    return new RegExp(patterns.join("|")).test(node.fullName);
  };

  var getValue = function getValue() {
    return unescapeQuoteEntities$1(node.value);
  };

  var shouldHug = false;

  var __onHtmlBindingRoot = function __onHtmlBindingRoot(root) {
    var rootNode = root.type === "NGRoot" ? root.node.type === "NGMicrosyntax" && root.node.body.length === 1 && root.node.body[0].type === "NGMicrosyntaxExpression" ? root.node.body[0].expression : root.node : root.type === "JsExpressionRoot" ? root.node : root;

    if (rootNode && (rootNode.type === "ObjectExpression" || rootNode.type === "ArrayExpression")) {
      shouldHug = true;
    }
  };

  var printHug = function printHug(doc) {
    return group$f(doc);
  };

  var printExpand = function printExpand(doc) {
    return group$f(concat$g([indent$9(concat$g([softline$7, doc])), softline$7]));
  };

  var printMaybeHug = function printMaybeHug(doc) {
    return shouldHug ? printHug(doc) : printExpand(doc);
  };

  var textToDoc = function textToDoc(code, opts) {
    return originalTextToDoc(code, Object.assign({
      __onHtmlBindingRoot
    }, opts));
  };

  if (node.fullName === "srcset" && (node.parent.fullName === "img" || node.parent.fullName === "source")) {
    return printExpand(printImgSrcset$1(getValue()));
  }

  if (options.parser === "vue") {
    if (node.fullName === "v-for") {
      return printVueFor$1(getValue(), textToDoc);
    }

    if (node.fullName === "slot-scope") {
      return printVueSlotScope$1(getValue(), textToDoc);
    }
    /**
     *     @click="jsStatement"
     *     @click="jsExpression"
     *     v-on:click="jsStatement"
     *     v-on:click="jsExpression"
     */


    var vueEventBindingPatterns = ["^@", "^v-on:"];
    /**
     *     :class="vueExpression"
     *     v-bind:id="vueExpression"
     */

    var vueExpressionBindingPatterns = ["^:", "^v-bind:"];
    /**
     *     v-if="jsExpression"
     */

    var jsExpressionBindingPatterns = ["^v-"];

    if (isKeyMatched(vueEventBindingPatterns)) {
      var value = getValue();
      return printMaybeHug(isVueEventBindingExpression$3(value) ? textToDoc(value, {
        parser: "__js_expression"
      }) : stripTrailingHardline$2(textToDoc(value, {
        parser: "__vue_event_binding"
      })));
    }

    if (isKeyMatched(vueExpressionBindingPatterns)) {
      return printMaybeHug(textToDoc(getValue(), {
        parser: "__vue_expression"
      }));
    }

    if (isKeyMatched(jsExpressionBindingPatterns)) {
      return printMaybeHug(textToDoc(getValue(), {
        parser: "__js_expression"
      }));
    }
  }

  if (options.parser === "angular") {
    var ngTextToDoc = function ngTextToDoc(code, opts) {
      return (// angular does not allow trailing comma
        textToDoc(code, Object.assign({
          trailingComma: "none"
        }, opts))
      );
    };
    /**
     *     *directive="angularDirective"
     */


    var ngDirectiveBindingPatterns = ["^\\*"];
    /**
     *     (click)="angularStatement"
     *     on-click="angularStatement"
     */

    var ngStatementBindingPatterns = ["^\\(.+\\)$", "^on-"];
    /**
     *     [target]="angularExpression"
     *     bind-target="angularExpression"
     *     [(target)]="angularExpression"
     *     bindon-target="angularExpression"
     */

    var ngExpressionBindingPatterns = ["^\\[.+\\]$", "^bind(on)?-"];
    /**
     *     i18n="longDescription"
     *     i18n-attr="longDescription"
     */

    var ngI18nPatterns = ["^i18n(-.+)?$"];

    if (isKeyMatched(ngStatementBindingPatterns)) {
      return printMaybeHug(ngTextToDoc(getValue(), {
        parser: "__ng_action"
      }));
    }

    if (isKeyMatched(ngExpressionBindingPatterns)) {
      return printMaybeHug(ngTextToDoc(getValue(), {
        parser: "__ng_binding"
      }));
    }

    if (isKeyMatched(ngI18nPatterns)) {
      return printExpand(fill$5(getTextValueParts(node, getValue())));
    }

    if (isKeyMatched(ngDirectiveBindingPatterns)) {
      return printMaybeHug(ngTextToDoc(getValue(), {
        parser: "__ng_directive"
      }));
    }

    var interpolationRegex = /\{\{([\s\S]+?)\}\}/g;

    var _value2 = getValue();

    if (interpolationRegex.test(_value2)) {
      var parts = [];

      _value2.split(interpolationRegex).forEach(function (part, index) {
        if (index % 2 === 0) {
          parts.push(concat$g(replaceEndOfLineWith$2(part, literalline$6)));
        } else {
          try {
            parts.push(group$f(concat$g(["{{", indent$9(concat$g([line$8, ngTextToDoc(part, {
              parser: "__ng_interpolation",
              __isInHtmlInterpolation: true // to avoid unexpected `}}`

            })])), line$8, "}}"])));
          } catch (e) {
            parts.push("{{", concat$g(replaceEndOfLineWith$2(part, literalline$6)), "}}");
          }
        }
      });

      return group$f(concat$g(parts));
    }
  }

  return null;
}

var printerHtml = {
  preprocess: preprocess_1$2,
  print: genericPrint$5,
  insertPragma: insertPragma$7,
  massageAstNode: clean$6,
  embed: embed$4
};

var CATEGORY_HTML = "HTML"; // format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js

var options$6 = {
  htmlWhitespaceSensitivity: {
    since: "1.15.0",
    category: CATEGORY_HTML,
    type: "choice",
    default: "css",
    description: "How to handle whitespaces in HTML.",
    choices: [{
      value: "css",
      description: "Respect the default value of CSS display property."
    }, {
      value: "strict",
      description: "Whitespaces are considered sensitive."
    }, {
      value: "ignore",
      description: "Whitespaces are considered insensitive."
    }]
  },
  vueIndentScriptAndStyle: {
    since: "1.19.0",
    category: CATEGORY_HTML,
    type: "boolean",
    default: false,
    description: "Indent script and style tags in Vue files."
  }
};

var name$g = "HTML";
var type$e = "markup";
var tmScope$e = "text.html.basic";
var aceMode$e = "html";
var codemirrorMode$b = "htmlmixed";
var codemirrorMimeType$b = "text/html";
var color$3 = "#e34c26";
var aliases$5 = [
	"xhtml"
];
var extensions$e = [
	".html",
	".htm",
	".html.hl",
	".inc",
	".st",
	".xht",
	".xhtml"
];
var languageId$e = 146;
var HTML = {
	name: name$g,
	type: type$e,
	tmScope: tmScope$e,
	aceMode: aceMode$e,
	codemirrorMode: codemirrorMode$b,
	codemirrorMimeType: codemirrorMimeType$b,
	color: color$3,
	aliases: aliases$5,
	extensions: extensions$e,
	languageId: languageId$e
};

var HTML$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$g,
  type: type$e,
  tmScope: tmScope$e,
  aceMode: aceMode$e,
  codemirrorMode: codemirrorMode$b,
  codemirrorMimeType: codemirrorMimeType$b,
  color: color$3,
  aliases: aliases$5,
  extensions: extensions$e,
  languageId: languageId$e,
  'default': HTML
});

var name$h = "Vue";
var type$f = "markup";
var color$4 = "#2c3e50";
var extensions$f = [
	".vue"
];
var tmScope$f = "text.html.vue";
var aceMode$f = "html";
var languageId$f = 391;
var Vue = {
	name: name$h,
	type: type$f,
	color: color$4,
	extensions: extensions$f,
	tmScope: tmScope$f,
	aceMode: aceMode$f,
	languageId: languageId$f
};

var Vue$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$h,
  type: type$f,
  color: color$4,
  extensions: extensions$f,
  tmScope: tmScope$f,
  aceMode: aceMode$f,
  languageId: languageId$f,
  'default': Vue
});

var require$$0$6 = getCjsExportFromNamespace(HTML$1);

var require$$1$2 = getCjsExportFromNamespace(Vue$1);

var languages$5 = [createLanguage(require$$0$6, function (data) {
  return Object.assign(data, {
    name: "Angular",
    since: "1.15.0",
    parsers: ["angular"],
    vscodeLanguageIds: ["html"],
    extensions: [".component.html"],
    filenames: []
  });
}), createLanguage(require$$0$6, function (data) {
  return Object.assign(data, {
    since: "1.15.0",
    parsers: ["html"],
    vscodeLanguageIds: ["html"],
    extensions: data.extensions.concat([".mjml" // MJML is considered XML in Linguist but it should be formatted as HTML
    ])
  });
}), createLanguage(require$$0$6, function (data) {
  return Object.assign(data, {
    name: "Lightning Web Components",
    since: "1.17.0",
    parsers: ["lwc"],
    vscodeLanguageIds: ["html"],
    extensions: [],
    filenames: []
  });
}), createLanguage(require$$1$2, function (data) {
  return Object.assign(data, {
    since: "1.10.0",
    parsers: ["vue"],
    vscodeLanguageIds: ["vue"]
  });
})];
var printers$5 = {
  html: printerHtml
};
var languageHtml = {
  languages: languages$5,
  printers: printers$5,
  options: options$6
};

function isPragma(text) {
  return /^\s*@(prettier|format)\s*$/.test(text);
}

function hasPragma$4(text) {
  return /^\s*#[^\n\S]*@(prettier|format)\s*?(\n|$)/.test(text);
}

function insertPragma$8(text) {
  return `# @format\n\n${text}`;
}

var pragma$5 = {
  isPragma,
  hasPragma: hasPragma$4,
  insertPragma: insertPragma$8
};

var getLast$4 = util.getLast;

function getAncestorCount(path, filter) {
  var counter = 0;
  var pathStackLength = path.stack.length - 1;

  for (var i = 0; i < pathStackLength; i++) {
    var value = path.stack[i];

    if (isNode$1(value) && filter(value)) {
      counter++;
    }
  }

  return counter;
}
/**
 * @param {any} value
 * @param {string[]=} types
 */


function isNode$1(value, types) {
  return value && typeof value.type === "string" && (!types || types.indexOf(value.type) !== -1);
}

function mapNode(node, callback, parent) {
  return callback("children" in node ? Object.assign({}, node, {
    children: node.children.map(function (childNode) {
      return mapNode(childNode, callback, node);
    })
  }) : node, parent);
}

function defineShortcut(x, key, getter) {
  Object.defineProperty(x, key, {
    get: getter,
    enumerable: false
  });
}

function isNextLineEmpty$5(node, text) {
  var newlineCount = 0;
  var textLength = text.length;

  for (var i = node.position.end.offset - 1; i < textLength; i++) {
    var char = text[i];

    if (char === "\n") {
      newlineCount++;
    }

    if (newlineCount === 1 && /\S/.test(char)) {
      return false;
    }

    if (newlineCount === 2) {
      return true;
    }
  }

  return false;
}

function isLastDescendantNode(path) {
  var node = path.getValue();

  switch (node.type) {
    case "tag":
    case "anchor":
    case "comment":
      return false;
  }

  var pathStackLength = path.stack.length;

  for (var i = 1; i < pathStackLength; i++) {
    var item = path.stack[i];
    var parentItem = path.stack[i - 1];

    if (Array.isArray(parentItem) && typeof item === "number" && item !== parentItem.length - 1) {
      return false;
    }
  }

  return true;
}

function getLastDescendantNode$1(node) {
  return "children" in node && node.children.length !== 0 ? getLastDescendantNode$1(getLast$4(node.children)) : node;
}

function isPrettierIgnore$2(comment) {
  return comment.value.trim() === "prettier-ignore";
}

function hasPrettierIgnore$5(path) {
  var node = path.getValue();

  if (node.type === "documentBody") {
    var document = path.getParentNode();
    return hasEndComments(document.head) && isPrettierIgnore$2(getLast$4(document.head.endComments));
  }

  return hasLeadingComments(node) && isPrettierIgnore$2(getLast$4(node.leadingComments))