
                                        && reference.node.parent.arguments.length > index;
                                    // argument in super.m(...)
                                    var isSuperMethodCall = ts.isPropertyAccessExpression(reference.node.parent)
                                        && ts.isSuperKeyword(reference.node.parent.expression)
                                        && ts.isCallExpression(reference.node.parent.parent)
                                        && reference.node.parent.parent.arguments.length > index;
                                    // parameter in overridden or overriding method
                                    var isOverriddenMethod = (ts.isMethodDeclaration(reference.node.parent) || ts.isMethodSignature(reference.node.parent))
                                        && reference.node.parent !== parameter.parent
                                        && reference.node.parent.parameters.length > index;
                                    if (isSuperCall_1 || isSuperMethodCall || isOverriddenMethod)
                                        return false;
                                }
                            }
                        }
                    }
                    return true;
                case 254 /* FunctionDeclaration */: {
                    if (parent.name && isCallbackLike(checker, sourceFile, parent.name)) {
                        return isLastParameter(parent, parameter, isFixAll);
                    }
                    return true;
                }
                case 211 /* FunctionExpression */:
                case 212 /* ArrowFunction */:
                    // Can't remove a non-last parameter in a callback. Can remove a parameter in code-fix-all if future parameters are also unused.
                    return isLastParameter(parent, parameter, isFixAll);
                case 171 /* SetAccessor */:
                    // Setter must have a parameter
                    return false;
                default:
                    return ts.Debug.failBadSyntaxKind(parent);
            }
        }
        function isCallbackLike(checker, sourceFile, name) {
            return !!ts.FindAllReferences.Core.eachSymbolReferenceInFile(name, checker, sourceFile, function (reference) {
                return ts.isIdentifier(reference) && ts.isCallExpression(reference.parent) && reference.parent.arguments.indexOf(reference) >= 0;
            });
        }
        function isLastParameter(func, parameter, isFixAll) {
            var parameters = func.parameters;
            var index = parameters.indexOf(parameter);
            ts.Debug.assert(index !== -1, "The parameter should already be in the list");
            return isFixAll ?
                parameters.slice(index + 1).every(function (p) { return ts.isIdentifier(p.name) && !p.symbol.isReferenced; }) :
                index === parameters.length - 1;
        }
        function mayDeleteExpression(node) {
            return ((ts.isBinaryExpression(node.parent) && node.parent.left === node) ||
                ((ts.isPostfixUnaryExpression(node.parent) || ts.isPrefixUnaryExpression(node.parent)) && node.parent.operand === node)) && ts.isExpressionStatement(node.parent.parent);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "fixUnreachableCode";
        var errorCodes = [ts.Diagnostics.Unreachable_code_detected.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, context.sourceFile, context.span.start, context.span.length, context.errorCode); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Remove_unreachable_code, fixId, ts.Diagnostics.Remove_all_unreachable_code)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) { return doChange(changes, diag.file, diag.start, diag.length, diag.code); }); },
        });
        function doChange(changes, sourceFile, start, length, errorCode) {
            var token = ts.getTokenAtPosition(sourceFile, start);
            var statement = ts.findAncestor(token, ts.isStatement);
            if (statement.getStart(sourceFile) !== token.getStart(sourceFile)) {
                var logData = JSON.stringify({
                    statementKind: ts.Debug.formatSyntaxKind(statement.kind),
                    tokenKind: ts.Debug.formatSyntaxKind(token.kind),
                    errorCode: errorCode,
                    start: start,
                    length: length
                });
                ts.Debug.fail("Token and statement should start at the same point. " + logData);
            }
            var container = (ts.isBlock(statement.parent) ? statement.parent : statement).parent;
            if (!ts.isBlock(statement.parent) || statement === ts.first(statement.parent.statements)) {
                switch (container.kind) {
                    case 237 /* IfStatement */:
                        if (container.elseStatement) {
                            if (ts.isBlock(statement.parent)) {
                                break;
                            }
                            else {
                                changes.replaceNode(sourceFile, statement, ts.factory.createBlock(ts.emptyArray));
                            }
                            return;
                        }
                    // falls through
                    case 239 /* WhileStatement */:
                    case 240 /* ForStatement */:
                        changes.delete(sourceFile, container);
                        return;
                }
            }
            if (ts.isBlock(statement.parent)) {
                var end_3 = start + length;
                var lastStatement = ts.Debug.checkDefined(lastWhere(ts.sliceAfter(statement.parent.statements, statement), function (s) { return s.pos < end_3; }), "Some statement should be last");
                changes.deleteNodeRange(sourceFile, statement, lastStatement);
            }
            else {
                changes.delete(sourceFile, statement);
            }
        }
        function lastWhere(a, pred) {
            var last;
            for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
                var value = a_1[_i];
                if (!pred(value))
                    break;
                last = value;
            }
            return last;
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "fixUnusedLabel";
        var errorCodes = [ts.Diagnostics.Unused_label.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, context.sourceFile, context.span.start); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Remove_unused_label, fixId, ts.Diagnostics.Remove_all_unused_labels)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) { return doChange(changes, diag.file, diag.start); }); },
        });
        function doChange(changes, sourceFile, start) {
            var token = ts.getTokenAtPosition(sourceFile, start);
            var labeledStatement = ts.cast(token.parent, ts.isLabeledStatement);
            var pos = token.getStart(sourceFile);
            var statementPos = labeledStatement.statement.getStart(sourceFile);
            // If label is on a separate line, just delete the rest of that line, but not the indentation of the labeled statement.
            var end = ts.positionsAreOnSameLine(pos, statementPos, sourceFile) ? statementPos
                : ts.skipTrivia(sourceFile.text, ts.findChildOfKind(labeledStatement, 58 /* ColonToken */, sourceFile).end, /*stopAfterLineBreak*/ true);
            changes.deleteRange(sourceFile, { pos: pos, end: end });
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixIdPlain = "fixJSDocTypes_plain";
        var fixIdNullable = "fixJSDocTypes_nullable";
        var errorCodes = [ts.Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile;
                var checker = context.program.getTypeChecker();
                var info = getInfo(sourceFile, context.span.start, checker);
                if (!info)
                    return undefined;
                var typeNode = info.typeNode, type = info.type;
                var original = typeNode.getText(sourceFile);
                var actions = [fix(type, fixIdPlain, ts.Diagnostics.Change_all_jsdoc_style_types_to_TypeScript)];
                if (typeNode.kind === 309 /* JSDocNullableType */) {
                    // for nullable types, suggest the flow-compatible `T | null | undefined`
                    // in addition to the jsdoc/closure-compatible `T | null`
                    actions.push(fix(checker.getNullableType(type, 32768 /* Undefined */), fixIdNullable, ts.Diagnostics.Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types));
                }
                return actions;
                function fix(type, fixId, fixAllDescription) {
                    var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, typeNode, type, checker); });
                    return codefix.createCodeFixAction("jdocTypes", changes, [ts.Diagnostics.Change_0_to_1, original, checker.typeToString(type)], fixId, fixAllDescription);
                }
            },
            fixIds: [fixIdPlain, fixIdNullable],
            getAllCodeActions: function (context) {
                var fixId = context.fixId, program = context.program, sourceFile = context.sourceFile;
                var checker = program.getTypeChecker();
                return codefix.codeFixAll(context, errorCodes, function (changes, err) {
                    var info = getInfo(err.file, err.start, checker);
                    if (!info)
                        return;
                    var typeNode = info.typeNode, type = info.type;
                    var fixedType = typeNode.kind === 309 /* JSDocNullableType */ && fixId === fixIdNullable ? checker.getNullableType(type, 32768 /* Undefined */) : type;
                    doChange(changes, sourceFile, typeNode, fixedType, checker);
                });
            }
        });
        function doChange(changes, sourceFile, oldTypeNode, newType, checker) {
            changes.replaceNode(sourceFile, oldTypeNode, checker.typeToTypeNode(newType, /*enclosingDeclaration*/ oldTypeNode, /*flags*/ undefined)); // TODO: GH#18217
        }
        function getInfo(sourceFile, pos, checker) {
            var decl = ts.findAncestor(ts.getTokenAtPosition(sourceFile, pos), isTypeContainer);
            var typeNode = decl && decl.type;
            return typeNode && { typeNode: typeNode, type: checker.getTypeFromTypeNode(typeNode) };
        }
        function isTypeContainer(node) {
            // NOTE: Some locations are not handled yet:
            // MappedTypeNode.typeParameters and SignatureDeclaration.typeParameters, as well as CallExpression.typeArguments
            switch (node.kind) {
                case 227 /* AsExpression */:
                case 172 /* CallSignature */:
                case 173 /* ConstructSignature */:
                case 254 /* FunctionDeclaration */:
                case 170 /* GetAccessor */:
                case 174 /* IndexSignature */:
                case 193 /* MappedType */:
                case 167 /* MethodDeclaration */:
                case 166 /* MethodSignature */:
                case 162 /* Parameter */:
                case 165 /* PropertyDeclaration */:
                case 164 /* PropertySignature */:
                case 171 /* SetAccessor */:
                case 257 /* TypeAliasDeclaration */:
                case 209 /* TypeAssertionExpression */:
                case 252 /* VariableDeclaration */:
                    return true;
                default:
                    return false;
            }
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "fixMissingCallParentheses";
        var errorCodes = [
            ts.Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead.code,
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            fixIds: [fixId],
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span;
                var callName = getCallName(sourceFile, span.start);
                if (!callName)
                    return;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, context.sourceFile, callName); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Add_missing_call_parentheses, fixId, ts.Diagnostics.Add_all_missing_call_parentheses)];
            },
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var callName = getCallName(diag.file, diag.start);
                if (callName)
                    doChange(changes, diag.file, callName);
            }); }
        });
        function doChange(changes, sourceFile, name) {
            changes.replaceNodeWithText(sourceFile, name, name.text + "()");
        }
        function getCallName(sourceFile, start) {
            var token = ts.getTokenAtPosition(sourceFile, start);
            if (ts.isPropertyAccessExpression(token.parent)) {
                var current = token.parent;
                while (ts.isPropertyAccessExpression(current.parent)) {
                    current = current.parent;
                }
                return current.name;
            }
            if (ts.isIdentifier(token)) {
                return token;
            }
            return undefined;
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "fixAwaitInSyncFunction";
        var errorCodes = [
            ts.Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules.code,
            ts.Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules.code,
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span;
                var nodes = getNodes(sourceFile, span.start);
                if (!nodes)
                    return undefined;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, nodes); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Add_async_modifier_to_containing_function, fixId, ts.Diagnostics.Add_all_missing_async_modifiers)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) {
                var seen = new ts.Map();
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                    var nodes = getNodes(diag.file, diag.start);
                    if (!nodes || !ts.addToSeen(seen, ts.getNodeId(nodes.insertBefore)))
                        return;
                    doChange(changes, context.sourceFile, nodes);
                });
            },
        });
        function getReturnType(expr) {
            if (expr.type) {
                return expr.type;
            }
            if (ts.isVariableDeclaration(expr.parent) &&
                expr.parent.type &&
                ts.isFunctionTypeNode(expr.parent.type)) {
                return expr.parent.type.type;
            }
        }
        function getNodes(sourceFile, start) {
            var token = ts.getTokenAtPosition(sourceFile, start);
            var containingFunction = ts.getContainingFunction(token);
            if (!containingFunction) {
                return;
            }
            var insertBefore;
            switch (containingFunction.kind) {
                case 167 /* MethodDeclaration */:
                    insertBefore = containingFunction.name;
                    break;
                case 254 /* FunctionDeclaration */:
                case 211 /* FunctionExpression */:
                    insertBefore = ts.findChildOfKind(containingFunction, 98 /* FunctionKeyword */, sourceFile);
                    break;
                case 212 /* ArrowFunction */:
                    insertBefore = ts.findChildOfKind(containingFunction, 20 /* OpenParenToken */, sourceFile) || ts.first(containingFunction.parameters);
                    break;
                default:
                    return;
            }
            return insertBefore && {
                insertBefore: insertBefore,
                returnType: getReturnType(containingFunction)
            };
        }
        function doChange(changes, sourceFile, _a) {
            var insertBefore = _a.insertBefore, returnType = _a.returnType;
            if (returnType) {
                var entityName = ts.getEntityNameFromTypeNode(returnType);
                if (!entityName || entityName.kind !== 79 /* Identifier */ || entityName.text !== "Promise") {
                    changes.replaceNode(sourceFile, returnType, ts.factory.createTypeReferenceNode("Promise", ts.factory.createNodeArray([returnType])));
                }
            }
            changes.insertModifierBefore(sourceFile, 130 /* AsyncKeyword */, insertBefore);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var errorCodes = [
            ts.Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property.code,
            ts.Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor.code,
        ];
        var fixId = "fixPropertyOverrideAccessor";
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var edits = doChange(context.sourceFile, context.span.start, context.span.length, context.errorCode, context);
                if (edits) {
                    return [codefix.createCodeFixAction(fixId, edits, ts.Diagnostics.Generate_get_and_set_accessors, fixId, ts.Diagnostics.Generate_get_and_set_accessors_for_all_overriding_properties)];
                }
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var edits = doChange(diag.file, diag.start, diag.length, diag.code, context);
                if (edits) {
                    for (var _i = 0, edits_2 = edits; _i < edits_2.length; _i++) {
                        var edit = edits_2[_i];
                        changes.pushRaw(context.sourceFile, edit);
                    }
                }
            }); },
        });
        function doChange(file, start, length, code, context) {
            var startPosition;
            var endPosition;
            if (code === ts.Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property.code) {
                startPosition = start;
                endPosition = start + length;
            }
            else if (code === ts.Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor.code) {
                var checker = context.program.getTypeChecker();
                var node = ts.getTokenAtPosition(file, start).parent;
                ts.Debug.assert(ts.isAccessor(node), "error span of fixPropertyOverrideAccessor should only be on an accessor");
                var containingClass = node.parent;
                ts.Debug.assert(ts.isClassLike(containingClass), "erroneous accessors should only be inside classes");
                var base = ts.singleOrUndefined(codefix.getAllSupers(containingClass, checker));
                if (!base)
                    return [];
                var name = ts.unescapeLeadingUnderscores(ts.getTextOfPropertyName(node.name));
                var baseProp = checker.getPropertyOfType(checker.getTypeAtLocation(base), name);
                if (!baseProp || !baseProp.valueDeclaration)
                    return [];
                startPosition = baseProp.valueDeclaration.pos;
                endPosition = baseProp.valueDeclaration.end;
                file = ts.getSourceFileOfNode(baseProp.valueDeclaration);
            }
            else {
                ts.Debug.fail("fixPropertyOverrideAccessor codefix got unexpected error code " + code);
            }
            return codefix.generateAccessorFromProperty(file, context.program, startPosition, endPosition, context, ts.Diagnostics.Generate_get_and_set_accessors.message);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "inferFromUsage";
        var errorCodes = [
            // Variable declarations
            ts.Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined.code,
            // Variable uses
            ts.Diagnostics.Variable_0_implicitly_has_an_1_type.code,
            // Parameter declarations
            ts.Diagnostics.Parameter_0_implicitly_has_an_1_type.code,
            ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type.code,
            // Get Accessor declarations
            ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation.code,
            ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type.code,
            // Set Accessor declarations
            ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation.code,
            // Property declarations
            ts.Diagnostics.Member_0_implicitly_has_an_1_type.code,
            //// Suggestions
            // Variable declarations
            ts.Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage.code,
            // Variable uses
            ts.Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage.code,
            // Parameter declarations
            ts.Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage.code,
            ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage.code,
            // Get Accessor declarations
            ts.Diagnostics.Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage.code,
            ts.Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage.code,
            // Set Accessor declarations
            ts.Diagnostics.Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage.code,
            // Property declarations
            ts.Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage.code,
            // Function expressions and declarations
            ts.Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation.code,
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, program = context.program, start = context.span.start, errorCode = context.errorCode, cancellationToken = context.cancellationToken, host = context.host, preferences = context.preferences;
                var token = ts.getTokenAtPosition(sourceFile, start);
                var declaration;
                var changes = ts.textChanges.ChangeTracker.with(context, function (changes) { declaration = doChange(changes, sourceFile, token, errorCode, program, cancellationToken, /*markSeen*/ ts.returnTrue, host, preferences); });
                var name = declaration && ts.getNameOfDeclaration(declaration);
                return !name || changes.length === 0 ? undefined
                    : [codefix.createCodeFixAction(fixId, changes, [getDiagnostic(errorCode, token), name.getText(sourceFile)], fixId, ts.Diagnostics.Infer_all_types_from_usage)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) {
                var sourceFile = context.sourceFile, program = context.program, cancellationToken = context.cancellationToken, host = context.host, preferences = context.preferences;
                var markSeen = ts.nodeSeenTracker();
                return codefix.codeFixAll(context, errorCodes, function (changes, err) {
                    doChange(changes, sourceFile, ts.getTokenAtPosition(err.file, err.start), err.code, program, cancellationToken, markSeen, host, preferences);
                });
            },
        });
        function getDiagnostic(errorCode, token) {
            switch (errorCode) {
                case ts.Diagnostics.Parameter_0_implicitly_has_an_1_type.code:
                case ts.Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage.code:
                    return ts.isSetAccessorDeclaration(ts.getContainingFunction(token)) ? ts.Diagnostics.Infer_type_of_0_from_usage : ts.Diagnostics.Infer_parameter_types_from_usage; // TODO: GH#18217
                case ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type.code:
                case ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage.code:
                    return ts.Diagnostics.Infer_parameter_types_from_usage;
                case ts.Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation.code:
                    return ts.Diagnostics.Infer_this_type_of_0_from_usage;
                default:
                    return ts.Diagnostics.Infer_type_of_0_from_usage;
            }
        }
        /** Map suggestion code to error code */
        function mapSuggestionDiagnostic(errorCode) {
            switch (errorCode) {
                case ts.Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage.code:
                    return ts.Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined.code;
                case ts.Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage.code:
                    return ts.Diagnostics.Variable_0_implicitly_has_an_1_type.code;
                case ts.Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage.code:
                    return ts.Diagnostics.Parameter_0_implicitly_has_an_1_type.code;
                case ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage.code:
                    return ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type.code;
                case ts.Diagnostics.Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage.code:
                    return ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation.code;
                case ts.Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage.code:
                    return ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type.code;
                case ts.Diagnostics.Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage.code:
                    return ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation.code;
                case ts.Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage.code:
                    return ts.Diagnostics.Member_0_implicitly_has_an_1_type.code;
            }
            return errorCode;
        }
        function doChange(changes, sourceFile, token, errorCode, program, cancellationToken, markSeen, host, preferences) {
            if (!ts.isParameterPropertyModifier(token.kind) && token.kind !== 79 /* Identifier */ && token.kind !== 25 /* DotDotDotToken */ && token.kind !== 108 /* ThisKeyword */) {
                return undefined;
            }
            var parent = token.parent;
            var importAdder = codefix.createImportAdder(sourceFile, program, preferences, host);
            errorCode = mapSuggestionDiagnostic(errorCode);
            switch (errorCode) {
                // Variable and Property declarations
                case ts.Diagnostics.Member_0_implicitly_has_an_1_type.code:
                case ts.Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined.code:
                    if ((ts.isVariableDeclaration(parent) && markSeen(parent)) || ts.isPropertyDeclaration(parent) || ts.isPropertySignature(parent)) { // handle bad location
                        annotateVariableDeclaration(changes, importAdder, sourceFile, parent, program, host, cancellationToken);
                        importAdder.writeFixes(changes);
                        return parent;
                    }
                    if (ts.isPropertyAccessExpression(parent)) {
                        var type = inferTypeForVariableFromUsage(parent.name, program, cancellationToken);
                        var typeNode = ts.getTypeNodeIfAccessible(type, parent, program, host);
                        if (typeNode) {
                            // Note that the codefix will never fire with an existing `@type` tag, so there is no need to merge tags
                            var typeTag = ts.factory.createJSDocTypeTag(/*tagName*/ undefined, ts.factory.createJSDocTypeExpression(typeNode), /*comment*/ undefined);
                            addJSDocTags(changes, sourceFile, ts.cast(parent.parent.parent, ts.isExpressionStatement), [typeTag]);
                        }
                        importAdder.writeFixes(changes);
                        return parent;
                    }
                    return undefined;
                case ts.Diagnostics.Variable_0_implicitly_has_an_1_type.code: {
                    var symbol = program.getTypeChecker().getSymbolAtLocation(token);
                    if (symbol && symbol.valueDeclaration && ts.isVariableDeclaration(symbol.valueDeclaration) && markSeen(symbol.valueDeclaration)) {
                        annotateVariableDeclaration(changes, importAdder, sourceFile, symbol.valueDeclaration, program, host, cancellationToken);
                        importAdder.writeFixes(changes);
                        return symbol.valueDeclaration;
                    }
                    return undefined;
                }
            }
            var containingFunction = ts.getContainingFunction(token);
            if (containingFunction === undefined) {
                return undefined;
            }
            var declaration;
            switch (errorCode) {
                // Parameter declarations
                case ts.Diagnostics.Parameter_0_implicitly_has_an_1_type.code:
                    if (ts.isSetAccessorDeclaration(containingFunction)) {
                        annotateSetAccessor(changes, importAdder, sourceFile, containingFunction, program, host, cancellationToken);
                        declaration = containingFunction;
                        break;
                    }
                // falls through
                case ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type.code:
                    if (markSeen(containingFunction)) {
                        var param = ts.cast(parent, ts.isParameter);
                        annotateParameters(changes, importAdder, sourceFile, param, containingFunction, program, host, cancellationToken);
                        declaration = param;
                    }
                    break;
                // Get Accessor declarations
                case ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation.code:
                case ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type.code:
                    if (ts.isGetAccessorDeclaration(containingFunction) && ts.isIdentifier(containingFunction.name)) {
                        annotate(changes, importAdder, sourceFile, containingFunction, inferTypeForVariableFromUsage(containingFunction.name, program, cancellationToken), program, host);
                        declaration = containingFunction;
                    }
                    break;
                // Set Accessor declarations
                case ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation.code:
                    if (ts.isSetAccessorDeclaration(containingFunction)) {
                        annotateSetAccessor(changes, importAdder, sourceFile, containingFunction, program, host, cancellationToken);
                        declaration = containingFunction;
                    }
                    break;
                // Function 'this'
                case ts.Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation.code:
                    if (ts.textChanges.isThisTypeAnnotatable(containingFunction) && markSeen(containingFunction)) {
                        annotateThis(changes, sourceFile, containingFunction, program, host, cancellationToken);
                        declaration = containingFunction;
                    }
                    break;
                default:
                    return ts.Debug.fail(String(errorCode));
            }
            importAdder.writeFixes(changes);
            return declaration;
        }
        function annotateVariableDeclaration(changes, importAdder, sourceFile, declaration, program, host, cancellationToken) {
            if (ts.isIdentifier(declaration.name)) {
                annotate(changes, importAdder, sourceFile, declaration, inferTypeForVariableFromUsage(declaration.name, program, cancellationToken), program, host);
            }
        }
        function annotateParameters(changes, importAdder, sourceFile, parameterDeclaration, containingFunction, program, host, cancellationToken) {
            if (!ts.isIdentifier(parameterDeclaration.name)) {
                return;
            }
            var parameterInferences = inferTypeForParametersFromUsage(containingFunction, sourceFile, program, cancellationToken);
            ts.Debug.assert(containingFunction.parameters.length === parameterInferences.length, "Parameter count and inference count should match");
            if (ts.isInJSFile(containingFunction)) {
                annotateJSDocParameters(changes, sourceFile, parameterInferences, program, host);
            }
            else {
                var needParens = ts.isArrowFunction(containingFunction) && !ts.findChildOfKind(containingFunction, 20 /* OpenParenToken */, sourceFile);
                if (needParens)
                    changes.insertNodeBefore(sourceFile, ts.first(containingFunction.parameters), ts.factory.createToken(20 /* OpenParenToken */));
                for (var _i = 0, parameterInferences_1 = parameterInferences; _i < parameterInferences_1.length; _i++) {
                    var _a = parameterInferences_1[_i], declaration = _a.declaration, type = _a.type;
                    if (declaration && !declaration.type && !declaration.initializer) {
                        annotate(changes, importAdder, sourceFile, declaration, type, program, host);
                    }
                }
                if (needParens)
                    changes.insertNodeAfter(sourceFile, ts.last(containingFunction.parameters), ts.factory.createToken(21 /* CloseParenToken */));
            }
        }
        function annotateThis(changes, sourceFile, containingFunction, program, host, cancellationToken) {
            var references = getFunctionReferences(containingFunction, sourceFile, program, cancellationToken);
            if (!references || !references.length) {
                return;
            }
            var thisInference = inferTypeFromReferences(program, references, cancellationToken).thisParameter();
            var typeNode = ts.getTypeNodeIfAccessible(thisInference, containingFunction, program, host);
            if (!typeNode) {
                return;
            }
            if (ts.isInJSFile(containingFunction)) {
                annotateJSDocThis(changes, sourceFile, containingFunction, typeNode);
            }
            else {
                changes.tryInsertThisTypeAnnotation(sourceFile, containingFunction, typeNode);
            }
        }
        function annotateJSDocThis(changes, sourceFile, containingFunction, typeNode) {
            addJSDocTags(changes, sourceFile, containingFunction, [
                ts.factory.createJSDocThisTag(/*tagName*/ undefined, ts.factory.createJSDocTypeExpression(typeNode)),
            ]);
        }
        function annotateSetAccessor(changes, importAdder, sourceFile, setAccessorDeclaration, program, host, cancellationToken) {
            var param = ts.firstOrUndefined(setAccessorDeclaration.parameters);
            if (param && ts.isIdentifier(setAccessorDeclaration.name) && ts.isIdentifier(param.name)) {
                var type = inferTypeForVariableFromUsage(setAccessorDeclaration.name, program, cancellationToken);
                if (type === program.getTypeChecker().getAnyType()) {
                    type = inferTypeForVariableFromUsage(param.name, program, cancellationToken);
                }
                if (ts.isInJSFile(setAccessorDeclaration)) {
                    annotateJSDocParameters(changes, sourceFile, [{ declaration: param, type: type }], program, host);
                }
                else {
                    annotate(changes, importAdder, sourceFile, param, type, program, host);
                }
            }
        }
        function annotate(changes, importAdder, sourceFile, declaration, type, program, host) {
            var typeNode = ts.getTypeNodeIfAccessible(type, declaration, program, host);
            if (typeNode) {
                if (ts.isInJSFile(sourceFile) && declaration.kind !== 164 /* PropertySignature */) {
                    var parent = ts.isVariableDeclaration(declaration) ? ts.tryCast(declaration.parent.parent, ts.isVariableStatement) : declaration;
                    if (!parent) {
                        return;
                    }
                    var typeExpression = ts.factory.createJSDocTypeExpression(typeNode);
                    var typeTag = ts.isGetAccessorDeclaration(declaration) ? ts.factory.createJSDocReturnTag(/*tagName*/ undefined, typeExpression, /*comment*/ undefined) : ts.factory.createJSDocTypeTag(/*tagName*/ undefined, typeExpression, /*comment*/ undefined);
                    addJSDocTags(changes, sourceFile, parent, [typeTag]);
                }
                else if (!tryReplaceImportTypeNodeWithAutoImport(typeNode, declaration, sourceFile, changes, importAdder, ts.getEmitScriptTarget(program.getCompilerOptions()))) {
                    changes.tryInsertTypeAnnotation(sourceFile, declaration, typeNode);
                }
            }
        }
        function tryReplaceImportTypeNodeWithAutoImport(typeNode, declaration, sourceFile, changes, importAdder, scriptTarget) {
            var importableReference = codefix.tryGetAutoImportableReferenceFromTypeNode(typeNode, scriptTarget);
            if (importableReference && changes.tryInsertTypeAnnotation(sourceFile, declaration, importableReference.typeNode)) {
                ts.forEach(importableReference.symbols, function (s) { return importAdder.addImportFromExportedSymbol(s, /*usageIsTypeOnly*/ true); });
                return true;
            }
            return false;
        }
        function annotateJSDocParameters(changes, sourceFile, parameterInferences, program, host) {
            var signature = parameterInferences.length && parameterInferences[0].declaration.parent;
            if (!signature) {
                return;
            }
            var inferences = ts.mapDefined(parameterInferences, function (inference) {
                var param = inference.declaration;
                // only infer parameters that have (1) no type and (2) an accessible inferred type
                if (param.initializer || ts.getJSDocType(param) || !ts.isIdentifier(param.name)) {
                    return;
                }
                var typeNode = inference.type && ts.getTypeNodeIfAccessible(inference.type, param, program, host);
                if (typeNode) {
                    var name = ts.factory.cloneNode(param.name);
                    ts.setEmitFlags(name, 1536 /* NoComments */ | 2048 /* NoNestedComments */);
                    return { name: ts.factory.cloneNode(param.name), param: param, isOptional: !!inference.isOptional, typeNode: typeNode };
                }
            });
            if (!inferences.length) {
                return;
            }
            if (ts.isArrowFunction(signature) || ts.isFunctionExpression(signature)) {
                var needParens = ts.isArrowFunction(signature) && !ts.findChildOfKind(signature, 20 /* OpenParenToken */, sourceFile);
                if (needParens) {
                    changes.insertNodeBefore(sourceFile, ts.first(signature.parameters), ts.factory.createToken(20 /* OpenParenToken */));
                }
                ts.forEach(inferences, function (_a) {
                    var typeNode = _a.typeNode, param = _a.param;
                    var typeTag = ts.factory.createJSDocTypeTag(/*tagName*/ undefined, ts.factory.createJSDocTypeExpression(typeNode));
                    var jsDoc = ts.factory.createJSDocComment(/*comment*/ undefined, [typeTag]);
                    changes.insertNodeAt(sourceFile, param.getStart(sourceFile), jsDoc, { suffix: " " });
                });
                if (needParens) {
                    changes.insertNodeAfter(sourceFile, ts.last(signature.parameters), ts.factory.createToken(21 /* CloseParenToken */));
                }
            }
            else {
                var paramTags = ts.map(inferences, function (_a) {
                    var name = _a.name, typeNode = _a.typeNode, isOptional = _a.isOptional;
                    return ts.factory.createJSDocParameterTag(/*tagName*/ undefined, name, /*isBracketed*/ !!isOptional, ts.factory.createJSDocTypeExpression(typeNode), /* isNameFirst */ false, /*comment*/ undefined);
                });
                addJSDocTags(changes, sourceFile, signature, paramTags);
            }
        }
        function addJSDocTags(changes, sourceFile, parent, newTags) {
            var comments = ts.flatMap(parent.jsDoc, function (j) { return typeof j.comment === "string" ? ts.factory.createJSDocText(j.comment) : j.comment; });
            var oldTags = ts.flatMapToMutable(parent.jsDoc, function (j) { return j.tags; });
            var unmergedNewTags = newTags.filter(function (newTag) { return !oldTags || !oldTags.some(function (tag, i) {
                var merged = tryMergeJsdocTags(tag, newTag);
                if (merged)
                    oldTags[i] = merged;
                return !!merged;
            }); });
            var tag = ts.factory.createJSDocComment(ts.factory.createNodeArray(ts.intersperse(comments, ts.factory.createJSDocText("\n"))), ts.factory.createNodeArray(__spreadArray(__spreadArray([], (oldTags || ts.emptyArray), true), unmergedNewTags, true)));
            var jsDocNode = parent.kind === 212 /* ArrowFunction */ ? getJsDocNodeForArrowFunction(parent) : parent;
            jsDocNode.jsDoc = parent.jsDoc;
            jsDocNode.jsDocCache = parent.jsDocCache;
            changes.insertJsdocCommentBefore(sourceFile, jsDocNode, tag);
        }
        codefix.addJSDocTags = addJSDocTags;
        function getJsDocNodeForArrowFunction(signature) {
            if (signature.parent.kind === 165 /* PropertyDeclaration */) {
                return signature.parent;
            }
            return signature.parent.parent;
        }
        function tryMergeJsdocTags(oldTag, newTag) {
            if (oldTag.kind !== newTag.kind) {
                return undefined;
            }
            switch (oldTag.kind) {
                case 335 /* JSDocParameterTag */: {
                    var oldParam = oldTag;
                    var newParam = newTag;
                    return ts.isIdentifier(oldParam.name) && ts.isIdentifier(newParam.name) && oldParam.name.escapedText === newParam.name.escapedText
                        ? ts.factory.createJSDocParameterTag(/*tagName*/ undefined, newParam.name, /*isBracketed*/ false, newParam.typeExpression, newParam.isNameFirst, oldParam.comment)
                        : undefined;
                }
                case 336 /* JSDocReturnTag */:
                    return ts.factory.createJSDocReturnTag(/*tagName*/ undefined, newTag.typeExpression, oldTag.comment);
            }
        }
        function getReferences(token, program, cancellationToken) {
            // Position shouldn't matter since token is not a SourceFile.
            return ts.mapDefined(ts.FindAllReferences.getReferenceEntriesForNode(-1, token, program, program.getSourceFiles(), cancellationToken), function (entry) {
                return entry.kind !== 0 /* Span */ ? ts.tryCast(entry.node, ts.isIdentifier) : undefined;
            });
        }
        function inferTypeForVariableFromUsage(token, program, cancellationToken) {
            var references = getReferences(token, program, cancellationToken);
            return inferTypeFromReferences(program, references, cancellationToken).single();
        }
        function inferTypeForParametersFromUsage(func, sourceFile, program, cancellationToken) {
            var references = getFunctionReferences(func, sourceFile, program, cancellationToken);
            return references && inferTypeFromReferences(program, references, cancellationToken).parameters(func) ||
                func.parameters.map(function (p) { return ({
                    declaration: p,
                    type: ts.isIdentifier(p.name) ? inferTypeForVariableFromUsage(p.name, program, cancellationToken) : program.getTypeChecker().getAnyType()
                }); });
        }
        function getFunctionReferences(containingFunction, sourceFile, program, cancellationToken) {
            var searchToken;
            switch (containingFunction.kind) {
                case 169 /* Constructor */:
                    searchToken = ts.findChildOfKind(containingFunction, 133 /* ConstructorKeyword */, sourceFile);
                    break;
                case 212 /* ArrowFunction */:
                case 211 /* FunctionExpression */:
                    var parent = containingFunction.parent;
                    searchToken = (ts.isVariableDeclaration(parent) || ts.isPropertyDeclaration(parent)) && ts.isIdentifier(parent.name) ?
                        parent.name :
                        containingFunction.name;
                    break;
                case 254 /* FunctionDeclaration */:
                case 167 /* MethodDeclaration */:
                case 166 /* MethodSignature */:
                    searchToken = containingFunction.name;
                    break;
            }
            if (!searchToken) {
                return undefined;
            }
            return getReferences(searchToken, program, cancellationToken);
        }
        function inferTypeFromReferences(program, references, cancellationToken) {
            var checker = program.getTypeChecker();
            var builtinConstructors = {
                string: function () { return checker.getStringType(); },
                number: function () { return checker.getNumberType(); },
                Array: function (t) { return checker.createArrayType(t); },
                Promise: function (t) { return checker.createPromiseType(t); },
            };
            var builtins = [
                checker.getStringType(),
                checker.getNumberType(),
                checker.createArrayType(checker.getAnyType()),
                checker.createPromiseType(checker.getAnyType()),
            ];
            return {
                single: single,
                parameters: parameters,
                thisParameter: thisParameter,
            };
            function createEmptyUsage() {
                return {
                    isNumber: undefined,
                    isString: undefined,
                    isNumberOrString: undefined,
                    candidateTypes: undefined,
                    properties: undefined,
                    calls: undefined,
                    constructs: undefined,
                    numberIndex: undefined,
                    stringIndex: undefined,
                    candidateThisTypes: undefined,
                    inferredTypes: undefined,
                };
            }
            function combineUsages(usages) {
                var combinedProperties = new ts.Map();
                for (var _i = 0, usages_1 = usages; _i < usages_1.length; _i++) {
                    var u = usages_1[_i];
                    if (u.properties) {
                        u.properties.forEach(function (p, name) {
                            if (!combinedProperties.has(name)) {
                                combinedProperties.set(name, []);
                            }
                            combinedProperties.get(name).push(p);
                        });
                    }
                }
                var properties = new ts.Map();
                combinedProperties.forEach(function (ps, name) {
                    properties.set(name, combineUsages(ps));
                });
                return {
                    isNumber: usages.some(function (u) { return u.isNumber; }),
                    isString: usages.some(function (u) { return u.isString; }),
                    isNumberOrString: usages.some(function (u) { return u.isNumberOrString; }),
                    candidateTypes: ts.flatMap(usages, function (u) { return u.candidateTypes; }),
                    properties: properties,
                    calls: ts.flatMap(usages, function (u) { return u.calls; }),
                    constructs: ts.flatMap(usages, function (u) { return u.constructs; }),
                    numberIndex: ts.forEach(usages, function (u) { return u.numberIndex; }),
                    stringIndex: ts.forEach(usages, function (u) { return u.stringIndex; }),
                    candidateThisTypes: ts.flatMap(usages, function (u) { return u.candidateThisTypes; }),
                    inferredTypes: undefined, // clear type cache
                };
            }
            function single() {
                return combineTypes(inferTypesFromReferencesSingle(references));
            }
            function parameters(declaration) {
                if (references.length === 0 || !declaration.parameters) {
                    return undefined;
                }
                var usage = createEmptyUsage();
                for (var _i = 0, references_3 = references; _i < references_3.length; _i++) {
                    var reference = references_3[_i];
                    cancellationToken.throwIfCancellationRequested();
                    calculateUsageOfNode(reference, usage);
                }
                var calls = __spreadArray(__spreadArray([], usage.constructs || [], true), usage.calls || [], true);
                return declaration.parameters.map(function (parameter, parameterIndex) {
                    var types = [];
                    var isRest = ts.isRestParameter(parameter);
                    var isOptional = false;
                    for (var _i = 0, calls_1 = calls; _i < calls_1.length; _i++) {
                        var call = calls_1[_i];
                        if (call.argumentTypes.length <= parameterIndex) {
                            isOptional = ts.isInJSFile(declaration);
                            types.push(checker.getUndefinedType());
                        }
                        else if (isRest) {
                            for (var i = parameterIndex; i < call.argumentTypes.length; i++) {
                                types.push(checker.getBaseTypeOfLiteralType(call.argumentTypes[i]));
                            }
                        }
                        else {
                            types.push(checker.getBaseTypeOfLiteralType(call.argumentTypes[parameterIndex]));
                        }
                    }
                    if (ts.isIdentifier(parameter.name)) {
                        var inferred = inferTypesFromReferencesSingle(getReferences(parameter.name, program, cancellationToken));
                        types.push.apply(types, (isRest ? ts.mapDefined(inferred, checker.getElementTypeOfArrayType) : inferred));
                    }
                    var type = combineTypes(types);
                    return {
                        type: isRest ? checker.createArrayType(type) : type,
                        isOptional: isOptional && !isRest,
                        declaration: parameter
                    };
                });
            }
            function thisParameter() {
                var usage = createEmptyUsage();
                for (var _i = 0, references_4 = references; _i < references_4.length; _i++) {
                    var reference = references_4[_i];
                    cancellationToken.throwIfCancellationRequested();
                    calculateUsageOfNode(reference, usage);
                }
                return combineTypes(usage.candidateThisTypes || ts.emptyArray);
            }
            function inferTypesFromReferencesSingle(references) {
                var usage = createEmptyUsage();
                for (var _i = 0, references_5 = references; _i < references_5.length; _i++) {
                    var reference = references_5[_i];
                    cancellationToken.throwIfCancellationRequested();
                    calculateUsageOfNode(reference, usage);
                }
                return inferTypes(usage);
            }
            function calculateUsageOfNode(node, usage) {
                while (ts.isRightSideOfQualifiedNameOrPropertyAccess(node)) {
                    node = node.parent;
                }
                switch (node.parent.kind) {
                    case 236 /* ExpressionStatement */:
                        inferTypeFromExpressionStatement(node, usage);
                        break;
                    case 218 /* PostfixUnaryExpression */:
                        usage.isNumber = true;
                        break;
                    case 217 /* PrefixUnaryExpression */:
                        inferTypeFromPrefixUnaryExpression(node.parent, usage);
                        break;
                    case 219 /* BinaryExpression */:
                        inferTypeFromBinaryExpression(node, node.parent, usage);
                        break;
                    case 287 /* CaseClause */:
                    case 288 /* DefaultClause */:
                        inferTypeFromSwitchStatementLabel(node.parent, usage);
                        break;
                    case 206 /* CallExpression */:
                    case 207 /* NewExpression */:
                        if (node.parent.expression === node) {
                            inferTypeFromCallExpression(node.parent, usage);
                        }
                        else {
                            inferTypeFromContextualType(node, usage);
                        }
                        break;
                    case 204 /* PropertyAccessExpression */:
                        inferTypeFromPropertyAccessExpression(node.parent, usage);
                        break;
                    case 205 /* ElementAccessExpression */:
                        inferTypeFromPropertyElementExpression(node.parent, node, usage);
                        break;
                    case 291 /* PropertyAssignment */:
                    case 292 /* ShorthandPropertyAssignment */:
                        inferTypeFromPropertyAssignment(node.parent, usage);
                        break;
                    case 165 /* PropertyDeclaration */:
                        inferTypeFromPropertyDeclaration(node.parent, usage);
                        break;
                    case 252 /* VariableDeclaration */: {
                        var _a = node.parent, name = _a.name, initializer = _a.initializer;
                        if (node === name) {
                            if (initializer) { // This can happen for `let x = null;` which still has an implicit-any error.
                                addCandidateType(usage, checker.getTypeAtLocation(initializer));
                            }
                            break;
                        }
                    }
                    // falls through
                    default:
                        return inferTypeFromContextualType(node, usage);
                }
            }
            function inferTypeFromContextualType(node, usage) {
                if (ts.isExpressionNode(node)) {
                    addCandidateType(usage, checker.getContextualType(node));
                }
            }
            function inferTypeFromExpressionStatement(node, usage) {
                addCandidateType(usage, ts.isCallExpression(node) ? checker.getVoidType() : checker.getAnyType());
            }
            function inferTypeFromPrefixUnaryExpression(node, usage) {
                switch (node.operator) {
                    case 45 /* PlusPlusToken */:
                    case 46 /* MinusMinusToken */:
                    case 40 /* MinusToken */:
                    case 54 /* TildeToken */:
                        usage.isNumber = true;
                        break;
                    case 39 /* PlusToken */:
                        usage.isNumberOrString = true;
                        break;
                    // case SyntaxKind.ExclamationToken:
                    // no inferences here;
                }
            }
            function inferTypeFromBinaryExpression(node, parent, usage) {
                switch (parent.operatorToken.kind) {
                    // ExponentiationOperator
                    case 42 /* AsteriskAsteriskToken */:
                    // MultiplicativeOperator
                    // falls through
                    case 41 /* AsteriskToken */:
                    case 43 /* SlashToken */:
                    case 44 /* PercentToken */:
                    // ShiftOperator
                    // falls through
                    case 47 /* LessThanLessThanToken */:
                    case 48 /* GreaterThanGreaterThanToken */:
                    case 49 /* GreaterThanGreaterThanGreaterThanToken */:
                    // BitwiseOperator
                    // falls through
                    case 50 /* AmpersandToken */:
                    case 51 /* BarToken */:
                    case 52 /* CaretToken */:
                    // CompoundAssignmentOperator
                    // falls through
                    case 65 /* MinusEqualsToken */:
                    case 67 /* AsteriskAsteriskEqualsToken */:
                    case 66 /* AsteriskEqualsToken */:
                    case 68 /* SlashEqualsToken */:
                    case 69 /* PercentEqualsToken */:
                    case 73 /* AmpersandEqualsToken */:
                    case 74 /* BarEqualsToken */:
                    case 78 /* CaretEqualsToken */:
                    case 70 /* LessThanLessThanEqualsToken */:
                    case 72 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                    case 71 /* GreaterThanGreaterThanEqualsToken */:
                    // AdditiveOperator
                    // falls through
                    case 40 /* MinusToken */:
                    // RelationalOperator
                    // falls through
                    case 29 /* LessThanToken */:
                    case 32 /* LessThanEqualsToken */:
                    case 31 /* GreaterThanToken */:
                    case 33 /* GreaterThanEqualsToken */:
                        var operandType = checker.getTypeAtLocation(parent.left === node ? parent.right : parent.left);
                        if (operandType.flags & 1056 /* EnumLike */) {
                            addCandidateType(usage, operandType);
                        }
                        else {
                            usage.isNumber = true;
                        }
                        break;
                    case 64 /* PlusEqualsToken */:
                    case 39 /* PlusToken */:
                        var otherOperandType = checker.getTypeAtLocation(parent.left === node ? parent.right : parent.left);
                        if (otherOperandType.flags & 1056 /* EnumLike */) {
                            addCandidateType(usage, otherOperandType);
                        }
                        else if (otherOperandType.flags & 296 /* NumberLike */) {
                            usage.isNumber = true;
                        }
                        else if (otherOperandType.flags & 402653316 /* StringLike */) {
                            usage.isString = true;
                        }
                        else if (otherOperandType.flags & 1 /* Any */) {
                            // do nothing, maybe we'll learn something elsewhere
                        }
                        else {
                            usage.isNumberOrString = true;
                        }
                        break;
                    //  AssignmentOperators
                    case 63 /* EqualsToken */:
                    case 34 /* EqualsEqualsToken */:
                    case 36 /* EqualsEqualsEqualsToken */:
                    case 37 /* ExclamationEqualsEqualsToken */:
                    case 35 /* ExclamationEqualsToken */:
                        addCandidateType(usage, checker.getTypeAtLocation(parent.left === node ? parent.right : parent.left));
                        break;
                    case 101 /* InKeyword */:
                        if (node === parent.left) {
                            usage.isString = true;
                        }
                        break;
                    // LogicalOperator Or NullishCoalescing
                    case 56 /* BarBarToken */:
                    case 60 /* QuestionQuestionToken */:
                        if (node === parent.left &&
                            (node.parent.parent.kind === 252 /* VariableDeclaration */ || ts.isAssignmentExpression(node.parent.parent, /*excludeCompoundAssignment*/ true))) {
                            // var x = x || {};
                            // TODO: use getFalsyflagsOfType
                            addCandidateType(usage, checker.getTypeAtLocation(parent.right));
                        }
                        break;
                    case 55 /* AmpersandAmpersandToken */:
                    case 27 /* CommaToken */:
                    case 102 /* InstanceOfKeyword */:
                        // nothing to infer here
                        break;
                }
            }
            function inferTypeFromSwitchStatementLabel(parent, usage) {
                addCandidateType(usage, checker.getTypeAtLocation(parent.parent.parent.expression));
            }
            function inferTypeFromCallExpression(parent, usage) {
                var call = {
                    argumentTypes: [],
                    return_: createEmptyUsage()
                };
                if (parent.arguments) {
                    for (var _i = 0, _a = parent.arguments; _i < _a.length; _i++) {
                        var argument = _a[_i];
                        call.argumentTypes.push(checker.getTypeAtLocation(argument));
                    }
                }
                calculateUsageOfNode(parent, call.return_);
                if (parent.kind === 206 /* CallExpression */) {
                    (usage.calls || (usage.calls = [])).push(call);
                }
                else {
                    (usage.constructs || (usage.constructs = [])).push(call);
                }
            }
            function inferTypeFromPropertyAccessExpression(parent, usage) {
                var name = ts.escapeLeadingUnderscores(parent.name.text);
                if (!usage.properties) {
                    usage.properties = new ts.Map();
                }
                var propertyUsage = usage.properties.get(name) || createEmptyUsage();
                calculateUsageOfNode(parent, propertyUsage);
                usage.properties.set(name, propertyUsage);
            }
            function inferTypeFromPropertyElementExpression(parent, node, usage) {
                if (node === parent.argumentExpression) {
                    usage.isNumberOrString = true;
                    return;
                }
                else {
                    var indexType = checker.getTypeAtLocation(parent.argumentExpression);
                    var indexUsage = createEmptyUsage();
                    calculateUsageOfNode(parent, indexUsage);
                    if (indexType.flags & 296 /* NumberLike */) {
                        usage.numberIndex = indexUsage;
                    }
                    else {
                        usage.stringIndex = indexUsage;
                    }
                }
            }
            function inferTypeFromPropertyAssignment(assignment, usage) {
                var nodeWithRealType = ts.isVariableDeclaration(assignment.parent.parent) ?
                    assignment.parent.parent :
                    assignment.parent;
                addCandidateThisType(usage, checker.getTypeAtLocation(nodeWithRealType));
            }
            function inferTypeFromPropertyDeclaration(declaration, usage) {
                addCandidateThisType(usage, checker.getTypeAtLocation(declaration.parent));
            }
            function removeLowPriorityInferences(inferences, priorities) {
                var toRemove = [];
                for (var _i = 0, inferences_1 = inferences; _i < inferences_1.length; _i++) {
                    var i = inferences_1[_i];
                    for (var _a = 0, priorities_1 = priorities; _a < priorities_1.length; _a++) {
                        var _b = priorities_1[_a], high = _b.high, low = _b.low;
                        if (high(i)) {
                            ts.Debug.assert(!low(i), "Priority can't have both low and high");
                            toRemove.push(low);
                        }
                    }
                }
                return inferences.filter(function (i) { return toRemove.every(function (f) { return !f(i); }); });
            }
            function combineFromUsage(usage) {
                return combineTypes(inferTypes(usage));
            }
            function combineTypes(inferences) {
                if (!inferences.length)
                    return checker.getAnyType();
                // 1. string or number individually override string | number
                // 2. non-any, non-void overrides any or void
                // 3. non-nullable, non-any, non-void, non-anonymous overrides anonymous types
                var stringNumber = checker.getUnionType([checker.getStringType(), checker.getNumberType()]);
                var priorities = [
                    {
                        high: function (t) { return t === checker.getStringType() || t === checker.getNumberType(); },
                        low: function (t) { return t === stringNumber; }
                    },
                    {
                        high: function (t) { return !(t.flags & (1 /* Any */ | 16384 /* Void */)); },
                        low: function (t) { return !!(t.flags & (1 /* Any */ | 16384 /* Void */)); }
                    },
                    {
                        high: function (t) { return !(t.flags & (98304 /* Nullable */ | 1 /* Any */ | 16384 /* Void */)) && !(ts.getObjectFlags(t) & 16 /* Anonymous */); },
                        low: function (t) { return !!(ts.getObjectFlags(t) & 16 /* Anonymous */); }
                    }
                ];
                var good = removeLowPriorityInferences(inferences, priorities);
                var anons = good.filter(function (i) { return ts.getObjectFlags(i) & 16 /* Anonymous */; });
                if (anons.length) {
                    good = good.filter(function (i) { return !(ts.getObjectFlags(i) & 16 /* Anonymous */); });
                    good.push(combineAnonymousTypes(anons));
                }
                return checker.getWidenedType(checker.getUnionType(good.map(checker.getBaseTypeOfLiteralType), 2 /* Subtype */));
            }
            function combineAnonymousTypes(anons) {
                if (anons.length === 1) {
                    return anons[0];
                }
                var calls = [];
                var constructs = [];
                var stringIndices = [];
                var numberIndices = [];
                var stringIndexReadonly = false;
                var numberIndexReadonly = false;
                var props = ts.createMultiMap();
                for (var _i = 0, anons_1 = anons; _i < anons_1.length; _i++) {
                    var anon = anons_1[_i];
                    for (var _a = 0, _b = checker.getPropertiesOfType(anon); _a < _b.length; _a++) {
                        var p = _b[_a];
                        props.add(p.name, p.valueDeclaration ? checker.getTypeOfSymbolAtLocation(p, p.valueDeclaration) : checker.getAnyType());
                    }
                    calls.push.apply(calls, checker.getSignaturesOfType(anon, 0 /* Call */));
                    constructs.push.apply(constructs, checker.getSignaturesOfType(anon, 1 /* Construct */));
                    var stringIndexInfo = checker.getIndexInfoOfType(anon, 0 /* String */);
                    if (stringIndexInfo) {
                        stringIndices.push(stringIndexInfo.type);
                        stringIndexReadonly = stringIndexReadonly || stringIndexInfo.isReadonly;
                    }
                    var numberIndexInfo = checker.getIndexInfoOfType(anon, 1 /* Number */);
                    if (numberIndexInfo) {
                        numberIndices.push(numberIndexInfo.type);
                        numberIndexReadonly = numberIndexReadonly || numberIndexInfo.isReadonly;
                    }
                }
                var members = ts.mapEntries(props, function (name, types) {
                    var isOptional = types.length < anons.length ? 16777216 /* Optional */ : 0;
                    var s = checker.createSymbol(4 /* Property */ | isOptional, name);
                    s.type = checker.getUnionType(types);
                    return [name, s];
                });
                var indexInfos = [];
                if (stringIndices.length)
                    indexInfos.push(checker.createIndexInfo(checker.getStringType(), checker.getUnionType(stringIndices), stringIndexReadonly));
                if (numberIndices.length)
                    indexInfos.push(checker.createIndexInfo(checker.getNumberType(), checker.getUnionType(numberIndices), numberIndexReadonly));
                return checker.createAnonymousType(anons[0].symbol, members, calls, constructs, indexInfos);
            }
            function inferTypes(usage) {
                var _a, _b, _c;
                var types = [];
                if (usage.isNumber) {
                    types.push(checker.getNumberType());
                }
                if (usage.isString) {
                    types.push(checker.getStringType());
                }
                if (usage.isNumberOrString) {
                    types.push(checker.getUnionType([checker.getStringType(), checker.getNumberType()]));
                }
                if (usage.numberIndex) {
                    types.push(checker.createArrayType(combineFromUsage(usage.numberIndex)));
                }
                if (((_a = usage.properties) === null || _a === void 0 ? void 0 : _a.size) || ((_b = usage.calls) === null || _b === void 0 ? void 0 : _b.length) || ((_c = usage.constructs) === null || _c === void 0 ? void 0 : _c.length) || usage.stringIndex) {
                    types.push(inferStructuralType(usage));
                }
                types.push.apply(types, (usage.candidateTypes || []).map(function (t) { return checker.getBaseTypeOfLiteralType(t); }));
                types.push.apply(types, inferNamedTypesFromProperties(usage));
                return types;
            }
            function inferStructuralType(usage) {
                var members = new ts.Map();
                if (usage.properties) {
                    usage.properties.forEach(function (u, name) {
                        var symbol = checker.createSymbol(4 /* Property */, name);
                        symbol.type = combineFromUsage(u);
                        members.set(name, symbol);
                    });
                }
                var callSignatures = usage.calls ? [getSignatureFromCalls(usage.calls)] : [];
                var constructSignatures = usage.constructs ? [getSignatureFromCalls(usage.constructs)] : [];
                var indexInfos = usage.stringIndex ? [checker.createIndexInfo(checker.getStringType(), combineFromUsage(usage.stringIndex), /*isReadonly*/ false)] : [];
                return checker.createAnonymousType(/*symbol*/ undefined, members, callSignatures, constructSignatures, indexInfos);
            }
            function inferNamedTypesFromProperties(usage) {
                if (!usage.properties || !usage.properties.size)
                    return [];
                var types = builtins.filter(function (t) { return allPropertiesAreAssignableToUsage(t, usage); });
                if (0 < types.length && types.length < 3) {
                    return types.map(function (t) { return inferInstantiationFromUsage(t, usage); });
                }
                return [];
            }
            function allPropertiesAreAssignableToUsage(type, usage) {
                if (!usage.properties)
                    return false;
                return !ts.forEachEntry(usage.properties, function (propUsage, name) {
                    var source = checker.getTypeOfPropertyOfType(type, name);
                    if (!source) {
                        return true;
                    }
                    if (propUsage.calls) {
                        var sigs = checker.getSignaturesOfType(source, 0 /* Call */);
                        return !sigs.length || !checker.isTypeAssignableTo(source, getFunctionFromCalls(propUsage.calls));
                    }
                    else {
                        return !checker.isTypeAssignableTo(source, combineFromUsage(propUsage));
                    }
                });
            }
            /**
             * inference is limited to
             * 1. generic types with a single parameter
             * 2. inference to/from calls with a single signature
             */
            function inferInstantiationFromUsage(type, usage) {
                if (!(ts.getObjectFlags(type) & 4 /* Reference */) || !usage.properties) {
                    return type;
                }
                var generic = type.target;
                var singleTypeParameter = ts.singleOrUndefined(generic.typeParameters);
                if (!singleTypeParameter)
                    return type;
                var types = [];
                usage.properties.forEach(function (propUsage, name) {
                    var genericPropertyType = checker.getTypeOfPropertyOfType(generic, name);
                    ts.Debug.assert(!!genericPropertyType, "generic should have all the properties of its reference.");
                    types.push.apply(types, inferTypeParameters(genericPropertyType, combineFromUsage(propUsage), singleTypeParameter));
                });
                return builtinConstructors[type.symbol.escapedName](combineTypes(types));
            }
            function inferTypeParameters(genericType, usageType, typeParameter) {
                if (genericType === typeParameter) {
                    return [usageType];
                }
                else if (genericType.flags & 3145728 /* UnionOrIntersection */) {
                    return ts.flatMap(genericType.types, function (t) { return inferTypeParameters(t, usageType, typeParameter); });
                }
                else if (ts.getObjectFlags(genericType) & 4 /* Reference */ && ts.getObjectFlags(usageType) & 4 /* Reference */) {
                    // this is wrong because we need a reference to the targetType to, so we can check that it's also a reference
                    var genericArgs = checker.getTypeArguments(genericType);
                    var usageArgs = checker.getTypeArguments(usageType);
                    var types = [];
                    if (genericArgs && usageArgs) {
                        for (var i = 0; i < genericArgs.length; i++) {
                            if (usageArgs[i]) {
                                types.push.apply(types, inferTypeParameters(genericArgs[i], usageArgs[i], typeParameter));
                            }
                        }
                    }
                    return types;
                }
                var genericSigs = checker.getSignaturesOfType(genericType, 0 /* Call */);
                var usageSigs = checker.getSignaturesOfType(usageType, 0 /* Call */);
                if (genericSigs.length === 1 && usageSigs.length === 1) {
                    return inferFromSignatures(genericSigs[0], usageSigs[0], typeParameter);
                }
                return [];
            }
            function inferFromSignatures(genericSig, usageSig, typeParameter) {
                var types = [];
                for (var i = 0; i < genericSig.parameters.length; i++) {
                    var genericParam = genericSig.parameters[i];
                    var usageParam = usageSig.parameters[i];
                    var isRest = genericSig.declaration && ts.isRestParameter(genericSig.declaration.parameters[i]);
                    if (!usageParam) {
                        break;
                    }
                    var genericParamType = genericParam.valueDeclaration ? checker.getTypeOfSymbolAtLocation(genericParam, genericParam.valueDeclaration) : checker.getAnyType();
                    var elementType = isRest && checker.getElementTypeOfArrayType(genericParamType);
                    if (elementType) {
                        genericParamType = elementType;
                    }
                    var targetType = usageParam.type
                        || (usageParam.valueDeclaration ? checker.getTypeOfSymbolAtLocation(usageParam, usageParam.valueDeclaration) : checker.getAnyType());
                    types.push.apply(types, inferTypeParameters(genericParamType, targetType, typeParameter));
                }
                var genericReturn = checker.getReturnTypeOfSignature(genericSig);
                var usageReturn = checker.getReturnTypeOfSignature(usageSig);
                types.push.apply(types, inferTypeParameters(genericReturn, usageReturn, typeParameter));
                return types;
            }
            function getFunctionFromCalls(calls) {
                return checker.createAnonymousType(/*symbol*/ undefined, ts.createSymbolTable(), [getSignatureFromCalls(calls)], ts.emptyArray, ts.emptyArray);
            }
            function getSignatureFromCalls(calls) {
                var parameters = [];
                var length = Math.max.apply(Math, calls.map(function (c) { return c.argumentTypes.length; }));
                var _loop_15 = function (i) {
                    var symbol = checker.createSymbol(1 /* FunctionScopedVariable */, ts.escapeLeadingUnderscores("arg" + i));
                    symbol.type = combineTypes(calls.map(function (call) { return call.argumentTypes[i] || checker.getUndefinedType(); }));
                    if (calls.some(function (call) { return call.argumentTypes[i] === undefined; })) {
                        symbol.flags |= 16777216 /* Optional */;
                    }
                    parameters.push(symbol);
                };
                for (var i = 0; i < length; i++) {
                    _loop_15(i);
                }
                var returnType = combineFromUsage(combineUsages(calls.map(function (call) { return call.return_; })));
                return checker.createSignature(/*declaration*/ undefined, /*typeParameters*/ undefined, /*thisParameter*/ undefined, parameters, returnType, /*typePredicate*/ undefined, length, 0 /* None */);
            }
            function addCandidateType(usage, type) {
                if (type && !(type.flags & 1 /* Any */) && !(type.flags & 131072 /* Never */)) {
                    (usage.candidateTypes || (usage.candidateTypes = [])).push(type);
                }
            }
            function addCandidateThisType(usage, type) {
                if (type && !(type.flags & 1 /* Any */) && !(type.flags & 131072 /* Never */)) {
                    (usage.candidateThisTypes || (usage.candidateThisTypes = [])).push(type);
                }
            }
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "fixReturnTypeInAsyncFunction";
        var errorCodes = [
            ts.Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0.code,
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            fixIds: [fixId],
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, program = context.program, span = context.span;
                var checker = program.getTypeChecker();
                var info = getInfo(sourceFile, program.getTypeChecker(), span.start);
                if (!info) {
                    return undefined;
                }
                var returnTypeNode = info.returnTypeNode, returnType = info.returnType, promisedTypeNode = info.promisedTypeNode, promisedType = info.promisedType;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, returnTypeNode, promisedTypeNode); });
                return [codefix.createCodeFixAction(fixId, changes, [ts.Diagnostics.Replace_0_with_Promise_1,
                        checker.typeToString(returnType), checker.typeToString(promisedType)], fixId, ts.Diagnostics.Fix_all_incorrect_return_type_of_an_async_functions)];
            },
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var info = getInfo(diag.file, context.program.getTypeChecker(), diag.start);
                if (info) {
                    doChange(changes, diag.file, info.returnTypeNode, info.promisedTypeNode);
                }
            }); }
        });
        function getInfo(sourceFile, checker, pos) {
            if (ts.isInJSFile(sourceFile)) {
                return undefined;
            }
            var token = ts.getTokenAtPosition(sourceFile, pos);
            var func = ts.findAncestor(token, ts.isFunctionLikeDeclaration);
            var returnTypeNode = func === null || func === void 0 ? void 0 : func.type;
            if (!returnTypeNode) {
                return undefined;
            }
            var returnType = checker.getTypeFromTypeNode(returnTypeNode);
            var promisedType = checker.getAwaitedType(returnType) || checker.getVoidType();
            var promisedTypeNode = checker.typeToTypeNode(promisedType, /*enclosingDeclaration*/ returnTypeNode, /*flags*/ undefined);
            if (promisedTypeNode) {
                return { returnTypeNode: returnTypeNode, returnType: returnType, promisedTypeNode: promisedTypeNode, promisedType: promisedType };
            }
        }
        function doChange(changes, sourceFile, returnTypeNode, promisedTypeNode) {
            changes.replaceNode(sourceFile, returnTypeNode, ts.factory.createTypeReferenceNode("Promise", [promisedTypeNode]));
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixName = "disableJsDiagnostics";
        var fixId = "disableJsDiagnostics";
        var errorCodes = ts.mapDefined(Object.keys(ts.Diagnostics), function (key) {
            var diag = ts.Diagnostics[key];
            return diag.category === ts.DiagnosticCategory.Error ? diag.code : undefined;
        });
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, program = context.program, span = context.span, host = context.host, formatContext = context.formatContext;
                if (!ts.isInJSFile(sourceFile) || !ts.isCheckJsEnabledForFile(sourceFile, program.getCompilerOptions())) {
                    return undefined;
                }
                var newLineCharacter = sourceFile.checkJsDirective ? "" : ts.getNewLineOrDefaultFromHost(host, formatContext.options);
                var fixes = [
                    // fixId unnecessary because adding `// @ts-nocheck` even once will ignore every error in the file.
                    codefix.createCodeFixActionWithoutFixAll(fixName, [codefix.createFileTextChanges(sourceFile.fileName, [
                            ts.createTextChange(sourceFile.checkJsDirective
                                ? ts.createTextSpanFromBounds(sourceFile.checkJsDirective.pos, sourceFile.checkJsDirective.end)
                                : ts.createTextSpan(0, 0), "// @ts-nocheck" + newLineCharacter),
                        ])], ts.Diagnostics.Disable_checking_for_this_file),
                ];
                if (ts.textChanges.isValidLocationToAddComment(sourceFile, span.start)) {
                    fixes.unshift(codefix.createCodeFixAction(fixName, ts.textChanges.ChangeTracker.with(context, function (t) { return makeChange(t, sourceFile, span.start); }), ts.Diagnostics.Ignore_this_error_message, fixId, ts.Diagnostics.Add_ts_ignore_to_all_error_messages));
                }
                return fixes;
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) {
                var seenLines = new ts.Set();
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                    if (ts.textChanges.isValidLocationToAddComment(diag.file, diag.start)) {
                        makeChange(changes, diag.file, diag.start, seenLines);
                    }
                });
            },
        });
        function makeChange(changes, sourceFile, position, seenLines) {
            var lineNumber = ts.getLineAndCharacterOfPosition(sourceFile, position).line;
            // Only need to add `// @ts-ignore` for a line once.
            if (!seenLines || ts.tryAddToSet(seenLines, lineNumber)) {
                changes.insertCommentBeforeLine(sourceFile, lineNumber, position, " @ts-ignore");
            }
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        /**
         * Finds members of the resolved type that are missing in the class pointed to by class decl
         * and generates source code for the missing members.
         * @param possiblyMissingSymbols The collection of symbols to filter and then get insertions for.
         * @param importAdder If provided, type annotations will use identifier type references instead of ImportTypeNodes, and the missing imports will be added to the importAdder.
         * @returns Empty string iff there are no member insertions.
         */
        function createMissingMemberNodes(classDeclaration, possiblyMissingSymbols, sourceFile, context, preferences, importAdder, addClassElement) {
            var classMembers = classDeclaration.symbol.members;
            for (var _i = 0, possiblyMissingSymbols_1 = possiblyMissingSymbols; _i < possiblyMissingSymbols_1.length; _i++) {
                var symbol = possiblyMissingSymbols_1[_i];
                if (!classMembers.has(symbol.escapedName)) {
                    addNewNodeForMemberSymbol(symbol, classDeclaration, sourceFile, context, preferences, importAdder, addClassElement);
                }
            }
        }
        codefix.createMissingMemberNodes = createMissingMemberNodes;
        function getNoopSymbolTrackerWithResolver(context) {
            return {
                trackSymbol: function () { return false; },
                moduleResolverHost: ts.getModuleSpecifierResolverHost(context.program, context.host),
            };
        }
        codefix.getNoopSymbolTrackerWithResolver = getNoopSymbolTrackerWithResolver;
        /**
         * @returns Empty string iff there we can't figure out a representation for `symbol` in `enclosingDeclaration`.
         */
        function addNewNodeForMemberSymbol(symbol, enclosingDeclaration, sourceFile, context, preferences, importAdder, addClassElement) {
            var declarations = symbol.getDeclarations();
            if (!(declarations && declarations.length)) {
                return undefined;
            }
            var checker = context.program.getTypeChecker();
            var scriptTarget = ts.getEmitScriptTarget(context.program.getCompilerOptions());
            var declaration = declarations[0];
            var name = ts.getSynthesizedDeepClone(ts.getNameOfDeclaration(declaration), /*includeTrivia*/ false);
            var visibilityModifier = createVisibilityModifier(ts.getEffectiveModifierFlags(declaration));
            var modifiers = visibilityModifier ? ts.factory.createNodeArray([visibilityModifier]) : undefined;
            var type = checker.getWidenedType(checker.getTypeOfSymbolAtLocation(symbol, enclosingDeclaration));
            var optional = !!(symbol.flags & 16777216 /* Optional */);
            var ambient = !!(enclosingDeclaration.flags & 8388608 /* Ambient */);
            var quotePreference = ts.getQuotePreference(sourceFile, preferences);
            switch (declaration.kind) {
                case 164 /* PropertySignature */:
                case 165 /* PropertyDeclaration */:
                    var flags = quotePreference === 0 /* Single */ ? 268435456 /* UseSingleQuotesForStringLiteralType */ : undefined;
                    var typeNode = checker.typeToTypeNode(type, enclosingDeclaration, flags, getNoopSymbolTrackerWithResolver(context));
                    if (importAdder) {
                        var importableReference = tryGetAutoImportableReferenceFromTypeNode(typeNode, scriptTarget);
                        if (importableReference) {
                            typeNode = importableReference.typeNode;
                            importSymbols(importAdder, importableReference.symbols);
                        }
                    }
                    addClassElement(ts.factory.createPropertyDeclaration(
                    /*decorators*/ undefined, modifiers, name, optional ? ts.factory.createToken(57 /* QuestionToken */) : undefined, typeNode, 
                    /*initializer*/ undefined));
                    break;
                case 170 /* GetAccessor */:
                case 171 /* SetAccessor */: {
                    var typeNode_1 = checker.typeToTypeNode(type, enclosingDeclaration, /*flags*/ undefined, getNoopSymbolTrackerWithResolver(context));
                    var allAccessors = ts.getAllAccessorDeclarations(declarations, declaration);
                    var orderedAccessors = allAccessors.secondAccessor
                        ? [allAccessors.firstAccessor, allAccessors.secondAccessor]
                        : [allAccessors.firstAccessor];
                    if (importAdder) {
                        var importableReference = tryGetAutoImportableReferenceFromTypeNode(typeNode_1, scriptTarget);
                        if (importableReference) {
                            typeNode_1 = importableReference.typeNode;
                            importSymbols(importAdder, importableReference.symbols);
                        }
                    }
                    for (var _i = 0, orderedAccessors_1 = orderedAccessors; _i < orderedAccessors_1.length; _i++) {
                        var accessor = orderedAccessors_1[_i];
                        if (ts.isGetAccessorDeclaration(accessor)) {
                            addClassElement(ts.factory.createGetAccessorDeclaration(
                            /*decorators*/ undefined, modifiers, name, ts.emptyArray, typeNode_1, ambient ? undefined : createStubbedMethodBody(quotePreference)));
                        }
                        else {
                            ts.Debug.assertNode(accessor, ts.isSetAccessorDeclaration, "The counterpart to a getter should be a setter");
                            var parameter = ts.getSetAccessorValueParameter(accessor);
                            var parameterName = parameter && ts.isIdentifier(parameter.name) ? ts.idText(parameter.name) : undefined;
                            addClassElement(ts.factory.createSetAccessorDeclaration(
                            /*decorators*/ undefined, modifiers, name, createDummyParameters(1, [parameterName], [typeNode_1], 1, /*inJs*/ false), ambient ? undefined : createStubbedMethodBody(quotePreference)));
                        }
                    }
                    break;
                }
                case 166 /* MethodSignature */:
                case 167 /* MethodDeclaration */:
                    // The signature for the implementation appears as an entry in `signatures` iff
                    // there is only one signature.
                    // If there are overloads and an implementation signature, it appears as an
                    // extra declaration that isn't a signature for `type`.
                    // If there is more than one overload but no implementation signature
                    // (eg: an abstract method or interface declaration), there is a 1-1
                    // correspondence of declarations and signatures.
                    var signatures = checker.getSignaturesOfType(type, 0 /* Call */);
                    if (!ts.some(signatures)) {
                        break;
                    }
                    if (declarations.length === 1) {
                        ts.Debug.assert(signatures.length === 1, "One declaration implies one signature");
                        var signature = signatures[0];
                        outputMethod(quotePreference, signature, modifiers, name, ambient ? undefined : createStubbedMethodBody(quotePreference));
                        break;
                    }
                    for (var _a = 0, signatures_1 = signatures; _a < signatures_1.length; _a++) {
                        var signature = signatures_1[_a];
                        // Ensure nodes are fresh so they can have different positions when going through formatting.
                        outputMethod(quotePreference, signature, ts.getSynthesizedDeepClones(modifiers, /*includeTrivia*/ false), ts.getSynthesizedDeepClone(name, /*includeTrivia*/ false));
                    }
                    if (!ambient) {
                        if (declarations.length > signatures.length) {
                            var signature = checker.getSignatureFromDeclaration(declarations[declarations.length - 1]);
                            outputMethod(quotePreference, signature, modifiers, name, createStubbedMethodBody(quotePreference));
                        }
                        else {
                            ts.Debug.assert(declarations.length === signatures.length, "Declarations and signatures should match count");
                            addClassElement(createMethodImplementingSignatures(checker, context, enclosingDeclaration, signatures, name, optional, modifiers, quotePreference));
                        }
                    }
                    break;
            }
            function outputMethod(quotePreference, signature, modifiers, name, body) {
                var method = createSignatureDeclarationFromSignature(167 /* MethodDeclaration */, context, quotePreference, signature, body, name, modifiers, optional, enclosingDeclaration, importAdder);
                if (method)
                    addClassElement(method);
            }
        }
        function createSignatureDeclarationFromSignature(kind, context, quotePreference, signature, body, name, modifiers, optional, enclosingDeclaration, importAdder) {
            var program = context.program;
            var checker = program.getTypeChecker();
            var scriptTarget = ts.getEmitScriptTarget(program.getCompilerOptions());
            var flags = 1 /* NoTruncation */ | 1073741824 /* NoUndefinedOptionalParameterType */ | 256 /* SuppressAnyReturnType */ | (quotePreference === 0 /* Single */ ? 268435456 /* UseSingleQuotesForStringLiteralType */ : 0);
            var signatureDeclaration = checker.signatureToSignatureDeclaration(signature, kind, enclosingDeclaration, flags, getNoopSymbolTrackerWithResolver(context));
            if (!signatureDeclaration) {
                return undefined;
            }
            var typeParameters = signatureDeclaration.typeParameters;
            var parameters = signatureDeclaration.parameters;
            var type = signatureDeclaration.type;
            if (importAdder) {
                if (typeParameters) {
                    var newTypeParameters = ts.sameMap(typeParameters, function (typeParameterDecl) {
                        var constraint = typeParameterDecl.constraint;
                        var defaultType = typeParameterDecl.default;
                        if (constraint) {
                            var importableReference = tryGetAutoImportableReferenceFromTypeNode(constraint, scriptTarget);
                            if (importableReference) {
                                constraint = importableReference.typeNode;
                                importSymbols(importAdder, importableReference.symbols);
                            }
                        }
                        if (defaultType) {
                            var importableReference = tryGetAutoImportableReferenceFromTypeNode(defaultType, scriptTarget);
                            if (importableReference) {
                                defaultType = importableReference.typeNode;
                                importSymbols(importAdder, importableReference.symbols);
                            }
                        }
                        return ts.factory.updateTypeParameterDeclaration(typeParameterDecl, typeParameterDecl.name, constraint, defaultType);
                    });
                    if (typeParameters !== newTypeParameters) {
                        typeParameters = ts.setTextRange(ts.factory.createNodeArray(newTypeParameters, typeParameters.hasTrailingComma), typeParameters);
                    }
                }
                var newParameters = ts.sameMap(parameters, function (parameterDecl) {
                    var importableReference = tryGetAutoImportableReferenceFromTypeNode(parameterDecl.type, scriptTarget);
                    var type = parameterDecl.type;
                    if (importableReference) {
                        type = importableReference.typeNode;
                        importSymbols(importAdder, importableReference.symbols);
                    }
                    return ts.factory.updateParameterDeclaration(parameterDecl, parameterDecl.decorators, parameterDecl.modifiers, parameterDecl.dotDotDotToken, parameterDecl.name, parameterDecl.questionToken, type, parameterDecl.initializer);
                });
                if (parameters !== newParameters) {
                    parameters = ts.setTextRange(ts.factory.createNodeArray(newParameters, parameters.hasTrailingComma), parameters);
                }
                if (type) {
                    var importableReference = tryGetAutoImportableReferenceFromTypeNode(type, scriptTarget);
                    if (importableReference) {
                        type = importableReference.typeNode;
                        importSymbols(importAdder, importableReference.symbols);
                    }
                }
            }
            var questionToken = optional ? ts.factory.createToken(57 /* QuestionToken */) : undefined;
            var asteriskToken = signatureDeclaration.asteriskToken;
            if (ts.isFunctionExpression(signatureDeclaration)) {
                return ts.factory.updateFunctionExpression(signatureDeclaration, modifiers, signatureDeclaration.asteriskToken, ts.tryCast(name, ts.isIdentifier), typeParameters, parameters, type, body !== null && body !== void 0 ? body : signatureDeclaration.body);
            }
            if (ts.isArrowFunction(signatureDeclaration)) {
                return ts.factory.updateArrowFunction(signatureDeclaration, modifiers, typeParameters, parameters, type, signatureDeclaration.equalsGreaterThanToken, body !== null && body !== void 0 ? body : signatureDeclaration.body);
            }
            if (ts.isMethodDeclaration(signatureDeclaration)) {
                return ts.factory.updateMethodDeclaration(signatureDeclaration, /* decorators */ undefined, modifiers, asteriskToken, name !== null && name !== void 0 ? name : ts.factory.createIdentifier(""), questionToken, typeParameters, parameters, type, body);
            }
            return undefined;
        }
        codefix.createSignatureDeclarationFromSignature = createSignatureDeclarationFromSignature;
        function createSignatureDeclarationFromCallExpression(kind, context, importAdder, call, name, modifierFlags, contextNode) {
            var quotePreference = ts.getQuotePreference(context.sourceFile, context.preferences);
            var scriptTarget = ts.getEmitScriptTarget(context.program.getCompilerOptions());
            var tracker = getNoopSymbolTrackerWithResolver(context);
            var checker = context.program.getTypeChecker();
            var isJs = ts.isInJSFile(contextNode);
            var typeArguments = call.typeArguments, args = call.arguments, parent = call.parent;
            var contextualType = isJs ? undefined : checker.getContextualType(call);
            var names = ts.map(args, function (arg) {
                return ts.isIdentifier(arg) ? arg.text : ts.isPropertyAccessExpression(arg) && ts.isIdentifier(arg.name) ? arg.name.text : undefined;
            });
            var types = isJs ? [] : ts.map(args, function (arg) {
                return typeToAutoImportableTypeNode(checker, importAdder, checker.getBaseTypeOfLiteralType(checker.getTypeAtLocation(arg)), contextNode, scriptTarget, /*flags*/ undefined, tracker);
            });
            var modifiers = modifierFlags
                ? ts.factory.createNodeArray(ts.factory.createModifiersFromModifierFlags(modifierFlags))
                : undefined;
            var asteriskToken = ts.isYieldExpression(parent)
                ? ts.factory.createToken(41 /* AsteriskToken */)
                : undefined;
            var typeParameters = isJs || typeArguments === undefined
                ? undefined
                : ts.map(typeArguments, function (_, i) {
                    return ts.factory.createTypeParameterDeclaration(84 /* T */ + typeArguments.length - 1 <= 90 /* Z */ ? String.fromCharCode(84 /* T */ + i) : "T" + i);
                });
            var parameters = createDummyParameters(args.length, names, types, /*minArgumentCount*/ undefined, isJs);
            var type = isJs || contextualType === undefined
                ? undefined
                : checker.typeToTypeNode(contextualType, contextNode, /*flags*/ undefined, tracker);
            if (kind === 167 /* MethodDeclaration */) {
                return ts.factory.createMethodDeclaration(
                /*decorators*/ undefined, modifiers, asteriskToken, name, 
                /*questionToken*/ undefined, typeParameters, parameters, type, ts.isInterfaceDeclaration(contextNode) ? undefined : createStubbedMethodBody(quotePreference));
            }
            return ts.factory.createFunctionDeclaration(
            /*decorators*/ undefined, modifiers, asteriskToken, name, typeParameters, parameters, type, createStubbedBody(ts.Diagnostics.Function_not_implemented.message, quotePreference));
        }
        codefix.createSignatureDeclarationFromCallExpression = createSignatureDeclarationFromCallExpression;
        function typeToAutoImportableTypeNode(checker, importAdder, type, contextNode, scriptTarget, flags, tracker) {
            var typeNode = checker.typeToTypeNode(type, contextNode, flags, tracker);
            if (typeNode && ts.isImportTypeNode(typeNode)) {
                var importableReference = tryGetAutoImportableReferenceFromTypeNode(typeNode, scriptTarget);
                if (importableReference) {
                    importSymbols(importAdder, importableReference.symbols);
                    typeNode = importableReference.typeNode;
                }
            }
            // Ensure nodes are fresh so they can have different positions when going through formatting.
            return ts.getSynthesizedDeepClone(typeNode);
        }
        codefix.typeToAutoImportableTypeNode = typeToAutoImportableTypeNode;
        function createDummyParameters(argCount, names, types, minArgumentCount, inJs) {
            var parameters = [];
            for (var i = 0; i < argCount; i++) {
                var newParameter = ts.factory.createParameterDeclaration(
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, 
                /*dotDotDotToken*/ undefined, 
                /*name*/ names && names[i] || "arg" + i, 
                /*questionToken*/ minArgumentCount !== undefined && i >= minArgumentCount ? ts.factory.createToken(57 /* QuestionToken */) : undefined, 
                /*type*/ inJs ? undefined : types && types[i] || ts.factory.createKeywordTypeNode(129 /* AnyKeyword */), 
                /*initializer*/ undefined);
                parameters.push(newParameter);
            }
            return parameters;
        }
        function createMethodImplementingSignatures(checker, context, enclosingDeclaration, signatures, name, optional, modifiers, quotePreference) {
            /** This is *a* signature with the maximal number of arguments,
             * such that if there is a "maximal" signature without rest arguments,
             * this is one of them.
             */
            var maxArgsSignature = signatures[0];
            var minArgumentCount = signatures[0].minArgumentCount;
            var someSigHasRestParameter = false;
            for (var _i = 0, signatures_2 = signatures; _i < signatures_2.length; _i++) {
                var sig = signatures_2[_i];
                minArgumentCount = Math.min(sig.minArgumentCount, minArgumentCount);
                if (ts.signatureHasRestParameter(sig)) {
                    someSigHasRestParameter = true;
                }
                if (sig.parameters.length >= maxArgsSignature.parameters.length && (!ts.signatureHasRestParameter(sig) || ts.signatureHasRestParameter(maxArgsSignature))) {
                    maxArgsSignature = sig;
                }
            }
            var maxNonRestArgs = maxArgsSignature.parameters.length - (ts.signatureHasRestParameter(maxArgsSignature) ? 1 : 0);
            var maxArgsParameterSymbolNames = maxArgsSignature.parameters.map(function (symbol) { return symbol.name; });
            var parameters = createDummyParameters(maxNonRestArgs, maxArgsParameterSymbolNames, /* types */ undefined, minArgumentCount, /*inJs*/ false);
            if (someSigHasRestParameter) {
                var anyArrayType = ts.factory.createArrayTypeNode(ts.factory.createKeywordTypeNode(129 /* AnyKeyword */));
                var restParameter = ts.factory.createParameterDeclaration(
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, ts.factory.createToken(25 /* DotDotDotToken */), maxArgsParameterSymbolNames[maxNonRestArgs] || "rest", 
                /*questionToken*/ maxNonRestArgs >= minArgumentCount ? ts.factory.createToken(57 /* QuestionToken */) : undefined, anyArrayType, 
                /*initializer*/ undefined);
                parameters.push(restParameter);
            }
            return createStubbedMethod(modifiers, name, optional, 
            /*typeParameters*/ undefined, parameters, getReturnTypeFromSignatures(signatures, checker, context, enclosingDeclaration), quotePreference);
        }
        function getReturnTypeFromSignatures(signatures, checker, context, enclosingDeclaration) {
            if (ts.length(signatures)) {
                var type = checker.getUnionType(ts.map(signatures, checker.getReturnTypeOfSignature));
                return checker.typeToTypeNode(type, enclosingDeclaration, /*flags*/ undefined, getNoopSymbolTrackerWithResolver(context));
            }
        }
        function createStubbedMethod(modifiers, name, optional, typeParameters, parameters, returnType, quotePreference) {
            return ts.factory.createMethodDeclaration(
            /*decorators*/ undefined, modifiers, 
            /*asteriskToken*/ undefined, name, optional ? ts.factory.createToken(57 /* QuestionToken */) : undefined, typeParameters, parameters, returnType, createStubbedMethodBody(quotePreference));
        }
        function createStubbedMethodBody(quotePreference) {
            return createStubbedBody(ts.Diagnostics.Method_not_implemented.message, quotePreference);
        }
        function createStubbedBody(text, quotePreference) {
            return ts.factory.createBlock([ts.factory.createThrowStatement(ts.factory.createNewExpression(ts.factory.createIdentifier("Error"), 
                /*typeArguments*/ undefined, 
                // TODO Handle auto quote preference.
                [ts.factory.createStringLiteral(text, /*isSingleQuote*/ quotePreference === 0 /* Single */)]))], 
            /*multiline*/ true);
        }
        codefix.createStubbedBody = createStubbedBody;
        function createVisibilityModifier(flags) {
            if (flags & 4 /* Public */) {
                return ts.factory.createToken(123 /* PublicKeyword */);
            }
            else if (flags & 16 /* Protected */) {
                return ts.factory.createToken(122 /* ProtectedKeyword */);
            }
            return undefined;
        }
        function setJsonCompilerOptionValues(changeTracker, configFile, options) {
            var tsconfigObjectLiteral = ts.getTsConfigObjectLiteralExpression(configFile);
            if (!tsconfigObjectLiteral)
                return undefined;
            var compilerOptionsProperty = findJsonProperty(tsconfigObjectLiteral, "compilerOptions");
            if (compilerOptionsProperty === undefined) {
                changeTracker.insertNodeAtObjectStart(configFile, tsconfigObjectLiteral, createJsonPropertyAssignment("compilerOptions", ts.factory.createObjectLiteralExpression(options.map(function (_a) {
                    var optionName = _a[0], optionValue = _a[1];
                    return createJsonPropertyAssignment(optionName, optionValue);
                }), /*multiLine*/ true)));
                return;
            }
            var compilerOptions = compilerOptionsProperty.initializer;
            if (!ts.isObjectLiteralExpression(compilerOptions)) {
                return;
            }
            for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
                var _a = options_1[_i], optionName = _a[0], optionValue = _a[1];
                var optionProperty = findJsonProperty(compilerOptions, optionName);
                if (optionProperty === undefined) {
                    changeTracker.insertNodeAtObjectStart(configFile, compilerOptions, createJsonPropertyAssignment(optionName, optionValue));
                }
                else {
                    changeTracker.replaceNode(configFile, optionProperty.initializer, optionValue);
                }
            }
        }
        codefix.setJsonCompilerOptionValues = setJsonCompilerOptionValues;
        function setJsonCompilerOptionValue(changeTracker, configFile, optionName, optionValue) {
            setJsonCompilerOptionValues(changeTracker, configFile, [[optionName, optionValue]]);
        }
        codefix.setJsonCompilerOptionValue = setJsonCompilerOptionValue;
        function createJsonPropertyAssignment(name, initializer) {
            return ts.factory.createPropertyAssignment(ts.factory.createStringLiteral(name), initializer);
        }
        codefix.createJsonPropertyAssignment = createJsonPropertyAssignment;
        function findJsonProperty(obj, name) {
            return ts.find(obj.properties, function (p) { return ts.isPropertyAssignment(p) && !!p.name && ts.isStringLiteral(p.name) && p.name.text === name; });
        }
        codefix.findJsonProperty = findJsonProperty;
        /**
         * Given a type node containing 'import("./a").SomeType<import("./b").OtherType<...>>',
         * returns an equivalent type reference node with any nested ImportTypeNodes also replaced
         * with type references, and a list of symbols that must be imported to use the type reference.
         */
        function tryGetAutoImportableReferenceFromTypeNode(importTypeNode, scriptTarget) {
            var symbols;
            var typeNode = ts.visitNode(importTypeNode, visit);
            if (symbols && typeNode) {
                return { typeNode: typeNode, symbols: symbols };
            }
            function visit(node) {
                var _a;
                if (ts.isLiteralImportTypeNode(node) && node.qualifier) {
                    // Symbol for the left-most thing after the dot
                    var firstIdentifier = ts.getFirstIdentifier(node.qualifier);
                    var name = ts.getNameForExportedSymbol(firstIdentifier.symbol, scriptTarget);
                    var qualifier = name !== firstIdentifier.text
                        ? replaceFirstIdentifierOfEntityName(node.qualifier, ts.factory.createIdentifier(name))
                        : node.qualifier;
                    symbols = ts.append(symbols, firstIdentifier.symbol);
                    var typeArguments = (_a = node.typeArguments) === null || _a === void 0 ? void 0 : _a.map(visit);
                    return ts.factory.createTypeReferenceNode(qualifier, typeArguments);
                }
                return ts.visitEachChild(node, visit, ts.nullTransformationContext);
            }
        }
        codefix.tryGetAutoImportableReferenceFromTypeNode = tryGetAutoImportableReferenceFromTypeNode;
        function replaceFirstIdentifierOfEntityName(name, newIdentifier) {
            if (name.kind === 79 /* Identifier */) {
                return newIdentifier;
            }
            return ts.factory.createQualifiedName(replaceFirstIdentifierOfEntityName(name.left, newIdentifier), name.right);
        }
        function importSymbols(importAdder, symbols) {
            symbols.forEach(function (s) { return importAdder.addImportFromExportedSymbol(s, /*usageIsTypeOnly*/ true); });
        }
        codefix.importSymbols = importSymbols;
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        function generateAccessorFromProperty(file, program, start, end, context, _actionName) {
            var fieldInfo = getAccessorConvertiblePropertyAtPosition(file, program, start, end);
            if (!fieldInfo || ts.refactor.isRefactorErrorInfo(fieldInfo))
                return undefined;
            var changeTracker = ts.textChanges.ChangeTracker.fromContext(context);
            var isStatic = fieldInfo.isStatic, isReadonly = fieldInfo.isReadonly, fieldName = fieldInfo.fieldName, accessorName = fieldInfo.accessorName, originalName = fieldInfo.originalName, type = fieldInfo.type, container = fieldInfo.container, declaration = fieldInfo.declaration;
            ts.suppressLeadingAndTrailingTrivia(fieldName);
            ts.suppressLeadingAndTrailingTrivia(accessorName);
            ts.suppressLeadingAndTrailingTrivia(declaration);
            ts.suppressLeadingAndTrailingTrivia(container);
            var accessorModifiers;
            var fieldModifiers;
            if (ts.isClassLike(container)) {
                var modifierFlags = ts.getEffectiveModifierFlags(declaration);
                if (ts.isSourceFileJS(file)) {
                    var modifiers = ts.createModifiers(modifierFlags);
                    accessorModifiers = modifiers;
                    fieldModifiers = modifiers;
                }
                else {
                    accessorModifiers = ts.createModifiers(prepareModifierFlagsForAccessor(modifierFlags));
                    fieldModifiers = ts.createModifiers(prepareModifierFlagsForField(modifierFlags));
                }
            }
            updateFieldDeclaration(changeTracker, file, declaration, type, fieldName, fieldModifiers);
            var getAccessor = generateGetAccessor(fieldName, accessorName, type, accessorModifiers, isStatic, container);
            ts.suppressLeadingAndTrailingTrivia(getAccessor);
            insertAccessor(changeTracker, file, getAccessor, declaration, container);
            if (isReadonly) {
                // readonly modifier only existed in classLikeDeclaration
                var constructor = ts.getFirstConstructorWithBody(container);
                if (constructor) {
                    updateReadonlyPropertyInitializerStatementConstructor(changeTracker, file, constructor, fieldName.text, originalName);
                }
            }
            else {
                var setAccessor = generateSetAccessor(fieldName, accessorName, type, accessorModifiers, isStatic, container);
                ts.suppressLeadingAndTrailingTrivia(setAccessor);
                insertAccessor(changeTracker, file, setAccessor, declaration, container);
            }
            return changeTracker.getChanges();
        }
        codefix.generateAccessorFromProperty = generateAccessorFromProperty;
        function isConvertibleName(name) {
            return ts.isIdentifier(name) || ts.isStringLiteral(name);
        }
        function isAcceptedDeclaration(node) {
            return ts.isParameterPropertyDeclaration(node, node.parent) || ts.isPropertyDeclaration(node) || ts.isPropertyAssignment(node);
        }
        function createPropertyName(name, originalName) {
            return ts.isIdentifier(originalName) ? ts.factory.createIdentifier(name) : ts.factory.createStringLiteral(name);
        }
        function createAccessorAccessExpression(fieldName, isStatic, container) {
            var leftHead = isStatic ? container.name : ts.factory.createThis(); // TODO: GH#18217
            return ts.isIdentifier(fieldName) ? ts.factory.createPropertyAccessExpression(leftHead, fieldName) : ts.factory.createElementAccessExpression(leftHead, ts.factory.createStringLiteralFromNode(fieldName));
        }
        function prepareModifierFlagsForAccessor(modifierFlags) {
            modifierFlags &= ~64 /* Readonly */; // avoid Readonly modifier because it will convert to get accessor
            modifierFlags &= ~8 /* Private */;
            if (!(modifierFlags & 16 /* Protected */)) {
                modifierFlags |= 4 /* Public */;
            }
            return modifierFlags;
        }
        function prepareModifierFlagsForField(modifierFlags) {
            modifierFlags &= ~4 /* Public */;
            modifierFlags &= ~16 /* Protected */;
            modifierFlags |= 8 /* Private */;
            return modifierFlags;
        }
        function getAccessorConvertiblePropertyAtPosition(file, program, start, end, considerEmptySpans) {
            if (considerEmptySpans === void 0) { considerEmptySpans = true; }
            var node = ts.getTokenAtPosition(file, start);
            var cursorRequest = start === end && considerEmptySpans;
            var declaration = ts.findAncestor(node.parent, isAcceptedDeclaration);
            // make sure declaration have AccessibilityModifier or Static Modifier or Readonly Modifier
            var meaning = 28 /* AccessibilityModifier */ | 32 /* Static */ | 64 /* Readonly */;
            if (!declaration || (!(ts.nodeOverlapsWithStartEnd(declaration.name, file, start, end) || cursorRequest))) {
                return {
                    error: ts.getLocaleSpecificMessage(ts.Diagnostics.Could_not_find_property_for_which_to_generate_accessor)
                };
            }
            if (!isConvertibleName(declaration.name)) {
                return {
                    error: ts.getLocaleSpecificMessage(ts.Diagnostics.Name_is_not_valid)
                };
            }
            if ((ts.getEffectiveModifierFlags(declaration) | meaning) !== meaning) {
                return {
                    error: ts.getLocaleSpecificMessage(ts.Diagnostics.Can_only_convert_property_with_modifier)
                };
            }
            var name = declaration.name.text;
            var startWithUnderscore = ts.startsWithUnderscore(name);
            var fieldName = createPropertyName(startWithUnderscore ? name : ts.getUniqueName("_" + name, file), declaration.name);
            var accessorName = createPropertyName(startWithUnderscore ? ts.getUniqueName(name.substring(1), file) : name, declaration.name);
            return {
                isStatic: ts.hasStaticModifier(declaration),
                isReadonly: ts.hasEffectiveReadonlyModifier(declaration),
                type: getDeclarationType(declaration, program),
                container: declaration.kind === 162 /* Parameter */ ? declaration.parent.parent : declaration.parent,
                originalName: declaration.name.text,
                declaration: declaration,
                fieldName: fieldName,
                accessorName: accessorName,
                renameAccessor: startWithUnderscore
            };
        }
        codefix.getAccessorConvertiblePropertyAtPosition = getAccessorConvertiblePropertyAtPosition;
        function generateGetAccessor(fieldName, accessorName, type, modifiers, isStatic, container) {
            return ts.factory.createGetAccessorDeclaration(
            /*decorators*/ undefined, modifiers, accessorName, 
            /*parameters*/ undefined, // TODO: GH#18217
            type, ts.factory.createBlock([
                ts.factory.createReturnStatement(createAccessorAccessExpression(fieldName, isStatic, container))
            ], /*multiLine*/ true));
        }
        function generateSetAccessor(fieldName, accessorName, type, modifiers, isStatic, container) {
            return ts.factory.createSetAccessorDeclaration(
            /*decorators*/ undefined, modifiers, accessorName, [ts.factory.createParameterDeclaration(
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, 
                /*dotDotDotToken*/ undefined, ts.factory.createIdentifier("value"), 
                /*questionToken*/ undefined, type)], ts.factory.createBlock([
                ts.factory.createExpressionStatement(ts.factory.createAssignment(createAccessorAccessExpression(fieldName, isStatic, container), ts.factory.createIdentifier("value")))
            ], /*multiLine*/ true));
        }
        function updatePropertyDeclaration(changeTracker, file, declaration, type, fieldName, modifiers) {
            var property = ts.factory.updatePropertyDeclaration(declaration, declaration.decorators, modifiers, fieldName, declaration.questionToken || declaration.exclamationToken, type, declaration.initializer);
            changeTracker.replaceNode(file, declaration, property);
        }
        function updatePropertyAssignmentDeclaration(changeTracker, file, declaration, fieldName) {
            var assignment = ts.factory.updatePropertyAssignment(declaration, fieldName, declaration.initializer);
            changeTracker.replacePropertyAssignment(file, declaration, assignment);
        }
        function updateFieldDeclaration(changeTracker, file, declaration, type, fieldName, modifiers) {
            if (ts.isPropertyDeclaration(declaration)) {
                updatePropertyDeclaration(changeTracker, file, declaration, type, fieldName, modifiers);
            }
            else if (ts.isPropertyAssignment(declaration)) {
                updatePropertyAssignmentDeclaration(changeTracker, file, declaration, fieldName);
            }
            else {
                changeTracker.replaceNode(file, declaration, ts.factory.updateParameterDeclaration(declaration, declaration.decorators, modifiers, declaration.dotDotDotToken, ts.cast(fieldName, ts.isIdentifier), declaration.questionToken, declaration.type, declaration.initializer));
            }
        }
        function insertAccessor(changeTracker, file, accessor, declaration, container) {
            ts.isParameterPropertyDeclaration(declaration, declaration.parent) ? changeTracker.insertNodeAtClassStart(file, container, accessor) :
                ts.isPropertyAssignment(declaration) ? changeTracker.insertNodeAfterComma(file, declaration, accessor) :
                    changeTracker.insertNodeAfter(file, declaration, accessor);
        }
        function updateReadonlyPropertyInitializerStatementConstructor(changeTracker, file, constructor, fieldName, originalName) {
            if (!constructor.body)
                return;
            constructor.body.forEachChild(function recur(node) {
                if (ts.isElementAccessExpression(node) &&
                    node.expression.kind === 108 /* ThisKeyword */ &&
                    ts.isStringLiteral(node.argumentExpression) &&
                    node.argumentExpression.text === originalName &&
                    ts.isWriteAccess(node)) {
                    changeTracker.replaceNode(file, node.argumentExpression, ts.factory.createStringLiteral(fieldName));
                }
                if (ts.isPropertyAccessExpression(node) && node.expression.kind === 108 /* ThisKeyword */ && node.name.text === originalName && ts.isWriteAccess(node)) {
                    changeTracker.replaceNode(file, node.name, ts.factory.createIdentifier(fieldName));
                }
                if (!ts.isFunctionLike(node) && !ts.isClassLike(node)) {
                    node.forEachChild(recur);
                }
            });
        }
        function getDeclarationType(declaration, program) {
            var typeNode = ts.getTypeAnnotationNode(declaration);
            if (ts.isPropertyDeclaration(declaration) && typeNode && declaration.questionToken) {
                var typeChecker = program.getTypeChecker();
                var type = typeChecker.getTypeFromTypeNode(typeNode);
                if (!typeChecker.isTypeAssignableTo(typeChecker.getUndefinedType(), type)) {
                    var types = ts.isUnionTypeNode(typeNode) ? typeNode.types : [typeNode];
                    return ts.factory.createUnionTypeNode(__spreadArray(__spreadArray([], types, true), [ts.factory.createKeywordTypeNode(151 /* UndefinedKeyword */)], false));
                }
            }
            return typeNode;
        }
        function getAllSupers(decl, checker) {
            var res = [];
            while (decl) {
                var superElement = ts.getClassExtendsHeritageElement(decl);
                var superSymbol = superElement && checker.getSymbolAtLocation(superElement.expression);
                if (!superSymbol)
                    break;
                var symbol = superSymbol.flags & 2097152 /* Alias */ ? checker.getAliasedSymbol(superSymbol) : superSymbol;
                var superDecl = symbol.declarations && ts.find(symbol.declarations, ts.isClassLike);
                if (!superDecl)
                    break;
                res.push(superDecl);
                decl = superDecl;
            }
            return res;
        }
        codefix.getAllSupers = getAllSupers;
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixName = "invalidImportSyntax";
        function getCodeFixesForImportDeclaration(context, node) {
            var sourceFile = ts.getSourceFileOfNode(node);
            var namespace = ts.getNamespaceDeclarationNode(node);
            var opts = context.program.getCompilerOptions();
            var variations = [];
            // import Bluebird from "bluebird";
            variations.push(createAction(context, sourceFile, node, ts.makeImport(namespace.name, /*namedImports*/ undefined, node.moduleSpecifier, ts.getQuotePreference(sourceFile, context.preferences))));
            if (ts.getEmitModuleKind(opts) === ts.ModuleKind.CommonJS) {
                // import Bluebird = require("bluebird");
                variations.push(createAction(context, sourceFile, node, ts.factory.createImportEqualsDeclaration(
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, 
                /*isTypeOnly*/ false, namespace.name, ts.factory.createExternalModuleReference(node.moduleSpecifier))));
            }
            return variations;
        }
        function createAction(context, sourceFile, node, replacement) {
            var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return t.replaceNode(sourceFile, node, replacement); });
            return codefix.createCodeFixActionWithoutFixAll(fixName, changes, [ts.Diagnostics.Replace_import_with_0, changes[0].textChanges[0].newText]);
        }
        codefix.registerCodeFix({
            errorCodes: [
                ts.Diagnostics.This_expression_is_not_callable.code,
                ts.Diagnostics.This_expression_is_not_constructable.code,
            ],
            getCodeActions: getActionsForUsageOfInvalidImport
        });
        function getActionsForUsageOfInvalidImport(context) {
            var sourceFile = context.sourceFile;
            var targetKind = ts.Diagnostics.This_expression_is_not_callable.code === context.errorCode ? 206 /* CallExpression */ : 207 /* NewExpression */;
            var node = ts.findAncestor(ts.getTokenAtPosition(sourceFile, context.span.start), function (a) { return a.kind === targetKind; });
            if (!node) {
                return [];
            }
            var expr = node.expression;
            return getImportCodeFixesForExpression(context, expr);
        }
        codefix.registerCodeFix({
            errorCodes: [
                // The following error codes cover pretty much all assignability errors that could involve an expression
                ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1.code,
                ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1.code,
                ts.Diagnostics.Type_0_is_not_assignable_to_type_1.code,
                ts.Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated.code,
                ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1.code,
                ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3.code,
                ts.Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3.code,
                ts.Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2.code,
                ts.Diagnostics.Property_0_in_type_1_is_not_assignable_to_type_2.code,
                ts.Diagnostics.Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property.code,
                ts.Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1.code,
            ],
            getCodeActions: getActionsForInvalidImportLocation
        });
        function getActionsForInvalidImportLocation(context) {
            var sourceFile = context.sourceFile;
            var node = ts.findAncestor(ts.getTokenAtPosition(sourceFile, context.span.start), function (a) { return a.getStart() === context.span.start && a.getEnd() === (context.span.start + context.span.length); });
            if (!node) {
                return [];
            }
            return getImportCodeFixesForExpression(context, node);
        }
        function getImportCodeFixesForExpression(context, expr) {
            var type = context.program.getTypeChecker().getTypeAtLocation(expr);
            if (!(type.symbol && type.symbol.originatingImport)) {
                return [];
            }
            var fixes = [];
            var relatedImport = type.symbol.originatingImport; // TODO: GH#18217
            if (!ts.isImportCall(relatedImport)) {
                ts.addRange(fixes, getCodeFixesForImportDeclaration(context, relatedImport));
            }
            if (ts.isExpression(expr) && !(ts.isNamedDeclaration(expr.parent) && expr.parent.name === expr)) {
                var sourceFile_2 = context.sourceFile;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return t.replaceNode(sourceFile_2, expr, ts.factory.createPropertyAccessExpression(expr, "default"), {}); });
                fixes.push(codefix.createCodeFixActionWithoutFixAll(fixName, changes, ts.Diagnostics.Use_synthetic_default_member));
            }
            return fixes;
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixName = "strictClassInitialization";
        var fixIdAddDefiniteAssignmentAssertions = "addMissingPropertyDefiniteAssignmentAssertions";
        var fixIdAddUndefinedType = "addMissingPropertyUndefinedType";
        var fixIdAddInitializer = "addMissingPropertyInitializer";
        var errorCodes = [ts.Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var propertyDeclaration = getPropertyDeclaration(context.sourceFile, context.span.start);
                if (!propertyDeclaration)
                    return;
                var result = [
                    getActionForAddMissingUndefinedType(context, propertyDeclaration),
                    getActionForAddMissingDefiniteAssignmentAssertion(context, propertyDeclaration)
                ];
                ts.append(result, getActionForAddMissingInitializer(context, propertyDeclaration));
                return result;
            },
            fixIds: [fixIdAddDefiniteAssignmentAssertions, fixIdAddUndefinedType, fixIdAddInitializer],
            getAllCodeActions: function (context) {
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                    var propertyDeclaration = getPropertyDeclaration(diag.file, diag.start);
                    if (!propertyDeclaration)
                        return;
                    switch (context.fixId) {
                        case fixIdAddDefiniteAssignmentAssertions:
                            addDefiniteAssignmentAssertion(changes, diag.file, propertyDeclaration);
                            break;
                        case fixIdAddUndefinedType:
                            addUndefinedType(changes, diag.file, propertyDeclaration);
                            break;
                        case fixIdAddInitializer:
                            var checker = context.program.getTypeChecker();
                            var initializer = getInitializer(checker, propertyDeclaration);
                            if (!initializer)
                                return;
                            addInitializer(changes, diag.file, propertyDeclaration, initializer);
                            break;
                        default:
                            ts.Debug.fail(JSON.stringify(context.fixId));
                    }
                });
            },
        });
        function getPropertyDeclaration(sourceFile, pos) {
            var token = ts.getTokenAtPosition(sourceFile, pos);
            return ts.isIdentifier(token) ? ts.cast(token.parent, ts.isPropertyDeclaration) : undefined;
        }
        function getActionForAddMissingDefiniteAssignmentAssertion(context, propertyDeclaration) {
            var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return addDefiniteAssignmentAssertion(t, context.sourceFile, propertyDeclaration); });
            return codefix.createCodeFixAction(fixName, changes, [ts.Diagnostics.Add_definite_assignment_assertion_to_property_0, propertyDeclaration.getText()], fixIdAddDefiniteAssignmentAssertions, ts.Diagnostics.Add_definite_assignment_assertions_to_all_uninitialized_properties);
        }
        function addDefiniteAssignmentAssertion(changeTracker, propertyDeclarationSourceFile, propertyDeclaration) {
            var property = ts.factory.updatePropertyDeclaration(propertyDeclaration, propertyDeclaration.decorators, propertyDeclaration.modifiers, propertyDeclaration.name, ts.factory.createToken(53 /* ExclamationToken */), propertyDeclaration.type, propertyDeclaration.initializer);
            changeTracker.replaceNode(propertyDeclarationSourceFile, propertyDeclaration, property);
        }
        function getActionForAddMissingUndefinedType(context, propertyDeclaration) {
            var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return addUndefinedType(t, context.sourceFile, propertyDeclaration); });
            return codefix.createCodeFixAction(fixName, changes, [ts.Diagnostics.Add_undefined_type_to_property_0, propertyDeclaration.name.getText()], fixIdAddUndefinedType, ts.Diagnostics.Add_undefined_type_to_all_uninitialized_properties);
        }
        function addUndefinedType(changeTracker, propertyDeclarationSourceFile, propertyDeclaration) {
            var undefinedTypeNode = ts.factory.createKeywordTypeNode(151 /* UndefinedKeyword */);
            var type = propertyDeclaration.type; // TODO: GH#18217
            var types = ts.isUnionTypeNode(type) ? type.types.concat(undefinedTypeNode) : [type, undefinedTypeNode];
            changeTracker.replaceNode(propertyDeclarationSourceFile, type, ts.factory.createUnionTypeNode(types));
        }
        function getActionForAddMissingInitializer(context, propertyDeclaration) {
            var checker = context.program.getTypeChecker();
            var initializer = getInitializer(checker, propertyDeclaration);
            if (!initializer)
                return undefined;
            var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return addInitializer(t, context.sourceFile, propertyDeclaration, initializer); });
            return codefix.createCodeFixAction(fixName, changes, [ts.Diagnostics.Add_initializer_to_property_0, propertyDeclaration.name.getText()], fixIdAddInitializer, ts.Diagnostics.Add_initializers_to_all_uninitialized_properties);
        }
        function addInitializer(changeTracker, propertyDeclarationSourceFile, propertyDeclaration, initializer) {
            var property = ts.factory.updatePropertyDeclaration(propertyDeclaration, propertyDeclaration.decorators, propertyDeclaration.modifiers, propertyDeclaration.name, propertyDeclaration.questionToken, propertyDeclaration.type, initializer);
            changeTracker.replaceNode(propertyDeclarationSourceFile, propertyDeclaration, property);
        }
        function getInitializer(checker, propertyDeclaration) {
            return getDefaultValueFromType(checker, checker.getTypeFromTypeNode(propertyDeclaration.type)); // TODO: GH#18217
        }
        function getDefaultValueFromType(checker, type) {
            if (type.flags & 512 /* BooleanLiteral */) {
                return (type === checker.getFalseType() || type === checker.getFalseType(/*fresh*/ true)) ? ts.factory.createFalse() : ts.factory.createTrue();
            }
            else if (type.isStringLiteral()) {
                return ts.factory.createStringLiteral(type.value);
            }
            else if (type.isNumberLiteral()) {
                return ts.factory.createNumericLiteral(type.value);
            }
            else if (type.flags & 2048 /* BigIntLiteral */) {
                return ts.factory.createBigIntLiteral(type.value);
            }
            else if (type.isUnion()) {
                return ts.firstDefined(type.types, function (t) { return getDefaultValueFromType(checker, t); });
            }
            else if (type.isClass()) {
                var classDeclaration = ts.getClassLikeDeclarationOfSymbol(type.symbol);
                if (!classDeclaration || ts.hasSyntacticModifier(classDeclaration, 128 /* Abstract */))
                    return undefined;
                var constructorDeclaration = ts.getFirstConstructorWithBody(classDeclaration);
                if (constructorDeclaration && constructorDeclaration.parameters.length)
                    return undefined;
                return ts.factory.createNewExpression(ts.factory.createIdentifier(type.symbol.name), /*typeArguments*/ undefined, /*argumentsArray*/ undefined);
            }
            else if (checker.isArrayLikeType(type)) {
                return ts.factory.createArrayLiteralExpression();
            }
            return undefined;
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "requireInTs";
        var errorCodes = [ts.Diagnostics.require_call_may_be_converted_to_an_import.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var info = getInfo(context.sourceFile, context.program, context.span.start);
                if (!info) {
                    return undefined;
                }
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, context.sourceFile, info); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Convert_require_to_import, fixId, ts.Diagnostics.Convert_all_require_to_import)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var info = getInfo(diag.file, context.program, diag.start);
                if (info) {
                    doChange(changes, context.sourceFile, info);
                }
            }); },
        });
        function doChange(changes, sourceFile, info) {
            var allowSyntheticDefaults = info.allowSyntheticDefaults, defaultImportName = info.defaultImportName, namedImports = info.namedImports, statement = info.statement, required = info.required;
            changes.replaceNode(sourceFile, statement, defaultImportName && !allowSyntheticDefaults
                ? ts.factory.createImportEqualsDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*isTypeOnly*/ false, defaultImportName, ts.factory.createExternalModuleReference(required))
                : ts.factory.createImportDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, ts.factory.createImportClause(/*isTypeOnly*/ false, defaultImportName, namedImports), required));
        }
        function getInfo(sourceFile, program, pos) {
            var parent = ts.getTokenAtPosition(sourceFile, pos).parent;
            if (!ts.isRequireCall(parent, /*checkArgumentIsStringLiteralLike*/ true)) {
                throw ts.Debug.failBadSyntaxKind(parent);
            }
            var decl = ts.cast(parent.parent, ts.isVariableDeclaration);
            var defaultImportName = ts.tryCast(decl.name, ts.isIdentifier);
            var namedImports = ts.isObjectBindingPattern(decl.name) ? tryCreateNamedImportsFromObjectBindingPattern(decl.name) : undefined;
            if (defaultImportName || namedImports) {
                return {
                    allowSyntheticDefaults: ts.getAllowSyntheticDefaultImports(program.getCompilerOptions()),
                    defaultImportName: defaultImportName,
                    namedImports: namedImports,
                    statement: ts.cast(decl.parent.parent, ts.isVariableStatement),
                    required: ts.first(parent.arguments)
                };
            }
        }
        function tryCreateNamedImportsFromObjectBindingPattern(node) {
            var importSpecifiers = [];
            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                if (!ts.isIdentifier(element.name) || element.initializer) {
                    return undefined;
                }
                importSpecifiers.push(ts.factory.createImportSpecifier(ts.tryCast(element.propertyName, ts.isIdentifier), element.name));
            }
            if (importSpecifiers.length) {
                return ts.factory.createNamedImports(importSpecifiers);
            }
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "useDefaultImport";
        var errorCodes = [ts.Diagnostics.Import_may_be_converted_to_a_default_import.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, start = context.span.start;
                var info = getInfo(sourceFile, start);
                if (!info)
                    return undefined;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, info, context.preferences); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Convert_to_default_import, fixId, ts.Diagnostics.Convert_all_to_default_imports)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var info = getInfo(diag.file, diag.start);
                if (info)
                    doChange(changes, diag.file, info, context.preferences);
            }); },
        });
        function getInfo(sourceFile, pos) {
            var name = ts.getTokenAtPosition(sourceFile, pos);
            if (!ts.isIdentifier(name))
                return undefined; // bad input
            var parent = name.parent;
            if (ts.isImportEqualsDeclaration(parent) && ts.isExternalModuleReference(parent.moduleReference)) {
                return { importNode: parent, name: name, moduleSpecifier: parent.moduleReference.expression };
            }
            else if (ts.isNamespaceImport(parent)) {
                var importNode = parent.parent.parent;
                return { importNode: importNode, name: name, moduleSpecifier: importNode.moduleSpecifier };
            }
        }
        function doChange(changes, sourceFile, info, preferences) {
            changes.replaceNode(sourceFile, info.importNode, ts.makeImport(info.name, /*namedImports*/ undefined, info.moduleSpecifier, ts.getQuotePreference(sourceFile, preferences)));
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "useBigintLiteral";
        var errorCodes = [
            ts.Diagnostics.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers.code,
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return makeChange(t, context.sourceFile, context.span); });
                if (changes.length > 0) {
                    return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Convert_to_a_bigint_numeric_literal, fixId, ts.Diagnostics.Convert_all_to_bigint_numeric_literals)];
                }
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) {
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) { return makeChange(changes, diag.file, diag); });
            },
        });
        function makeChange(changeTracker, sourceFile, span) {
            var numericLiteral = ts.tryCast(ts.getTokenAtPosition(sourceFile, span.start), ts.isNumericLiteral);
            if (!numericLiteral) {
                return;
            }
            // We use .getText to overcome parser inaccuracies: https://github.com/microsoft/TypeScript/issues/33298
            var newText = numericLiteral.getText(sourceFile) + "n";
            changeTracker.replaceNode(sourceFile, numericLiteral, ts.factory.createBigIntLiteral(newText));
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixIdAddMissingTypeof = "fixAddModuleReferTypeMissingTypeof";
        var fixId = fixIdAddMissingTypeof;
        var errorCodes = [ts.Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span;
                var importType = getImportTypeNode(sourceFile, span.start);
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, importType); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Add_missing_typeof, fixId, ts.Diagnostics.Add_missing_typeof)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                return doChange(changes, context.sourceFile, getImportTypeNode(diag.file, diag.start));
            }); },
        });
        function getImportTypeNode(sourceFile, pos) {
            var token = ts.getTokenAtPosition(sourceFile, pos);
            ts.Debug.assert(token.kind === 100 /* ImportKeyword */, "This token should be an ImportKeyword");
            ts.Debug.assert(token.parent.kind === 198 /* ImportType */, "Token parent should be an ImportType");
            return token.parent;
        }
        function doChange(changes, sourceFile, importType) {
            var newTypeNode = ts.factory.updateImportTypeNode(importType, importType.argument, importType.qualifier, importType.typeArguments, /* isTypeOf */ true);
            changes.replaceNode(sourceFile, importType, newTypeNode);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixID = "wrapJsxInFragment";
        var errorCodes = [ts.Diagnostics.JSX_expressions_must_have_one_parent_element.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span;
                var node = findNodeToFix(sourceFile, span.start);
                if (!node)
                    return undefined;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, node); });
                return [codefix.createCodeFixAction(fixID, changes, ts.Diagnostics.Wrap_in_JSX_fragment, fixID, ts.Diagnostics.Wrap_all_unparented_JSX_in_JSX_fragment)];
            },
            fixIds: [fixID],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var node = findNodeToFix(context.sourceFile, diag.start);
                if (!node)
                    return undefined;
                doChange(changes, context.sourceFile, node);
            }); },
        });
        function findNodeToFix(sourceFile, pos) {
            // The error always at 1st token that is "<" in "<a /><a />"
            var lessThanToken = ts.getTokenAtPosition(sourceFile, pos);
            var firstJsxElementOrOpenElement = lessThanToken.parent;
            var binaryExpr = firstJsxElementOrOpenElement.parent;
            if (!ts.isBinaryExpression(binaryExpr)) {
                // In case the start element is a JsxSelfClosingElement, it the end.
                // For JsxOpenElement, find one more parent
                binaryExpr = binaryExpr.parent;
                if (!ts.isBinaryExpression(binaryExpr))
                    return undefined;
            }
            if (!ts.nodeIsMissing(binaryExpr.operatorToken))
                return undefined;
            return binaryExpr;
        }
        function doChange(changeTracker, sf, node) {
            var jsx = flattenInvalidBinaryExpr(node);
            if (jsx)
                changeTracker.replaceNode(sf, node, ts.factory.createJsxFragment(ts.factory.createJsxOpeningFragment(), jsx, ts.factory.createJsxJsxClosingFragment()));
        }
        // The invalid syntax is constructed as
        // InvalidJsxTree :: One of
        //     JsxElement CommaToken InvalidJsxTree
        //     JsxElement CommaToken JsxElement
        function flattenInvalidBinaryExpr(node) {
            var children = [];
            var current = node;
            while (true) {
                if (ts.isBinaryExpression(current) && ts.nodeIsMissing(current.operatorToken) && current.operatorToken.kind === 27 /* CommaToken */) {
                    children.push(current.left);
                    if (ts.isJsxChild(current.right)) {
                        children.push(current.right);
                        // Indicates the tree has go to the bottom
                        return children;
                    }
                    else if (ts.isBinaryExpression(current.right)) {
                        current = current.right;
                        continue;
                    }
                    // Unreachable case
                    else
                        return undefined;
                }
                // Unreachable case
                else
                    return undefined;
            }
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixIdAddMissingTypeof = "fixConvertToMappedObjectType";
        var fixId = fixIdAddMissingTypeof;
        var errorCodes = [ts.Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span;
                var info = getInfo(sourceFile, span.start);
                if (!info)
                    return undefined;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, info); });
                var name = ts.idText(info.container.name);
                return [codefix.createCodeFixAction(fixId, changes, [ts.Diagnostics.Convert_0_to_mapped_object_type, name], fixId, [ts.Diagnostics.Convert_0_to_mapped_object_type, name])];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var info = getInfo(diag.file, diag.start);
                if (info)
                    doChange(changes, diag.file, info);
            }); }
        });
        function getInfo(sourceFile, pos) {
            var token = ts.getTokenAtPosition(sourceFile, pos);
            var indexSignature = ts.cast(token.parent.parent, ts.isIndexSignatureDeclaration);
            if (ts.isClassDeclaration(indexSignature.parent))
                return undefined;
            var container = ts.isInterfaceDeclaration(indexSignature.parent) ? indexSignature.parent : ts.cast(indexSignature.parent.parent, ts.isTypeAliasDeclaration);
            return { indexSignature: indexSignature, container: container };
        }
        function createTypeAliasFromInterface(declaration, type) {
            return ts.factory.createTypeAliasDeclaration(declaration.decorators, declaration.modifiers, declaration.name, declaration.typeParameters, type);
        }
        function doChange(changes, sourceFile, _a) {
            var indexSignature = _a.indexSignature, container = _a.container;
            var members = ts.isInterfaceDeclaration(container) ? container.members : container.type.members;
            var otherMembers = members.filter(function (member) { return !ts.isIndexSignatureDeclaration(member); });
            var parameter = ts.first(indexSignature.parameters);
            var mappedTypeParameter = ts.factory.createTypeParameterDeclaration(ts.cast(parameter.name, ts.isIdentifier), parameter.type);
            var mappedIntersectionType = ts.factory.createMappedTypeNode(ts.hasEffectiveReadonlyModifier(indexSignature) ? ts.factory.createModifier(143 /* ReadonlyKeyword */) : undefined, mappedTypeParameter, 
            /*nameType*/ undefined, indexSignature.questionToken, indexSignature.type);
            var intersectionType = ts.factory.createIntersectionTypeNode(__spreadArray(__spreadArray(__spreadArray([], ts.getAllSuperTypeNodes(container), true), [
                mappedIntersectionType
            ], false), (otherMembers.length ? [ts.factory.createTypeLiteralNode(otherMembers)] : ts.emptyArray), true));
            changes.replaceNode(sourceFile, container, createTypeAliasFromInterface(container, intersectionType));
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "removeAccidentalCallParentheses";
        var errorCodes = [
            ts.Diagnostics.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without.code,
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var callExpression = ts.findAncestor(ts.getTokenAtPosition(context.sourceFile, context.span.start), ts.isCallExpression);
                if (!callExpression) {
                    return undefined;
                }
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) {
                    t.deleteRange(context.sourceFile, { pos: callExpression.expression.end, end: callExpression.end });
                });
                return [codefix.createCodeFixActionWithoutFixAll(fixId, changes, ts.Diagnostics.Remove_parentheses)];
            },
            fixIds: [fixId],
        });
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "removeUnnecessaryAwait";
        var errorCodes = [
            ts.Diagnostics.await_has_no_effect_on_the_type_of_this_expression.code,
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return makeChange(t, context.sourceFile, context.span); });
                if (changes.length > 0) {
                    return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Remove_unnecessary_await, fixId, ts.Diagnostics.Remove_all_unnecessary_uses_of_await)];
                }
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) {
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) { return makeChange(changes, diag.file, diag); });
            },
        });
        function makeChange(changeTracker, sourceFile, span) {
            var awaitKeyword = ts.tryCast(ts.getTokenAtPosition(sourceFile, span.start), function (node) { return node.kind === 131 /* AwaitKeyword */; });
            var awaitExpression = awaitKeyword && ts.tryCast(awaitKeyword.parent, ts.isAwaitExpression);
            if (!awaitExpression) {
                return;
            }
            var expressionToReplace = awaitExpression;
            var hasSurroundingParens = ts.isParenthesizedExpression(awaitExpression.parent);
            if (hasSurroundingParens) {
                var leftMostExpression = ts.getLeftmostExpression(awaitExpression.expression, /*stopAtCallExpressions*/ false);
                if (ts.isIdentifier(leftMostExpression)) {
                    var precedingToken = ts.findPrecedingToken(awaitExpression.parent.pos, sourceFile);
                    if (precedingToken && precedingToken.kind !== 103 /* NewKeyword */) {
                        expressionToReplace = awaitExpression.parent;
                    }
                }
            }
            changeTracker.replaceNode(sourceFile, expressionToReplace, awaitExpression.expression);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var errorCodes = [ts.Diagnostics.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both.code];
        var fixId = "splitTypeOnlyImport";
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            fixIds: [fixId],
            getCodeActions: function (context) {
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) {
                    return splitTypeOnlyImport(t, getImportDeclaration(context.sourceFile, context.span), context);
                });
                if (changes.length) {
                    return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Split_into_two_separate_import_declarations, fixId, ts.Diagnostics.Split_all_invalid_type_only_imports)];
                }
            },
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, error) {
                splitTypeOnlyImport(changes, getImportDeclaration(context.sourceFile, error), context);
            }); },
        });
        function getImportDeclaration(sourceFile, span) {
            return ts.findAncestor(ts.getTokenAtPosition(sourceFile, span.start), ts.isImportDeclaration);
        }
        function splitTypeOnlyImport(changes, importDeclaration, context) {
            if (!importDeclaration) {
                return;
            }
            var importClause = ts.Debug.checkDefined(importDeclaration.importClause);
            changes.replaceNode(context.sourceFile, importDeclaration, ts.factory.updateImportDeclaration(importDeclaration, importDeclaration.decorators, importDeclaration.modifiers, ts.factory.updateImportClause(importClause, importClause.isTypeOnly, importClause.name, /*namedBindings*/ undefined), importDeclaration.moduleSpecifier));
            changes.insertNodeAfter(context.sourceFile, importDeclaration, ts.factory.createImportDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, ts.factory.updateImportClause(importClause, importClause.isTypeOnly, /*name*/ undefined, importClause.namedBindings), importDeclaration.moduleSpecifier));
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "fixConvertConstToLet";
        var errorCodes = [ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_constant.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span, program = context.program;
                var range = getConstTokenRange(sourceFile, span.start, program);
                if (range === undefined)
                    return;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, range); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Convert_const_to_let, fixId, ts.Diagnostics.Convert_const_to_let)];
            },
            fixIds: [fixId]
        });
        function getConstTokenRange(sourceFile, pos, program) {
            var _a;
            var checker = program.getTypeChecker();
            var symbol = checker.getSymbolAtLocation(ts.getTokenAtPosition(sourceFile, pos));
            var declaration = ts.tryCast((_a = symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration) === null || _a === void 0 ? void 0 : _a.parent, ts.isVariableDeclarationList);
            if (declaration === undefined)
                return;
            var constToken = ts.findChildOfKind(declaration, 85 /* ConstKeyword */, sourceFile);
            if (constToken === undefined)
                return;
            return ts.createRange(constToken.pos, constToken.end);
        }
        function doChange(changes, sourceFile, range) {
            changes.replaceRangeWithText(sourceFile, range, "let");
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "fixExpectedComma";
        var expectedErrorCode = ts.Diagnostics._0_expected.code;
        var errorCodes = [expectedErrorCode];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile;
                var info = getInfo(sourceFile, context.span.start, context.errorCode);
                if (!info) {
                    return undefined;
                }
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, info); });
                return [codefix.createCodeFixAction(fixId, changes, [ts.Diagnostics.Change_0_to_1, ";", ","], fixId, [ts.Diagnostics.Change_0_to_1, ";", ","])];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var info = getInfo(diag.file, diag.start, diag.code);
                if (info)
                    doChange(changes, context.sourceFile, info);
            }); },
        });
        function getInfo(sourceFile, pos, _) {
            var node = ts.getTokenAtPosition(sourceFile, pos);
            return (node.kind === 26 /* SemicolonToken */ &&
                node.parent &&
                (ts.isObjectLiteralExpression(node.parent) ||
                    ts.isArrayLiteralExpression(node.parent))) ? { node: node } : undefined;
        }
        function doChange(changes, sourceFile, _a) {
            var node = _a.node;
            var newNode = ts.factory.createToken(27 /* CommaToken */);
            changes.replaceNode(sourceFile, node, newNode);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixName = "addVoidToPromise";
        var fixId = "addVoidToPromise";
        var errorCodes = [
            ts.Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise.code
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            fixIds: [fixId],
            getCodeActions: function (context) {
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return makeChange(t, context.sourceFile, context.span, context.program); });
                if (changes.length > 0) {
                    return [codefix.createCodeFixAction(fixName, changes, ts.Diagnostics.Add_void_to_Promise_resolved_without_a_value, fixId, ts.Diagnostics.Add_void_to_all_Promises_resolved_without_a_value)];
                }
            },
            getAllCodeActions: function (context) {
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) { return makeChange(changes, diag.file, diag, context.program, new ts.Set()); });
            }
        });
        function makeChange(changes, sourceFile, span, program, seen) {
            var node = ts.getTokenAtPosition(sourceFile, span.start);
            if (!ts.isIdentifier(node) || !ts.isCallExpression(node.parent) || node.parent.expression !== node || node.parent.arguments.length !== 0)
                return;
            var checker = program.getTypeChecker();
            var symbol = checker.getSymbolAtLocation(node);
            // decl should be `new Promise((<decl>) => {})`
            var decl = symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration;
            if (!decl || !ts.isParameter(decl) || !ts.isNewExpression(decl.parent.parent))
                return;
            // no need to make this change if we have already seen this parameter.
            if (seen === null || seen === void 0 ? void 0 : seen.has(decl))
                return;
            seen === null || seen === void 0 ? void 0 : seen.add(decl);
            var typeArguments = getEffectiveTypeArguments(decl.parent.parent);
            if (ts.some(typeArguments)) {
                // append ` | void` to type argument
                var typeArgument = typeArguments[0];
                var needsParens = !ts.isUnionTypeNode(typeArgument) && !ts.isParenthesizedTypeNode(typeArgument) &&
                    ts.isParenthesizedTypeNode(ts.factory.createUnionTypeNode([typeArgument, ts.factory.createKeywordTypeNode(114 /* VoidKeyword */)]).types[0]);
                if (needsParens) {
                    changes.insertText(sourceFile, typeArgument.pos, "(");
                }
                changes.insertText(sourceFile, typeArgument.end, needsParens ? ") | void" : " | void");
            }
            else {
                // make sure the Promise is type is untyped (i.e., `unknown`)
                var signature = checker.getResolvedSignature(node.parent);
                var parameter = signature === null || signature === void 0 ? void 0 : signature.parameters[0];
                var parameterType = parameter && checker.getTypeOfSymbolAtLocation(parameter, decl.parent.parent);
                if (ts.isInJSFile(decl)) {
                    if (!parameterType || parameterType.flags & 3 /* AnyOrUnknown */) {
                        // give the expression a type
                        changes.insertText(sourceFile, decl.parent.parent.end, ")");
                        changes.insertText(sourceFile, ts.skipTrivia(sourceFile.text, decl.parent.parent.pos), "/** @type {Promise<void>} */(");
                    }
                }
                else {
                    if (!parameterType || parameterType.flags & 2 /* Unknown */) {
                        // add `void` type argument
                        changes.insertText(sourceFile, decl.parent.parent.expression.end, "<void>");
                    }
                }
            }
        }
        function getEffectiveTypeArguments(node) {
            var _a;
            if (ts.isInJSFile(node)) {
                if (ts.isParenthesizedExpression(node.parent)) {
                    var jsDocType = (_a = ts.getJSDocTypeTag(node.parent)) === null || _a === void 0 ? void 0 : _a.typeExpression.type;
                    if (jsDocType && ts.isTypeReferenceNode(jsDocType) && ts.isIdentifier(jsDocType.typeName) && ts.idText(jsDocType.typeName) === "Promise") {
                        return jsDocType.typeArguments;
                    }
                }
            }
            else {
                return node.typeArguments;
            }
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var refactor;
    (function (refactor) {
        var refactorName = "Convert export";
        var defaultToNamedAction = {
            name: "Convert default export to named export",
            description: ts.Diagnostics.Convert_default_export_to_named_export.message,
            kind: "refactor.rewrite.export.named"
        };
        var namedToDefaultAction = {
            name: "Convert named export to default export",
            description: ts.Diagnostics.Convert_named_export_to_default_export.message,
            kind: "refactor.rewrite.export.default"
        };
        refactor.registerRefactor(refactorName, {
            kinds: [
                defaultToNamedAction.kind,
                namedToDefaultAction.kind
            ],
            getAvailableActions: function (context) {
                var info = getInfo(context, context.triggerReason === "invoked");
                if (!info)
                    return ts.emptyArray;
                if (!refactor.isRefactorErrorInfo(info)) {
                    var action = info.wasDefault ? defaultToNamedAction : namedToDefaultAction;
                    return [{ name: refactorName, description: action.description, actions: [action] }];
                }
                if (context.preferences.provideRefactorNotApplicableReason) {
                    return [
                        { name: refactorName, description: ts.Diagnostics.Convert_default_export_to_named_export.message, actions: [
                                __assign(__assign({}, defaultToNamedAction), { notApplicableReason: info.error }),
                                __assign(__assign({}, namedToDefaultAction), { notApplicableReason: info.error }),
                            ] }
                    ];
                }
                return ts.emptyArray;
            },
            getEditsForAction: function (context, actionName) {
                ts.Debug.assert(actionName === defaultToNamedAction.name || actionName === namedToDefaultAction.name, "Unexpected action name");
                var info = getInfo(context);
                ts.Debug.assert(info && !refactor.isRefactorErrorInfo(info), "Expected applicable refactor info");
                var edits = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(context.file, context.program, info, t, context.cancellationToken); });
                return { edits: edits, renameFilename: undefined, renameLocation: undefined };
            },
        });
        ;
        function getInfo(context, considerPartialSpans) {
            if (considerPartialSpans === void 0) { considerPartialSpans = true; }
            var file = context.file, program = context.program;
            var span = ts.getRefactorContextSpan(context);
            var token = ts.getTokenAtPosition(file, span.start);
            var exportNode = !!(token.parent && ts.getSyntacticModifierFlags(token.parent) & 1 /* Export */) && considerPartialSpans ? token.parent : ts.getParentNodeInSpan(token, file, span);
            if (!exportNode || (!ts.isSourceFile(exportNode.parent) && !(ts.isModuleBlock(exportNode.parent) && ts.isAmbientModule(exportNode.parent.parent)))) {
                return { error: ts.getLocaleSpecificMessage(ts.Diagnostics.Could_not_find_export_statement) };
            }
            var exportingModuleSymbol = ts.isSourceFile(exportNode.parent) ? exportNode.parent.symbol : exportNode.parent.parent.symbol;
            var flags = ts.getSyntacticModifierFlags(exportNode) || ((ts.isExportAssignment(exportNode) && !exportNode.isExportEquals) ? 513 /* ExportDefault */ : 0 /* None */);
            var wasDefault = !!(flags & 512 /* Default */);
            // If source file already has a default export, don't offer refactor.
            if (!(flags & 1 /* Export */) || !wasDefault && exportingModuleSymbol.exports.has("default" /* Default */)) {
                return { error: ts.getLocaleSpecificMessage(ts.Diagnostics.This_file_already_has_a_default_export) };
            }
            var checker = program.getTypeChecker();
            var noSymbolError = function (id) {
                return (ts.isIdentifier(id) && checker.getSymbolAtLocation(id)) ? undefined
                    : { error: ts.getLocaleSpecificMessage(ts.Diagnostics.Can_only_convert_named_export) };
            };
            switch (exportNode.kind) {
                case 254 /* FunctionDeclaration */:
                case 255 /* ClassDeclaration */:
                case 256 /* InterfaceDeclaration */:
                case 258 /* EnumDeclaration */:
                case 257 /* TypeAliasDeclaration */:
                case 259 /* ModuleDeclaration */: {
                    var node = exportNode;
                    if (!node.name)
                        return undefined;
                    return noSymbolError(node.name)
                        || { exportNode: node, exportName: node.name, wasDefault: wasDefault, exportingModuleSymbol: exportingModuleSymbol };
                }
                case 235 /* VariableStatement */: {
                    var vs = exportNode;
                    // Must be `export const x = something;`.
                    if (!(vs.declarationList.flags & 2 /* Const */) || vs.declarationList.declarations.length !== 1) {
                        return undefined;
                    }
                    var decl = ts.first(vs.declarationList.declarations);
                    if (!decl.initializer)
                        return undefined;
                    ts.Debug.assert(!wasDefault, "Can't have a default flag here");
                    return noSymbolError(decl.name)
                        || { exportNode: vs, exportName: decl.name, wasDefault: wasDefault, exportingModuleSymbol: exportingModuleSymbol };
                }
                case 269 /* ExportAssignment */: {
                    var node = exportNode;
                    if (node.isExportEquals)
                        return undefined;
                    return noSymbolError(node.expression)
                        || { exportNode: node, exportName: node.expression, wasDefault: wasDefault, exportingModuleSymbol: exportingModuleSymbol };
                }
                default:
                    return undefined;
            }
        }
        function doChange(exportingSourceFile, program, info, changes, cancellationToken) {
            changeExport(exportingSourceFile, info, changes, program.getTypeChecker());
            changeImports(program, info, changes, cancellationToken);
        }
        function changeExport(exportingSourceFile, _a, changes, checker) {
            var wasDefault = _a.wasDefault, exportNode = _a.exportNode, exportName = _a.exportName;
            if (wasDefault) {
                if (ts.isExportAssignment(exportNode) && !exportNode.isExportEquals) {
                    var exp = exportNode.expression;
                    var spec = makeExportSpecifier(exp.text, exp.text);
                    changes.replaceNode(exportingSourceFile, exportNode, ts.factory.createExportDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*isTypeOnly*/ false, ts.factory.createNamedExports([spec])));
                }
                else {
                    changes.delete(exportingSourceFile, ts.Debug.checkDefined(ts.findModifier(exportNode, 88 /* DefaultKeyword */), "Should find a default keyword in modifier list"));
                }
            }
            else {
                var exportKeyword = ts.Debug.checkDefined(ts.findModifier(exportNode, 93 /* ExportKeyword */), "Should find an export keyword in modifier list");
                switch (exportNode.kind) {
                    case 254 /* FunctionDeclaration */:
                    case 255 /* ClassDeclaration */:
                    case 256 /* InterfaceDeclaration */:
                        changes.insertNodeAfter(exportingSourceFile, exportKeyword, ts.factory.createToken(88 /* DefaultKeyword */));
                        break;
                    case 235 /* VariableStatement */:
                        // If 'x' isn't used in this file and doesn't have type definition, `export const x = 0;` --> `export default 0;`
                        var decl = ts.first(exportNode.declarationList.declarations);
                        if (!ts.FindAllReferences.Core.isSymbolReferencedInFile(exportName, checker, exportingSourceFile) && !decl.type) {
                            // We checked in `getInfo` that an initializer exists.
                            changes.replaceNode(exportingSourceFile, exportNode, ts.factory.createExportDefault(ts.Debug.checkDefined(decl.initializer, "Initializer was previously known to be present")));
                            break;
                        }
                    // falls through
                    case 258 /* EnumDeclaration */:
                    case 257 /* TypeAliasDeclaration */:
                    case 259 /* ModuleDeclaration */:
                        // `export type T = number;` -> `type T = number; export default T;`
                        changes.deleteModifier(exportingSourceFile, exportKeyword);
                        changes.insertNodeAfter(exportingSourceFile, exportNode, ts.factory.createExportDefault(ts.factory.createIdentifier(exportName.text)));
                        break;
                    default:
                        ts.Debug.fail("Unexpected exportNode kind " + exportNode.kind);
                }
            }
        }
        function changeImports(program, _a, changes, cancellationToken) {
            var wasDefault = _a.wasDefault, exportName = _a.exportName, exportingModuleSymbol = _a.exportingModuleSymbol;
            var checker = program.getTypeChecker();
            var exportSymbol = ts.Debug.checkDefined(checker.getSymbolAtLocation(exportName), "Export name should resolve to a symbol");
            ts.FindAllReferences.Core.eachExportReference(program.getSourceFiles(), checker, cancellationToken, exportSymbol, exportingModuleSymbol, exportName.text, wasDefault, function (ref) {
                var importingSourceFile = ref.getSourceFile();
                if (wasDefault) {
                    changeDefaultToNamedImport(importingSourceFile, ref, changes, exportName.text);
                }
                else {
                    changeNamedToDefaultImport(importingSourceFile, ref, changes);
                }
            });
        }
        function changeDefaultToNamedImport(importingSourceFile, ref, changes, exportName) {
            var parent = ref.parent;
            switch (parent.kind) {
                case 204 /* PropertyAccessExpression */:
                    // `a.default` --> `a.foo`
                    changes.replaceNode(importingSourceFile, ref, ts.factory.createIdentifier(exportName));
                    break;
                case 268 /* ImportSpecifier */:
                case 273 /* ExportSpecifier */: {
                    var spec = parent;
                    // `default as foo` --> `foo`, `default as bar` --> `foo as bar`
                    changes.replaceNode(importingSourceFile, spec, makeImportSpecifier(exportName, spec.name.text));
                    break;
                }
                case 265 /* ImportClause */: {
                    var clause = parent;
                    ts.Debug.assert(clause.name === ref, "Import clause name should match provided ref");
                    var spec = makeImportSpecifier(exportName, ref.text);
                    var namedBindings = clause.namedBindings;
                    if (!namedBindings) {
                        // `import foo from "./a";` --> `import { foo } from "./a";`
                        changes.replaceNode(importingSourceFile, ref, ts.factory.createNamedImports([spec]));
                    }
                    else if (namedBindings.kind === 266 /* NamespaceImport */) {
                        // `import foo, * as a from "./a";` --> `import * as a from ".a/"; import { foo } from "./a";`
                        changes.deleteRange(importingSourceFile, { pos: ref.getStart(importingSourceFile), end: namedBindings.getStart(importingSourceFile) });
                        var quotePreference = ts.isStringLiteral(clause.parent.moduleSpecifier) ? ts.quotePreferenceFromString(clause.parent.moduleSpecifier, importingSourceFile) : 1 /* Double */;
                        var newImport = ts.makeImport(/*default*/ undefined, [makeImportSpecifier(exportName, ref.text)], clause.parent.moduleSpecifier, quotePreference);
                        changes.insertNodeAfter(importingSourceFile, clause.parent, newImport);
                    }
                    else {
                        // `import foo, { bar } from "./a"` --> `import { bar, foo } from "./a";`
                        changes.delete(importingSourceFile, ref);
                        changes.insertNodeAtEndOfList(importingSourceFile, namedBindings.elements, spec);
                    }
                    break;
                }
                default:
                    ts.Debug.failBadSyntaxKind(parent);
            }
        }
        function changeNamedToDefaultImport(importingSourceFile, ref, changes) {
            var parent = ref.parent;
            switch (parent.kind) {
                case 204 /* PropertyAccessExpression */:
                    // `a.foo` --> `a.default`
                    changes.replaceNode(importingSourceFile, ref, ts.factory.createIdentifier("default"));
                    break;
                case 268 /* ImportSpecifier */: {
                    // `import { foo } from "./a";` --> `import foo from "./a";`
                    // `import { foo as bar } from "./a";` --> `import bar from "./a";`
                    var defaultImport = ts.factory.createIdentifier(parent.name.text);
                    if (parent.parent.elements.length === 1) {
                        changes.replaceNode(importingSourceFile, parent.parent, defaultImport);
                    }
                    else {
                        changes.delete(importingSourceFile, parent);
                        changes.insertNodeBefore(importingSourceFile, parent.parent, defaultImport);
                    }
                    break;
                }
                case 273 /* ExportSpecifier */: {
                    // `export { foo } from "./a";` --> `export { default as foo } from "./a";`
                    // `export { foo as bar } from "./a";` --> `export { default as bar } from "./a";`
                    // `export { foo as default } from "./a";` --> `export { default } from "./a";`
                    // (Because `export foo from "./a";` isn't valid syntax.)
                    changes.replaceNode(importingSourceFile, parent, makeExportSpecifier("default", parent.name.text));
                    break;
                }
                default:
                    ts.Debug.assertNever(parent, "Unexpected parent kind " + parent.kind);
            }
        }
        function makeImportSpecifier(propertyName, name) {
            return ts.factory.createImportSpecifier(propertyName === name ? undefined : ts.factory.createIdentifier(propertyName), ts.factory.createIdentifier(name));
        }
        function makeExportSpecifier(propertyName, name) {
            return ts.factory.createExportSpecifier(propertyName === name ? undefined : ts.factory.createIdentifier(propertyName), ts.factory.createIdentifier(name));
        }
    })(refactor = ts.refactor || (ts.refactor = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var refactor;
    (function (refactor) {
        var refactorName = "Convert import";
        var namespaceToNamedAction = {
            name: "Convert namespace import to named imports",
            description: ts.Diagnostics.Convert_namespace_import_to_named_imports.message,
            kind: "refactor.rewrite.import.named",
        };
        var namedToNamespaceAction = {
            name: "Convert named imports to namespace import",
            description: ts.Diagnostics.Convert_named_imports_to_namespace_import.message,
            kind: "refactor.rewrite.import.namespace",
        };
        refactor.registerRefactor(refactorName, {
            kinds: [
                namespaceToNamedAction.kind,
                namedToNamespaceAction.kind
            ],
            getAvailableActions: function (context) {
                var info = getImportToConvert(context, context.triggerReason === "invoked");
                if (!info)
                    return ts.emptyArray;
                if (!refactor.isRefactorErrorInfo(info)) {
                    var namespaceImport = info.kind === 266 /* NamespaceImport */;
                    var action = namespaceImport ? namespaceToNamedAction : namedToNamespaceAction;
                    return [{ name: refactorName, description: action.description, actions: [action] }];
                }
                if (context.preferences.provideRefactorNotApplicableReason) {
                    return [
                        { name: refactorName, description: namespaceToNamedAction.description,
                            actions: [__assign(__assign({}, namespaceToNamedAction), { notApplicableReason: info.error })] },
                        { name: refactorName, description: namedToNamespaceAction.description,
                            actions: [__assign(__assign({}, namedToNamespaceAction), { notApplicableReason: info.error })] }
                    ];
                }
                return ts.emptyArray;
            },
            getEditsForAction: function (context, actionName) {
                ts.Debug.assert(actionName === namespaceToNamedAction.name || actionName === namedToNamespaceAction.name, "Unexpected action name");
                var info = getImportToConvert(context);
                ts.Debug.assert(info && !refactor.isRefactorErrorInfo(info), "Expected applicable refactor info");
                var edits = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(context.file, context.program, t, info); });
                return { edits: edits, renameFilename: undefined, renameLocation: undefined };
            }
        });
        // Can convert imports of the form `import * as m from "m";` or `import d, { x, y } from "m";`.
        function getImportToConvert(context, considerPartialSpans) {
            if (considerPartialSpans === void 0) { considerPartialSpans = true; }
            var file = context.file;
            var span = ts.getRefactorContextSpan(context);
            var token = ts.getTokenAtPosition(file, span.start);
            var importDecl = considerPartialSpans ? ts.findAncestor(token, ts.isImportDeclaration) : ts.getParentNodeInSpan(token, file, span);
            if (!importDecl || !ts.isImportDeclaration(importDecl))
                return { error: "Selection is not an import declaration." };
            if (importDecl.getEnd() < span.start + span.length)
                return undefined;
            var importClause = importDecl.importClause;
            if (!importClause) {
                return { error: ts.getLocaleSpecificMessage(ts.Diagnostics.Could_not_find_import_clause) };
            }
            if (!importClause.namedBindings) {
                return { error: ts.getLocaleSpecificMessage(ts.Diagnostics.Could_not_find_namespace_import_or_named_imports) };
            }
            return importClause.namedBindings;
        }
        function doChange(sourceFile, program, changes, toConvert) {
            var checker = program.getTypeChecker();
            if (toConvert.kind === 266 /* NamespaceImport */) {
                doChangeNamespaceToNamed(sourceFile, checker, changes, toConvert, ts.getAllowSyntheticDefaultImports(program.getCompilerOptions()));
            }
            else {
                doChangeNamedToNamespace(sourceFile, checker, changes, toConvert);
            }
        }
        function doChangeNamespaceToNamed(sourceFile, checker, changes, toConvert, allowSyntheticDefaultImports) {
            var usedAsNamespaceOrDefault = false;
            var nodesToReplace = [];
            var conflictingNames = new ts.Map();
            ts.FindAllReferences.Core.eachSymbolReferenceInFile(toConvert.name, checker, sourceFile, function (id) {
                if (!ts.isPropertyAccessOrQualifiedName(id.parent)) {
                    usedAsNamespaceOrDefault = true;
                }
                else {
                    var exportName = getRightOfPropertyAccessOrQualifiedName(id.parent).text;
                    if (checker.resolveName(exportName, id, 67108863 /* All */, /*excludeGlobals*/ true)) {
                        conflictingNames.set(exportName, true);
                    }
                    ts.Debug.assert(getLeftOfPropertyAccessOrQualifiedName(id.parent) === id, "Parent expression should match id");
                    nodesToReplace.push(id.parent);
                }
            });
            // We may need to change `mod.x` to `_x` to avoid a name conflict.
            var exportNameToImportName = new ts.Map();
            for (var _i = 0, nodesToReplace_1 = nodesToReplace; _i < nodesToReplace_1.length; _i++) {
                var propertyAccessOrQualifiedName = nodesToReplace_1[_i];
                var exportName = getRightOfPropertyAccessOrQualifiedName(propertyAccessOrQualifiedName).text;
                var importName = exportNameToImportName.get(exportName);
                if (importName === undefined) {
                    exportNameToImportName.set(exportName, importName = conflictingNames.has(exportName) ? ts.getUniqueName(exportName, sourceFile) : exportName);
                }
                changes.replaceNode(sourceFile, propertyAccessOrQualifiedName, ts.factory.createIdentifier(importName));
            }
            var importSpecifiers = [];
            exportNameToImportName.forEach(function (name, propertyName) {
                importSpecifiers.push(ts.factory.createImportSpecifier(name === propertyName ? undefined : ts.factory.createIdentifier(propertyName), ts.factory.createIdentifier(name)));
            });
            var importDecl = toConvert.parent.parent;
            if (usedAsNamespaceOrDefault && !allowSyntheticDefaultImports) {
                // Need to leave the namespace import alone
                changes.insertNodeAfter(sourceFile, importDecl, updateImport(importDecl, /*defaultImportName*/ undefined, importSpecifiers));
            }
            else {
                changes.replaceNode(sourceFile, importDecl, updateImport(importDecl, usedAsNamespaceOrDefault ? ts.factory.createIdentifier(toConvert.name.text) : undefined, importSpecifiers));
            }
        }
        function getRightOfPropertyAccessOrQualifiedName(propertyAccessOrQualifiedName) {
            return ts.isPropertyAccessExpression(propertyAccessOrQualifiedName) ? propertyAccessOrQualifiedName.name : propertyAccessOrQualifiedName.right;
        }
        function getLeftOfPropertyAccessOrQualifiedName(propertyAccessOrQualifiedName) {
            return ts.isPropertyAccessExpression(propertyAccessOrQualifiedName) ? propertyAccessOrQualifiedName.expression : propertyAccessOrQualifiedName.left;
        }
        function doChangeNamedToNamespace(sourceFile, checker, changes, toConvert) {
            var importDecl = toConvert.parent.parent;
            var moduleSpecifier = importDecl.moduleSpecifier;
            var toConvertSymbols = new ts.Set();
            toConvert.elements.forEach(function (namedImport) {
                var symbol = checker.getSymbolAtLocation(namedImport.name);
                if (symbol) {
                    toConvertSymbols.add(symbol);
                }
            });
            var preferredName = moduleSpecifier && ts.isStringLiteral(moduleSpecifier) ? ts.codefix.moduleSpecifierToValidIdentifier(moduleSpecifier.text, 99 /* ESNext */) : "module";
            function hasNamespaceNameConflict(namedImport) {
                // We need to check if the preferred namespace name (`preferredName`) we'd like to use in the refactored code will present a name conflict.
                // A name conflict means that, in a scope where we would like to use the preferred namespace name, there already exists a symbol with that name in that scope.
                // We are going to use the namespace name in the scopes the named imports being refactored are referenced,
                // so we look for conflicts by looking at every reference to those named imports.
                return !!ts.FindAllReferences.Core.eachSymbolReferenceInFile(namedImport.name, checker, sourceFile, function (id) {
                    var symbol = checker.resolveName(preferredName, id, 67108863 /* All */, /*excludeGlobals*/ true);
                    if (symbol) { // There already is a symbol with the same name as the preferred namespace name.
                        if (toConvertSymbols.has(symbol)) { // `preferredName` resolves to a symbol for one of the named import references we are going to transform into namespace import references...
                            return ts.isExportSpecifier(id.parent); // ...but if this reference is an export specifier, it will not be transformed, so it is a conflict; otherwise, it will be renamed and is not a conflict.
                        }
                        return true; // `preferredName` resolves to any other symbol, which will be present in the refactored code and so poses a name conflict.
                    }
                    return false; // There is no symbol with the same name as the preferred namespace name, so no conflict.
                });
            }
            var namespaceNameConflicts = toConvert.elements.some(hasNamespaceNameConflict);
            var namespaceImportName = namespaceNameConflicts ? ts.getUniqueName(preferredName, sourceFile) : preferredName;
            // Imports that need to be kept as named imports in the refactored code, to avoid changing the semantics.
            // More specifically, those are named imports that appear in named exports in the original code, e.g. `a` in `import { a } from "m"; export { a }`.
            var neededNamedImports = new ts.Set();
            var _loop_16 = function (element) {
                var propertyName = (element.propertyName || element.name).text;
                ts.FindAllReferences.Core.eachSymbolReferenceInFile(element.name, checker, sourceFile, function (id) {
                    var access = ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(namespaceImportName), propertyName);
                    if (ts.isShorthandPropertyAssignment(id.parent)) {
                        changes.replaceNode(sourceFile, id.parent, ts.factory.createPropertyAssignment(id.text, access));
                    }
                    else if (ts.isExportSpecifier(id.parent)) {
                        neededNamedImports.add(element);
                    }
                    else {
                        changes.replaceNode(sourceFile, id, access);
                    }
                });
            };
            for (var _i = 0, _a = toConvert.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                _loop_16(element);
            }
            changes.replaceNode(sourceFile, toConvert, ts.factory.createNamespaceImport(ts.factory.createIdentifier(namespaceImportName)));
            if (neededNamedImports.size) {
                var newNamedImports = ts.arrayFrom(neededNamedImports.values()).map(function (element) {
                    return ts.factory.createImportSpecifier(element.propertyName && ts.factory.createIdentifier(element.propertyName.text), ts.factory.createIdentifier(element.name.text));
                });
                changes.insertNodeAfter(sourceFile, toConvert.parent.parent, updateImport(importDecl, /*defaultImportName*/ undefined, newNamedImports));
            }
        }
        function updateImport(old, defaultImportName, elements) {
            return ts.factory.createImportDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, ts.factory.createImportClause(/*isTypeOnly*/ false, defaultImportName, elements && elements.length ? ts.factory.createNamedImports(elements) : undefined), old.moduleSpecifier);
        }
    })(refactor = ts.refactor || (ts.refactor = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var refactor;
    (function (refactor) {
        var convertToOptionalChainExpression;
        (function (convertToOptionalChainExpression) {
            var refactorName = "Convert to optional chain expression";
            var convertToOptionalChainExpressionMessage = ts.getLocaleSpecificMessage(ts.Diagnostics.Convert_to_optional_chain_expression);
            var toOptionalChainAction = {
                name: refactorName,
                description: convertToOptionalChainExpressionMessage,
                kind: "refactor.rewrite.expression.optionalChain",
            };
            refactor.registerRefactor(refactorName, {
                kinds: [toOptionalChainAction.kind],
                getAvailableActions: getAvailableActions,
                getEditsForAction: getEditsForAction
            });
            function getAvailableActions(context) {
                var info = getInfo(context, context.triggerReason === "invoked");
                if (!info)
                    return ts.emptyArray;
                if (!refactor.isRefactorErrorInfo(info)) {
                    return [{
                            name: refactorName,
                            description: convertToOptionalChainExpressionMessage,
                            actions: [toOptionalChainAction],
                        }];
                }
                if (context.preferences.provideRefactorNotApplicableReason) {
                    return [{
                            name: refactorName,
                            description: convertToOptionalChainExpressionMessage,
                            actions: [__assign(__assign({}, toOptionalChainAction), { notApplicableReason: info.error })],
                        }];
                }
                return ts.emptyArray;
            }
            function getEditsForAction(context, actionName) {
                var info = getInfo(context);
                ts.Debug.assert(info && !refactor.isRefactorErrorInfo(info), "Expected applicable refactor info");
                var edits = ts.textChanges.ChangeTracker.with(context, function (t) {
                    return doChange(context.file, context.program.getTypeChecker(), t, info, actionName);
                });
                return { edits: edits, renameFilename: undefined, renameLocation: undefined };
            }
            ;
            function isValidExpression(node) {
                return ts.isBinaryExpression(node) || ts.isConditionalExpression(node);
            }
            function isValidStatement(node) {
                return ts.isExpressionStatement(node) || ts.isReturnStatement(node) || ts.isVariableStatement(node);
            }
            function isValidExpressionOrStatement(node) {
                return isValidExpression(node) || isValidStatement(node);
            }
            function getInfo(context, considerEmptySpans) {
                if (considerEmptySpans === void 0) { considerEmptySpans = true; }
                var file = context.file, program = context.program;
                var span = ts.getRefactorContextSpan(context);
                var forEmptySpan = span.length === 0;
                if (forEmptySpan && !considerEmptySpans)
                    return undefined;
                // selecting fo[|o && foo.ba|]r should be valid, so adjust span to fit start and end tokens
                var startToken = ts.getTokenAtPosition(file, span.start);
                var endToken = ts.findTokenOnLeftOfPosition(file, span.start + span.length);
                var adjustedSpan = ts.createTextSpanFromBounds(startToken.pos, endToken && endToken.end >= startToken.pos ? endToken.getEnd() : startToken.getEnd());
                var parent = forEmptySpan ? getValidParentNodeOfEmptySpan(startToken) : getValidParentNodeContainingSpan(startToken, adjustedSpan);
                var expression = parent && isValidExpressionOrStatement(parent) ? getExpression(parent) : undefined;
                if (!expression)
                    return { error: ts.getLocaleSpecificMessage(ts.Diagnostics.Could_not_find_convertible_access_expression) };
                var checker = program.getTypeChecker();
                return ts.isConditionalExpression(expression) ? getConditionalInfo(expression, checker) : getBinaryInfo(expression);
            }
            function getConditionalInfo(expression, checker) {
                var condition = expression.condition;
                var finalExpression = getFinalExpressionInChain(expression.whenTrue);
                if (!finalExpression || checker.isNullableType(checker.getTypeAtLocation(finalExpression))) {
                    return { error: ts.getLocaleSpecificMessage(ts.Diagnostics.Could_not_find_convertible_access_expression) };
                }
                if ((ts.isPropertyAccessExpression(condition) || ts.isIdentifier(condition))
                    && getMatchingStart(condition, finalExpression.expression)) {
                    return { finalExpression: finalExpression, occurrences: [condition], expression: expression };
                }
                else if (ts.isBinaryExpression(condition)) {
                    var occurrences = getOccurrencesInExpression(finalExpression.expression, condition);
                    return occurrences ? { finalExpression: finalExpression, occurrences: occurrences, expression: expression } :
                        { error: ts.getLocaleSpecificMessage(ts.Diagnostics.Could_not_find_matching_access_expressions) };
                }
            }
            function getBinaryInfo(expression) {
                if (expression.operatorToken.kind !== 55 /* AmpersandAmpersandToken */) {
                    return { error: ts.getLocaleSpecificMessage(ts.Diagnostics.Can_only_convert_logical_AND_access_chains) };
                }
                ;
                var finalExpression = getFinalExpressionInChain(expression.right);
                if (!finalExpression)
                    return { error: ts.getLocaleSpecificMessage(ts.Diagnostics.Could_not_find_convertible_access_expression) };
                var occurrences = getOccurrencesInExpression(finalExpression.expression, expression.left);
                return occurrences ? { finalExpression: finalExpression, occurrences: occurrences, expression: expression } :
                    { error: ts.getLocaleSpecificMessage(ts.Diagnostics.Could_not_find_matching_access_expressions) };
            }
            /**
             * Gets a list of property accesses that appear in matchTo and occur in sequence in expression.
             */
            function getOccurrencesInExpression(matchTo, expression) {
                var occurrences = [];
                while (ts.isBinaryExpression(expression) && expression.operatorToken.kind === 55 /* AmpersandAmpersandToken */) {
                    var match = getMatchingStart(ts.skipParentheses(matchTo), ts.skipParentheses(expression.right));
                    if (!match) {
                        break;
                    }
                    occurrences.push(match);
                    matchTo = match;
                    expression = expression.left;
                }
                var finalMatch = getMatchingStart(matchTo, expression);
                if (finalMatch) {
                    occurrences.push(finalMatch);
                }
                return occurrences.length > 0 ? occurrences : undefined;
            }
            /**
             * Returns subchain if chain begins with subchain syntactically.
             */
            function getMatchingStart(chain, subchain) {
                if (!ts.isIdentifier(subchain) && !ts.isPropertyAccessExpression(subchain) && !ts.isElementAccessExpression(subchain)) {
                    return undefined;
                }
                return chainStartsWith(chain, subchain) ? subchain : undefined;
            }
            /**
             * Returns true if chain begins with subchain syntactically.
             */
            function chainStartsWith(chain, subchain) {
                // skip until we find a matching identifier.
                while (ts.isCallExpression(chain) || ts.isPropertyAccessExpression(chain) || ts.isElementAccessExpression(chain)) {
                    if (getTextOfChainNode(chain) === getTextOfChainNode(subchain))
                        break;
                    chain = chain.expression;
                }
                // check that the chains match at each access. Call chains in subchain are not valid.
                while ((ts.isPropertyAccessExpression(chain) && ts.isPropertyAccessExpression(subchain)) ||
                    (ts.isElementAccessExpression(chain) && ts.isElementAccessExpression(subchain))) {
                    if (getTextOfChainNode(chain) !== getTextOfChainNode(subchain))
                        return false;
                    chain = chain.expression;
                    subchain = subchain.expression;
                }
                // check if we have reached a final identifier.
                return ts.isIdentifier(chain) && ts.isIdentifier(subchain) && chain.getText() === subchain.getText();
            }
            function getTextOfChainNode(node) {
                if (ts.isIdentifier(node) || ts.isStringOrNumericLiteralLike(node)) {
                    return node.getText();
                }
                if (ts.isPropertyAccessExpression(node)) {
                    return getTextOfChainNode(node.name);
                }
                if (ts.isElementAccessExpression(node)) {
                    return getTextOfChainNode(node.argumentExpression);
                }
                return undefined;
            }
            /**
             * Find the least ancestor of the input node that is a valid type for extraction and contains the input span.
             */
            function getValidParentNodeContainingSpan(node, span) {
                while (node.parent) {
                    if (isValidExpressionOrStatement(node) && span.length !== 0 && node.end >= span.start + span.length) {
                        return node;
                    }
                    node = node.parent;
                }
                return undefined;
            }
            /**
             * Finds an ancestor of the input node that is a valid type for extraction, skipping subexpressions.
             */
            function getValidParentNodeOfEmptySpan(node) {
                while (node.parent) {
                    if (isValidExpressionOrStatement(node) && !isValidExpressionOrStatement(node.parent)) {
                        return node;
                    }
                    node = node.parent;
                }
                return undefined;
            }
            /**
             * Gets an expression of valid extraction type from a valid statement or expression.
             */
            function getExpression(node) {
                if (isValidExpression(node)) {
                    return node;
                }
                if (ts.isVariableStatement(node)) {
                    var variable = ts.getSingleVariableOfVariableStatement(node);
                    var initializer = variable === null || variable === void 0 ? void 0 : variable.initializer;
                    return initializer && isValidExpression(initializer) ? initializer : undefined;
                }
                return node.expression && isValidExpression(node.expression) ? node.expression : undefined;
            }
            /**
             * Gets a property access expression which may be nested inside of a binary expression. The final
             * expression in an && chain will occur as the right child of the parent binary expression, unless
             * it is followed by a different binary operator.
             * @param node the right child of a binary expression or a call expression.
             */
            function getFinalExpressionInChain(node) {
                // foo && |foo.bar === 1|; - here the right child of the && binary expression is another binary expression.
                // the rightmost member of the && chain should be the leftmost child of that expression.
                node = ts.skipParentheses(node);
                if (ts.isBinaryExpression(node)) {
                    return getFinalExpressionInChain(node.left);
                }
                // foo && |foo.bar()()| - nested calls are treated like further accesses.
                else if ((ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node) || ts.isCallExpression(node)) && !ts.isOptionalChain(node)) {
                    return node;
                }
                return undefined;
            }
            /**
             * Creates an access chain from toConvert with '?.' accesses at expressions appearing in occurrences.
             */
            function convertOccurrences(checker, toConvert, occurrences) {
                if (ts.isPropertyAccessExpression(toConvert) || ts.isElementAccessExpression(toConvert) || ts.isCallExpression(toConvert)) {
                    var chain = convertOccurrences(checker, toConvert.expression, occurrences);
                    var lastOccurrence = occurrences.length > 0 ? occurrences[occurrences.length - 1] : undefined;
                    var isOccurrence = (lastOccurrence === null || lastOccurrence === void 0 ? void 0 : lastOccurrence.getText()) === toConvert.expression.getText();
                    if (isOccurrence)
                        occurrences.pop();
                    if (ts.isCallExpression(toConvert)) {
                        return isOccurrence ?
                            ts.factory.createCallChain(chain, ts.factory.createToken(28 /* QuestionDotToken */), toConvert.typeArguments, toConvert.arguments) :
                            ts.factory.createCallChain(chain, toConvert.questionDotToken, toConvert.typeArguments, toConvert.arguments);
                    }
                    else if (ts.isPropertyAccessExpression(toConvert)) {
                        return isOccurrence ?
                            ts.factory.createPropertyAccessChain(chain, ts.factory.createToken(28 /* QuestionDotToken */), toConvert.name) :
                            ts.factory.createPropertyAccessChain(chain, toConvert.questionDotToken, toConvert.name);
                    }
                    else if (ts.isElementAccessExpression(toConvert)) {
                        return isOccurrence ?
                            ts.factory.createElementAccessChain(chain, ts.factory.createToken(28 /* QuestionDotToken */), toConvert.argumentExpression) :
                            ts.factory.createElementAccessChain(chain, toConvert.questionDotToken, toConvert.argumentExpression);
                    }
                }
                return toConvert;
            }
            function doChange(sourceFile, checker, changes, info, _actionName) {
                var finalExpression = info.finalExpression, occurrences = info.occurrences, expression = info.expression;
                var firstOccurrence = occurrences[occurrences.length - 1];
                var convertedChain = convertOccurrences(checker, finalExpression, occurrences);
                if (convertedChain && (ts.isPropertyAccessExpression(convertedChain) || ts.isElementAccessExpression(convertedChain) || ts.isCallExpression(convertedChain))) {
                    if (ts.isBinaryExpression(expression)) {
                        changes.replaceNodeRange(sourceFile, firstOccurrence, finalExpression, convertedChain);
                    }
                    else if (ts.isConditionalExpression(expression)) {
                        changes.replaceNode(sourceFile, expression, ts.factory.createBinaryExpression(convertedChain, ts.factory.createToken(60 /* QuestionQuestionToken */), expression.whenFalse));
                    }
                }
            }
        })(convertToOptionalChainExpression = refactor.convertToOptionalChainExpression || (refactor.convertToOptionalChainExpression = {}));
    })(refactor = ts.refactor || (ts.refactor = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var refactor;
    (function (refactor) {
        var addOrRemoveBracesToArrowFunction;
        (function (addOrRemoveBracesToArrowFunction) {
            var refactorName = "Convert overload list to single signature";
            var refactorDescription = ts.Diagnostics.Convert_overload_list_to_single_signature.message;
            var functionOverloadAction = {
                name: refactorName,
                description: refactorDescription,
                kind: "refactor.rewrite.function.overloadList",
            };
            refactor.registerRefactor(refactorName, {
                kinds: [functionOverloadAction.kind],
                getEditsForAction: getEditsForAction,
                getAvailableActions: getAvailableActions
            });
            function getAvailableActions(context) {
                var file = context.file, startPosition = context.startPosition, program = context.program;
                var info = getConvertableOverloadListAtPosition(file, startPosition, program);
                if (!info)
                    return ts.emptyArray;
                return [{
                        name: refactorName,
                        description: refactorDescription,
                        actions: [functionOverloadAction]
                    }];
            }
            function getEditsForAction(context) {
                var file = context.file, startPosition = context.startPosition, program = context.program;
                var signatureDecls = getConvertableOverloadListAtPosition(file, startPosition, program);
                if (!signatureDecls)
                    return undefined;
                var checker = program.getTypeChecker();
                var lastDeclaration = signatureDecls[signatureDecls.length - 1];
                var updated = lastDeclaration;
                switch (lastDeclaration.kind) {
                    case 166 /* MethodSignature */: {
                        updated = ts.factory.updateMethodSignature(lastDeclaration, lastDeclaration.modifiers, lastDeclaration.name, lastDeclaration.questionToken, lastDeclaration.typeParameters, getNewParametersForCombinedSignature(signatureDecls), lastDeclaration.type);
                        break;
                    }
                    case 167 /* MethodDeclaration */: {
                        updated = ts.factory.updateMethodDeclaration(lastDeclaration, lastDeclaration.decorators, lastDeclaration.modifiers, lastDeclaration.asteriskToken, lastDeclaration.name, lastDeclaration.questionToken, lastDeclaration.typeParameters, getNewParametersForCombinedSignature(signatureDecls), lastDeclaration.type, lastDeclaration.body);
                        break;
                    }
                    case 172 /* CallSignature */: {
                        updated = ts.factory.updateCallSignature(lastDeclaration, lastDeclaration.typeParameters, getNewParametersForCombinedSignature(signatureDecls), lastDeclaration.type);
                        break;
                    }
                    case 169 /* Constructor */: {
                        updated = ts.factory.updateConstructorDeclaration(lastDeclaration, lastDeclaration.decorators, lastDeclaration.modifiers, getNewParametersForCombinedSignature(signatureDecls), lastDeclaration.body);
                        break;
                    }
                    case 173 /* ConstructSignature */: {
                        updated = ts.factory.updateConstructSignature(lastDeclaration, lastDeclaration.typeParameters, getNewParametersForCombinedSignature(signatureDecls), lastDeclaration.type);
                        break;
                    }
                    case 254 /* FunctionDeclaration */: {
                        updated = ts.factory.updateFunctionDeclaration(lastDeclaration, lastDeclaration.decorators, lastDeclaration.modifiers, lastDeclaration.asteriskToken, lastDeclaration.name, lastDeclaration.typeParameters, getNewParametersForCombinedSignature(signatureDecls), lastDeclaration.type, lastDeclaration.body);
                        break;
                    }
                    default: return ts.Debug.failBadSyntaxKind(lastDeclaration, "Unhandled signature kind in overload list conversion refactoring");
                }
                if (updated === lastDeclaration) {
                    return; // No edits to apply, do nothing
                }
                var edits = ts.textChanges.ChangeTracker.with(context, function (t) {
                    t.replaceNodeRange(file, signatureDecls[0], signatureDecls[signatureDecls.length - 1], updated);
                });
                return { renameFilename: undefined, renameLocation: undefined, edits: edits };
                function getNewParametersForCombinedSignature(signatureDeclarations) {
                    var lastSig = signatureDeclarations[signatureDeclarations.length - 1];
                    if (ts.isFunctionLikeDeclaration(lastSig) && lastSig.body) {
                        // Trim away implementation signature arguments (they should already be compatible with overloads, but are likely less precise to guarantee compatability with the overloads)
                        signatureDeclarations = signatureDeclarations.slice(0, signatureDeclarations.length - 1);
                    }
                    return ts.factory.createNodeArray([
                        ts.factory.createParameterDeclaration(
                        /*decorators*/ undefined, 
                        /*modifiers*/ undefined, ts.factory.createToken(25 /* DotDotDotToken */), "args", 
                        /*questionToken*/ undefined, ts.factory.createUnionTypeNode(ts.map(signatureDeclarations, convertSignatureParametersToTuple)))
                    ]);
                }
                function convertSignatureParametersToTuple(decl) {
                    var members = ts.map(decl.parameters, convertParameterToNamedTupleMember);
                    return ts.setEmitFlags(ts.factory.createTupleTypeNode(members), ts.some(members, function (m) { return !!ts.length(ts.getSyntheticLeadingComments(m)); }) ? 0 /* None */ : 1 /* SingleLine */);
                }
                function convertParameterToNamedTupleMember(p) {
                    ts.Debug.assert(ts.isIdentifier(p.name)); // This is checked during refactoring applicability checking
                    var result = ts.setTextRange(ts.factory.createNamedTupleMember(p.dotDotDotToken, p.name, p.questionToken, p.type || ts.factory.createKeywordTypeNode(129 /* AnyKeyword */)), p);
                    var parameterDocComment = p.symbol && p.symbol.getDocumentationComment(checker);
                    if (parameterDocComment) {
                        var newComment = ts.displayPartsToString(parameterDocComment);
                        if (newComment.length) {
                            ts.setSyntheticLeadingComments(result, [{
                                    text: "*\n" + newComment.split("\n").map(function (c) { return " * " + c; }).join("\n") + "\n ",
                                    kind: 3 /* MultiLineCommentTrivia */,
                                    pos: -1,
                                    end: -1,
                                    hasTrailingNewLine: true,
                                    hasLeadingNewline: true,
                                }]);
                        }
                    }
                    return result;
                }
            }
            function isConvertableSignatureDeclaration(d) {
                switch (d.kind) {
                    case 166 /* MethodSignature */:
                    case 167 /* MethodDeclaration */:
                    case 172 /* CallSignature */:
                    case 169 /* Constructor */:
                    case 173 /* ConstructSignature */:
                    case 254 /* FunctionDeclaration */:
                        return true;
                }
                return false;
            }
            function getConvertableOverloadListAtPosition(file, startPosition, program) {
                var node = ts.getTokenAtPosition(file, startPosition);
                var containingDecl = ts.findAncestor(node, isConvertableSignatureDeclaration);
                if (!containingDecl) {
                    return;
                }
                var checker = program.getTypeChecker();
                var signatureSymbol = containingDecl.symbol;
                if (!signatureSymbol) {
                    return;
                }
                var decls = signatureSymbol.declarations;
                if (ts.length(decls) <= 1) {
                    return;
                }
                if (!ts.every(decls, function (d) { return ts.getSourceFileOfNode(d) === file; })) {
                    return;
                }
                if (!isConvertableSignatureDeclaration(decls[0])) {
                    return;
                }
                var kindOne = decls[0].kind;
                if (!ts.every(decls, function (d) { return d.kind === kindOne; })) {
                    return;
                }
                var signatureDecls = decls;
                if (ts.some(signatureDecls, function (d) { return !!d.typeParameters || ts.some(d.parameters, function (p) { return !!p.decorators || !!p.modifiers || !ts.isIdentifier(p.name); }); })) {
                    return;
                }
                var signatures = ts.mapDefined(signatureDecls, function (d) { return checker.getSignatureFromDeclaration(d); });
                if (ts.length(signatures) !== ts.length(decls)) {
                    return;
                }
                var returnOne = checker.getReturnTypeOfSignature(signatures[0]);
                if (!ts.every(signatures, function (s) { return checker.getReturnTypeOfSignature(s) === returnOne; })) {
                    return;
                }
                return signatureDecls;
            }
        })(addOrRemoveBracesToArrowFunction = refactor.addOrRemoveBracesToArrowFunction || (refactor.addOrRemoveBracesToArrowFunction = {}));
    })(refactor = ts.refactor || (ts.refactor = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var refactor;
    (function (refactor) {
        var extractSymbol;
        (function (extractSymbol) {
            var refactorName = "Extract Symbol";
            var extractConstantAction = {
                name: "Extract Constant",
                description: ts.getLocaleSpecificMessage(ts.Diagnostics.Extract_constant),
                kind: "refactor.extract.constant",
            };
            var extractFunctionAction = {
                name: "Extract Function",
                description: ts.getLocaleSpecificMessage(ts.Diagnostics.Extract_function),
                kind: "refactor.extract.function",
            };
            refactor.registerRefactor(refactorName, {
                kinds: [
                    extractConstantAction.kind,
                    extractFunctionAction.kind
                ],
                getAvailableActions: getAvailableActions,
                getEditsForAction: getEditsForAction
            });
            /**
             * Compute the associated code actions
             * Exported for tests.
             */
            function getAvailableActions(context) {
                var requestedRefactor = context.kind;
                var rangeToExtract = getRangeToExtract(context.file, ts.getRefactorContextSpan(context), context.triggerReason === "invoked");
                var targetRange = rangeToExtract.targetRange;
                if (targetRange === undefined) {
                    if (!rangeToExtract.errors || rangeToExtract.errors.length === 0 || !context.preferences.provideRefactorNotApplicableReason) {
                        return ts.emptyArray;
                    }
                    var errors = [];
                    if (refactor.refactorKindBeginsWith(extractFunctionAction.kind, requestedRefactor)) {
                        errors.push({
                            name: refactorName,
                            description: extractFunctionAction.description,
                            actions: [__assign(__assign({}, extractFunctionAction), { notApplicableReason: getStringError(rangeToExtract.errors) })]
                        });
                    }
                    if (refactor.refactorKindBeginsWith(extractConstantAction.kind, requestedRefactor)) {
                        errors.push({
                            name: refactorName,
                            description: extractConstantAction.description,
                            actions: [__assign(__assign({}, extractConstantAction), { notApplicableReason: getStringError(rangeToExtract.errors) })]
                        });
                    }
                    return errors;
                }
                var extractions = getPossibleExtractions(targetRange, context);
                if (extractions === undefined) {
                    // No extractions possible
                    return ts.emptyArray;
                }
                var functionActions = [];
                var usedFunctionNames = new ts.Map();
                var innermostErrorFunctionAction;
                var constantActions = [];
                var usedConstantNames = new ts.Map();
                var innermostErrorConstantAction;
                var i = 0;
                for (var _i = 0, extractions_1 = extractions; _i < extractions_1.length; _i++) {
                    var _a = extractions_1[_i], functionExtraction = _a.functionExtraction, constantExtraction = _a.constantExtraction;
                    var description = functionExtraction.description;
                    if (refactor.refactorKindBeginsWith(extractFunctionAction.kind, requestedRefactor)) {
                        if (functionExtraction.errors.length === 0) {
                            // Don't issue refactorings with duplicated names.
                            // Scopes come back in "innermost first" order, so extractions will
                            // preferentially go into nearer scopes
                            if (!usedFunctionNames.has(description)) {
                                usedFunctionNames.set(description, true);
                                functionActions.push({
                                    description: description,
                                    name: "function_scope_" + i,
                                    kind: extractFunctionAction.kind
                                });
                            }
                        }
                        else if (!innermostErrorFunctionAction) {
                            innermostErrorFunctionAction = {
                                description: description,
                                name: "function_scope_" + i,
                                notApplicableReason: getStringError(functionExtraction.errors),
                                kind: extractFunctionAction.kind
                            };
                        }
                    }
                    if (refactor.refactorKindBeginsWith(extractConstantAction.kind, requestedRefactor)) {
                        if (constantExtraction.errors.length === 0) {
                            // Don't issue refactorings with duplicated names.
                            // Scopes come back in "innermost first" order, so extractions will
                            // preferentially go into nearer scopes
                            var description_1 = constantExtraction.description;
                            if (!usedConstantNames.has(description_1)) {
                                usedConstantNames.set(description_1, true);
                                constantActions.push({
                                    description: description_1,
                                    name: "constant_scope_" + i,
                                    kind: extractConstantAction.kind
                                });
                            }
                        }
                        else if (!innermostErrorConstantAction) {
                            innermostErrorConstantAction = {
                                description: description,
                                name: "constant_scope_" + i,
                                notApplicableReason: getStringError(constantExtraction.errors),
                                kind: extractConstantAction.kind
                            };
                        }
                    }
                    // *do* increment i anyway because we'll look for the i-th scope
                    // later when actually doing the refactoring if the user requests it
                    i++;
                }
                var infos = [];
                if (functionActions.length) {
                    infos.push({
                        name: refactorName,
                        description: ts.getLocaleSpecificMessage(ts.Diagnostics.Extract_function),
                        actions: functionActions,
                    });
                }
                else if (context.preferences.provideRefactorNotApplicableReason && innermostErrorFunctionAction) {
                    infos.push({
                        name: refactorName,
                        description: ts.getLocaleSpecificMessage(ts.Diagnostics.Extract_function),
                        actions: [innermostErrorFunctionAction]
                    });
                }
                if (constantActions.length) {
                    infos.push({
                        name: refactorName,
                        description: ts.getLocaleSpecificMessage(ts.Diagnostics.Extract_constant),
                        actions: constantActions
                    });
                }
                else if (context.preferences.provideRefactorNotApplicableReason && innermostErrorConstantAction) {
                    infos.push({
                        name: refactorName,
                        description: ts.getLocaleSpecificMessage(ts.Diagnostics.Extract_constant),
                        actions: [innermostErrorConstantAction]
                    });
                }
                return infos.length ? infos : ts.emptyArray;
                function getStringError(errors) {
                    var error = errors[0].messageText;
                    if (typeof error !== "string") {
                        error = error.messageText;
                    }
                    return error;
                }
            }
            extractSymbol.getAvailableActions = getAvailableActions;
            /* Exported for tests */
            function getEditsForAction(context, actionName) {
                var rangeToExtract = getRangeToExtract(context.file, ts.getRefactorContextSpan(context));
                var targetRange = rangeToExtract.targetRange; // TODO:GH#18217
                var parsedFunctionIndexMatch = /^function_scope_(\d+)$/.exec(actionName);
                if (parsedFunctionIndexMatch) {
                    var index = +parsedFunctionIndexMatch[1];
                    ts.Debug.assert(isFinite(index), "Expected to parse a finite number from the function scope index");
                    return getFunctionExtractionAtIndex(targetRange, context, index);
                }
                var parsedConstantIndexMatch = /^constant_scope_(\d+)$/.exec(actionName);
                if (parsedConstantIndexMatch) {
                    var index = +parsedConstantIndexMatch[1];
                    ts.Debug.assert(isFinite(index), "Expected to parse a finite number from the constant scope index");
                    return getConstantExtractionAtIndex(targetRange, context, index);
                }
                ts.Debug.fail("Unrecognized action name");
            }
            extractSymbol.getEditsForAction = getEditsForAction;
            // Move these into diagnostic messages if they become user-facing
            var Messages;
            (function (Messages) {
                function createMessage(message) {
                    return { message: message, code: 0, category: ts.DiagnosticCategory.Message, key: message };
                }
                Messages.cannotExtractRange = createMessage("Cannot extract range.");
                Messages.cannotExtractImport = createMessage("Cannot extract import statement.");
                Messages.cannotExtractSuper = createMessage("Cannot extract super call.");
                Messages.cannotExtractJSDoc = createMessage("Cannot extract JSDoc.");
                Messages.cannotExtractEmpty = createMessage("Cannot extract empty range.");
                Messages.expressionExpected = createMessage("expression expected.");
                Messages.uselessConstantType = createMessage("No reason to extract constant of type.");
                Messages.statementOrExpressionExpected = createMessage("Statement or expression expected.");
                Messages.cannotExtractRangeContainingConditionalBreakOrContinueStatements = createMessage("Cannot extract range containing conditional break or continue statements.");
                Messages.cannotExtractRangeContainingConditionalReturnStatement = createMessage("Cannot extract range containing conditional return statement.");
                Messages.cannotExtractRangeContainingLabeledBreakOrContinueStatementWithTargetOutsideOfTheRange = createMessage("Cannot extract range containing labeled break or continue with target outside of the range.");
                Messages.cannotExtractRangeThatContainsWritesToReferencesLocatedOutsideOfTheTargetRangeInGenerators = createMessage("Cannot extract range containing writes to references located outside of the target range in generators.");
                Messages.typeWillNotBeVisibleInTheNewScope = createMessage("Type will not visible in the new scope.");
                Messages.functionWillNotBeVisibleInTheNewScope = createMessage("Function will not visible in the new scope.");
                Messages.cannotExtractIdentifier = createMessage("Select more than a single identifier.");
                Messages.cannotExtractExportedEntity = createMessage("Cannot extract exported declaration");
                Messages.cannotWriteInExpression = createMessage("Cannot write back side-effects when extracting an expression");
                Messages.cannotExtractReadonlyPropertyInitializerOutsideConstructor = createMessage("Cannot move initialization of read-only class property outside of the constructor");
                Messages.cannotExtractAmbientBlock = createMessage("Cannot extract code from ambient contexts");
                Messages.cannotAccessVariablesFromNestedScopes = createMessage("Cannot access variables from nested scopes");
                Messages.cannotExtractToJSClass = createMessage("Cannot extract constant to a class scope in JS");
                Messages.cannotExtractToExpressionArrowFunction = createMessage("Cannot extract constant to an arrow function without a block");
            })(Messages = extractSymbol.Messages || (extractSymbol.Messages = {}));
            var RangeFacts;
            (function (RangeFacts) {
                RangeFacts[RangeFacts["None"] = 0] = "None";
                RangeFacts[RangeFacts["HasReturn"] = 1] = "HasReturn";
                RangeFacts[RangeFacts["IsGenerator"] = 2] = "IsGenerator";
                RangeFacts[RangeFacts["IsAsyncFunction"] = 4] = "IsAsyncFunction";
                RangeFacts[RangeFacts["UsesThis"] = 8] = "UsesThis";
                /**
                 * The range is in a function which needs the 'static' modifier in a class
                 */
                RangeFacts[RangeFacts["InStaticRegion"] = 16] = "InStaticRegion";
            })(RangeFacts || (RangeFacts = {}));
            /**
             * getRangeToExtract takes a span inside a text file and returns either an expression or an array
             * of statements representing the minimum set of nodes needed to extract the entire span. This
             * process may fail, in which case a set of errors is returned instead. These errors are shown to
             * users if they have the provideRefactorNotApplicableReason option set.
             */
            // exported only for tests
            function getRangeToExtract(sourceFile, span, invoked) {
                if (invoked === void 0) { invoked = true; }
                var length = span.length;
                if (length === 0 && !invoked) {
                    return { errors: [ts.createFileDiagnostic(sourceFile, span.start, length, Messages.cannotExtractEmpty)] };
                }
                var cursorRequest = length === 0 && invoked;
                var startToken = ts.findFirstNonJsxWhitespaceToken(sourceFile, span.start);
                var endToken = ts.findTokenOnLeftOfPosition(sourceFile, ts.textSpanEnd(span));
                /* If the refactoring command is invoked through a keyboard action it's safe to assume that the user is actively looking for
                refactoring actions at the span location. As they may not know the exact range that will trigger a refactoring, we expand the
                searched span to cover a real node range making it more likely that something useful will show up. */
                var adjustedSpan = startToken && endToken && invoked ? getAdjustedSpanFromNodes(startToken, endToken, sourceFile) : span;
                // Walk up starting from the the start position until we find a non-SourceFile node that subsumes the selected span.
                // This may fail (e.g. you select two statements in the root of a source file)
                var start = cursorRequest ? getExtractableParent(startToken) : ts.getParentNodeInSpan(startToken, sourceFile, adjustedSpan);
                // Do the same for the ending position
                var end = cursorRequest ? start : ts.getParentNodeInSpan(endToken, sourceFile, adjustedSpan);
                var declarations = [];
                // We'll modify these flags as we walk the tree to collect data
                // about what things need to be done as part of the extraction.
                var rangeFacts = RangeFacts.None;
                if (!start || !end) {
                    // cannot find either start or end node
                    return { errors: [ts.createFileDiagnostic(sourceFile, span.start, length, Messages.cannotExtractRange)] };
                }
                if (ts.isJSDoc(start)) {
                    return { errors: [ts.createFileDiagnostic(sourceFile, span.start, length, Messages.cannotExtractJSDoc)] };
                }
                if (start.parent !== end.parent) {
                    // start and end nodes belong to different subtrees
                    return { errors: [ts.createFileDiagnostic(sourceFile, span.start, length, Messages.cannotExtractRange)] };
                }
                if (start !== end) {
                    // start and end should be statements and parent should be either block or a source file
                    if (!isBlockLike(start.parent)) {
                        return { errors: [ts.createFileDiagnostic(sourceFile, span.start, length, Messages.cannotExtractRange)] };
                    }
                    var statements = [];
                    var start2 = start; // TODO: GH#18217 Need to alias `start` to get this to compile. See https://github.com/Microsoft/TypeScript/issues/19955#issuecomment-344118248
                    for (var _i = 0, _a = start2.parent.statements; _i < _a.length; _i++) {
                        var statement = _a[_i];
                        if (statement === start || statements.length) {
                            var errors_1 = checkNode(statement);
                            if (errors_1) {
                                return { errors: errors_1 };
                            }
                            statements.push(statement);
                        }
                        if (statement === end) {
                            break;
                        }
                    }
                    if (!statements.length) {
                        // https://github.com/Microsoft/TypeScript/issues/20559
                        // Ranges like [|case 1: break;|] will fail to populate `statements` because
                        // they will never find `start` in `start.parent.statements`.
                        // Consider: We could support ranges like [|case 1:|] by refining them to just
                        // the expression.
                        return { errors: [ts.createFileDiagnostic(sourceFile, span.start, length, Messages.cannotExtractRange)] };
                    }
                    return { targetRange: { range: statements, facts: rangeFacts, declarations: declarations } };
                }
                if (ts.isReturnStatement(start) && !start.expression) {
                    // Makes no sense to extract an expression-less return statement.
                    return { errors: [ts.createFileDiagnostic(sourceFile, span.start, length, Messages.cannotExtractRange)] };
                }
                // We have a single node (start)
                var node = refineNode(start);
                var errors = checkRootNode(node) || checkNode(node);
                if (errors) {
                    return { errors: errors };
                }
                return { targetRange: { range: getStatementOrExpressionRange(node), facts: rangeFacts, declarations: declarations } }; // TODO: GH#18217
                /**
                 * Attempt to refine the extraction node (generally, by shrinking it) to produce better results.
                 * @param node The unrefined extraction node.
                 */
                function refineNode(node) {
                    if (ts.isReturnStatement(node)) {
                        if (node.expression) {
                            return node.expression;
                        }
                    }
                    else if (ts.isVariableStatement(node)) {
                        var numInitializers = 0;
                        var lastInitializer = void 0;
                        for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                            var declaration = _a[_i];
                            if (declaration.initializer) {
                                numInitializers++;
                                lastInitializer = declaration.initializer;
                            }
                        }
                        if (numInitializers === 1) {
                            return lastInitializer;
                        }
                        // No special handling if there are multiple initializers.
                    }
                    else if (ts.isVariableDeclaration(node)) {
                        if (node.initializer) {
                            return node.initializer;
                        }
                    }
                    return node;
                }
                function checkRootNode(node) {
                    if (ts.isIdentifier(ts.isExpressionStatement(node) ? node.expression : node)) {
                        return [ts.createDiagnosticForNode(node, Messages.cannotExtractIdentifier)];
                    }
                    return undefined;
                }
                function checkForStaticContext(nodeToCheck, containingClass) {
                    var current = nodeToCheck;
                    while (current !== containingClass) {
                        if (current.kind === 165 /* PropertyDeclaration */) {
                            if (ts.isStatic(current)) {
                                rangeFacts |= RangeFacts.InStaticRegion;
                            }
                            break;
                        }
                        else if (current.kind === 162 /* Parameter */) {
                            var ctorOrMethod = ts.getContainingFunction(current);
                            if (ctorOrMethod.kind === 169 /* Constructor */) {
                                rangeFacts |= RangeFacts.InStaticRegion;
                            }
                            break;
                        }
                        else if (current.kind === 167 /* MethodDeclaration */) {
                            if (ts.isStatic(current)) {
                                rangeFacts |= RangeFacts.InStaticRegion;
                            }
                        }
                        current = current.parent;
                    }
                }
                // Verifies whether we can actually extract this node or not.
                function checkNode(nodeToCheck) {
                    var PermittedJumps;
                    (function (PermittedJumps) {
                        PermittedJumps[PermittedJumps["None"] = 0] = "None";
                        PermittedJumps[PermittedJumps["Break"] = 1] = "Break";
                        PermittedJumps[PermittedJumps["Continue"] = 2] = "Continue";
                        PermittedJumps[PermittedJumps["Return"] = 4] = "Return";
                    })(PermittedJumps || (PermittedJumps = {}));
                    // We believe it's true because the node is from the (unmodified) tree.
                    ts.Debug.assert(nodeToCheck.pos <= nodeToCheck.end, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809 (1)");
                    // For understanding how skipTrivia functioned:
                    ts.Debug.assert(!ts.positionIsSynthesized(nodeToCheck.pos), "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809 (2)");
                    if (!ts.isStatement(nodeToCheck) && !(ts.isExpressionNode(nodeToCheck) && isExtractableExpression(nodeToCheck))) {
                        return [ts.createDiagnosticForNode(nodeToCheck, Messages.statementOrExpressionExpected)];
                    }
                    if (nodeToCheck.flags & 8388608 /* Ambient */) {
                        return [ts.createDiagnosticForNode(nodeToCheck, Messages.cannotExtractAmbientBlock)];
                    }
                    // If we're in a class, see whether we're in a static region (static property initializer, static method, class constructor parameter default)
                    var containingClass = ts.getContainingClass(nodeToCheck);
                    if (containingClass) {
                        checkForStaticContext(nodeToCheck, containingClass);
                    }
                    var errors;
                    var permittedJumps = 4 /* Return */;
                    var seenLabels;
                    visit(nodeToCheck);
                    return errors;
                    function visit(node) {
                        if (errors) {
                            // already found an error - can stop now
                            return true;
                        }
                        if (ts.isDeclaration(node)) {
                            var declaringNode = (node.kind === 252 /* VariableDeclaration */) ? node.parent.parent : node;
                            if (ts.hasSyntacticModifier(declaringNode, 1 /* Export */)) {
                                // TODO: GH#18217 Silly to use `errors ||` since it's definitely not defined (see top of `visit`)
                                // Also, if we're only pushing one error, just use `let error: Diagnostic | undefined`!
                                // Also TODO: GH#19956
                                (errors || (errors = [])).push(ts.createDiagnosticForNode(node, Messages.cannotExtractExportedEntity));
                                return true;
                            }
                            declarations.push(node.symbol);
                        }
                        // Some things can't be extracted in certain situations
                        switch (node.kind) {
                            case 264 /* ImportDeclaration */:
                                (errors || (errors = [])).push(ts.createDiagnosticForNode(node, Messages.cannotExtractImport));
                                return true;
                            case 269 /* ExportAssignment */:
                                (errors || (errors = [])).push(ts.createDiagnosticForNode(node, Messages.cannotExtractExportedEntity));
                                return true;
                            case 106 /* SuperKeyword */:
                                // For a super *constructor call*, we have to be extracting the entire class,
                                // but a super *method call* simply implies a 'this' reference
                                if (node.parent.kind === 206 /* CallExpression */) {
                                    // Super constructor call
                                    var containingClass_1 = ts.getContainingClass(node); // TODO:GH#18217
                                    if (containingClass_1.pos < span.start || containingClass_1.end >= (span.start + span.length)) {
                                        (errors || (errors = [])).push(ts.createDiagnosticForNode(node, Messages.cannotExtractSuper));
                                        return true;
                                    }
                                }
                                else {
                                    rangeFacts |= RangeFacts.UsesThis;
                                }
                                break;
                            case 212 /* ArrowFunction */:
                                // check if arrow function uses this
                                ts.forEachChild(node, function check(n) {
                                    if (ts.isThis(n)) {
                                        rangeFacts |= RangeFacts.UsesThis;
                                    }
                                    else if (ts.isClassLike(n) || (ts.isFunctionLike(n) && !ts.isArrowFunction(n))) {
                                        return false;
                                    }
                                    else {
                                        ts.forEachChild(n, check);
                                    }
                                });
                            // falls through
                            case 255 /* ClassDeclaration */:
                            case 254 /* FunctionDeclaration */:
                                if (ts.isSourceFile(node.parent) && node.parent.externalModuleIndicator === undefined) {
                                    // You cannot extract global declarations
                                    (errors || (errors = [])).push(ts.createDiagnosticForNode(node, Messages.functionWillNotBeVisibleInTheNewScope));
                                }
                            // falls through
                            case 224 /* ClassExpression */:
                            case 211 /* FunctionExpression */:
                            case 167 /* MethodDeclaration */:
                            case 169 /* Constructor */:
                            case 170 /* GetAccessor */:
                            case 171 /* SetAccessor */:
                                // do not dive into functions or classes
                                return false;
                        }
                        var savedPermittedJumps = permittedJumps;
                        switch (node.kind) {
                            case 237 /* IfStatement */:
                                permittedJumps = 0 /* None */;
                                break;
                            case 250 /* TryStatement */:
                                // forbid all jumps inside try blocks
                                permittedJumps = 0 /* None */;
                                break;
                            case 233 /* Block */:
                                if (node.parent && node.parent.kind === 250 /* TryStatement */ && node.parent.finallyBlock === node) {
                                    // allow unconditional returns from finally blocks
                                    permittedJumps = 4 /* Return */;
                                }
                                break;
                            case 288 /* DefaultClause */:
                            case 287 /* CaseClause */:
                                // allow unlabeled break inside case clauses
                                permittedJumps |= 1 /* Break */;
                                break;
                            default:
                                if (ts.isIterationStatement(node, /*lookInLabeledStatements*/ false)) {
                                    // allow unlabeled break/continue inside loops
                                    permittedJumps |= 1 /* Break */ | 2 /* Continue */;
                                }
                                break;
                        }
                        switch (node.kind) {
                            case 190 /* ThisType */:
                            case 108 /* ThisKeyword */:
                                rangeFacts |= RangeFacts.UsesThis;
                                break;
                            case 248 /* LabeledStatement */: {
                                var label = node.label;
                                (seenLabels || (see