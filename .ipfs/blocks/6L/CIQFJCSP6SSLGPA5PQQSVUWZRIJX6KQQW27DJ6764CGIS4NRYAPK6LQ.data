s, spreadType, restType);
            }
            return getInferredTypes(context);
        }
        function getMutableArrayOrTupleType(type) {
            return type.flags & 1048576 /* Union */ ? mapType(type, getMutableArrayOrTupleType) :
                type.flags & 1 /* Any */ || isMutableArrayOrTuple(getBaseConstraintOfType(type) || type) ? type :
                    isTupleType(type) ? createTupleType(getTypeArguments(type), type.target.elementFlags, /*readonly*/ false, type.target.labeledElementDeclarations) :
                        createTupleType([type], [8 /* Variadic */]);
        }
        function getSpreadArgumentType(args, index, argCount, restType, context, checkMode) {
            if (index >= argCount - 1) {
                var arg = args[argCount - 1];
                if (isSpreadArgument(arg)) {
                    // We are inferring from a spread expression in the last argument position, i.e. both the parameter
                    // and the argument are ...x forms.
                    return getMutableArrayOrTupleType(arg.kind === 230 /* SyntheticExpression */ ? arg.type :
                        checkExpressionWithContextualType(arg.expression, restType, context, checkMode));
                }
            }
            var types = [];
            var flags = [];
            var names = [];
            for (var i = index; i < argCount; i++) {
                var arg = args[i];
                if (isSpreadArgument(arg)) {
                    var spreadType = arg.kind === 230 /* SyntheticExpression */ ? arg.type : checkExpression(arg.expression);
                    if (isArrayLikeType(spreadType)) {
                        types.push(spreadType);
                        flags.push(8 /* Variadic */);
                    }
                    else {
                        types.push(checkIteratedTypeOrElementType(33 /* Spread */, spreadType, undefinedType, arg.kind === 223 /* SpreadElement */ ? arg.expression : arg));
                        flags.push(4 /* Rest */);
                    }
                }
                else {
                    var contextualType = getIndexedAccessType(restType, getNumberLiteralType(i - index), 256 /* Contextual */);
                    var argType = checkExpressionWithContextualType(arg, contextualType, context, checkMode);
                    var hasPrimitiveContextualType = maybeTypeOfKind(contextualType, 131068 /* Primitive */ | 4194304 /* Index */ | 134217728 /* TemplateLiteral */ | 268435456 /* StringMapping */);
                    types.push(hasPrimitiveContextualType ? getRegularTypeOfLiteralType(argType) : getWidenedLiteralType(argType));
                    flags.push(1 /* Required */);
                }
                if (arg.kind === 230 /* SyntheticExpression */ && arg.tupleNameSource) {
                    names.push(arg.tupleNameSource);
                }
            }
            return createTupleType(types, flags, /*readonly*/ false, ts.length(names) === ts.length(types) ? names : undefined);
        }
        function checkTypeArguments(signature, typeArgumentNodes, reportErrors, headMessage) {
            var isJavascript = ts.isInJSFile(signature.declaration);
            var typeParameters = signature.typeParameters;
            var typeArgumentTypes = fillMissingTypeArguments(ts.map(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript);
            var mapper;
            for (var i = 0; i < typeArgumentNodes.length; i++) {
                ts.Debug.assert(typeParameters[i] !== undefined, "Should not call checkTypeArguments with too many type arguments");
                var constraint = getConstraintOfTypeParameter(typeParameters[i]);
                if (constraint) {
                    var errorInfo = reportErrors && headMessage ? (function () { return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1); }) : undefined;
                    var typeArgumentHeadMessage = headMessage || ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1;
                    if (!mapper) {
                        mapper = createTypeMapper(typeParameters, typeArgumentTypes);
                    }
                    var typeArgument = typeArgumentTypes[i];
                    if (!checkTypeAssignableTo(typeArgument, getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument), reportErrors ? typeArgumentNodes[i] : undefined, typeArgumentHeadMessage, errorInfo)) {
                        return undefined;
                    }
                }
            }
            return typeArgumentTypes;
        }
        function getJsxReferenceKind(node) {
            if (isJsxIntrinsicIdentifier(node.tagName)) {
                return 2 /* Mixed */;
            }
            var tagType = getApparentType(checkExpression(node.tagName));
            if (ts.length(getSignaturesOfType(tagType, 1 /* Construct */))) {
                return 0 /* Component */;
            }
            if (ts.length(getSignaturesOfType(tagType, 0 /* Call */))) {
                return 1 /* Function */;
            }
            return 2 /* Mixed */;
        }
        /**
         * Check if the given signature can possibly be a signature called by the JSX opening-like element.
         * @param node a JSX opening-like element we are trying to figure its call signature
         * @param signature a candidate signature we are trying whether it is a call signature
         * @param relation a relationship to check parameter and argument type
         */
        function checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer) {
            // Stateless function components can have maximum of three arguments: "props", "context", and "updater".
            // However "context" and "updater" are implicit and can't be specify by users. Only the first parameter, props,
            // can be specified by users through attributes property.
            var paramType = getEffectiveFirstArgumentForJsxSignature(signature, node);
            var attributesType = checkExpressionWithContextualType(node.attributes, paramType, /*inferenceContext*/ undefined, checkMode);
            return checkTagNameDoesNotExpectTooManyArguments() && checkTypeRelatedToAndOptionallyElaborate(attributesType, paramType, relation, reportErrors ? node.tagName : undefined, node.attributes, 
            /*headMessage*/ undefined, containingMessageChain, errorOutputContainer);
            function checkTagNameDoesNotExpectTooManyArguments() {
                var _a;
                if (getJsxNamespaceContainerForImplicitImport(node)) {
                    return true; // factory is implicitly jsx/jsxdev - assume it fits the bill, since we don't strongly look for the jsx/jsxs/jsxDEV factory APIs anywhere else (at least not yet)
                }
                var tagType = ts.isJsxOpeningElement(node) || ts.isJsxSelfClosingElement(node) && !isJsxIntrinsicIdentifier(node.tagName) ? checkExpression(node.tagName) : undefined;
                if (!tagType) {
                    return true;
                }
                var tagCallSignatures = getSignaturesOfType(tagType, 0 /* Call */);
                if (!ts.length(tagCallSignatures)) {
                    return true;
                }
                var factory = getJsxFactoryEntity(node);
                if (!factory) {
                    return true;
                }
                var factorySymbol = resolveEntityName(factory, 111551 /* Value */, /*ignoreErrors*/ true, /*dontResolveAlias*/ false, node);
                if (!factorySymbol) {
                    return true;
                }
                var factoryType = getTypeOfSymbol(factorySymbol);
                var callSignatures = getSignaturesOfType(factoryType, 0 /* Call */);
                if (!ts.length(callSignatures)) {
                    return true;
                }
                var hasFirstParamSignatures = false;
                var maxParamCount = 0;
                // Check that _some_ first parameter expects a FC-like thing, and that some overload of the SFC expects an acceptable number of arguments
                for (var _i = 0, callSignatures_1 = callSignatures; _i < callSignatures_1.length; _i++) {
                    var sig = callSignatures_1[_i];
                    var firstparam = getTypeAtPosition(sig, 0);
                    var signaturesOfParam = getSignaturesOfType(firstparam, 0 /* Call */);
                    if (!ts.length(signaturesOfParam))
                        continue;
                    for (var _b = 0, signaturesOfParam_1 = signaturesOfParam; _b < signaturesOfParam_1.length; _b++) {
                        var paramSig = signaturesOfParam_1[_b];
                        hasFirstParamSignatures = true;
                        if (hasEffectiveRestParameter(paramSig)) {
                            return true; // some signature has a rest param, so function components can have an arbitrary number of arguments
                        }
                        var paramCount = getParameterCount(paramSig);
                        if (paramCount > maxParamCount) {
                            maxParamCount = paramCount;
                        }
                    }
                }
                if (!hasFirstParamSignatures) {
                    // Not a single signature had a first parameter which expected a signature - for back compat, and
                    // to guard against generic factories which won't have signatures directly, do not error
                    return true;
                }
                var absoluteMinArgCount = Infinity;
                for (var _c = 0, tagCallSignatures_1 = tagCallSignatures; _c < tagCallSignatures_1.length; _c++) {
                    var tagSig = tagCallSignatures_1[_c];
                    var tagRequiredArgCount = getMinArgumentCount(tagSig);
                    if (tagRequiredArgCount < absoluteMinArgCount) {
                        absoluteMinArgCount = tagRequiredArgCount;
                    }
                }
                if (absoluteMinArgCount <= maxParamCount) {
                    return true; // some signature accepts the number of arguments the function component provides
                }
                if (reportErrors) {
                    var diag = ts.createDiagnosticForNode(node.tagName, ts.Diagnostics.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3, ts.entityNameToString(node.tagName), absoluteMinArgCount, ts.entityNameToString(factory), maxParamCount);
                    var tagNameDeclaration = (_a = getSymbolAtLocation(node.tagName)) === null || _a === void 0 ? void 0 : _a.valueDeclaration;
                    if (tagNameDeclaration) {
                        ts.addRelatedInfo(diag, ts.createDiagnosticForNode(tagNameDeclaration, ts.Diagnostics._0_is_declared_here, ts.entityNameToString(node.tagName)));
                    }
                    if (errorOutputContainer && errorOutputContainer.skipLogging) {
                        (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                    }
                    if (!errorOutputContainer.skipLogging) {
                        diagnostics.add(diag);
                    }
                }
                return false;
            }
        }
        function getSignatureApplicabilityError(node, args, signature, relation, checkMode, reportErrors, containingMessageChain) {
            var errorOutputContainer = { errors: undefined, skipLogging: true };
            if (ts.isJsxOpeningLikeElement(node)) {
                if (!checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer)) {
                    ts.Debug.assert(!reportErrors || !!errorOutputContainer.errors, "jsx should have errors when reporting errors");
                    return errorOutputContainer.errors || ts.emptyArray;
                }
                return undefined;
            }
            var thisType = getThisTypeOfSignature(signature);
            if (thisType && thisType !== voidType && node.kind !== 207 /* NewExpression */) {
                // If the called expression is not of the form `x.f` or `x["f"]`, then sourceType = voidType
                // If the signature's 'this' type is voidType, then the check is skipped -- anything is compatible.
                // If the expression is a new expression, then the check is skipped.
                var thisArgumentNode = getThisArgumentOfCall(node);
                var thisArgumentType = getThisArgumentType(thisArgumentNode);
                var errorNode = reportErrors ? (thisArgumentNode || node) : undefined;
                var headMessage_1 = ts.Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1;
                if (!checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage_1, containingMessageChain, errorOutputContainer)) {
                    ts.Debug.assert(!reportErrors || !!errorOutputContainer.errors, "this parameter should have errors when reporting errors");
                    return errorOutputContainer.errors || ts.emptyArray;
                }
            }
            var headMessage = ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
            var restType = getNonArrayRestType(signature);
            var argCount = restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length;
            for (var i = 0; i < argCount; i++) {
                var arg = args[i];
                if (arg.kind !== 225 /* OmittedExpression */) {
                    var paramType = getTypeAtPosition(signature, i);
                    var argType = checkExpressionWithContextualType(arg, paramType, /*inferenceContext*/ undefined, checkMode);
                    // If one or more arguments are still excluded (as indicated by CheckMode.SkipContextSensitive),
                    // we obtain the regular type of any object literal arguments because we may not have inferred complete
                    // parameter types yet and therefore excess property checks may yield false positives (see #17041).
                    var checkArgType = checkMode & 4 /* SkipContextSensitive */ ? getRegularTypeOfObjectLiteral(argType) : argType;
                    if (!checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation, reportErrors ? arg : undefined, arg, headMessage, containingMessageChain, errorOutputContainer)) {
                        ts.Debug.assert(!reportErrors || !!errorOutputContainer.errors, "parameter should have errors when reporting errors");
                        maybeAddMissingAwaitInfo(arg, checkArgType, paramType);
                        return errorOutputContainer.errors || ts.emptyArray;
                    }
                }
            }
            if (restType) {
                var spreadType = getSpreadArgumentType(args, argCount, args.length, restType, /*context*/ undefined, checkMode);
                var restArgCount = args.length - argCount;
                var errorNode = !reportErrors ? undefined :
                    restArgCount === 0 ? node :
                        restArgCount === 1 ? args[argCount] :
                            ts.setTextRangePosEnd(createSyntheticExpression(node, spreadType), args[argCount].pos, args[args.length - 1].end);
                if (!checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage, /*containingMessageChain*/ undefined, errorOutputContainer)) {
                    ts.Debug.assert(!reportErrors || !!errorOutputContainer.errors, "rest parameter should have errors when reporting errors");
                    maybeAddMissingAwaitInfo(errorNode, spreadType, restType);
                    return errorOutputContainer.errors || ts.emptyArray;
                }
            }
            return undefined;
            function maybeAddMissingAwaitInfo(errorNode, source, target) {
                if (errorNode && reportErrors && errorOutputContainer.errors && errorOutputContainer.errors.length) {
                    // Bail if target is Promise-like---something else is wrong
                    if (getAwaitedTypeOfPromise(target)) {
                        return;
                    }
                    var awaitedTypeOfSource = getAwaitedTypeOfPromise(source);
                    if (awaitedTypeOfSource && isTypeRelatedTo(awaitedTypeOfSource, target, relation)) {
                        ts.addRelatedInfo(errorOutputContainer.errors[0], ts.createDiagnosticForNode(errorNode, ts.Diagnostics.Did_you_forget_to_use_await));
                    }
                }
            }
        }
        /**
         * Returns the this argument in calls like x.f(...) and x[f](...). Undefined otherwise.
         */
        function getThisArgumentOfCall(node) {
            var expression = node.kind === 206 /* CallExpression */ ? node.expression :
                node.kind === 208 /* TaggedTemplateExpression */ ? node.tag : undefined;
            if (expression) {
                var callee = ts.skipOuterExpressions(expression);
                if (ts.isAccessExpression(callee)) {
                    return callee.expression;
                }
            }
        }
        function createSyntheticExpression(parent, type, isSpread, tupleNameSource) {
            var result = ts.parseNodeFactory.createSyntheticExpression(type, isSpread, tupleNameSource);
            ts.setTextRange(result, parent);
            ts.setParent(result, parent);
            return result;
        }
        /**
         * Returns the effective arguments for an expression that works like a function invocation.
         */
        function getEffectiveCallArguments(node) {
            if (node.kind === 208 /* TaggedTemplateExpression */) {
                var template = node.template;
                var args_3 = [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
                if (template.kind === 221 /* TemplateExpression */) {
                    ts.forEach(template.templateSpans, function (span) {
                        args_3.push(span.expression);
                    });
                }
                return args_3;
            }
            if (node.kind === 163 /* Decorator */) {
                return getEffectiveDecoratorArguments(node);
            }
            if (ts.isJsxOpeningLikeElement(node)) {
                return node.attributes.properties.length > 0 || (ts.isJsxOpeningElement(node) && node.parent.children.length > 0) ? [node.attributes] : ts.emptyArray;
            }
            var args = node.arguments || ts.emptyArray;
            var spreadIndex = getSpreadArgumentIndex(args);
            if (spreadIndex >= 0) {
                // Create synthetic arguments from spreads of tuple types.
                var effectiveArgs_1 = args.slice(0, spreadIndex);
                var _loop_23 = function (i) {
                    var arg = args[i];
                    // We can call checkExpressionCached because spread expressions never have a contextual type.
                    var spreadType = arg.kind === 223 /* SpreadElement */ && (flowLoopCount ? checkExpression(arg.expression) : checkExpressionCached(arg.expression));
                    if (spreadType && isTupleType(spreadType)) {
                        ts.forEach(getTypeArguments(spreadType), function (t, i) {
                            var _a;
                            var flags = spreadType.target.elementFlags[i];
                            var syntheticArg = createSyntheticExpression(arg, flags & 4 /* Rest */ ? createArrayType(t) : t, !!(flags & 12 /* Variable */), (_a = spreadType.target.labeledElementDeclarations) === null || _a === void 0 ? void 0 : _a[i]);
                            effectiveArgs_1.push(syntheticArg);
                        });
                    }
                    else {
                        effectiveArgs_1.push(arg);
                    }
                };
                for (var i = spreadIndex; i < args.length; i++) {
                    _loop_23(i);
                }
                return effectiveArgs_1;
            }
            return args;
        }
        /**
         * Returns the synthetic argument list for a decorator invocation.
         */
        function getEffectiveDecoratorArguments(node) {
            var parent = node.parent;
            var expr = node.expression;
            switch (parent.kind) {
                case 255 /* ClassDeclaration */:
                case 224 /* ClassExpression */:
                    // For a class decorator, the `target` is the type of the class (e.g. the
                    // "static" or "constructor" side of the class).
                    return [
                        createSyntheticExpression(expr, getTypeOfSymbol(getSymbolOfNode(parent)))
                    ];
                case 162 /* Parameter */:
                    // A parameter declaration decorator will have three arguments (see
                    // `ParameterDecorator` in core.d.ts).
                    var func = parent.parent;
                    return [
                        createSyntheticExpression(expr, parent.parent.kind === 169 /* Constructor */ ? getTypeOfSymbol(getSymbolOfNode(func)) : errorType),
                        createSyntheticExpression(expr, anyType),
                        createSyntheticExpression(expr, numberType)
                    ];
                case 165 /* PropertyDeclaration */:
                case 167 /* MethodDeclaration */:
                case 170 /* GetAccessor */:
                case 171 /* SetAccessor */:
                    // A method or accessor declaration decorator will have two or three arguments (see
                    // `PropertyDecorator` and `MethodDecorator` in core.d.ts). If we are emitting decorators
                    // for ES3, we will only pass two arguments.
                    var hasPropDesc = parent.kind !== 165 /* PropertyDeclaration */ && languageVersion !== 0 /* ES3 */;
                    return [
                        createSyntheticExpression(expr, getParentTypeOfClassElement(parent)),
                        createSyntheticExpression(expr, getClassElementPropertyKeyType(parent)),
                        createSyntheticExpression(expr, hasPropDesc ? createTypedPropertyDescriptorType(getTypeOfNode(parent)) : anyType)
                    ];
            }
            return ts.Debug.fail();
        }
        /**
         * Returns the argument count for a decorator node that works like a function invocation.
         */
        function getDecoratorArgumentCount(node, signature) {
            switch (node.parent.kind) {
                case 255 /* ClassDeclaration */:
                case 224 /* ClassExpression */:
                    return 1;
                case 165 /* PropertyDeclaration */:
                    return 2;
                case 167 /* MethodDeclaration */:
                case 170 /* GetAccessor */:
                case 171 /* SetAccessor */:
                    // For ES3 or decorators with only two parameters we supply only two arguments
                    return languageVersion === 0 /* ES3 */ || signature.parameters.length <= 2 ? 2 : 3;
                case 162 /* Parameter */:
                    return 3;
                default:
                    return ts.Debug.fail();
            }
        }
        function getDiagnosticSpanForCallNode(node, doNotIncludeArguments) {
            var start;
            var length;
            var sourceFile = ts.getSourceFileOfNode(node);
            if (ts.isPropertyAccessExpression(node.expression)) {
                var nameSpan = ts.getErrorSpanForNode(sourceFile, node.expression.name);
                start = nameSpan.start;
                length = doNotIncludeArguments ? nameSpan.length : node.end - start;
            }
            else {
                var expressionSpan = ts.getErrorSpanForNode(sourceFile, node.expression);
                start = expressionSpan.start;
                length = doNotIncludeArguments ? expressionSpan.length : node.end - start;
            }
            return { start: start, length: length, sourceFile: sourceFile };
        }
        function getDiagnosticForCallNode(node, message, arg0, arg1, arg2, arg3) {
            if (ts.isCallExpression(node)) {
                var _a = getDiagnosticSpanForCallNode(node), sourceFile = _a.sourceFile, start = _a.start, length_6 = _a.length;
                return ts.createFileDiagnostic(sourceFile, start, length_6, message, arg0, arg1, arg2, arg3);
            }
            else {
                return ts.createDiagnosticForNode(node, message, arg0, arg1, arg2, arg3);
            }
        }
        function isPromiseResolveArityError(node) {
            if (!ts.isCallExpression(node) || !ts.isIdentifier(node.expression))
                return false;
            var symbol = resolveName(node.expression, node.expression.escapedText, 111551 /* Value */, undefined, undefined, false);
            var decl = symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration;
            if (!decl || !ts.isParameter(decl) || !isFunctionExpressionOrArrowFunction(decl.parent) || !ts.isNewExpression(decl.parent.parent) || !ts.isIdentifier(decl.parent.parent.expression)) {
                return false;
            }
            var globalPromiseSymbol = getGlobalPromiseConstructorSymbol(/*reportErrors*/ false);
            if (!globalPromiseSymbol)
                return false;
            var constructorSymbol = getSymbolAtLocation(decl.parent.parent.expression, /*ignoreErrors*/ true);
            return constructorSymbol === globalPromiseSymbol;
        }
        function getArgumentArityError(node, signatures, args) {
            var _a;
            var spreadIndex = getSpreadArgumentIndex(args);
            if (spreadIndex > -1) {
                return ts.createDiagnosticForNode(args[spreadIndex], ts.Diagnostics.A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter);
            }
            var min = Number.POSITIVE_INFINITY; // smallest parameter count
            var max = Number.NEGATIVE_INFINITY; // largest parameter count
            var maxBelow = Number.NEGATIVE_INFINITY; // largest parameter count that is smaller than the number of arguments
            var minAbove = Number.POSITIVE_INFINITY; // smallest parameter count that is larger than the number of arguments
            var closestSignature;
            for (var _i = 0, signatures_8 = signatures; _i < signatures_8.length; _i++) {
                var sig = signatures_8[_i];
                var minParameter = getMinArgumentCount(sig);
                var maxParameter = getParameterCount(sig);
                // smallest/largest parameter counts
                if (minParameter < min) {
                    min = minParameter;
                    closestSignature = sig;
                }
                max = Math.max(max, maxParameter);
                // shortest parameter count *longer than the call*/longest parameter count *shorter than the call*
                if (minParameter < args.length && minParameter > maxBelow)
                    maxBelow = minParameter;
                if (args.length < maxParameter && maxParameter < minAbove)
                    minAbove = maxParameter;
            }
            var hasRestParameter = ts.some(signatures, hasEffectiveRestParameter);
            var parameterRange = hasRestParameter ? min
                : min < max ? min + "-" + max
                    : min;
            var error = hasRestParameter ? ts.Diagnostics.Expected_at_least_0_arguments_but_got_1
                : parameterRange === 1 && args.length === 0 && isPromiseResolveArityError(node) ? ts.Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise
                    : ts.Diagnostics.Expected_0_arguments_but_got_1;
            if (min < args.length && args.length < max) {
                // between min and max, but with no matching overload
                return getDiagnosticForCallNode(node, ts.Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove);
            }
            else if (args.length < min) {
                // too short: put the error span on the call expression, not any of the args
                var diagnostic = getDiagnosticForCallNode(node, error, parameterRange, args.length);
                var parameter = (_a = closestSignature === null || closestSignature === void 0 ? void 0 : closestSignature.declaration) === null || _a === void 0 ? void 0 : _a.parameters[closestSignature.thisParameter ? args.length + 1 : args.length];
                if (parameter) {
                    var parameterError = ts.createDiagnosticForNode(parameter, ts.isBindingPattern(parameter.name) ? ts.Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided
                        : ts.isRestParameter(parameter) ? ts.Diagnostics.Arguments_for_the_rest_parameter_0_were_not_provided
                            : ts.Diagnostics.An_argument_for_0_was_not_provided, !parameter.name ? args.length : !ts.isBindingPattern(parameter.name) ? ts.idText(ts.getFirstIdentifier(parameter.name)) : undefined);
                    return ts.addRelatedInfo(diagnostic, parameterError);
                }
                return diagnostic;
            }
            else {
                // too long; error goes on the excess parameters
                var errorSpan = ts.factory.createNodeArray(args.slice(max));
                var pos = ts.first(errorSpan).pos;
                var end = ts.last(errorSpan).end;
                if (end === pos) {
                    end++;
                }
                ts.setTextRangePosEnd(errorSpan, pos, end);
                return ts.createDiagnosticForNodeArray(ts.getSourceFileOfNode(node), errorSpan, error, parameterRange, args.length);
            }
        }
        function getTypeArgumentArityError(node, signatures, typeArguments) {
            var argCount = typeArguments.length;
            // No overloads exist
            if (signatures.length === 1) {
                var sig = signatures[0];
                var min_1 = getMinTypeArgumentCount(sig.typeParameters);
                var max = ts.length(sig.typeParameters);
                return ts.createDiagnosticForNodeArray(ts.getSourceFileOfNode(node), typeArguments, ts.Diagnostics.Expected_0_type_arguments_but_got_1, min_1 < max ? min_1 + "-" + max : min_1, argCount);
            }
            // Overloads exist
            var belowArgCount = -Infinity;
            var aboveArgCount = Infinity;
            for (var _i = 0, signatures_9 = signatures; _i < signatures_9.length; _i++) {
                var sig = signatures_9[_i];
                var min_2 = getMinTypeArgumentCount(sig.typeParameters);
                var max = ts.length(sig.typeParameters);
                if (min_2 > argCount) {
                    aboveArgCount = Math.min(aboveArgCount, min_2);
                }
                else if (max < argCount) {
                    belowArgCount = Math.max(belowArgCount, max);
                }
            }
            if (belowArgCount !== -Infinity && aboveArgCount !== Infinity) {
                return ts.createDiagnosticForNodeArray(ts.getSourceFileOfNode(node), typeArguments, ts.Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount);
            }
            return ts.createDiagnosticForNodeArray(ts.getSourceFileOfNode(node), typeArguments, ts.Diagnostics.Expected_0_type_arguments_but_got_1, belowArgCount === -Infinity ? aboveArgCount : belowArgCount, argCount);
        }
        function resolveCall(node, signatures, candidatesOutArray, checkMode, callChainFlags, fallbackError) {
            var isTaggedTemplate = node.kind === 208 /* TaggedTemplateExpression */;
            var isDecorator = node.kind === 163 /* Decorator */;
            var isJsxOpeningOrSelfClosingElement = ts.isJsxOpeningLikeElement(node);
            var reportErrors = !candidatesOutArray && produceDiagnostics;
            var typeArguments;
            if (!isDecorator) {
                typeArguments = node.typeArguments;
                // We already perform checking on the type arguments on the class declaration itself.
                if (isTaggedTemplate || isJsxOpeningOrSelfClosingElement || node.expression.kind !== 106 /* SuperKeyword */) {
                    ts.forEach(typeArguments, checkSourceElement);
                }
            }
            var candidates = candidatesOutArray || [];
            // reorderCandidates fills up the candidates array directly
            reorderCandidates(signatures, candidates, callChainFlags);
            if (!candidates.length) {
                if (reportErrors) {
                    diagnostics.add(getDiagnosticForCallNode(node, ts.Diagnostics.Call_target_does_not_contain_any_signatures));
                }
                return resolveErrorCall(node);
            }
            var args = getEffectiveCallArguments(node);
            // The excludeArgument array contains true for each context sensitive argument (an argument
            // is context sensitive it is susceptible to a one-time permanent contextual typing).
            //
            // The idea is that we will perform type argument inference & assignability checking once
            // without using the susceptible parameters that are functions, and once more for those
            // parameters, contextually typing each as we go along.
            //
            // For a tagged template, then the first argument be 'undefined' if necessary because it
            // represents a TemplateStringsArray.
            //
            // For a decorator, no arguments are susceptible to contextual typing due to the fact
            // decorators are applied to a declaration by the emitter, and not to an expression.
            var isSingleNonGenericCandidate = candidates.length === 1 && !candidates[0].typeParameters;
            var argCheckMode = !isDecorator && !isSingleNonGenericCandidate && ts.some(args, isContextSensitive) ? 4 /* SkipContextSensitive */ : 0 /* Normal */;
            // The following variables are captured and modified by calls to chooseOverload.
            // If overload resolution or type argument inference fails, we want to report the
            // best error possible. The best error is one which says that an argument was not
            // assignable to a parameter. This implies that everything else about the overload
            // was fine. So if there is any overload that is only incorrect because of an
            // argument, we will report an error on that one.
            //
            //     function foo(s: string): void;
            //     function foo(n: number): void; // Report argument error on this overload
            //     function foo(): void;
            //     foo(true);
            //
            // If none of the overloads even made it that far, there are two possibilities.
            // There was a problem with type arguments for some overload, in which case
            // report an error on that. Or none of the overloads even had correct arity,
            // in which case give an arity error.
            //
            //     function foo<T extends string>(x: T): void; // Report type argument error
            //     function foo(): void;
            //     foo<number>(0);
            //
            var candidatesForArgumentError;
            var candidateForArgumentArityError;
            var candidateForTypeArgumentError;
            var result;
            // If we are in signature help, a trailing comma indicates that we intend to provide another argument,
            // so we will only accept overloads with arity at least 1 higher than the current number of provided arguments.
            var signatureHelpTrailingComma = !!(checkMode & 16 /* IsForSignatureHelp */) && node.kind === 206 /* CallExpression */ && node.arguments.hasTrailingComma;
            // Section 4.12.1:
            // if the candidate list contains one or more signatures for which the type of each argument
            // expression is a subtype of each corresponding parameter type, the return type of the first
            // of those signatures becomes the return type of the function call.
            // Otherwise, the return type of the first signature in the candidate list becomes the return
            // type of the function call.
            //
            // Whether the call is an error is determined by assignability of the arguments. The subtype pass
            // is just important for choosing the best signature. So in the case where there is only one
            // signature, the subtype pass is useless. So skipping it is an optimization.
            if (candidates.length > 1) {
                result = chooseOverload(candidates, subtypeRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma);
            }
            if (!result) {
                result = chooseOverload(candidates, assignableRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma);
            }
            if (result) {
                return result;
            }
            // No signatures were applicable. Now report errors based on the last applicable signature with
            // no arguments excluded from assignability checks.
            // If candidate is undefined, it means that no candidates had a suitable arity. In that case,
            // skip the checkApplicableSignature check.
            if (reportErrors) {
                if (candidatesForArgumentError) {
                    if (candidatesForArgumentError.length === 1 || candidatesForArgumentError.length > 3) {
                        var last_2 = candidatesForArgumentError[candidatesForArgumentError.length - 1];
                        var chain_1;
                        if (candidatesForArgumentError.length > 3) {
                            chain_1 = ts.chainDiagnosticMessages(chain_1, ts.Diagnostics.The_last_overload_gave_the_following_error);
                            chain_1 = ts.chainDiagnosticMessages(chain_1, ts.Diagnostics.No_overload_matches_this_call);
                        }
                        var diags = getSignatureApplicabilityError(node, args, last_2, assignableRelation, 0 /* Normal */, /*reportErrors*/ true, function () { return chain_1; });
                        if (diags) {
                            for (var _i = 0, diags_1 = diags; _i < diags_1.length; _i++) {
                                var d = diags_1[_i];
                                if (last_2.declaration && candidatesForArgumentError.length > 3) {
                                    ts.addRelatedInfo(d, ts.createDiagnosticForNode(last_2.declaration, ts.Diagnostics.The_last_overload_is_declared_here));
                                }
                                addImplementationSuccessElaboration(last_2, d);
                                diagnostics.add(d);
                            }
                        }
                        else {
                            ts.Debug.fail("No error for last overload signature");
                        }
                    }
                    else {
                        var allDiagnostics = [];
                        var max = 0;
                        var min_3 = Number.MAX_VALUE;
                        var minIndex = 0;
                        var i_1 = 0;
                        var _loop_24 = function (c) {
                            var chain_2 = function () { return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Overload_0_of_1_2_gave_the_following_error, i_1 + 1, candidates.length, signatureToString(c)); };
                            var diags_2 = getSignatureApplicabilityError(node, args, c, assignableRelation, 0 /* Normal */, /*reportErrors*/ true, chain_2);
                            if (diags_2) {
                                if (diags_2.length <= min_3) {
                                    min_3 = diags_2.length;
                                    minIndex = i_1;
                                }
                                max = Math.max(max, diags_2.length);
                                allDiagnostics.push(diags_2);
                            }
                            else {
                                ts.Debug.fail("No error for 3 or fewer overload signatures");
                            }
                            i_1++;
                        };
                        for (var _a = 0, candidatesForArgumentError_1 = candidatesForArgumentError; _a < candidatesForArgumentError_1.length; _a++) {
                            var c = candidatesForArgumentError_1[_a];
                            _loop_24(c);
                        }
                        var diags_3 = max > 1 ? allDiagnostics[minIndex] : ts.flatten(allDiagnostics);
                        ts.Debug.assert(diags_3.length > 0, "No errors reported for 3 or fewer overload signatures");
                        var chain = ts.chainDiagnosticMessages(ts.map(diags_3, function (d) { return typeof d.messageText === "string" ? d : d.messageText; }), ts.Diagnostics.No_overload_matches_this_call);
                        // The below is a spread to guarantee we get a new (mutable) array - our `flatMap` helper tries to do "smart" optimizations where it reuses input
                        // arrays and the emptyArray singleton where possible, which is decidedly not what we want while we're still constructing this diagnostic
                        var related = __spreadArray([], ts.flatMap(diags_3, function (d) { return d.relatedInformation; }), true);
                        var diag = void 0;
                        if (ts.every(diags_3, function (d) { return d.start === diags_3[0].start && d.length === diags_3[0].length && d.file === diags_3[0].file; })) {
                            var _b = diags_3[0], file = _b.file, start = _b.start, length_7 = _b.length;
                            diag = { file: file, start: start, length: length_7, code: chain.code, category: chain.category, messageText: chain, relatedInformation: related };
                        }
                        else {
                            diag = ts.createDiagnosticForNodeFromMessageChain(node, chain, related);
                        }
                        addImplementationSuccessElaboration(candidatesForArgumentError[0], diag);
                        diagnostics.add(diag);
                    }
                }
                else if (candidateForArgumentArityError) {
                    diagnostics.add(getArgumentArityError(node, [candidateForArgumentArityError], args));
                }
                else if (candidateForTypeArgumentError) {
                    checkTypeArguments(candidateForTypeArgumentError, node.typeArguments, /*reportErrors*/ true, fallbackError);
                }
                else {
                    var signaturesWithCorrectTypeArgumentArity = ts.filter(signatures, function (s) { return hasCorrectTypeArgumentArity(s, typeArguments); });
                    if (signaturesWithCorrectTypeArgumentArity.length === 0) {
                        diagnostics.add(getTypeArgumentArityError(node, signatures, typeArguments));
                    }
                    else if (!isDecorator) {
                        diagnostics.add(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args));
                    }
                    else if (fallbackError) {
                        diagnostics.add(getDiagnosticForCallNode(node, fallbackError));
                    }
                }
            }
            return getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray);
            function addImplementationSuccessElaboration(failed, diagnostic) {
                var _a, _b;
                var oldCandidatesForArgumentError = candidatesForArgumentError;
                var oldCandidateForArgumentArityError = candidateForArgumentArityError;
                var oldCandidateForTypeArgumentError = candidateForTypeArgumentError;
                var failedSignatureDeclarations = ((_b = (_a = failed.declaration) === null || _a === void 0 ? void 0 : _a.symbol) === null || _b === void 0 ? void 0 : _b.declarations) || ts.emptyArray;
                var isOverload = failedSignatureDeclarations.length > 1;
                var implDecl = isOverload ? ts.find(failedSignatureDeclarations, function (d) { return ts.isFunctionLikeDeclaration(d) && ts.nodeIsPresent(d.body); }) : undefined;
                if (implDecl) {
                    var candidate = getSignatureFromDeclaration(implDecl);
                    var isSingleNonGenericCandidate_1 = !candidate.typeParameters;
                    if (chooseOverload([candidate], assignableRelation, isSingleNonGenericCandidate_1)) {
                        ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(implDecl, ts.Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible));
                    }
                }
                candidatesForArgumentError = oldCandidatesForArgumentError;
                candidateForArgumentArityError = oldCandidateForArgumentArityError;
                candidateForTypeArgumentError = oldCandidateForTypeArgumentError;
            }
            function chooseOverload(candidates, relation, isSingleNonGenericCandidate, signatureHelpTrailingComma) {
                if (signatureHelpTrailingComma === void 0) { signatureHelpTrailingComma = false; }
                candidatesForArgumentError = undefined;
                candidateForArgumentArityError = undefined;
                candidateForTypeArgumentError = undefined;
                if (isSingleNonGenericCandidate) {
                    var candidate = candidates[0];
                    if (ts.some(typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {
                        return undefined;
                    }
                    if (getSignatureApplicabilityError(node, args, candidate, relation, 0 /* Normal */, /*reportErrors*/ false, /*containingMessageChain*/ undefined)) {
                        candidatesForArgumentError = [candidate];
                        return undefined;
                    }
                    return candidate;
                }
                for (var candidateIndex = 0; candidateIndex < candidates.length; candidateIndex++) {
                    var candidate = candidates[candidateIndex];
                    if (!hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {
                        continue;
                    }
                    var checkCandidate = void 0;
                    var inferenceContext = void 0;
                    if (candidate.typeParameters) {
                        var typeArgumentTypes = void 0;
                        if (ts.some(typeArguments)) {
                            typeArgumentTypes = checkTypeArguments(candidate, typeArguments, /*reportErrors*/ false);
                            if (!typeArgumentTypes) {
                                candidateForTypeArgumentError = candidate;
                                continue;
                            }
                        }
                        else {
                            inferenceContext = createInferenceContext(candidate.typeParameters, candidate, /*flags*/ ts.isInJSFile(node) ? 2 /* AnyDefault */ : 0 /* None */);
                            typeArgumentTypes = inferTypeArguments(node, candidate, args, argCheckMode | 8 /* SkipGenericFunctions */, inferenceContext);
                            argCheckMode |= inferenceContext.flags & 4 /* SkippedGenericFunction */ ? 8 /* SkipGenericFunctions */ : 0 /* Normal */;
                        }
                        checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, ts.isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);
                        // If the original signature has a generic rest type, instantiation may produce a
                        // signature with different arity and we need to perform another arity check.
                        if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {
                            candidateForArgumentArityError = checkCandidate;
                            continue;
                        }
                    }
                    else {
                        checkCandidate = candidate;
                    }
                    if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors*/ false, /*containingMessageChain*/ undefined)) {
                        // Give preference to error candidates that have no rest parameters (as they are more specific)
                        (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
                        continue;
                    }
                    if (argCheckMode) {
                        // If one or more context sensitive arguments were excluded, we start including
                        // them now (and keeping do so for any subsequent candidates) and perform a second
                        // round of type inference and applicability checking for this particular candidate.
                        argCheckMode = 0 /* Normal */;
                        if (inferenceContext) {
                            var typeArgumentTypes = inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext);
                            checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, ts.isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);
                            // If the original signature has a generic rest type, instantiation may produce a
                            // signature with different arity and we need to perform another arity check.
                            if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {
                                candidateForArgumentArityError = checkCandidate;
                                continue;
                            }
                        }
                        if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors*/ false, /*containingMessageChain*/ undefined)) {
                            // Give preference to error candidates that have no rest parameters (as they are more specific)
                            (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
                            continue;
                        }
                    }
                    candidates[candidateIndex] = checkCandidate;
                    return checkCandidate;
                }
                return undefined;
            }
        }
        // No signature was applicable. We have already reported the errors for the invalid signature.
        function getCandidateForOverloadFailure(node, candidates, args, hasCandidatesOutArray) {
            ts.Debug.assert(candidates.length > 0); // Else should not have called this.
            checkNodeDeferred(node);
            // Normally we will combine overloads. Skip this if they have type parameters since that's hard to combine.
            // Don't do this if there is a `candidatesOutArray`,
            // because then we want the chosen best candidate to be one of the overloads, not a combination.
            return hasCandidatesOutArray || candidates.length === 1 || candidates.some(function (c) { return !!c.typeParameters; })
                ? pickLongestCandidateSignature(node, candidates, args)
                : createUnionOfSignaturesForOverloadFailure(candidates);
        }
        function createUnionOfSignaturesForOverloadFailure(candidates) {
            var thisParameters = ts.mapDefined(candidates, function (c) { return c.thisParameter; });
            var thisParameter;
            if (thisParameters.length) {
                thisParameter = createCombinedSymbolFromTypes(thisParameters, thisParameters.map(getTypeOfParameter));
            }
            var _a = ts.minAndMax(candidates, getNumNonRestParameters), minArgumentCount = _a.min, maxNonRestParam = _a.max;
            var parameters = [];
            var _loop_25 = function (i) {
                var symbols = ts.mapDefined(candidates, function (s) { return signatureHasRestParameter(s) ?
                    i < s.parameters.length - 1 ? s.parameters[i] : ts.last(s.parameters) :
                    i < s.parameters.length ? s.parameters[i] : undefined; });
                ts.Debug.assert(symbols.length !== 0);
                parameters.push(createCombinedSymbolFromTypes(symbols, ts.mapDefined(candidates, function (candidate) { return tryGetTypeAtPosition(candidate, i); })));
            };
            for (var i = 0; i < maxNonRestParam; i++) {
                _loop_25(i);
            }
            var restParameterSymbols = ts.mapDefined(candidates, function (c) { return signatureHasRestParameter(c) ? ts.last(c.parameters) : undefined; });
            var flags = 0 /* None */;
            if (restParameterSymbols.length !== 0) {
                var type = createArrayType(getUnionType(ts.mapDefined(candidates, tryGetRestTypeOfSignature), 2 /* Subtype */));
                parameters.push(createCombinedSymbolForOverloadFailure(restParameterSymbols, type));
                flags |= 1 /* HasRestParameter */;
            }
            if (candidates.some(signatureHasLiteralTypes)) {
                flags |= 2 /* HasLiteralTypes */;
            }
            return createSignature(candidates[0].declaration, 
            /*typeParameters*/ undefined, // Before calling this we tested for `!candidates.some(c => !!c.typeParameters)`.
            thisParameter, parameters, 
            /*resolvedReturnType*/ getIntersectionType(candidates.map(getReturnTypeOfSignature)), 
            /*typePredicate*/ undefined, minArgumentCount, flags);
        }
        function getNumNonRestParameters(signature) {
            var numParams = signature.parameters.length;
            return signatureHasRestParameter(signature) ? numParams - 1 : numParams;
        }
        function createCombinedSymbolFromTypes(sources, types) {
            return createCombinedSymbolForOverloadFailure(sources, getUnionType(types, 2 /* Subtype */));
        }
        function createCombinedSymbolForOverloadFailure(sources, type) {
            // This function is currently only used for erroneous overloads, so it's good enough to just use the first source.
            return createSymbolWithType(ts.first(sources), type);
        }
        function pickLongestCandidateSignature(node, candidates, args) {
            // Pick the longest signature. This way we can get a contextual type for cases like:
            //     declare function f(a: { xa: number; xb: number; }, b: number);
            //     f({ |
            // Also, use explicitly-supplied type arguments if they are provided, so we can get a contextual signature in cases like:
            //     declare function f<T>(k: keyof T);
            //     f<Foo>("
            var bestIndex = getLongestCandidateIndex(candidates, apparentArgumentCount === undefined ? args.length : apparentArgumentCount);
            var candidate = candidates[bestIndex];
            var typeParameters = candidate.typeParameters;
            if (!typeParameters) {
                return candidate;
            }
            var typeArgumentNodes = callLikeExpressionMayHaveTypeArguments(node) ? node.typeArguments : undefined;
            var instantiated = typeArgumentNodes
                ? createSignatureInstantiation(candidate, getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, ts.isInJSFile(node)))
                : inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args);
            candidates[bestIndex] = instantiated;
            return instantiated;
        }
        function getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isJs) {
            var typeArguments = typeArgumentNodes.map(getTypeOfNode);
            while (typeArguments.length > typeParameters.length) {
                typeArguments.pop();
            }
            while (typeArguments.length < typeParameters.length) {
                typeArguments.push(getConstraintOfTypeParameter(typeParameters[typeArguments.length]) || getDefaultTypeArgumentType(isJs));
            }
            return typeArguments;
        }
        function inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args) {
            var inferenceContext = createInferenceContext(typeParameters, candidate, /*flags*/ ts.isInJSFile(node) ? 2 /* AnyDefault */ : 0 /* None */);
            var typeArgumentTypes = inferTypeArguments(node, candidate, args, 4 /* SkipContextSensitive */ | 8 /* SkipGenericFunctions */, inferenceContext);
            return createSignatureInstantiation(candidate, typeArgumentTypes);
        }
        function getLongestCandidateIndex(candidates, argsCount) {
            var maxParamsIndex = -1;
            var maxParams = -1;
            for (var i = 0; i < candidates.length; i++) {
                var candidate = candidates[i];
                var paramCount = getParameterCount(candidate);
                if (hasEffectiveRestParameter(candidate) || paramCount >= argsCount) {
                    return i;
                }
                if (paramCount > maxParams) {
                    maxParams = paramCount;
                    maxParamsIndex = i;
                }
            }
            return maxParamsIndex;
        }
        function resolveCallExpression(node, candidatesOutArray, checkMode) {
            if (node.expression.kind === 106 /* SuperKeyword */) {
                var superType = checkSuperExpression(node.expression);
                if (isTypeAny(superType)) {
                    for (var _i = 0, _a = node.arguments; _i < _a.length; _i++) {
                        var arg = _a[_i];
                        checkExpression(arg); // Still visit arguments so they get marked for visibility, etc
                    }
                    return anySignature;
                }
                if (superType !== errorType) {
                    // In super call, the candidate signatures are the matching arity signatures of the base constructor function instantiated
                    // with the type arguments specified in the extends clause.
                    var baseTypeNode = ts.getEffectiveBaseTypeNode(ts.getContainingClass(node));
                    if (baseTypeNode) {
                        var baseConstructors = getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode);
                        return resolveCall(node, baseConstructors, candidatesOutArray, checkMode, 0 /* None */);
                    }
                }
                return resolveUntypedCall(node);
            }
            var callChainFlags;
            var funcType = checkExpression(node.expression);
            if (ts.isCallChain(node)) {
                var nonOptionalType = getOptionalExpressionType(funcType, node.expression);
                callChainFlags = nonOptionalType === funcType ? 0 /* None */ :
                    ts.isOutermostOptionalChain(node) ? 16 /* IsOuterCallChain */ :
                        8 /* IsInnerCallChain */;
                funcType = nonOptionalType;
            }
            else {
                callChainFlags = 0 /* None */;
            }
            funcType = checkNonNullTypeWithReporter(funcType, node.expression, reportCannotInvokePossiblyNullOrUndefinedError);
            if (funcType === silentNeverType) {
                return silentNeverSignature;
            }
            var apparentType = getApparentType(funcType);
            if (apparentType === errorType) {
                // Another error has already been reported
                return resolveErrorCall(node);
            }
            // Technically, this signatures list may be incomplete. We are taking the apparent type,
            // but we are not including call signatures that may have been added to the Object or
            // Function interface, since they have none by default. This is a bit of a leap of faith
            // that the user will not add any.
            var callSignatures = getSignaturesOfType(apparentType, 0 /* Call */);
            var numConstructSignatures = getSignaturesOfType(apparentType, 1 /* Construct */).length;
            // TS 1.0 Spec: 4.12
            // In an untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual
            // types are provided for the argument expressions, and the result is always of type Any.
            if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures)) {
                // The unknownType indicates that an error already occurred (and was reported).  No
                // need to report another error in this case.
                if (funcType !== errorType && node.typeArguments) {
                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
                }
                return resolveUntypedCall(node);
            }
            // If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.
            // TypeScript employs overload resolution in typed function calls in order to support functions
            // with multiple call signatures.
            if (!callSignatures.length) {
                if (numConstructSignatures) {
                    error(node, ts.Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
                }
                else {
                    var relatedInformation = void 0;
                    if (node.arguments.length === 1) {
                        var text = ts.getSourceFileOfNode(node).text;
                        if (ts.isLineBreak(text.charCodeAt(ts.skipTrivia(text, node.expression.end, /* stopAfterLineBreak */ true) - 1))) {
                            relatedInformation = ts.createDiagnosticForNode(node.expression, ts.Diagnostics.Are_you_missing_a_semicolon);
                        }
                    }
                    invocationError(node.expression, apparentType, 0 /* Call */, relatedInformation);
                }
                return resolveErrorCall(node);
            }
            // When a call to a generic function is an argument to an outer call to a generic function for which
            // inference is in process, we have a choice to make. If the inner call relies on inferences made from
            // its contextual type to its return type, deferring the inner call processing allows the best possible
            // contextual type to accumulate. But if the outer call relies on inferences made from the return type of
            // the inner call, the inner call should be processed early. There's no sure way to know which choice is
            // right (only a full unification algorithm can determine that), so we resort to the following heuristic:
            // If no type arguments are specified in the inner call and at least one call signature is generic and
            // returns a function type, we choose to defer processing. This narrowly permits function composition
            // operators to flow inferences through return types, but otherwise processes calls right away. We
            // use the resolvingSignature singleton to indicate that we deferred processing. This result will be
            // propagated out and eventually turned into nonInferrableType (a type that is assignable to anything and
            // from which we never make inferences).
            if (checkMode & 8 /* SkipGenericFunctions */ && !node.typeArguments && callSignatures.some(isGenericFunctionReturningFunction)) {
                skippedGenericFunction(node, checkMode);
                return resolvingSignature;
            }
            // If the function is explicitly marked with `@class`, then it must be constructed.
            if (callSignatures.some(function (sig) { return ts.isInJSFile(sig.declaration) && !!ts.getJSDocClassTag(sig.declaration); })) {
                error(node, ts.Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
                return resolveErrorCall(node);
            }
            return resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags);
        }
        function isGenericFunctionReturningFunction(signature) {
            return !!(signature.typeParameters && isFunctionType(getReturnTypeOfSignature(signature)));
        }
        /**
         * TS 1.0 spec: 4.12
         * If FuncExpr is of type Any, or of an object type that has no call or construct signatures
         * but is a subtype of the Function interface, the call is an untyped function call.
         */
        function isUntypedFunctionCall(funcType, apparentFuncType, numCallSignatures, numConstructSignatures) {
            // We exclude union types because we may have a union of function types that happen to have no common signatures.
            return isTypeAny(funcType) || isTypeAny(apparentFuncType) && !!(funcType.flags & 262144 /* TypeParameter */) ||
                !numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags & 1048576 /* Union */) && !(getReducedType(apparentFuncType).flags & 131072 /* Never */) && isTypeAssignableTo(funcType, globalFunctionType);
        }
        function resolveNewExpression(node, candidatesOutArray, checkMode) {
            if (node.arguments && languageVersion < 1 /* ES5 */) {
                var spreadIndex = getSpreadArgumentIndex(node.arguments);
                if (spreadIndex >= 0) {
                    error(node.arguments[spreadIndex], ts.Diagnostics.Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher);
                }
            }
            var expressionType = checkNonNullExpression(node.expression);
            if (expressionType === silentNeverType) {
                return silentNeverSignature;
            }
            // If expressionType's apparent type(section 3.8.1) is an object type with one or
            // more construct signatures, the expression is processed in the same manner as a
            // function call, but using the construct signatures as the initial set of candidate
            // signatures for overload resolution. The result type of the function call becomes
            // the result type of the operation.
            expressionType = getApparentType(expressionType);
            if (expressionType === errorType) {
                // Another error has already been reported
                return resolveErrorCall(node);
            }
            // TS 1.0 spec: 4.11
            // If expressionType is of type Any, Args can be any argument
            // list and the result of the operation is of type Any.
            if (isTypeAny(expressionType)) {
                if (node.typeArguments) {
                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
                }
                return resolveUntypedCall(node);
            }
            // Technically, this signatures list may be incomplete. We are taking the apparent type,
            // but we are not including construct signatures that may have been added to the Object or
            // Function interface, since they have none by default. This is a bit of a leap of faith
            // that the user will not add any.
            var constructSignatures = getSignaturesOfType(expressionType, 1 /* Construct */);
            if (constructSignatures.length) {
                if (!isConstructorAccessible(node, constructSignatures[0])) {
                    return resolveErrorCall(node);
                }
                // If the expression is a class of abstract type, or an abstract construct signature,
                // then it cannot be instantiated.
                // In the case of a merged class-module or class-interface declaration,
                // only the class declaration node will have the Abstract flag set.
                if (constructSignatures.some(function (signature) { return signature.flags & 4 /* Abstract */; })) {
                    error(node, ts.Diagnostics.Cannot_create_an_instance_of_an_abstract_class);
                    return resolveErrorCall(node);
                }
                var valueDecl = expressionType.symbol && ts.getClassLikeDeclarationOfSymbol(expressionType.symbol);
                if (valueDecl && ts.hasSyntacticModifier(valueDecl, 128 /* Abstract */)) {
                    error(node, ts.Diagnostics.Cannot_create_an_instance_of_an_abstract_class);
                    return resolveErrorCall(node);
                }
                return resolveCall(node, constructSignatures, candidatesOutArray, checkMode, 0 /* None */);
            }
            // If expressionType's apparent type is an object type with no construct signatures but
            // one or more call signatures, the expression is processed as a function call. A compile-time
            // error occurs if the result of the function call is not Void. The type of the result of the
            // operation is Any. It is an error to have a Void this type.
            var callSignatures = getSignaturesOfType(expressionType, 0 /* Call */);
            if (callSignatures.length) {
                var signature = resolveCall(node, callSignatures, candidatesOutArray, checkMode, 0 /* None */);
                if (!noImplicitAny) {
                    if (signature.declaration && !isJSConstructor(signature.declaration) && getReturnTypeOfSignature(signature) !== voidType) {
                        error(node, ts.Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);
                    }
                    if (getThisTypeOfSignature(signature) === voidType) {
                        error(node, ts.Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void);
                    }
                }
                return signature;
            }
            invocationError(node.expression, expressionType, 1 /* Construct */);
            return resolveErrorCall(node);
        }
        function typeHasProtectedAccessibleBase(target, type) {
            var baseTypes = getBaseTypes(type);
            if (!ts.length(baseTypes)) {
                return false;
            }
            var firstBase = baseTypes[0];
            if (firstBase.flags & 2097152 /* Intersection */) {
                var types = firstBase.types;
                var mixinFlags = findMixins(types);
                var i = 0;
                for (var _i = 0, _a = firstBase.types; _i < _a.length; _i++) {
                    var intersectionMember = _a[_i];
                    // We want to ignore mixin ctors
                    if (!mixinFlags[i]) {
                        if (ts.getObjectFlags(intersectionMember) & (1 /* Class */ | 2 /* Interface */)) {
                            if (intersectionMember.symbol === target) {
                                return true;
                            }
                            if (typeHasProtectedAccessibleBase(target, intersectionMember)) {
                                return true;
                            }
                        }
                    }
                    i++;
                }
                return false;
            }
            if (firstBase.symbol === target) {
                return true;
            }
            return typeHasProtectedAccessibleBase(target, firstBase);
        }
        function isConstructorAccessible(node, signature) {
            if (!signature || !signature.declaration) {
                return true;
            }
            var declaration = signature.declaration;
            var modifiers = ts.getSelectedEffectiveModifierFlags(declaration, 24 /* NonPublicAccessibilityModifier */);
            // (1) Public constructors and (2) constructor functions are always accessible.
            if (!modifiers || declaration.kind !== 169 /* Constructor */) {
                return true;
            }
            var declaringClassDeclaration = ts.getClassLikeDeclarationOfSymbol(declaration.parent.symbol);
            var declaringClass = getDeclaredTypeOfSymbol(declaration.parent.symbol);
            // A private or protected constructor can only be instantiated within its own class (or a subclass, for protected)
            if (!isNodeWithinClass(node, declaringClassDeclaration)) {
                var containingClass = ts.getContainingClass(node);
                if (containingClass && modifiers & 16 /* Protected */) {
                    var containingType = getTypeOfNode(containingClass);
                    if (typeHasProtectedAccessibleBase(declaration.parent.symbol, containingType)) {
                        return true;
                    }
                }
                if (modifiers & 8 /* Private */) {
                    error(node, ts.Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
                }
                if (modifiers & 16 /* Protected */) {
                    error(node, ts.Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
                }
                return false;
            }
            return true;
        }
        function invocationErrorDetails(errorTarget, apparentType, kind) {
            var errorInfo;
            var isCall = kind === 0 /* Call */;
            var awaitedType = getAwaitedType(apparentType);
            var maybeMissingAwait = awaitedType && getSignaturesOfType(awaitedType, kind).length > 0;
            if (apparentType.flags & 1048576 /* Union */) {
                var types = apparentType.types;
                var hasSignatures = false;
                for (var _i = 0, types_20 = types; _i < types_20.length; _i++) {
                    var constituent = types_20[_i];
                    var signatures = getSignaturesOfType(constituent, kind);
                    if (signatures.length !== 0) {
                        hasSignatures = true;
                        if (errorInfo) {
                            // Bail early if we already have an error, no chance of "No constituent of type is callable"
                            break;
                        }
                    }
                    else {
                        // Error on the first non callable constituent only
                        if (!errorInfo) {
                            errorInfo = ts.chainDiagnosticMessages(errorInfo, isCall ?
                                ts.Diagnostics.Type_0_has_no_call_signatures :
                                ts.Diagnostics.Type_0_has_no_construct_signatures, typeToString(constituent));
                            errorInfo = ts.chainDiagnosticMessages(errorInfo, isCall ?
                                ts.Diagnostics.Not_all_constituents_of_type_0_are_callable :
                                ts.Diagnostics.Not_all_constituents_of_type_0_are_constructable, typeToString(apparentType));
                        }
                        if (hasSignatures) {
                            // Bail early if we already found a siganture, no chance of "No constituent of type is callable"
                            break;
                        }
                    }
                }
                if (!hasSignatures) {
                    errorInfo = ts.chainDiagnosticMessages(
                    /* detials */ undefined, isCall ?
                        ts.Diagnostics.No_constituent_of_type_0_is_callable :
                        ts.Diagnostics.No_constituent_of_type_0_is_constructable, typeToString(apparentType));
                }
                if (!errorInfo) {
                    errorInfo = ts.chainDiagnosticMessages(errorInfo, isCall ?
                        ts.Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other :
                        ts.Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other, typeToString(apparentType));
                }
            }
            else {
                errorInfo = ts.chainDiagnosticMessages(errorInfo, isCall ?
                    ts.Diagnostics.Type_0_has_no_call_signatures :
                    ts.Diagnostics.Type_0_has_no_construct_signatures, typeToString(apparentType));
            }
            var headMessage = isCall ? ts.Diagnostics.This_expression_is_not_callable : ts.Diagnostics.This_expression_is_not_constructable;
            // Diagnose get accessors incorrectly called as functions
            if (ts.isCallExpression(errorTarget.parent) && errorTarget.parent.arguments.length === 0) {
                var resolvedSymbol = getNodeLinks(errorTarget).resolvedSymbol;
                if (resolvedSymbol && resolvedSymbol.flags & 32768 /* GetAccessor */) {
                    headMessage = ts.Diagnostics.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without;
                }
            }
            return {
                messageChain: ts.chainDiagnosticMessages(errorInfo, headMessage),
                relatedMessage: maybeMissingAwait ? ts.Diagnostics.Did_you_forget_to_use_await : undefined,
            };
        }
        function invocationError(errorTarget, apparentType, kind, relatedInformation) {
            var _a = invocationErrorDetails(errorTarget, apparentType, kind), messageChain = _a.messageChain, relatedInfo = _a.relatedMessage;
            var diagnostic = ts.createDiagnosticForNodeFromMessageChain(errorTarget, messageChain);
            if (relatedInfo) {
                ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(errorTarget, relatedInfo));
            }
            if (ts.isCallExpression(errorTarget.parent)) {
                var _b = getDiagnosticSpanForCallNode(errorTarget.parent, /* doNotIncludeArguments */ true), start = _b.start, length_8 = _b.length;
                diagnostic.start = start;
                diagnostic.length = length_8;
            }
            diagnostics.add(diagnostic);
            invocationErrorRecovery(apparentType, kind, relatedInformation ? ts.addRelatedInfo(diagnostic, relatedInformation) : diagnostic);
        }
        function invocationErrorRecovery(apparentType, kind, diagnostic) {
            if (!apparentType.symbol) {
                return;
            }
            var importNode = getSymbolLinks(apparentType.symbol).originatingImport;
            // Create a diagnostic on the originating import if possible onto which we can attach a quickfix
            //  An import call expression cannot be rewritten into another form to correct the error - the only solution is to use `.default` at the use-site
            if (importNode && !ts.isImportCall(importNode)) {
                var sigs = getSignaturesOfType(getTypeOfSymbol(getSymbolLinks(apparentType.symbol).target), kind);
                if (!sigs || !sigs.length)
                    return;
                ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(importNode, ts.Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead));
            }
        }
        function resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode) {
            var tagType = checkExpression(node.tag);
            var apparentType = getApparentType(tagType);
            if (apparentType === errorType) {
                // Another error has already been reported
                return resolveErrorCall(node);
            }
            var callSignatures = getSignaturesOfType(apparentType, 0 /* Call */);
            var numConstructSignatures = getSignaturesOfType(apparentType, 1 /* Construct */).length;
            if (isUntypedFunctionCall(tagType, apparentType, callSignatures.length, numConstructSignatures)) {
                return resolveUntypedCall(node);
            }
            if (!callSignatures.length) {
                if (ts.isArrayLiteralExpression(node.parent)) {
                    var diagnostic = ts.createDiagnosticForNode(node.tag, ts.Diagnostics.It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked);
                    diagnostics.add(diagnostic);
                    return resolveErrorCall(node);
                }
                invocationError(node.tag, apparentType, 0 /* Call */);
                return resolveErrorCall(node);
            }
            return resolveCall(node, callSignatures, candidatesOutArray, checkMode, 0 /* None */);
        }
        /**
         * Gets the localized diagnostic head message to use for errors when resolving a decorator as a call expression.
         */
        function getDiagnosticHeadMessageForDecoratorResolution(node) {
            switch (node.parent.kind) {
                case 255 /* ClassDeclaration */:
                case 224 /* ClassExpression */:
                    return ts.Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;
                case 162 /* Parameter */:
                    return ts.Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;
                case 165 /* PropertyDeclaration */:
                    return ts.Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;
                case 167 /* MethodDeclaration */:
                case 170 /* GetAccessor */:
                case 171 /* SetAccessor */:
                    return ts.Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;
                default:
                    return ts.Debug.fail();
            }
        }
        /**
         * Resolves a decorator as if it were a call expression.
         */
        function resolveDecorator(node, candidatesOutArray, checkMode) {
            var funcType = checkExpression(node.expression);
            var apparentType = getApparentType(funcType);
            if (apparentType === errorType) {
                return resolveErrorCall(node);
            }
            var callSignatures = getSignaturesOfType(apparentType, 0 /* Call */);
            var numConstructSignatures = getSignaturesOfType(apparentType, 1 /* Construct */).length;
            if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures)) {
                return resolveUntypedCall(node);
            }
            if (isPotentiallyUncalledDecorator(node, callSignatures)) {
                var nodeStr = ts.getTextOfNode(node.expression, /*includeTrivia*/ false);
                error(node, ts.Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0, nodeStr);
                return resolveErrorCall(node);
            }
            var headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
            if (!callSignatures.length) {
                var errorDetails = invocationErrorDetails(node.expression, apparentType, 0 /* Call */);
                var messageChain = ts.chainDiagnosticMessages(errorDetails.messageChain, headMessage);
                var diag = ts.createDiagnosticForNodeFromMessageChain(node.expression, messageChain);
                if (errorDetails.relatedMessage) {
                    ts.addRelatedInfo(diag, ts.createDiagnosticForNode(node.expression, errorDetails.relatedMessage));
                }
                diagnostics.add(diag);
                invocationErrorRecovery(apparentType, 0 /* Call */, diag);
                return resolveErrorCall(node);
            }
            return resolveCall(node, callSignatures, candidatesOutArray, checkMode, 0 /* None */, headMessage);
        }
        function createSignatureForJSXIntrinsic(node, result) {
            var namespace = getJsxNamespaceAt(node);
            var exports = namespace && getExportsOfSymbol(namespace);
            // We fake up a SFC signature for each intrinsic, however a more specific per-element signature drawn from the JSX declaration
            // file would probably be preferable.
            var typeSymbol = exports && getSymbol(exports, JsxNames.Element, 788968 /* Type */);
            var returnNode = typeSymbol && nodeBuilder.symbolToEntityName(typeSymbol, 788968 /* Type */, node);
            var declaration = ts.factory.createFunctionTypeNode(/*typeParameters*/ undefined, [ts.factory.createParameterDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotdotdot*/ undefined, "props", /*questionMark*/ undefined, nodeBuilder.typeToTypeNode(result, node))], returnNode ? ts.factory.createTypeReferenceNode(returnNode, /*typeArguments*/ undefined) : ts.factory.createKeywordTypeNode(129 /* AnyKeyword */));
            var parameterSymbol = createSymbol(1 /* FunctionScopedVariable */, "props");
            parameterSymbol.type = result;
            return createSignature(declaration, 
            /*typeParameters*/ undefined, 
            /*thisParameter*/ undefined, [parameterSymbol], typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType, 
            /*returnTypePredicate*/ undefined, 1, 0 /* None */);
        }
        function resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode) {
            if (isJsxIntrinsicIdentifier(node.tagName)) {
                var result = getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node);
                var fakeSignature = createSignatureForJSXIntrinsic(node, result);
                checkTypeAssignableToAndOptionallyElaborate(checkExpressionWithContextualType(node.attributes, getEffectiveFirstArgumentForJsxSignature(fakeSignature, node), /*mapper*/ undefined, 0 /* Normal */), result, node.tagName, node.attributes);
                if (ts.length(node.typeArguments)) {
                    ts.forEach(node.typeArguments, checkSourceElement);
                    diagnostics.add(ts.createDiagnosticForNodeArray(ts.getSourceFileOfNode(node), node.typeArguments, ts.Diagnostics.Expected_0_type_arguments_but_got_1, 0, ts.length(node.typeArguments)));
                }
                return fakeSignature;
            }
            var exprTypes = checkExpression(node.tagName);
            var apparentType = getApparentType(exprTypes);
            if (apparentType === errorType) {
                return resolveErrorCall(node);
            }
            var signatures = getUninstantiatedJsxSignaturesOfType(exprTypes, node);
            if (isUntypedFunctionCall(exprTypes, apparentType, signatures.length, /*constructSignatures*/ 0)) {
                return resolveUntypedCall(node);
            }
            if (signatures.length === 0) {
                // We found no signatures at all, which is an error
                error(node.tagName, ts.Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, ts.getTextOfNode(node.tagName));
                return resolveErrorCall(node);
            }
            return resolveCall(node, signatures, candidatesOutArray, checkMode, 0 /* None */);
        }
        /**
         * Sometimes, we have a decorator that could accept zero arguments,
         * but is receiving too many arguments as part of the decorator invocation.
         * In those cases, a user may have meant to *call* the expression before using it as a decorator.
         */
        function isPotentiallyUncalledDecorator(decorator, signatures) {
            return signatures.length && ts.every(signatures, function (signature) {
                return signature.minArgumentCount === 0 &&
                    !signatureHasRestParameter(signature) &&
                    signature.parameters.length < getDecoratorArgumentCount(decorator, signature);
            });
        }
        function resolveSignature(node, candidatesOutArray, checkMode) {
            switch (node.kind) {
                case 206 /* CallExpression */:
                    return resolveCallExpression(node, candidatesOutArray, checkMode);
                case 207 /* NewExpression */:
                    return resolveNewExpression(node, candidatesOutArray, checkMode);
                case 208 /* TaggedTemplateExpression */:
                    return resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode);
                case 163 /* Decorator */:
                    return resolveDecorator(node, candidatesOutArray, checkMode);
                case 278 /* JsxOpeningElement */:
                case 277 /* JsxSelfClosingElement */:
                    return resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode);
            }
            throw ts.Debug.assertNever(node, "Branch in 'resolveSignature' should be unreachable.");
        }
        /**
         * Resolve a signature of a given call-like expression.
         * @param node a call-like expression to try resolve a signature for
         * @param candidatesOutArray an array of signature to be filled in by the function. It is passed by signature help in the language service;
         *                           the function will fill it up with appropriate candidate signatures
         * @return a signature of the call-like expression or undefined if one can't be found
         */
        function getResolvedSignature(node, candidatesOutArray, checkMode) {
            var links = getNodeLinks(node);
            // If getResolvedSignature has already been called, we will have cached the resolvedSignature.
            // However, it is possible that either candidatesOutArray was not passed in the first time,
            // or that a different candidatesOutArray was passed in. Therefore, we need to redo the work
            // to correctly fill the candidatesOutArray.
            var cached = links.resolvedSignature;
            if (cached && cached !== resolvingSignature && !candidatesOutArray) {
                return cached;
            }
            links.resolvedSignature = resolvingSignature;
            var result = resolveSignature(node, candidatesOutArray, checkMode || 0 /* Normal */);
            // When CheckMode.SkipGenericFunctions is set we use resolvingSignature to indicate that call
            // resolution should be deferred.
            if (result !== resolvingSignature) {
                // If signature resolution originated in control flow type analysis (for example to compute the
                // assigned type in a flow assignment) we don't cache the result as it may be based on temporary
                // types from the control flow analysis.
                links.resolvedSignature = flowLoopStart === flowLoopCount ? result : cached;
            }
            return result;
        }
        /**
         * Indicates whether a declaration can be treated as a constructor in a JavaScript
         * file.
         */
        function isJSConstructor(node) {
            var _a;
            if (!node || !ts.isInJSFile(node)) {
                return false;
            }
            var func = ts.isFunctionDeclaration(node) || ts.isFunctionExpression(node) ? node :
                ts.isVariableDeclaration(node) && node.initializer && ts.isFunctionExpression(node.initializer) ? node.initializer :
                    undefined;
            if (func) {
                // If the node has a @class tag, treat it like a constructor.
                if (ts.getJSDocClassTag(node))
                    return true;
                // If the symbol of the node has members, treat it like a constructor.
                var symbol = getSymbolOfNode(func);
                return !!((_a = symbol === null || symbol === void 0 ? void 0 : symbol.members) === null || _a === void 0 ? void 0 : _a.size);
            }
            return false;
        }
        function mergeJSSymbols(target, source) {
            var _a, _b;
            if (source) {
                var links = getSymbolLinks(source);
                if (!links.inferredClassSymbol || !links.inferredClassSymbol.has(getSymbolId(target))) {
                    var inferred = ts.isTransientSymbol(target) ? target : cloneSymbol(target);
                    inferred.exports = inferred.exports || ts.createSymbolTable();
                    inferred.members = inferred.members || ts.createSymbolTable();
                    inferred.flags |= source.flags & 32 /* Class */;
                    if ((_a = source.exports) === null || _a === void 0 ? void 0 : _a.size) {
                        mergeSymbolTable(inferred.exports, source.exports);
                    }
                    if ((_b = source.members) === null || _b === void 0 ? void 0 : _b.size) {
                        mergeSymbolTable(inferred.members, source.members);
                    }
                    (links.inferredClassSymbol || (links.inferredClassSymbol = new ts.Map())).set(getSymbolId(inferred), inferred);
                    return inferred;
                }
                return links.inferredClassSymbol.get(getSymbolId(target));
            }
        }
        function getAssignedClassSymbol(decl) {
            var _a;
            var assignmentSymbol = decl && getSymbolOfExpando(decl, /*allowDeclaration*/ true);
            var prototype = (_a = assignmentSymbol === null || assignmentSymbol === void 0 ? void 0 : assignmentSymbol.exports) === null || _a === void 0 ? void 0 : _a.get("prototype");
            var init = (prototype === null || prototype === void 0 ? void 0 : prototype.valueDeclaration) && getAssignedJSPrototype(prototype.valueDeclaration);
            return init ? getSymbolOfNode(init) : undefined;
        }
        function getSymbolOfExpando(node, allowDeclaration) {
            if (!node.parent) {
                return undefined;
            }
            var name;
            var decl;
            if (ts.isVariableDeclaration(node.parent) && node.parent.initializer === node) {
                if (!ts.isInJSFile(node) && !(ts.isVarConst(node.parent) && ts.isFunctionLikeDeclaration(node))) {
                    return undefined;
                }
                name = node.parent.name;
                decl = node.parent;
            }
            else if (ts.isBinaryExpression(node.parent)) {
                var parentNode = node.parent;
                var parentNodeOperator = node.parent.operatorToken.kind;
                if (parentNodeOperator === 63 /* EqualsToken */ && (allowDeclaration || parentNode.right === node)) {
                    name = parentNode.left;
                    decl = name;
                }
                else if (parentNodeOperator === 56 /* BarBarToken */ || parentNodeOperator === 60 /* QuestionQuestionToken */) {
                    if (ts.isVariableDeclaration(parentNode.parent) && parentNode.parent.initializer === parentNode) {
                        name = parentNode.parent.name;
                        decl = parentNode.parent;
                    }
                    else if (ts.isBinaryExpression(parentNode.parent) && parentNode.parent.operatorToken.kind === 63 /* EqualsToken */ && (allowDeclaration || parentNode.parent.right === parentNode)) {
                        name = parentNode.parent.left;
                        decl = name;
                    }
                    if (!name || !ts.isBindableStaticNameExpression(name) || !ts.isSameEntityName(name, parentNode.left)) {
                        return undefined;
                    }
                }
            }
            else if (allowDeclaration && ts.isFunctionDeclaration(node)) {
                name = node.name;
                decl = node;
            }
            if (!decl || !name || (!allowDeclaration && !ts.getExpandoInitializer(node, ts.isPrototypeAccess(name)))) {
                return undefined;
            }
            return getSymbolOfNode(decl);
        }
        function getAssignedJSPrototype(node) {
            if (!node.parent) {
                return false;
            }
            var parent = node.parent;
            while (parent && parent.kind === 204 /* PropertyAccessExpression */) {
                parent = parent.parent;
            }
            if (parent && ts.isBinaryExpression(parent) && ts.isPrototypeAccess(parent.left) && parent.operatorToken.kind === 63 /* EqualsToken */) {
                var right = ts.getInitializerOfBinaryExpression(parent);
                return ts.isObjectLiteralExpression(right) && right;
            }
        }
        /**
         * Syntactically and semantically checks a call or new expression.
         * @param node The call/new expression to be checked.
         * @returns On success, the expression's signature's return type. On failure, anyType.
         */
        function checkCallExpression(node, checkMode) {
            var _a;
            if (!checkGrammarTypeArguments(node, node.typeArguments))
                checkGrammarArguments(node.arguments);
            var signature = getResolvedSignature(node, /*candidatesOutArray*/ undefined, checkMode);
            if (signature === resolvingSignature) {
                // CheckMode.SkipGenericFunctions is enabled and this is a call to a generic function that
                // returns a function type. We defer checking and return nonInferrableType.
                return nonInferrableType;
            }
            checkDeprecatedSignature(signature, node);
            if (node.expression.kind === 106 /* SuperKeyword */) {
                return voidType;
            }
            if (node.kind === 207 /* NewExpression */) {
                var declaration = signature.declaration;
                if (declaration &&
                    declaration.kind !== 169 /* Constructor */ &&
                    declaration.kind !== 173 /* ConstructSignature */ &&
                    declaration.kind !== 178 /* ConstructorType */ &&
                    !ts.isJSDocConstructSignature(declaration) &&
                    !isJSConstructor(declaration)) {
                    // When resolved signature is a call signature (and not a construct signature) the result type is any
                    if (noImplicitAny) {
                        error(node, ts.Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);
                    }
                    return anyType;
                }
            }
            // In JavaScript files, calls to any identifier 'require' are treated as external module imports
            if (ts.isInJSFile(node) && isCommonJsRequire(node)) {
                return resolveExternalModuleTypeByLiteral(node.arguments[0]);
            }
            var returnType = getReturnTypeOfSignature(signature);
            // Treat any call to the global 'Symbol' function that is part of a const variable or readonly property
            // as a fresh unique symbol literal type.
            if (returnType.flags & 12288 /* ESSymbolLike */ && isSymbolOrSymbolForCall(node)) {
                return getESSymbolLikeTypeForNode(ts.walkUpParenthesizedExpressions(node.parent));
            }
            if (node.kind === 206 /* CallExpression */ && !node.questionDotToken && node.parent.kind === 236 /* ExpressionStatement */ &&
                returnType.flags & 16384 /* Void */ && getTypePredicateOfSignature(signature)) {
                if (!ts.isDottedName(node.expression)) {
                    error(node.expression, ts.Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name);
                }
                else if (!getEffectsSignature(node)) {
                    var diagnostic = error(node.expression, ts.Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation);
                    getTypeOfDottedName(node.expression, diagnostic);
                }
            }
            if (ts.isInJSFile(node)) {
                var jsSymbol = getSymbolOfExpando(node, /*allowDeclaration*/ false);
                if ((_a = jsSymbol === null || jsSymbol === void 0 ? void 0 : jsSymbol.exports) === null || _a === void 0 ? void 0 : _a.size) {
                    var jsAssignmentType = createAnonymousType(jsSymbol, jsSymbol.exports, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                    jsAssignmentType.objectFlags |= 8192 /* JSLiteral */;
                    return getIntersectionType([returnType, jsAssignmentType]);
                }
            }
            return returnType;
        }
        function checkDeprecatedSignature(signature, node) {
            if (signature.declaration && signature.declaration.flags & 134217728 /* Deprecated */) {
                var suggestionNode = getDeprecatedSuggestionNode(node);
                var name = ts.tryGetPropertyAccessOrIdentifierToString(ts.getInvokedExpression(node));
                addDeprecatedSuggestionWithSignature(suggestionNode, signature.declaration, name, signatureToString(signature));
            }
        }
        function getDeprecatedSuggestionNode(node) {
            node = ts.skipParentheses(node);
            switch (node.kind) {
                case 206 /* CallExpression */:
                case 163 /* Decorator */:
                case 207 /* NewExpression */:
                    return getDeprecatedSuggestionNode(node.expression);
                case 208 /* TaggedTemplateExpression */:
                    return getDeprecatedSuggestionNode(node.tag);
                case 278 /* JsxOpeningElement */:
                case 277 /* JsxSelfClosingElement */:
                    return getDeprecatedSuggestionNode(node.tagName);
                case 205 /* ElementAccessExpression */:
                    return node.argumentExpression;
                case 204 /* PropertyAccessExpression */:
                    return node.name;
                case 176 /* TypeReference */:
                    var typeReference = node;
                    return ts.isQualifiedName(typeReference.typeName) ? typeReference.typeName.right : typeReference;
                default:
                    return node;
            }
        }
        function isSymbolOrSymbolForCall(node) {
            if (!ts.isCallExpression(node))
                return false;
            var left = node.expression;
            if (ts.isPropertyAccessExpression(left) && left.name.escapedText === "for") {
                left = left.expression;
            }
            if (!ts.isIdentifier(left) || left.escapedText !== "Symbol") {
                return false;
            }
            // make sure `Symbol` is the global symbol
            var globalESSymbol = getGlobalESSymbolConstructorSymbol(/*reportErrors*/ false);
            if (!globalESSymbol) {
                return false;
            }
            return globalESSymbol === resolveName(left, "Symbol", 111551 /* Value */, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false);
        }
        function checkImportCallExpression(node) {
            // Check grammar of dynamic import
            if (!checkGrammarArguments(node.arguments))
                checkGrammarImportCallExpression(node);
            if (node.arguments.length === 0) {
                return createPromiseReturnType(node, anyType);
            }
            var specifier = node.arguments[0];
            var specifierType = checkExpressionCached(specifier);
            // Even though multiple arguments is grammatically incorrect, type-check extra arguments for completion
            for (var i = 1; i < node.arguments.length; ++i) {
                checkExpressionCached(node.arguments[i]);
            }
            if (specifierType.flags & 32768 /* Undefined */ || specifierType.flags & 65536 /* Null */ || !isTypeAssignableTo(specifierType, stringType)) {
                error(specifier, ts.Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0, typeToString(specifierType));
            }
            // resolveExternalModuleName will return undefined if the moduleReferenceExpression is not a string literal
            var moduleSymbol = resolveExternalModuleName(node, specifier);
            if (moduleSymbol) {
                var esModuleSymbol = resolveESModuleSymbol(moduleSymbol, specifier, /*dontRecursivelyResolve*/ true, /*suppressUsageError*/ false);
                if (esModuleSymbol) {
                    return createPromiseReturnType(node, getTypeWithSyntheticDefaultImportType(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol));
                }
            }
            return createPromiseReturnType(node, anyType);
        }
        function getTypeWithSyntheticDefaultImportType(type, symbol, originalSymbol) {
            var _a;
            if (allowSyntheticDefaultImports && type && type !== errorType) {
                var synthType = type;
                if (!synthType.syntheticType) {
                    var file = (_a = originalSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isSourceFile);
                    var hasSyntheticDefault = canHaveSyntheticDefault(file, originalSymbol, /*dontResolveAlias*/ false);
                    if (hasSyntheticDefault) {
                        var memberTable = ts.createSymbolTable();
                        var newSymbol = createSymbol(2097152 /* Alias */, "default" /* Default */);
                        newSymbol.parent = originalSymbol;
                        newSymbol.nameType = getStringLiteralType("default");
                        newSymbol.target = resolveSymbol(symbol);
                        memberTable.set("default" /* Default */, newSymbol);
                        var anonymousSymbol = createSymbol(2048 /* TypeLiteral */, "__type" /* Type */);
                        var defaultContainingObject = createAnonymousType(anonymousSymbol, memberTable, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                        anonymousSymbol.type = defaultContainingObject;
                        synthType.syntheticType = isValidSpreadType(type) ? getSpreadType(type, defaultContainingObject, anonymousSymbol, /*objectFlags*/ 0, /*readonly*/ false) : defaultContainingObject;
                    }
                    else {
                        synthType.syntheticType = type;
                    }
                }
                return synthType.syntheticType;
            }
            return type;
        }
        function isCommonJsRequire(node) {
            if (!ts.isRequireCall(node, /*checkArgumentIsStringLiteralLike*/ true)) {
                return false;
            }
            // Make sure require is not a local function
            if (!ts.isIdentifier(node.expression))
                return ts.Debug.fail();
            var resolvedRequire = resolveName(node.expression, node.expression.escapedText, 111551 /* Value */, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ true); // TODO: GH#18217
            if (resolvedRequire === requireSymbol) {
                return true;
            }
            // project includes symbol named 'require' - make sure that it is ambient and local non-alias
            if (resolvedRequire.flags & 2097152 /* Alias */) {
                return false;
            }
            var targetDeclarationKind = resolvedRequire.flags & 16 /* Function */
                ? 254 /* FunctionDeclaration */
                : resolvedRequire.flags & 3 /* Variable */
                    ? 252 /* VariableDeclaration */
                    : 0 /* Unknown */;
            if (targetDeclarationKind !== 0 /* Unknown */) {
                var decl = ts.getDeclarationOfKind(resolvedRequire, targetDeclarationKind);
                // function/variable declaration should be ambient
                return !!decl && !!(decl.flags & 8388608 /* Ambient */);
            }
            return false;
        }
        function checkTaggedTemplateExpression(node) {
            if (!checkGrammarTaggedTemplateChain(node))
                checkGrammarTypeArguments(node, node.typeArguments);
            if (languageVersion < 2 /* ES2015 */) {
                checkExternalEmitHelpers(node, 262144 /* MakeTemplateObject */);
            }
            var signature = getResolvedSignature(node);
            checkDeprecatedSignature(signature, node);
            return getReturnTypeOfSignature(signature);
        }
        function checkAssertion(node) {
            return checkAssertionWorker(node, node.type, node.expression);
        }
        function isValidConstAssertionArgument(node) {
            switch (node.kind) {
                case 10 /* StringLiteral */:
                case 14 /* NoSubstitutionTemplateLiteral */:
                case 8 /* NumericLiteral */:
                case 9 /* BigIntLiteral */:
                case 110 /* TrueKeyword */:
                case 95 /* FalseKeyword */:
                case 202 /* ArrayLiteralExpression */:
                case 203 /* ObjectLiteralExpression */:
                case 221 /* TemplateExpression */:
                    return true;
                case 210 /* ParenthesizedExpression */:
                    return isValidConstAssertionArgument(node.expression);
                case 217 /* PrefixUnaryExpression */:
                    var op = node.operator;
                    var arg = node.operand;
                    return op === 40 /* MinusToken */ && (arg.kind === 8 /* NumericLiteral */ || arg.kind === 9 /* BigIntLiteral */) ||
                        op === 39 /* PlusToken */ && arg.kind === 8 /* NumericLiteral */;
                case 204 /* PropertyAccessExpression */:
                case 205 /* ElementAccessExpression */:
                    var expr = node.expression;
                    if (ts.isIdentifier(expr)) {
                        var symbol = getSymbolAtLocation(expr);
                        if (symbol && symbol.flags & 2097152 /* Alias */) {
                            symbol = resolveAlias(symbol);
                        }
                        return !!(symbol && (symbol.flags & 384 /* Enum */) && getEnumKind(symbol) === 1 /* Literal */);
                    }
            }
            return false;
        }
        function checkAssertionWorker(errNode, type, expression, checkMode) {
            var exprType = checkExpression(expression, checkMode);
            if (ts.isConstTypeReference(type)) {
                if (!isValidConstAssertionArgument(expression)) {
                    error(expression, ts.Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals);
                }
                return getRegularTypeOfLiteralType(exprType);
            }
            checkSourceElement(type);
            exprType = getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(exprType));
            var targetType = getTypeFromTypeNode(type);
            if (produceDiagnostics && targetType !== errorType) {
                var widenedType = getWidenedType(exprType);
                if (!isTypeComparableTo(targetType, widenedType)) {
                    checkTypeComparableTo(exprType, targetType, errNode, ts.Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first);
                }
            }
            return targetType;
        }
        function checkNonNullChain(node) {
            var leftType = checkExpression(node.expression);
            var nonOptionalType = getOptionalExpressionType(leftType, node.expression);
            return propagateOptionalTypeMarker(getNonNullableType(nonOptionalType), node, nonOptionalType !== leftType);
        }
        function checkNonNullAssertion(node) {
            return node.flags & 32 /* OptionalChain */ ? checkNonNullChain(node) :
                getNonNullableType(checkExpression(node.expression));
        }
        function checkMetaProperty(node) {
            checkGrammarMetaProperty(node);
            if (node.keywordToken === 103 /* NewKeyword */) {
                return checkNewTargetMetaProperty(node);
            }
            if (node.keywordToken === 100 /* ImportKeyword */) {
                return checkImportMetaProperty(node);
            }
            return ts.Debug.assertNever(node.keywordToken);
        }
        function checkMetaPropertyKeyword(node) {
            switch (node.keywordToken) {
                case 100 /* ImportKeyword */:
                    return getGlobalImportMetaExpressionType();
                case 103 /* NewKeyword */:
                    var type = checkNewTargetMetaProperty(node);
                    return type === errorType ? errorType : createNewTargetExpressionType(type);
                default:
                    ts.Debug.assertNever(node.keywordToken);
            }
        }
        function checkNewTargetMetaProperty(node) {
            var container = ts.getNewTargetContainer(node);
            if (!container) {
                error(node, ts.Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, "new.target");
                return errorType;
            }
            else if (container.kind === 169 /* Constructor */) {
                var symbol = getSymbolOfNode(container.parent);
                return getTypeOfSymbol(symbol);
            }
            else {
                var symbol = getSymbolOfNode(container);
                return getTypeOfSymbol(symbol);
            }
        }
        function checkImportMetaProperty(node) {
            if (moduleKind !== ts.ModuleKind.ES2020 && moduleKind !== ts.ModuleKind.ESNext && moduleKind !== ts.ModuleKind.System) {
                error(node, ts.Diagnostics.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_esnext_or_system);
            }
            var file = ts.getSourceFileOfNode(node);
            ts.Debug.assert(!!(file.flags & 2097152 /* PossiblyContainsImportMeta */), "Containing file is missing import meta node flag.");
            return node.name.escapedText === "meta" ? getGlobalImportMetaType() : errorType;
        }
        function getTypeOfParameter(symbol) {
            var type = getTypeOfSymbol(symbol);
            if (strictNullChecks) {
                var declaration = symbol.valueDeclaration;
                if (declaration && ts.hasInitializer(declaration)) {
                    return getOptionalType(type);
                }
            }
            return type;
        }
        function getTupleElementLabel(d) {
            ts.Debug.assert(ts.isIdentifier(d.name)); // Parameter declarations could be binding patterns, but we only allow identifier names
            return d.name.escapedText;
        }
        function getParameterNameAtPosition(signature, pos, overrideRestType) {
            var paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
            if (pos < paramCount) {
                return signature.parameters[pos].escapedName;
            }
            var restParameter = signature.parameters[paramCount] || unknownSymbol;
            var restType = overrideRestType || getTypeOfSymbol(restParameter);
            if (isTupleType(restType)) {
                var associatedNames = restType.target.labeledElementDeclarations;
                var index = pos - paramCount;
                return associatedNames && getTupleElementLabel(associatedNames[index]) || restParameter.escapedName + "_" + index;
            }
            return restParameter.escapedName;
        }
        function getParameterIdentifierNameAtPosition(signature, pos) {
            var paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
            if (pos < paramCount) {
                var param = signature.parameters[pos];
                return isParameterDeclarationWithIdentifierName(param) ? [param.escapedName, false] : undefined;
            }
            var restParameter = signature.parameters[paramCount] || unknownSymbol;
            if (!isParameterDeclarationWithIdentifierName(restParameter)) {
                return undefined;
            }
            var restType = getTypeOfSymbol(restParameter);
            if (isTupleType(restType)) {
                var associatedNames = restType.target.labeledElementDeclarations;
                var index = pos - paramCount;
                var associatedName = associatedNames === null || associatedNames === void 0 ? void 0 : associatedNames[index];
                var isRestTupleElement = !!(associatedName === null || associatedName === void 0 ? void 0 : associatedName.dotDotDotToken);
                return associatedName ? [
                    getTupleElementLabel(associatedName),
                    isRestTupleElement
                ] : undefined;
            }
            if (pos === paramCount) {
                return [restParameter.escapedName, true];
            }
            return undefined;
        }
        function isParameterDeclarationWithIdentifierName(symbol) {
            return symbol.valueDeclaration && ts.isParameter(symbol.valueDeclaration) && ts.isIdentifier(symbol.valueDeclaration.name);
        }
        function isValidDeclarationForTupleLabel(d) {
            return d.kind === 195 /* NamedTupleMember */ || (ts.isParameter(d) && d.name && ts.isIdentifier(d.name));
        }
        function getNameableDeclarationAtPosition(signature, pos) {
            var paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
            if (pos < paramCount) {
                var decl = signature.parameters[pos].valueDeclaration;
                return decl && isValidDeclarationForTupleLabel(decl) ? decl : undefined;
            }
            var restParameter = signature.parameters[paramCount] || unknownSymbol;
            var restType = getTypeOfSymbol(restParameter);
            if (isTupleType(restType)) {
                var associatedNames = restType.target.labeledElementDeclarations;
                var index = pos - paramCount;
                return associatedNames && associatedNames[index];
            }
            return restParameter.valueDeclaration && isValidDeclarationForTupleLabel(restParameter.valueDeclaration) ? restParameter.valueDeclaration : undefined;
        }
        function getTypeAtPosition(signature, pos) {
            return tryGetTypeAtPosition(signature, pos) || anyType;
        }
        function tryGetTypeAtPosition(signature, pos) {
            var paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
            if (pos < paramCount) {
                return getTypeOfParameter(signature.parameters[pos]);
            }
            if (signatureHasRestParameter(signature)) {
                // We want to return the value undefined for an out of bounds parameter position,
                // so we need to check bounds here before calling getIndexedAccessType (which
                // otherwise would return the type 'undefined').
                var restType = getTypeOfSymbol(signature.parameters[paramCount]);
                var index = pos - paramCount;
                if (!isTupleType(restType) || restType.target.hasRestElement || index < restType.target.fixedLength) {
                    return getIndexedAccessType(restType, getNumberLiteralType(index));
                }
            }
            return undefined;
        }
        function getRestTypeAtPosition(source, pos) {
            var parameterCount = getParameterCount(source);
            var minArgumentCount = getMinArgumentCount(source);
            var restType = getEffectiveRestType(source);
            if (restType && pos >= parameterCount - 1) {
                return pos === parameterCount - 1 ? restType : createArrayType(getIndexedAccessType(restType, numberType));
            }
            var types = [];
            var flags = [];
            var names = [];
            for (var i = pos; i < parameterCount; i++) {
                if (!restType || i < parameterCount - 1) {
                    types.push(getTypeAtPosition(source, i));
                    flags.push(i < minArgumentCount ? 1 /* Required */ : 2 /* Optional */);
                }
                else {
                    types.push(restType);
                    flags.push(8 /* Variadic */);
                }
                var name = getNameableDeclarationAtPosition(source, i);
                if (name) {
                    names.push(name);
                }
            }
            return createTupleType(types, flags, /*readonly*/ false, ts.length(names) === ts.length(types) ? names : undefined);
        }
        // Return the number of parameters in a signature. The rest parameter, if present, counts as one
        // parameter. For example, the parameter count of (x: number, y: number, ...z: string[]) is 3 and
        // the parameter count of (x: number, ...args: [number, ...string[], boolean])) is also 3. In the
        // latter example, the effective rest type is [...string[], boolean].
        function getParameterCount(signature) {
            var length = signature.parameters.length;
            if (signatureHasRestParameter(signature)) {
                var restType = getTypeOfSymbol(signature.parameters[length - 1]);
                if (isTupleType(restType)) {
                    return length + restType.target.fixedLength - (restType.target.hasRestElement ? 0 : 1);
                }
            }
            return length;
        }
        function getMinArgumentCount(signature, flags) {
            var strongArityForUntypedJS = flags & 1 /* StrongArityForUntypedJS */;
            var voidIsNonOptional = flags & 2 /* VoidIsNonOptional */;
            if (voidIsNonOptional || signature.resolvedMinArgumentCount === undefined) {
                var minArgumentCount = void 0;
                if (signatureHasRestParameter(signature)) {
                    var restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                    if (isTupleType(restType)) {
                        var firstOptionalIndex = ts.findIndex(restType.target.elementFlags, function (f) { return !(f & 1 /* Required */); });
                        var requiredCount = firstOptionalIndex < 0 ? restType.target.fixedLength : firstOptionalIndex;
                        if (requiredCount > 0) {
                            minArgumentCount = signature.parameters.length - 1 + requiredCount;
                        }
                    }
                }
                if (minArgumentCount === undefined) {
                    if (!strongArityForUntypedJS && signature.flags & 32 /* IsUntypedSignatureInJSFile */) {
                        return 0;
                    }
                    minArgumentCount = signature.minArgumentCount;
                }
                if (voidIsNonOptional) {
                    return minArgumentCount;
                }
                for (var i = minArgumentCount - 1; i >= 0; i--) {
                    var type = getTypeAtPosition(signature, i);
                    if (filterType(type, acceptsVoid).flags & 131072 /* Never */) {
                        break;
                    }
                    minArgumentCount = i;
                }
                signature.resolvedMinArgumentCount = minArgumentCount;
            }
            return signature.resolvedMinArgumentCount;
        }
        function hasEffectiveRestParameter(signature) {
            if (signatureHasRestParameter(signature)) {
                var restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                return !isTupleType(restType) || restType.target.hasRestElement;
            }
            return false;
        }
        function getEffectiveRestType(signature) {
            if (signatureHasRestParameter(signature)) {
                var restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                if (!isTupleType(restType)) {
                    return restType;
                }
                if (restType.target.hasRestElement) {
                    return sliceTupleType(restType, restType.target.fixedLength);
                }
            }
            return undefined;
        }
        function getNonArrayRestType(signature) {
            var restType = getEffectiveRestType(signature);
            return restType && !isArrayType(restType) && !isTypeAny(restType) && (getReducedType(restType).flags & 131072 /* Never */) === 0 ? restType : undefined;
        }
        function getTypeOfFirstParameterOfSignature(signature) {
            return getTypeOfFirstParameterOfSignatureWithFallback(signature, neverType);
        }
        function getTypeOfFirstParameterOfSignatureWithFallback(signature, fallbackType) {
            return signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : fallbackType;
        }
        function inferFromAnnotatedParameters(signature, context, inferenceContext) {
            var len = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
            for (var i = 0; i < len; i++) {
                var declaration = signature.parameters[i].valueDeclaration;
                if (declaration.type) {
                    var typeNode = ts.getEffectiveTypeAnnotationNode(declaration);
                    if (typeNode) {
                        inferTypes(inferenceContext.inferences, getTypeFromTypeNode(typeNode), getTypeAtPosition(context, i));
                    }
                }
            }
            var restType = getEffectiveRestType(context);
            if (restType && restType.flags & 262144 /* TypeParameter */) {
                // The contextual signature has a generic rest parameter. We first instantiate the contextual
                // signature (without fixing type parameters) and assign types to contextually typed parameters.
                var instantiatedContext = instantiateSignature(context, inferenceContext.nonFixingMapper);
                assignContextualParameterTypes(signature, instantiatedContext);
                // We then infer from a tuple type representing the parameters that correspond to the contextual
                // rest parameter.
                var restPos = getParameterCount(context) - 1;
                inferTypes(inferenceContext.inferences, getRestTypeAtPosition(signature, restPos), restType);
            }
        }
        function assignContextualParameterTypes(signature, context) {
            if (context.typeParameters) {
                if (!signature.typeParameters) {
                    signature.typeParameters = context.typeParameters;
                }
                else {
                    return; // This signature has already has a contextual inference performed and cached on it!
                }
            }
            if (context.thisParameter) {
                var parameter = signature.thisParameter;
                if (!parameter || parameter.valueDeclaration && !parameter.valueDeclaration.type) {
                    if (!parameter) {
                        signature.thisParameter = createSymbolWithType(context.thisParameter, /*type*/ undefined);
                    }
                    assignParameterType(signature.thisParameter, getTypeOfSymbol(context.thisParameter));
                }
            }
            var len = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
            for (var i = 0; i < len; i++) {
                var parameter = signature.parameters[i];
                if (!ts.getEffectiveTypeAnnotationNode(parameter.valueDeclaration)) {
                    var contextualParameterType = tryGetTypeAtPosition(context, i);
                    assignParameterType(parameter, contextualParameterType);
                }
            }
            if (signatureHasRestParameter(signature)) {
                // parameter might be a transient symbol generated by use of `arguments` in the function body.
                var parameter = ts.last(signature.parameters);
                if (ts.isTransientSymbol(parameter) || !ts.getEffectiveTypeAnnotationNode(parameter.valueDeclaration)) {
                    var contextualParameterType = getRestTypeAtPosition(context, len);
                    assignParameterType(parameter, contextualParameterType);
                }
            }
        }
        function assignNonContextualParameterTypes(signature) {
            if (signature.thisParameter) {
                assignParameterType(signature.thisParameter);
            }
            for (var _i = 0, _a = signature.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                assignParameterType(parameter);
            }
        }
        function assignParameterType(parameter, type) {
            var links = getSymbolLinks(parameter);
            if (!links.type) {
                var declaration = parameter.valueDeclaration;
                links.type = type || getWidenedTypeForVariableLikeDeclaration(declaration, /*includeOptionality*/ true);
                if (declaration.name.kind !== 79 /* Identifier */) {
                    // if inference didn't come up with anything but unknown, fall back to the binding pattern if present.
                    if (links.type === unknownType) {
                        links.type = getTypeFromBindingPattern(declaration.name);
                    }
                    assignBindingElementTypes(declaration.name);
                }
            }
        }
        // When contextual typing assigns a type to a parameter that contains a binding pattern, we also need to push
        // the destructured type into the contained binding elements.
        function assignBindingElementTypes(pattern) {
            for (var _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                if (!ts.isOmittedExpression(element)) {
                    if (element.name.kind === 79 /* Identifier */) {
                        getSymbolLinks(getSymbolOfNode(element)).type = getTypeForBindingElement(element);
                    }
                    else {
                        assignBindingElementTypes(element.name);
                    }
                }
            }
        }
        function createPromiseType(promisedType) {
            // creates a `Promise<T>` type where `T` is the promisedType argument
            var globalPromiseType = getGlobalPromiseType(/*reportErrors*/ true);
            if (globalPromiseType !== emptyGenericType) {
                // if the promised type is itself a promise, get the underlying type; otherwise, fallback to the promised type
                promisedType = getAwaitedType(promisedType) || unknownType;
                return createTypeReference(globalPromiseType, [promisedType]);
            }
            return unknownType;
        }
        function createPromiseLikeType(promisedType) {
            // creates a `PromiseLike<T>` type where `T` is the promisedType argument
            var globalPromiseLikeType = getGlobalPromiseLikeType(/*reportErrors*/ true);
            if (globalPromiseLikeType !== emptyGenericType) {
                // if the promised type is itself a promise, get the underlying type; otherwise, fallback to the promised type
                promisedType = getAwaitedType(promisedType) || unknownType;
                return createTypeReference(globalPromiseLikeType, [promisedType]);
            }
            return unknownType;
        }
        function createPromiseReturnType(func, promisedType) {
            var promiseType = createPromiseType(promisedType);
            if (promiseType === unknownType) {
                error(func, ts.isImportCall(func) ?
                    ts.Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option :
                    ts.Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option);
                return errorType;
            }
            else if (!getGlobalPromiseConstructorSymbol(/*reportErrors*/ true)) {
                error(func, ts.isImportCall(func) ?
                    ts.Diagnostics.A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option :
                    ts.Diagnostics.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option);
            }
            return promiseType;
        }
        function createNewTargetExpressionType(targetType) {
            // Create a synthetic type `NewTargetExpression { target: TargetType; }`
            var symbol = createSymbol(0 /* None */, "NewTargetExpression");
            var targetPropertySymbol = createSymbol(4 /* Property */, "target", 8 /* Readonly */);
            targetPropertySymbol.parent = symbol;
            targetPropertySymbol.type = targetType;
            var members = ts.createSymbolTable([targetPropertySymbol]);
            symbol.members = members;
            return createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        }
        function getReturnTypeFromBody(func, checkMode) {
            if (!func.body) {
                return errorType;
            }
            var functionFlags = ts.getFunctionFlags(func);
            var isAsync = (functionFlags & 2 /* Async */) !== 0;
            var isGenerator = (functionFlags & 1 /* Generator */) !== 0;
            var returnType;
            var yieldType;
            var nextType;
            var fallbackReturnType = voidType;
            if (func.body.kind !== 233 /* Block */) { // Async or normal arrow function
                returnType = checkExpressionCached(func.body, checkMode && checkMode & ~8 /* SkipGenericFunctions */);
                if (isAsync) {
                    // From within an async function you can return either a non-promise value or a promise. Any
                    // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                    // return type of the body should be unwrapped to its awaited type, which we will wrap in
                    // the native Promise<T> type later in this function.
                    returnType = checkAwaitedType(returnType, /*errorNode*/ func, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                }
            }
            else if (isGenerator) { // Generator or AsyncGenerator function
                var returnTypes = checkAndAggregateReturnExpressionTypes(func, checkMode);
                if (!returnTypes) {
                    fallbackReturnType = neverType;
                }
                else if (returnTypes.length > 0) {
                    returnType = getUnionType(returnTypes, 2 /* Subtype */);
                }
                var _a = checkAndAggregateYieldOperandTypes(func, checkMode), yieldTypes = _a.yieldTypes, nextTypes = _a.nextTypes;
                yieldType = ts.some(yieldTypes) ? getUnionType(yieldTypes, 2 /* Subtype */) : undefined;
                nextType = ts.some(nextTypes) ? getIntersectionType(nextTypes) : undefined;
            }
            else { // Async or normal function
                var types = checkAndAggregateReturnExpressionTypes(func, checkMode);
                if (!types) {
                    // For an async function, the return type will not be never, but rather a Promise for never.
                    return functionFlags & 2 /* Async */
                        ? createPromiseReturnType(func, neverType) // Async function
                        : neverType; // Normal function
                }
                if (types.length === 0) {
                    // For an async function, the return type will not be void, but rather a Promise for void.
                    return functionFlags & 2 /* Async */
                        ? createPromiseReturnType(func, voidType) // Async function
                        : voidType; // Normal function
                }
                // Return a union of the return expression types.
                returnType = getUnionType(types, 2 /* Subtype */);
            }
            if (returnType || yieldType || nextType) {
                if (yieldType)
                    reportErrorsFromWidening(func, yieldType, 3 /* GeneratorYield */);
                if (returnType)
                    reportErrorsFromWidening(func, returnType, 1 /* FunctionReturn */);
                if (nextType)
                    reportErrorsFromWidening(func, nextType, 2 /* GeneratorNext */);
                if (returnType && isUnitType(returnType) ||
                    yieldType && isUnitType(yieldType) ||
                    nextType && isUnitType(nextType)) {
                    var contextualSignature = getContextualSignatureForFunctionLikeDeclaration(func);
                    var contextualType = !contextualSignature ? undefined :
                        contextualSignature === getSignatureFromDeclaration(func) ? isGenerator ? undefined : returnType :
                            instantiateContextualType(getReturnTypeOfSignature(contextualSignature), func);
                    if (isGenerator) {
                        yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, 0 /* Yield */, isAsync);
                        returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, 1 /* Return */, isAsync);
                        nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, 2 /* Next */, isAsync);
                    }
                    else {
                        returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync);
                    }
                }
                if (yieldType)
                    yieldType = getWidenedType(yieldType);
                if (returnType)
                    returnType = getWidenedType(returnType);
                if (nextType)
                    nextType = getWidenedType(nextType);
            }
            if (isGenerator) {
                return createGeneratorReturnType(yieldType || neverType, returnType || fallbackReturnType, nextType || getContextualIterationType(2 /* Next */, func) || unknownType, isAsync);
            }
            else {
                // From within an async function you can return either a non-promise value or a promise. Any
                // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                // return type of the body is awaited type of the body, wrapped in a native Promise<T> type.
                return isAsync
                    ? createPromiseType(returnType || fallbackReturnType)
                    : returnType || fallbackReturnType;
            }
        }
        function createGeneratorReturnType(yieldType, returnType, nextType, isAsyncGenerator) {
            var resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
            var globalGeneratorType = resolver.getGlobalGeneratorType(/*reportErrors*/ false);
            yieldType = resolver.resolveIterationType(yieldType, /*errorNode*/ undefined) || unknownType;
            returnType = resolver.resolveIterationType(returnType, /*errorNode*/ undefined) || unknownType;
            nextType = resolver.resolveIterationType(nextType, /*errorNode*/ undefined) || unknownType;
            if (globalGeneratorType === emptyGenericType) {
                // Fall back to the global IterableIterator if returnType is assignable to the expected return iteration
                // type of IterableIterator, and the expected next iteration type of IterableIterator is assignable to
                // nextType.
                var globalType = resolver.getGlobalIterableIteratorType(/*reportErrors*/ false);
                var iterationTypes = globalType !== emptyGenericType ? getIterationTypesOfGlobalIterableType(globalType, resolver) : undefined;
                var iterableIteratorReturnType = iterationTypes ? iterationTypes.returnType : anyType;
                var iterableIteratorNextType = iterationTypes ? iterationTypes.nextType : undefinedType;
                if (isTypeAssignableTo(returnType, iterableIteratorReturnType) &&
                    isTypeAssignableTo(iterableIteratorNextType, nextType)) {
                    if (globalType !== emptyGenericType) {
                        return createTypeFromGenericGlobalType(globalType, [yieldType]);
                    }
                    // The global IterableIterator type doesn't exist, so report an error
                    resolver.getGlobalIterableIteratorType(/*reportErrors*/ true);
                    return emptyObjectType;
                }
                // The global Generator type doesn't exist, so report an error
                resolver.getGlobalGeneratorType(/*reportErrors*/ true);
                return emptyObjectType;
            }
            return createTypeFromGenericGlobalType(globalGeneratorType, [yieldType, returnType, nextType]);
        }
        function checkAndAggregateYieldOperandTypes(func, checkMode) {
            var yieldTypes = [];
            var nextTypes = [];
            var isAsync = (ts.getFunctionFlags(func) & 2 /* Async */) !== 0;
            ts.forEachYieldExpression(func.body, function (yieldExpression) {
                var yieldExpressionType = yieldExpression.expression ? checkExpression(yieldExpression.expression, checkMode) : undefinedWideningType;
                ts.pushIfUnique(yieldTypes, getYieldedTypeOfYieldExpression(yieldExpression, yieldExpressionType, anyType, isAsync));
                var nextType;
                if (yieldExpression.asteriskToken) {
                    var iterationTypes = getIterationTypesOfIterable(yieldExpressionType, isAsync ? 19 /* AsyncYieldStar */ : 17 /* YieldStar */, yieldExpression.expression);
                    nextType = iterationTypes && iterationTypes.nextType;
                }
                else {
                    nextType = getContextualType(yieldExpression);
                }
                if (nextType)
                    ts.pushIfUnique(nextTypes, nextType);
            });
            return { yieldTypes: yieldTypes, nextTypes: nextTypes };
        }
        function getYieldedTypeOfYieldExpression(node, expressionType, sentType, isAsync) {
            var errorNode = node.expression || node;
            // A `yield*` expression effectively yields everything that its operand yields
            var yieldedType = node.asteriskToken ? checkIteratedTypeOrElementType(isAsync ? 19 /* AsyncYieldStar */ : 17 /* YieldStar */, expressionType, sentType, errorNode) : expressionType;
            return !isAsync ? yieldedType : getAwaitedType(yieldedType, errorNode, node.asteriskToken
                ? ts.Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member
                : ts.Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
        }
        /**
         * Collect the TypeFacts learned from a typeof switch with
         * total clauses `witnesses`, and the active clause ranging
         * from `start` to `end`. Parameter `hasDefault` denotes
         * whether the active clause contains a default clause.
         */
        function getFactsFromTypeofSwitch(start, end, witnesses, hasDefault) {
            var facts = 0 /* None */;
            // When in the default we only collect inequality facts
            // because default is 'in theory' a set of infinite
            // equalities.
            if (hasDefault) {
                // Value is not equal to any types after the active clause.
                for (var i = end; i < witnesses.length; i++) {
                    facts |= typeofNEFacts.get(witnesses[i]) || 32768 /* TypeofNEHostObject */;
                }
                // Remove inequalities for types that appear in the
                // active clause because they appear before other
                // types collected so far.
                for (var i = start; i < end; i++) {
                    facts &= ~(typeofNEFacts.get(witnesses[i]) || 0);
                }
                // Add inequalities for types before the active clause unconditionally.
                for (var i = 0; i < start; i++) {
                    facts |= typeofNEFacts.get(witnesses[i]) || 32768 /* TypeofNEHostObject */;
                }
            }
            // When in an active clause without default the set of
            // equalities is finite.
            else {
                // Add equalities for all types in the active clause.
                for (var i = start; i < end; i++) {
                    facts |= typeofEQFacts.get(witnesses[i]) || 128 /* TypeofEQHostObject */;
                }
                // Remove equalities for types that appear before the
                // active clause.
                for (var i = 0; i < start; i++) {
                    facts &= ~(typeofEQFacts.get(witnesses[i]) || 0);
                }
            }
            return facts;
        }
        function isExhaustiveSwitchStatement(node) {
            var links = getNodeLinks(node);
            return links.isExhaustive !== undefined ? links.isExhaustive : (links.isExhaustive = computeExhaustiveSwitchStatement(node));
        }
        function computeExhaustiveSwitchStatement(node) {
            if (node.expression.kind === 214 /* TypeOfExpression */) {
                var operandType = getTypeOfExpression(node.expression.expression);
                var witnesses = getSwitchClauseTypeOfWitnesses(node, /*retainDefault*/ false);
                // notEqualFacts states that the type of the switched value is not equal to every type in the switch.
                var notEqualFacts_1 = getFactsFromTypeofSwitch(0, 0, witnesses, /*hasDefault*/ true);
                var type_4 = getBaseConstraintOfType(operandType) || operandType;
                // Take any/unknown as a special condition. Or maybe we could change `type` to a union containing all primitive types.
                if (type_4.flags & 3 /* AnyOrUnknown */) {
                    return (556800 /* AllTypeofNE */ & notEqualFacts_1) === 556800 /* AllTypeofNE */;
                }
                return !!(filterType(type_4, function (t) { return (getTypeFacts(t) & notEqualFacts_1) === notEqualFacts_1; }).flags & 131072 /* Never */);
            }
            var type = getTypeOfExpression(node.expression);
            if (!isLiteralType(type)) {
                return false;
            }
            var switchTypes = getSwitchClauseTypes(node);
            if (!switchTypes.length || ts.some(switchTypes, isNeitherUnitTypeNorNever)) {
                return false;
            }
            return eachTypeContainedIn(mapType(type, getRegularTypeOfLiteralType), switchTypes);
        }
        function functionHasImplicitReturn(func) {
            return func.endFlowNode && isReachableFlowNode(func.endFlowNode);
        }
        /** NOTE: Return value of `[]` means a different thing than `undefined`. `[]` means func returns `void`, `undefined` means it returns `never`. */
        function checkAndAggregateReturnExpressionTypes(func, checkMode) {
            var functionFlags = ts.getFunctionFlags(func);
            var aggregatedTypes = [];
            var hasReturnWithNoExpression = functionHasImplicitReturn(func);
            var hasReturnOfTypeNever = false;
            ts.forEachReturnStatement(func.body, function (returnStatement) {
                var expr = returnStatement.expression;
                if (expr) {
                    var type = checkExpressionCached(expr, checkMode && checkMode & ~8 /* SkipGenericFunctions */);
                    if (functionFlags & 2 /* Async */) {
                        // From within an async function you can return either a non-promise value or a promise. Any
                        // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                        // return type of the body should be unwrapped to its awaited type, which should be wrapped in
                        // the native Promise<T> type by the caller.
                        type = checkAwaitedType(type, func, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                    }
                    if (type.flags & 131072 /* Never */) {
                        hasReturnOfTypeNever = true;
                    }
                    ts.pushIfUnique(aggregatedTypes, type);
                }
                else {
                    hasReturnWithNoExpression = true;
                }
            });
            if (aggregatedTypes.length === 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || mayReturnNever(func))) {
                return undefined;
            }
            if (strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression &&
                !(isJSConstructor(func) && aggregatedTypes.some(function (t) { return t.symbol === func.symbol; }))) {
                // Javascript "callable constructors", containing eg `if (!(this instanceof A)) return new A()` should not add undefined
                ts.pushIfUnique(aggregatedTypes, undefinedType);
            }
            return aggregatedTypes;
        }
        function mayReturnNever(func) {
            switch (func.kind) {
                case 211 /* FunctionExpression */:
                case 212 /* ArrowFunction */:
                    return true;
                case 167 /* MethodDeclaration */:
                    return func.parent.kind === 203 /* ObjectLiteralExpression */;
                default:
                    return false;
            }
        }
        /**
         * TypeScript Specification 1.0 (6.3) - July 2014
         *   An explicitly typed function whose return type isn't the Void type,
         *   the Any type, or a union type containing the Void or Any type as a constituent
         *   must have at least one return statement somewhere in its body.
         *   An exception to this rule is if the function implementation consists of a single 'throw' statement.
         *
         * @param returnType - return type of the function, can be undefined if return type is not explicitly specified
         */
        function checkAllCodePathsInNonVoidFunctionReturnOrThrow(func, returnType) {
            if (!produceDiagnostics) {
                return;
            }
            var functionFlags = ts.getFunctionFlags(func);
            var type = returnType && unwrapReturnType(returnType, functionFlags);
            // Functions with with an explicitly specified 'void' or 'any' return type don't need any return expressions.
            if (type && maybeTypeOfKind(type, 1 /* Any */ | 16384 /* Void */)) {
                return;
            }
            // If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.
            // also if HasImplicitReturn flag is not set this means that all codepaths in function body end with return or throw
            if (func.kind === 166 /* MethodSignature */ || ts.nodeIsMissing(func.body) || func.body.kind !== 233 /* Block */ || !functionHasImplicitReturn(func)) {
                return;
            }
            var hasExplicitReturn = func.flags & 512 /* HasExplicitReturn */;
            var errorNode = ts.getEffectiveReturnTypeNode(func) || func;
            if (type && type.flags & 131072 /* Never */) {
                error(errorNode, ts.Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point);
            }
            else if (type && !hasExplicitReturn) {
                // minimal check: function has syntactic return type annotation and no explicit return statements in the body
                // this function does not conform to the specification.
                error(errorNode, ts.Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value);
            }
            else if (type && strictNullChecks && !isTypeAssignableTo(undefinedType, type)) {
                error(errorNode, ts.Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined);
            }
            else if (compilerOptions.noImplicitReturns) {
                if (!type) {
                    // If return type annotation is omitted check if function has any explicit return statements.
                    // If it does not have any - its inferred return type is void - don't do any checks.
                    // Otherwise get inferred return type from function body and report error only if it is not void / anytype
                    if (!hasExplicitReturn) {
                        return;
                    }
                    var inferredReturnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                    if (isUnwrappedReturnTypeVoidOrAny(func, inferredReturnType)) {
                        return;
                    }
                }
                error(errorNode, ts.Diagnostics.Not_all_code_paths_return_a_value);
            }
        }
        function checkFunctionExpressionOrObjectLiteralMethod(node, checkMode) {
            ts.Debug.assert(node.kind !== 167 /* MethodDeclaration */ || ts.isObjectLiteralMethod(node));
            checkNodeDeferred(node);
            if (ts.isFunctionExpression(node)) {
                checkCollisionsForDeclarationName(node, node.name);
            }
            // The identityMapper object is used to indicate that function expressions are wildcards
            if (checkMode && checkMode & 4 /* SkipContextSensitive */ && isContextSensitive(node)) {
                // Skip parameters, return signature with return type that retains noncontextual parts so inferences can still be drawn in an early stage
                if (!ts.getEffectiveReturnTypeNode(node) && !ts.hasContextSensitiveParameters(node)) {
                    // Return plain anyFunctionType if there is no possibility we'll make inferences from the return type
                    var contextualSignature = getContextualSignature(node);
                    if (contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature))) {
                        var links = getNodeLinks(node);
                        if (links.contextFreeType) {
                            return links.contextFreeType;
                        }
                        var returnType = getReturnTypeFromBody(node, checkMode);
                        var returnOnlySignature = createSignature(undefined, undefined, undefined, ts.emptyArray, returnType, /*resolvedTypePredicate*/ undefined, 0, 0 /* None */);
                        var returnOnlyType = createAnonymousType(node.symbol, emptySymbols, [returnOnlySignature], ts.emptyArray, ts.emptyArray);
                        returnOnlyType.objectFlags |= 524288 /* NonInferrableType */;
                        return links.contextFreeType = returnOnlyType;
                    }
                }
                return anyFunctionType;
            }
            // Grammar checking
            var hasGrammarError = checkGrammarFunctionLikeDeclaration(node);
            if (!hasGrammarError && node.kind === 211 /* FunctionExpression */) {
                checkGrammarForGenerator(node);
            }
            contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode);
            return getTypeOfSymbol(getSymbolOfNode(node));
        }
        function contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode) {
            var links = getNodeLinks(node);
            // Check if function expression is contextually typed and assign parameter types if so.
            if (!(links.flags & 1024 /* ContextChecked */)) {
                var contextualSignature = getContextualSignature(node);
                // If a type check is started at a function expression that is an argument of a function call, obtaining the
                // contextual type may recursively get back to here during overload resolution of the call. If so, we will have
                // already assigned contextual types.
                if (!(links.flags & 1024 /* ContextChecked */)) {
                    links.flags |= 1024 /* ContextChecked */;
                    var signature = ts.firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfNode(node)), 0 /* Call */));
                    if (!signature) {
                        return;
                    }
                    if (isContextSensitive(node)) {
                        if (contextualSignature) {
                            var inferenceContext = getInferenceContext(node);
                            if (checkMode && checkMode & 2 /* Inferential */) {
                                inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext);
                            }
                            var instantiatedContextualSignature = inferenceContext ?
                                instantiateSignature(contextualSignature, inferenceContext.mapper) : contextualSignature;
                            assignContextualParameterTypes(signature, instantiatedContextualSignature);
                        }
                        else {
                            // Force resolution of all parameter types such that the absence of a contextual type is consistently reflected.
                            assignNonContextualParameterTypes(signature);
                        }
                    }
                    if (contextualSignature && !getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType) {
                        var returnType = getReturnTypeFromBody(node, checkMode);
                        if (!signature.resolvedReturnType) {
                            signature.resolvedReturnType = returnType;
                        }
                    }
                    checkSignatureDeclaration(node);
                }
            }
        }
        function checkFunctionExpressionOrObjectLiteralMethodDeferred(node) {
            ts.Debug.assert(node.kind !== 167 /* MethodDeclaration */ || ts.isObjectLiteralMethod(node));
            var functionFlags = ts.getFunctionFlags(node);
            var returnType = getReturnTypeFromAnnotation(node);
            checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
            if (node.body) {
                if (!ts.getEffectiveReturnTypeNode(node)) {
                    // There are some checks that are only performed in getReturnTypeFromBody, that may produce errors
                    // we need. An example is the noImplicitAny errors resulting from widening the return expression
                    // of a function. Because checking of function expression bodies is deferred, there was never an
                    // appropriate time to do this during the main walk of the file (see the comment at the top of
                    // checkFunctionExpressionBodies). So it must be done now.
                    getReturnTypeOfSignature(getSignatureFromDeclaration(node));
                }
                if (node.body.kind === 233 /* Block */) {
                    checkSourceElement(node.body);
                }
                else {
                    // From within an async function you can return either a non-promise value or a promise. Any
                    // Promise/A+ compatible implementation will always assimilate any foreign promise, so we
                    // should not be checking assignability of a promise to the return type. Instead, we need to
                    // check assignability of the awaited type of the expression body against the promised type of
                    // its return type annotation.
                    var exprType = checkExpression(node.body);
                    var returnOrPromisedType = returnType && unwrapReturnType(returnType, functionFlags);
                    if (returnOrPromisedType) {
                        if ((functionFlags & 3 /* AsyncGenerator */) === 2 /* Async */) { // Async function
                            var awaitedType = checkAwaitedType(exprType, node.body, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                            checkTypeAssignableToAndOptionallyElaborate(awaitedType, returnOrPromisedType, node.body, node.body);
                        }
                        else { // Normal function
                            checkTypeAssignableToAndOptionallyElaborate(exprType, returnOrPromisedType, node.body, node.body);
                        }
                    }
                }
            }
        }
        function checkArithmeticOperandType(operand, type, diagnostic, isAwaitValid) {
            if (isAwaitValid === void 0) { isAwaitValid = false; }
            if (!isTypeAssignableTo(type, numberOrBigIntType)) {
                var awaitedType = isAwaitValid && getAwaitedTypeOfPromise(type);
                errorAndMaybeSuggestAwait(operand, !!awaitedType && isTypeAssignableTo(awaitedType, numberOrBigIntType), diagnostic);
                return false;
            }
            return true;
        }
        function isReadonlyAssignmentDeclaration(d) {
            if (!ts.isCallExpression(d)) {
                return false;
            }
            if (!ts.isBindableObjectDefinePropertyCall(d)) {
                return false;
            }
            var objectLitType = checkExpressionCached(d.arguments[2]);
            var valueType = getTypeOfPropertyOfType(objectLitType, "value");
            if (valueType) {
                var writableProp = getPropertyOfType(objectLitType, "writable");
                var writableType = writableProp && getTypeOfSymbol(writableProp);
                if (!writableType || writableType === falseType || writableType === regularFalseType) {
                    return true;
                }
                // We include this definition whereupon we walk back and check the type at the declaration because
                // The usual definition of `Object.defineProperty` will _not_ cause literal types to be preserved in the
                // argument types, should the type be contextualized by the call itself.
                if (writableProp && writableProp.valueDeclaration && ts.isPropertyAssignment(writableProp.valueDeclaration)) {
                    var initializer = writableProp.valueDeclaration.initializer;
                    var rawOriginalType = checkExpression(initializer);
                    if (rawOriginalType === falseType || rawOriginalType === regularFalseType) {
                        return true;
                    }
                }
                return false;
            }
            var setProp = getPropertyOfType(objectLitType, "set");
            return !setProp;
        }
        function isReadonlySymbol(symbol) {
            // The following symbols are considered read-only:
            // Properties with a 'readonly' modifier
            // Variables declared with 'const'
            // Get accessors without matching set accessors
            // Enum members
            // Object.defineProperty assignments with writable false or no setter
            // Unions and intersections of the above (unions and intersections eagerly set isReadonly on creation)
            return !!(ts.getCheckFlags(symbol) & 8 /* Readonly */ ||
                symbol.flags & 4 /* Property */ && ts.getDeclarationModifierFlagsFromSymbol(symbol) & 64 /* Readonly */ ||
                symbol.flags & 3 /* Variable */ && getDeclarationNodeFlagsFromSymbol(symbol) & 2 /* Const */ ||
                symbol.flags & 98304 /* Accessor */ && !(symbol.flags & 65536 /* SetAccessor */) ||
                symbol.flags & 8 /* EnumMember */ ||
                ts.some(symbol.declarations, isReadonlyAssignmentDeclaration));
        }
        function isAssignmentToReadonlyEntity(expr, symbol, assignmentKind) {
            var _a, _b;
            if (assignmentKind === 0 /* None */) {
                // no assigment means it doesn't matter whether the entity is readonly
                return false;
            }
            if (isReadonlySymbol(symbol)) {
                // Allow assignments to readonly properties within constructors of the same class declaration.
                if (symbol.flags & 4 /* Property */ &&
                    ts.isAccessExpression(expr) &&
                    expr.expression.kind === 108 /* ThisKeyword */) {
                    // Look for if this is the constructor for the class that `symbol` is a property of.
                    var ctor = ts.getContainingFunction(expr);
                    if (!(ctor && (ctor.kind === 169 /* Constructor */ || isJSConstructor(ctor)))) {
                        return true;
                    }
                    if (symbol.valueDeclaration) {
                        var isAssignmentDeclaration_1 = ts.isBinaryExpression(symbol.valueDeclaration);
                        var isLocalPropertyDeclaration = ctor.parent === symbol.valueDeclaration.parent;
                        var isLocalParameterProperty = ctor === symbol.valueDeclaration.parent;
                        var isLocalThisPropertyAssignment = isAssignmentDeclaration_1 && ((_a = symbol.parent) === null || _a === void 0 ? void 0 : _a.valueDeclaration) === ctor.parent;
                        var isLocalThisPropertyAssignmentConstructorFunction = isAssignmentDeclaration_1 && ((_b = symbol.parent) === null || _b === void 0 ? void 0 : _b.valueDeclaration) === ctor;
                        var isWriteableSymbol = isLocalPropertyDeclaration
                            || isLocalParameterProperty
                            || isLocalThisPropertyAssignment
                            || isLocalThisPropertyAssignmentConstructorFunction;
                        return !isWriteableSymbol;
                    }
                }
                return true;
            }
            if (ts.isAccessExpression(expr)) {
                // references through namespace import should be readonly
                var node = ts.skipParentheses(expr.expression);
                if (node.kind === 79 /* Identifier */) {
                    var symbol_2 = getNodeLinks(node).resolvedSymbol;
                    if (symbol_2.flags & 2097152 /* Alias */) {
                        var declaration = getDeclarationOfAliasSymbol(symbol_2);
                        return !!declaration && declaration.kind === 266 /* NamespaceImport */;
                    }
                }
            }
            return false;
        }
        function checkReferenceExpression(expr, invalidReferenceMessage, invalidOptionalChainMessage) {
            // References are combinations of identifiers, parentheses, and property accesses.
            var node = ts.skipOuterExpressions(expr, 6 /* Assertions */ | 1 /* Parentheses */);
            if (node.kind !== 79 /* Identifier */ && !ts.isAccessExpression(node)) {
                error(expr, invalidReferenceMessage);
                return false;
            }
            if (node.flags & 32 /* OptionalChain */) {
                error(expr, invalidOptionalChainMessage);
                return false;
            }
            return true;
        }
        function checkDeleteExpression(node) {
            checkExpression(node.expression);
            var expr = ts.skipParentheses(node.expression);
            if (!ts.isAccessExpression(expr)) {
                error(expr, ts.Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference);
                return booleanType;
            }
            if (ts.isPropertyAccessExpression(expr) && ts.isPrivateIdentifier(expr.name)) {
                error(expr, ts.Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_private_identifier);
            }
            var links = getNodeLinks(expr);
            var symbol = getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol);
            if (symbol) {
                if (isReadonlySymbol(symbol)) {
                    error(expr, ts.Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property);
                }
                checkDeleteExpressionMustBeOptional(expr, symbol);
            }
            return booleanType;
        }
        function checkDeleteExpressionMustBeOptional(expr, symbol) {
            var type = getTypeOfSymbol(symbol);
            if (strictNullChecks &&
                !(type.flags & (3 /* AnyOrUnknown */ | 131072 /* Never */)) &&
                !(exactOptionalPropertyTypes ? symbol.flags & 16777216 /* Optional */ : getFalsyFlags(type) & 32768 /* Undefined */)) {
                error(expr, ts.Diagnostics.The_operand_of_a_delete_operator_must_be_optional);
            }
        }
        function checkTypeOfExpression(node) {
            checkExpression(node.expression);
            return typeofType;
        }
        function checkVoidExpression(node) {
            checkExpression(node.expression);
            return undefinedWideningType;
        }
        function checkAwaitExpression(node) {
            // Grammar checking
            if (produceDiagnostics) {
                var container = ts.getContainingFunctionOrClassStaticBlock(node);
                if (container && ts.isClassStaticBlockDeclaration(container)) {
                    error(node, ts.Diagnostics.Await_expression_cannot_be_used_inside_a_class_static_block);
                }
                else if (!(node.flags & 32768 /* AwaitContext */)) {
                    if (ts.isInTopLevelContext(node)) {
                        var sourceFile = ts.getSourceFileOfNode(node);
                        if (!hasParseDiagnostics(sourceFile)) {
                            var span = void 0;
                            if (!ts.isEffectiveExternalModule(sourceFile, compilerOptions)) {
                                if (!span)
                                    span = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
                                var diagnostic = ts.createFileDiagnostic(sourceFile, span.start, span.length, ts.Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module);
                                diagnostics.add(diagnostic);
                            }
                            if ((moduleKind !== ts.ModuleKind.ESNext && moduleKind !== ts.ModuleKind.System) || languageVersion < 4 /* ES2017 */) {
                                span = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
                                var diagnostic = ts.createFileDiagnostic(sourceFile, span.start, span.length, ts.Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_esnext_or_system_and_the_target_option_is_set_to_es2017_or_higher);
                                diagnostics.add(diagnostic);
                            }
                        }
                    }
                    else {
                        // use of 'await' in non-async function
                        var sourceFile = ts.getSourceFileOfNode(node);
                        if (!hasParseDiagnostics(sourceFile)) {
                            var span = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
                            var diagnostic = ts.createFileDiagnostic(sourceFile, span.start, span.length, ts.Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules);
                            if (container && container.kind !== 169 /* Constructor */ && (ts.getFunctionFlags(container) & 2 /* Async */) === 0) {
                                var relatedInfo = ts.createDiagnosticForNode(container, ts.Diagnostics.Did_you_mean_to_mark_this_function_as_async);
                                ts.addRelatedInfo(diagnostic, relatedInfo);
                            }
                            diagnostics.add(diagnostic);
                        }
                    }
                }
                if (isInParameterInitializerBeforeContainingFunction(node)) {
                    error(node, ts.Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer);
                }
            }
            var operandType = checkExpression(node.expression);
            var awaitedType = checkAwaitedType(operandType, node, ts.Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
            if (awaitedType === operandType && awaitedType !== errorType && !(operandType.flags & 3 /* AnyOrUnknown */)) {
                addErrorOrSuggestion(/*isError*/ false, ts.createDiagnosticForNode(node, ts.Diagnostics.await_has_no_effect_on_the_type_of_this_expression));
            }
            return awaitedType;
        }
        function checkPrefixUnaryExpression(node) {
            var operandType = checkExpression(node.operand);
            if (operandType === silentNeverType) {
                return silentNeverType;
            }
            switch (node.operand.kind) {
                case 8 /* NumericLiteral */:
                    switch (node.operator) {
                        case 40 /* MinusToken */:
                            return getFreshTypeOfLiteralType(getNumberLiteralType(-node.operand.text));
                        case 39 /* PlusToken */:
                            return getFreshTypeOfLiteralType(getNumberLiteralType(+node.operand.text));
                    }
                    break;
                case 9 /* BigIntLiteral */:
                    if (node.operator === 40 /* MinusToken */) {
                        return getFreshTypeOfLiteralType(getBigIntLiteralType({
                            negative: true,
                            base10Value: ts.parsePseudoBigInt(node.operand.text)
                        }));
                    }
            }
            switch (node.operator) {
                case 39 /* PlusToken */:
                case 40 /* MinusToken */:
                case 54 /* TildeToken */:
                    checkNonNullType(operandType, node.operand);
                    if (maybeTypeOfKind(operandType, 12288 /* ESSymbolLike */)) {
                        error(node.operand, ts.Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, ts.tokenToString(node.operator));
                    }
                    if (node.operator === 39 /* PlusToken */) {
                        if (maybeTypeOfKind(operandType, 2112 /* BigIntLike */)) {
                            error(node.operand, ts.Diagnostics.Operator_0_cannot_be_applied_to_type_1, ts.tokenToString(node.operator), typeToString(getBaseTypeOfLiteralType(operandType)));
                        }
                        return numberType;
                    }
                    return getUnaryResultType(operandType);
                case 53 /* ExclamationToken */:
                    checkTruthinessExpression(node.operand);
                    var facts = getTypeFacts(operandType) & (4194304 /* Truthy */ | 8388608 /* Falsy */);
                    return facts === 4194304 /* Truthy */ ? falseType :
                        facts === 8388608 /* Falsy */ ? trueType :
                            booleanType;
                case 45 /* PlusPlusToken */:
                case 46 /* MinusMinusToken */:
                    var ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);
                    if (ok) {
                        // run check only if former checks succeeded to avoid reporting cascading errors
                        checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access);
                    }
                    return getUnaryResultType(operandType);
            }
            return errorType;
        }
        function checkPostfixUnaryExpression(node) {
            var operandType = checkExpression(node.operand);
            if (operandType === silentNeverType) {
                return silentNeverType;
            }
            var ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);
            if (ok) {
                // run check only if former checks succeeded to avoid reporting cascading errors
                checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access);
            }
            return getUnaryResultType(operandType);
        }
        function getUnaryResultType(operandType) {
            if (maybeTypeOfKind(operandType, 2112 /* BigIntLike */)) {
                return isTypeAssignableToKind(operandType, 3 /* AnyOrUnknown */) || maybeTypeOfKind(operandType, 296 /* NumberLike */)
                    ? numberOrBigIntType
                    : bigintType;
            }
            // If it's not a bigint type, implicit coercion will result in a number
            return numberType;
        }
        // Return true if type might be of the given kind. A union or intersection type might be of a given
        // kind if at least one constituent type is of the given kind.
        function maybeTypeOfKind(type, kind) {
            if (type.flags & kind) {
                return true;
            }
            if (type.flags & 3145728 /* UnionOrIntersection */) {
                var types = type.types;
                for (var _i = 0, types_21 = types; _i < types_21.length; _i++) {
                    var t = types_21[_i];
                    if (maybeTypeOfKind(t, kind)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function isTypeAssignableToKind(source, kind, strict) {
            if (source.flags & kind) {
                return true;
            }
            if (strict && source.flags & (3 /* AnyOrUnknown */ | 16384 /* Void */ | 32768 /* Undefined */ | 65536 /* Null */)) {
                return false;
            }
            return !!(kind & 296 /* NumberLike */) && isTypeAssignableTo(source, numberType) ||
                !!(kind & 2112 /* BigIntLike */) && isTypeAssignableTo(source, bigintType) ||
                !!(kind & 402653316 /* StringLike */) && isTypeAssignableTo(source, stringType) ||
                !!(kind & 528 /* BooleanLike */) && isTypeAssignableTo(source, booleanType) ||
                !!(kind & 16384 /* Void */) && isTypeAssignableTo(source, voidType) ||
                !!(kind & 131072 /* Never */) && isTypeAssignableTo(source, neverType) ||
                !!(kind & 65536 /* Null */) && isTypeAssignableTo(source, nullType) ||
                !!(kind & 32768 /* Undefined */) && isTypeAssignableTo(source, undefinedType) ||
                !!(kind & 4096 /* ESSymbol */) && isTypeAssignableTo(source, esSymbolType) ||
                !!(kind & 67108864 /* NonPrimitive */) && isTypeAssignableTo(source, nonPrimitiveType);
        }
        function allTypesAssignableToKind(source, kind, strict) {
            return source.flags & 1048576 /* Union */ ?
                ts.every(source.types, function (subType) { return allTypesAssignableToKind(subType, kind, strict); }) :
                isTypeAssignableToKind(source, kind, strict);
        }
        function isConstEnumObjectType(type) {
            return !!(ts.getObjectFlags(type) & 16 /* Anonymous */) && !!type.symbol && isConstEnumSymbol(type.symbol);
        }
        function isConstEnumSymbol(symbol) {
            return (symbol.flags & 128 /* ConstEnum */) !== 0;
        }
        function checkInstanceOfExpression(left, right, leftType, rightType) {
            if (leftType === silentNeverType || rightType === silentNeverType) {
                return silentNeverType;
            }
            // TypeScript 1.0 spec (April 2014): 4.15.4
            // The instanceof operator requires the left operand to be of type Any, an object type, or a type parameter type,
            // and the right operand to be of type Any, a subtype of the 'Function' interface type, or have a call or construct signature.
            // The result is always of the Boolean primitive type.
            // NOTE: do not raise error if leftType is unknown as related error was already reported
            if (!isTypeAny(leftType) &&
                allTypesAssignableToKind(leftType, 131068 /* Primitive */)) {
                error(left, ts.Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            // NOTE: do not raise error if right is unknown as related error was already reported
            if (!(isTypeAny(rightType) || typeHasCallOrConstructSignatures(rightType) || isTypeSubtypeOf(rightType, globalFunctionType))) {
                error(right, ts.Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);
            }
            return booleanType;
        }
        function checkInExpression(left, right, leftType, rightType) {
            if (leftType === silentNeverType || rightType === silentNeverType) {
                return silentNeverType;
            }
            leftType = checkNonNullType(leftType, left);
            rightType = checkNonNullType(rightType, right);
            // TypeScript 1.0 spec (April 2014): 4.15.5
            // The in operator requires the left operand to be of type Any, the String primitive type, or the Number primitive type,
            // and the right operand to be
            //
            //   1. assignable to the non-primitive type,
            //   2. an unconstrained type parameter,
            //   3. a union or intersection including one or more type parameters, whose constituents are all assignable to the
            //      the non-primitive type, or are unconstrainted type parameters, or have constraints assignable to the
            //      non-primitive type, or
            //   4. a type parameter whose constraint is
            //      i. an object type,
            //     ii. the non-primitive type, or
            //    iii. a union or intersection with at least one constituent assignable to an object or non-primitive type.
            //
            // The divergent behavior for type parameters and unions containing type parameters is a workaround for type
            // parameters not being narrowable. If the right operand is a concrete type, we can error if there is any chance
            // it is a primitive. But if the operand is a type parameter, it cannot be narrowed, so we don't issue an error
            // unless *all* instantiations would result in an error.
            //
            // The result is always of the Boolean primitive type.
            if (!(allTypesAssignableToKind(leftType, 402653316 /* StringLike */ | 296 /* NumberLike */ | 12288 /* ESSymbolLike */) ||
                isTypeAssignableToKind(leftType, 4194304 /* Index */ | 134217728 /* TemplateLiteral */ | 268435456 /* StringMapping */ | 262144 /* TypeParameter */))) {
                error(left, ts.Diagnostics.The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol);
            }
            var rightTypeConstraint = getConstraintOfType(rightType);
            if (!allTypesAssignableToKind(rightType, 67108864 /* NonPrimitive */ | 58982400 /* InstantiableNonPrimitive */) ||
                rightTypeConstraint && (isTypeAssignableToKind(rightType, 3145728 /* UnionOrIntersection */) && !allTypesAssignableToKind(rightTypeConstraint, 67108864 /* NonPrimitive */ | 58982400 /* InstantiableNonPrimitive */) ||
                    !maybeTypeOfKind(rightTypeConstraint, 67108864 /* NonPrimitive */ | 58982400 /* InstantiableNonPrimitive */ | 524288 /* Object */))) {
                error(right, ts.Diagnostics.The_right_hand_side_of_an_in_expression_must_not_be_a_primitive);
            }
            return booleanType;
        }
        function checkObjectLiteralAssignment(node, sourceType, rightIsThis) {
            var properties = node.properties;
            if (strictNullChecks && properties.length === 0) {
                return checkNonNullType(sourceType, node);
            }
            for (var i = 0; i < properties.length; i++) {
                checkObjectLiteralDestructuringPropertyAssignment(node, sourceType, i, properties, rightIsThis);
            }
            return sourceType;
        }
        /** Note: If property cannot be a SpreadAssignment, then allProperties does not need to be provided */
        function checkObjectLiteralDestructuringPropertyAssignment(node, objectLiteralType, propertyIndex, allProperties, rightIsThis) {
            if (rightIsThis === void 0) { rightIsThis = false; }
            var properties = node.properties;
            var property = properties[propertyIndex];
            if (property.kind === 291 /* PropertyAssignment */ || property.kind === 292 /* ShorthandPropertyAssignment */) {
                var name = property.name;
                var exprType = getLiteralTypeFromPropertyName(name);
                if (isTypeUsableAsPropertyName(exprType)) {
                    var text = getPropertyNameFromType(exprType);
                    var prop = getPropertyOfType(objectLiteralType, text);
                    if (prop) {
                        markPropertyAsReferenced(prop, property, rightIsThis);
                        checkPropertyAccessibility(property, /*isSuper*/ false, /*writing*/ true, objectLiteralType, prop);
                    }
                }
                var elementType = getIndexedAccessType(objectLiteralType, exprType, 32 /* ExpressionPosition */, name);
                var type = getFlowTypeOfDestructuring(property, elementType);
                return checkDestructuringAssignment(property.kind === 292 /* ShorthandPropertyAssignment */ ? property : property.initializer, type);
            }
            else if (property.kind === 293 /* SpreadAssignment */) {
                if (propertyIndex < properties.length - 1) {
                    error(property, ts.Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
                }
                else {
                    if (languageVersion < 99 /* ESNext */) {
                        checkExternalEmitHelpers(property, 4 /* Rest */);
                    }
                    var nonRestNames = [];
                    if (allProperties) {
                        for (var _i = 0, allProperties_1 = allProperties; _i < allProperties_1.length; _i++) {
                            var otherProperty = allProperties_1[_i];
                            if (!ts.isSpreadAssignment(otherProperty)) {
                                nonRestNames.push(otherProperty.name);
                            }
                        }
                    }
                    var type = getRestType(objectLiteralType, nonRestNames, objectLiteralType.symbol);
                    checkGrammarForDisallowedTrailingComma(allProperties, ts.Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                    return checkDestructuringAssignment(property.expression, type);
                }
            }
            else {
                error(property, ts.Diagnostics.Property_assignment_expected);
            }
        }
        function checkArrayLiteralAssignment(node, sourceType, checkMode) {
            var elements = node.elements;
            if (languageVersion < 2 /* ES2015 */ && compilerOptions.downlevelIteration) {
                checkExternalEmitHelpers(node, 512 /* Read */);
            }
            // This elementType will be used if the specific property corresponding to this index is not
            // present (aka the tuple element property). This call also checks that the parentType is in
            // fact an iterable or array (depending on target language).
            var possiblyOutOfBoundsType = checkIteratedTypeOrElementType(65 /* Destructuring */ | 128 /* PossiblyOutOfBounds */, sourceType, undefinedType, node) || errorType;
            var inBoundsType = compilerOptions.noUncheckedIndexedAccess ? undefined : possiblyOutOfBoundsType;
            for (var i = 0; i < elements.length; i++) {
                var type = possiblyOutOfBoundsType;
                if (node.elements[i].kind === 223 /* SpreadElement */) {
                    type = inBoundsType = inBoundsType !== null && inBoundsType !== void 0 ? inBoundsType : (checkIteratedTypeOrElementType(65 /* Destructuring */, sourceType, undefinedType, node) || errorType);
                }
                checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, type, checkMode);
            }
            return sourceType;
        }
        function checkArrayLiteralDestructuringElementAssignment(node, sourceType, elementIndex, elementType, checkMode) {
            var elements = node.elements;
            var element = elements[elementIndex];
            if (element.kind !== 225 /* OmittedExpression */) {
                if (element.kind !== 223 /* SpreadElement */) {
                    var indexType = getNumberLiteralType(elementIndex);
                    if (isArrayLikeType(sourceType)) {
                        // We create a synthetic expression so that getIndexedAccessType doesn't get confused
                        // when the element is a SyntaxKind.ElementAccessExpression.
                        var accessFlags = 32 /* ExpressionPosition */ | (hasDefaultValue(element) ? 16 /* NoTupleBoundsCheck */ : 0);
                        var elementType_2 = getIndexedAccessTypeOrUndefined(sourceType, indexType, accessFlags, createSyntheticExpression(element, indexType)) || errorType;
                        var assignedType = hasDefaultValue(element) ? getTypeWithFacts(elementType_2, 524288 /* NEUndefined */) : elementType_2;
                        var type = getFlowTypeOfDestructuring(element, assignedType);
                        return checkDestructuringAssignment(element, type, checkMode);
                    }
                    return checkDestructuringAssignment(element, elementType, checkMode);
                }
                if (elementIndex < elements.length - 1) {
                    error(element, ts.Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
                }
                else {
                    var restExpression = element.expression;
                    if (restExpression.kind === 219 /* BinaryExpression */ && restExpression.operatorToken.kind === 63 /* EqualsToken */) {
                        error(restExpression.operatorToken, ts.Diagnostics.A_rest_element_cannot_have_an_initializer);
                    }
                    else {
                        checkGrammarForDisallowedTrailingComma(node.elements, ts.Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                        var type = everyType(sourceType, isTupleType) ?
                            mapType(sourceType, function (t) { return sliceTupleType(t, elementIndex); }) :
                            createArrayType(elementType);
                        return checkDestructuringAssignment(restExpression, type, checkMode);
                    }
                }
            }
            return undefined;
        }
        function checkDestructuringAssignment(exprOrAssignment, sourceType, checkMode, rightIsThis) {
            var target;
            if (exprOrAssignment.kind === 292 /* ShorthandPropertyAssignment */) {
                var prop = exprOrAssignment;
                if (prop.objectAssignmentInitializer) {
                    // In strict null checking mode, if a default value of a non-undefined type is specified, remove
                    // undefined from the final type.
                    if (strictNullChecks &&
                        !(getFalsyFlags(checkExpression(prop.objectAssignmentInitializer)) & 32768 /* Undefined */)) {
                        sourceType = getTypeWithFacts(sourceType, 524288 /* NEUndefined */);
                    }
                    checkBinaryLikeExpression(prop.name, prop.equalsToken, prop.objectAssignmentInitializer, checkMode);
                }
                target = exprOrAssignment.name;
            }
            else {
                target = exprOrAssignment;
            }
            if (target.kind === 219 /* BinaryExpression */ && target.operatorToken.kind === 63 /* EqualsToken */) {
                checkBinaryExpression(target, checkMode);
                target = target.left;
            }
            if (target.kind === 203 /* ObjectLiteralExpression */) {
                return checkObjectLiteralAssignment(target, sourceType, rightIsThis);
            }
            if (target.kind === 202 /* ArrayLiteralExpression */) {
                return checkArrayLiteralAssignment(target, sourceType, checkMode);
            }
            return checkReferenceAssignment(target, sourceType, checkMode);
        }
        function checkReferenceAssignment(target, sourceType, checkMode) {
            var targetType = checkExpression(target, checkMode);
            var error = target.parent.kind === 293 /* SpreadAssignment */ ?
                ts.Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access :
                ts.Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access;
            var optionalError = target.parent.kind === 293 /* SpreadAssignment */ ?
                ts.Diagnostics.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access :
                ts.Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access;
            if (checkReferenceExpression(target, error, optionalError)) {
                checkTypeAssignableToAndOptionallyElaborate(sourceType, targetType, target, target);
            }
            if (ts.isPrivateIdentifierPropertyAccessExpression(target)) {
                checkExternalEmitHelpers(target.parent, 1048576 /* ClassPrivateFieldSet */);
            }
            return sourceType;
        }
        /**
         * This is a *shallow* check: An expression is side-effect-free if the
         * evaluation of the expression *itself* cannot produce side effects.
         * For example, x++ / 3 is side-effect free because the / operator
         * does not have side effects.
         * The intent is to "smell test" an expression for correctness in positions where
         * its value is discarded (e.g. the left side of the comma operator).
         */
        function isSideEffectFree(node) {
            node = ts.skipParentheses(node);
            switch (node.kind) {
                case 79 /* Identifier */:
                case 10 /* StringLiteral */:
                case 13 /* RegularExpressionLiteral */:
                case 208 /* TaggedTemplateExpression */:
                case 221 /* TemplateExpression */:
                case 14 /* NoSubstitutionTemplateLiteral */:
                case 8 /* NumericLiteral */:
                case 9 /* BigIntLiteral */:
                case 110 /* TrueKeyword */:
                case 95 /* FalseKeyword */:
                case 104 /* NullKeyword */:
                case 151 /* UndefinedKeyword */:
                case 211 /* FunctionExpression */:
                case 224 /* ClassExpression */:
                case 212 /* ArrowFunction */:
                case 202 /* ArrayLiteralExpression */:
                case 203 /* ObjectLiteralExpression */:
                case 214 /* TypeOfExpression */:
                case 228 /* NonNullExpression */:
                case 277 /* JsxSelfClosingElement */:
                case 276 /* JsxElement */:
                    return true;
                case 220 /* ConditionalExpression */:
                    return isSideEffectFree(node.whenTrue) &&
                        isSideEffectFree(node.whenFalse);
                case 219 /* BinaryExpression */:
                    if (ts.isAssignmentOperator(node.operatorToken.kind)) {
                        return false;
                    }
                    return isSideEffectFree(node.left) &&
                        isSideEffectFree(node.right);
                case 217 /* PrefixUnaryExpression */:
                case 218 /* PostfixUnaryExpression */:
                    // Unary operators ~, !, +, and - have no side effects.
                    // The rest do.
                    switch (node.operator) {
                        case 53 /* ExclamationToken */:
                        case 39 /* PlusToken */:
                        case 40 /* MinusToken */:
                        case 54 /* TildeToken */:
                            return true;
                    }
                    return false;
                // Some forms listed here for clarity
                case 215 /* VoidExpression */: // Explicit opt-out
                case 209 /* TypeAssertionExpression */: // Not SEF, but can produce useful type warnings
                case 227 /* AsExpression */: // Not SEF, but can produce useful type warnings
                default:
                    return false;
            }
        }
        function isTypeEqualityComparableTo(source, target) {
            return (target.flags & 98304 /* Nullable */) !== 0 || isTypeComparableTo(source, target);
        }
        function createCheckBinaryExpression() {
            var trampoline = ts.createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState);
            return function (node, checkMode) {
                var result = trampoline(node, checkMode);
                ts.Debug.assertIsDefined(result);
                return result;
            };
            function onEnter(node, state, checkMode) {
                if (state) {
                    state.stackIndex++;
                    state.skip = false;
                    setLeftType(state, /*type*/ undefined);
                    setLastResult(state, /*type*/ undefined);
                }
                else {
                    state = {
                        checkMode: checkMode,
                        skip: false,
                        stackIndex: 0,
                        typeStack: [undefined, undefined],
                    };
                }
                if (ts.isInJSFile(node) && ts.getAssignedExpandoInitializer(node)) {
                    state.skip = true;
                    setLastResult(state, checkExpression(node.right, checkMode));
                    return state;
                }
                checkGrammarNullishCoalesceWithLogicalExpression(node);
                var operator = node.operatorToken.kind;
                if (operator === 63 /* EqualsToken */ && (node.left.kind === 203 /* ObjectLiteralExpression */ || node.left.kind === 202 /* ArrayLiteralExpression */)) {
                    state.skip = true;
                    setLastResult(state, checkDestructuringAssignment(node.left, checkExpression(node.right, checkMode), checkMode, node.right.kind === 108 /* ThisKeyword */));
                    return state;
                }
                return state;
            }
            function onLeft(left, state, _node) {
                if (!state.skip) {
                    return maybeCheckExpression(state, left);
                }
            }
            function onOperator(operatorToken, state, node) {
                if (!state.skip) {
                    var leftType = getLastResult(state);
                    ts.Debug.assertIsDefined(leftType);
                    setLeftType(state, leftType);
                    setLastResult(state, /*type*/ undefined);
                    var operator = operatorToken.kind;
                    if (operator === 55 /* AmpersandAmpersandToken */ || operator === 56 /* BarBarToken */ || operator === 60 /* QuestionQuestionToken */) {
                        if (operator === 55 /* AmpersandAmpersandToken */) {
                            var parent = ts.walkUpParenthesizedExpressions(node.parent);
                            checkTestingKnownTruthyCallableOrAwaitableType(node.left, leftType, ts.isIfStatement(parent) ? parent.thenStatement : undefined);
                        }
                        checkTruthinessOfType(leftType, node.left);
                    }
                }
            }
            function onRight(right, state, _node) {
                if (!state.skip) {
                    return maybeCheckExpression(state, right);
                }
            }
            function onExit(node, state) {
                var result;
                if (state.skip) {
                    result = getLastResult(state);
                }
                else {
                    var leftType = getLeftType(state);
                    ts.Debug.assertIsDefined(leftType);
                    var rightType = getLastResult(state);
                    ts.Debug.assertIsDefined(rightType);
                    result = checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, node);
                }
                state.skip = false;
                setLeftType(state, /*type*/ undefined);
                setLastResult(state, /*type*/ undefined);
                state.stackIndex--;
                return result;
            }
            function foldState(state, result, _side) {
                setLastResult(state, result);
                return state;
            }
            function maybeCheckExpression(state, node) {
                if (ts.isBinaryExpression(node)) {
                    return node;
                }
                setLastResult(state, checkExpression(node, state.checkMode));
            }
            function getLeftType(state) {
                return state.typeStack[state.stackIndex];
            }
            function setLeftType(state, type) {
                state.typeStack[state.stackIndex] = type;
            }
            function getLastResult(state) {
                return state.typeStack[state.stackIndex + 1];
            }
            function setLastResult(state, type) {
                // To reduce overhead, reuse the next stack entry to store the
                // last result. This avoids the overhead of an additional property
                // on `WorkArea` and reuses empty stack entries as we walk back up
                // the stack.
                state.typeStack[state.stackIndex + 1] = type;
            }
        }
        function checkGrammarNullishCoalesceWithLogicalExpression(node) {
            var left = node.left, operatorToken = node.operatorToken, right = node.right;
            if (operatorToken.kind === 60 /* QuestionQuestionToken */) {
                if (ts.isBinaryExpression(left) && (left.operatorToken.kind === 56 /* BarBarToken */ || left.operatorToken.kind === 55 /* AmpersandAmpersandToken */)) {
                    grammarErrorOnNode(left, ts.Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, ts.tokenToString(left.operatorToken.kind), ts.tokenToString(operatorToken.kind));
                }
                if (ts.isBinaryExpression(right) && (right.operatorToken.kind === 56 /* BarBarToken */ || right.operatorToken.kind === 55 /* AmpersandAmpersandToken */)) {
                    grammarErrorOnNode(right, ts.Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, ts.tokenToString(right.operatorToken.kind), ts.tokenToString(operatorToken.kind));
                }
            }
        }
        // Note that this and `checkBinaryExpression` above should behave mostly the same, except this elides some
        // expression-wide checks and does not use a work stack to fold nested binary expressions into the same callstack frame
        function checkBinaryLikeExpression(left, operatorToken, right, checkMode, errorNode) {
            var operator = operatorToken.kind;
            if (operator === 63 /* EqualsToken */ && (left.kind === 203 /* ObjectLiteralExpression */ || left.kind === 202 /* ArrayLiteralExpression */)) {
                return checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode, right.kind === 108 /* ThisKeyword */);
            }
            var leftType;
            if (operator === 55 /* AmpersandAmpersandToken */ || operator === 56 /* BarBarToken */ || operator === 60 /* QuestionQuestionToken */) {
                leftType = checkTruthinessExpression(left, checkMode);
            }
            else {
                leftType = checkExpression(left, checkMode);
            }
            var rightType = checkExpression(right, checkMode);
            return checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, errorNode);
        }
        function checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, errorNode) {
            var operator = operatorToken.kind;
            switch (operator) {
                case 41 /* AsteriskToken */:
                case 42 /* AsteriskAsteriskToken */:
                case 66 /* AsteriskEqualsToken */:
                case 67 /* AsteriskAsteriskEqualsToken */:
                case 43 /* SlashToken */:
                case 68 /* SlashEqualsToken */:
                case 44 /* PercentToken */:
                case 69 /* PercentEqualsToken */:
                case 40 /* MinusToken */:
                case 65 /* MinusEqualsToken */:
                case 47 /* LessThanLessThanToken */:
                case 70 /* LessThanLessThanEqualsToken */:
                case 48 /* GreaterThanGreaterThanToken */:
                case 71 /* GreaterThanGreaterThanEqualsToken */:
                case 49 /* GreaterThanGreaterThanGreaterThanToken */:
                case 72 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 51 /* BarToken */:
                case 74 /* BarEqualsToken */:
                case 52 /* CaretToken */:
                case 78 /* CaretEqualsToken */:
                case 50 /* AmpersandToken */:
                case 73 /* AmpersandEqualsToken */:
                    if (leftType === silentNeverType || rightType === silentNeverType) {
                        return silentNeverType;
                    }
                    leftType = checkNonNullType(leftType, left);
                    rightType = checkNonNullType(rightType, right);
                    var suggestedOperator = void 0;
                    // if a user tries to apply a bitwise operator to 2 boolean operands
                    // try and return them a helpful suggestion
                    if ((leftType.flags & 528 /* BooleanLike */) &&
                        (rightType.flags & 528 /* BooleanLike */) &&
                        (suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind)) !== undefined) {
                        error(errorNode || operatorToken, ts.Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, ts.tokenToString(operatorToken.kind), ts.tokenToString(suggestedOperator));
                        return numberType;
                    }
                    else {
                        // otherwise just check each operand separately and report errors as normal
                        var leftOk = checkArithmeticOperandType(left, leftType, ts.Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid*/ true);
                        var rightOk = checkArithmeticOperandType(right, rightType, ts.Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid*/ true);
                        var resultType_1;
                        // If both are any or unknown, allow operation; assume it will resolve to number
                        if ((isTypeAssignableToKind(leftType, 3 /* AnyOrUnknown */) && isTypeAssignableToKind(rightType, 3 /* AnyOrUnknown */)) ||
                            // Or, if neither could be bigint, implicit coercion results in a number result
                            !(maybeTypeOfKind(leftType, 2112 /* BigIntLike */) || maybeTypeOfKind(rightType, 2112 /* BigIntLike */))) {
                            resultType_1 = numberType;
                        }
                        // At least one is assignable to bigint, so check that both are
                        else if (bothAreBigIntLike(leftType, rightType)) {
                            switch (operator) {
                                case 49 /* GreaterThanGreaterThanGreaterThanToken */:
                                case 72 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                                    reportOperatorError();
                                    break;
                                case 42 /* AsteriskAsteriskToken */:
                                case 67 /* AsteriskAsteriskEqualsToken */:
                                    if (languageVersion < 3 /* ES2016 */) {
                                        error(errorNode, ts.Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later);
                                    }
                            }
                            resultType_1 = bigintType;
                        }
                        // Exactly one of leftType/rightType is assignable to bigint
                        else {
                            reportOperatorError(bothAreBigIntLike);
                            resultType_1 = errorType;
                        }
                        if (leftOk && rightOk) {
                            checkAssignmentOperator(resultType_1);
                        }
                        return resultType_1;
                    }
                case 39 /* PlusToken */:
                case 64 /* PlusEqualsToken */:
                    if (leftType === silentNeverType || rightType === silentNeverType) {
                        return silentNeverType;
                    }
                    if (!isTypeAssignableToKind(leftType, 402653316 /* StringLike */) && !isTypeAssignableToKind(rightType, 402653316 /* StringLike */)) {
                        leftType = checkNonNullType(leftType, left);
                        rightType = checkNonNullType(rightType, right);
                    }
                    var resultType = void 0;
                    if (isTypeAssignableToKind(leftType, 296 /* NumberLike */, /*strict*/ true) && isTypeAssignableToKind(rightType, 296 /* NumberLike */, /*strict*/ true)) {
                        // Operands of an enum type are treated as having the primitive type Number.
                        // If both operands are of the Number primitive type, the result is of the Number primitive type.
                        resultType = numberType;
                    }
                    else if (isTypeAssignableToKind(leftType, 2112 /* BigIntLike */, /*strict*/ true) && isTypeAssignableToKind(rightType, 2112 /* BigIntLike */, /*strict*/ true)) {
                        // If both operands are of the BigInt primitive type, the result is of the BigInt primitive type.
                        resultType = bigintType;
                    }
                    else if (isTypeAssignableToKind(leftType, 402653316 /* StringLike */, /*strict*/ true) || isTypeAssignableToKind(rightType, 402653316 /* StringLike */, /*strict*/ true)) {
                        // If one or both operands are of the String primitive type, the result is of the String primitive type.
                        resultType = stringType;
                    }
                    else if (isTypeAny(leftType) || isTypeAny(rightType)) {
                        // Otherwise, the result is of type Any.
                        // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.
                        resultType = leftType === errorType || rightType === errorType ? errorType : anyType;
                    }
                    // Symbols are not allowed at all in arithmetic expressions
                    if (resultType && !checkForDisallowedESSymbolOperand(operator)) {
                        return resultType;
                    }
                    if (!resultType) {
                        // Types that have a reasonably good chance of being a valid operand type.
                        // If both types have an awaited type of one of these, we'll assume the user
                        // might be missing an await without doing an exhaustive check that inserting
                        // await(s) will actually be a completely valid binary expression.
                        var closeEnoughKind_1 = 296 /* NumberLike */ | 2112 /* BigIntLike */ | 402653316 /* StringLike */ | 3 /* AnyOrUnknown */;
                        reportOperatorError(function (left, right) {
                            return isTypeAssignableToKind(left, closeEnoughKind_1) &&
                                isTypeAssignableToKind(right, closeEnoughKind_1);
                        });
                        return anyType;
                    }
                    if (operator === 64 /* PlusEqualsToken */) {
                        checkAssignmentOperator(resultType);
                    }
                    return resultType;
                case 29 /* LessThanToken */:
                case 31 /* GreaterThanToken */:
                case 32 /* LessThanEqualsToken */:
                case 33 /* GreaterThanEqualsToken */:
                    if (checkForDisallowedESSymbolOperand(operator)) {
                        leftType = getBaseTypeOfLiteralType(checkNonNullType(leftType, left));
                        rightType = getBaseTypeOfLiteralType(checkNonNullType(rightType, right));
                        reportOperatorErrorUnless(function (left, right) {
                            return isTypeComparableTo(left, right) || isTypeComparableTo(right, left) || (isTypeAssignableTo(left, numberOrBigIntType) && isTypeAssignableTo(right, numberOrBigIntType));
                        });
                    }
                    return booleanType;
                case 34 /* EqualsEqualsToken */:
                case 35 /* ExclamationEqualsToken */:
                case 36 /* EqualsEqualsEqualsToken */:
                case 37 /* ExclamationEqualsEqualsToken */:
                    reportOperatorErrorUnless(function (left, right) { return isTypeEqualityComparableTo(left, right) || isTypeEqualityComparableTo(right, left); });
                    return booleanType;
                case 102 /* InstanceOfKeyword */:
                    return checkInstanceOfExpression(left, right, leftType, rightType);
                case 101 /* InKeyword */:
                    return checkInExpression(left, right, leftType, rightType);
                case 55 /* AmpersandAmpersandToken */:
                case 76 /* AmpersandAmpersandEqualsToken */: {
                    var resultType_2 = getTypeFacts(leftType) & 4194304 /* Truthy */ ?
                        getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) :
                        leftType;
                    if (operator === 76 /* AmpersandAmpersandEqualsToken */) {
                        checkAssignmentOperator(rightType);
                    }
                    return resultType_2;
                }
                case 56 /* BarBarToken */:
                case 75 /* BarBarEqualsToken */: {
                    var resultType_3 = getTypeFacts(leftType) & 8388608 /* Falsy */ ?
                        getUnionType([removeDefinitelyFalsyTypes(leftType), rightType], 2 /* Subtype */) :
                        leftType;
                    if (operator === 75 /* BarBarEqualsToken */) {
                        checkAssignmentOperator(rightType);
                    }
                    return resultType_3;
                }
                case 60 /* QuestionQuestionToken */:
                case 77 /* QuestionQuestionEqualsToken */: {
                    var resultType_4 = getTypeFacts(leftType) & 262144 /* EQUndefinedOrNull */ ?
                        getUnionType([getNonNullableType(leftType), rightType], 2 /* Subtype */) :
                        leftType;
                    if (operator === 77 /* QuestionQuestionEqualsToken */) {
                        checkAssignmentOperator(rightType);
                    }
                    return resultType_4;
                }
                case 63 /* EqualsToken */:
                    var declKind = ts.isBinaryExpression(left.parent) ? ts.getAssignmentDeclarationKind(left.parent) : 0 /* None */;
                    checkAssignmentDeclaration(declKind, rightType);
                    if (isAssignmentDeclaration(declKind)) {
                        if (!(rightType.flags & 524288 /* Object */) ||
                            declKind !== 2 /* ModuleExports */ &&
                                declKind !== 6 /* Prototype */ &&
                                !isEmptyObjectType(rightType) &&
                                !isFunctionObjectType(rightType) &&
                                !(ts.getObjectFlags(rightType) & 1 /* Class */)) {
                            // don't check assignability of module.exports=, C.prototype=, or expando types because they will necessarily be incomplete
                            checkAssignmentOperator(rightType);
                        }
                        return leftType;
                    }
                    else {
                        checkAssignmentOperator(rightType);
                        return getRegularTypeOfObjectLiteral(rightType);
                    }
                case 27 /* CommaToken */:
                    if (!compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isEvalNode(right)) {
                        var sf = ts.getSourceFileOfNode(left);
                        var sourceText = sf.text;
                        var start_3 = ts.skipTrivia(sourceText, left.pos);
                        var isInDiag2657 = sf.parseDiagnostics.some(function (diag) {
                            if (diag.code !== ts.Diagnostics.JSX_expressions_must_have_one_parent_element.code)
                                return false;
                            return ts.textSpanContainsPosition(diag, start_3);
                        });
                        if (!isInDiag2657)
                            error(left, ts.Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects);
                    }
                    return rightType;
                default:
                    return ts.Debug.fail();
            }
            function bothAreBigIntLike(left, right) {
                return isTypeAssignableToKind(left, 2112 /* BigIntLike */) && isTypeAssignableToKind(right, 2112 /* BigIntLike */);
            }
            function checkAssignmentDeclaration(kind, rightType) {
                if (kind === 2 /* ModuleExports */) {
                    for (var _i = 0, _a = getPropertiesOfObjectType(rightType); _i < _a.length; _i++) {
                        var prop = _a[_i];
                        var propType = getTypeOfSymbol(prop);
                        if (propType.symbol && propType.symbol.flags & 32 /* Class */) {
                            var name = prop.escapedName;
                            var symbol = resolveName(prop.valueDeclaration, name, 788968 /* Type */, undefined, name, /*isUse*/ false);
                            if ((symbol === null || symbol === void 0 ? void 0 : symbol.declarations) && symbol.declarations.some(ts.isJSDocTypedefTag)) {
                                addDuplicateDeclarationErrorsForSymbols(symbol, ts.Diagnostics.Duplicate_identifier_0, ts.unescapeLeadingUnderscores(name), prop);
                                addDuplicateDeclarationErrorsForSymbols(prop, ts.Diagnostics.Duplicate_identifier_0, ts.unescapeLeadingUnderscores(name), symbol);
                            }
                        }
                    }
                }
            }
            function isEvalNode(node) {
                return node.kind === 79 /* Identifier */ && node.escapedText === "eval";
            }
            // Return true if there was no error, false if there was an error.
            function checkForDisallowedESSymbolOperand(operator) {
                var offendingSymbolOperand = maybeTypeOfKind(leftType, 12288 /* ESSymbolLike */) ? left :
                    maybeTypeOfKind(rightType, 12288 /* ESSymbolLike */) ? right :
                        undefined;
                if (offendingSymbolOperand) {
                    error(offendingSymbolOperand, ts.Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, ts.tokenToString(operator));
                    return false;
                }
                return true;
            }
            function getSuggestedBooleanOperator(operator) {
                switch (operator) {
                    case 51 /* BarToken */:
                    case 74 /* BarEqualsToken */:
                        return 56 /* BarBarToken */;
                    case 52 /* CaretToken */:
                    case 78 /* CaretEqualsToken */:
                        return 37 /* ExclamationEqualsEqualsToken */;
                    case 50 /* AmpersandToken */:
                    case 73 /* AmpersandEqualsToken */:
                        return 55 /* AmpersandAmpersandToken */;
                    default:
                        return undefined;
                }
            }
            function checkAssignmentOperator(valueType) {
                if (produceDiagnostics && ts.isAssignmentOperator(operator)) {
                    // TypeScript 1.0 spec (April 2014): 4.17
                    // An assignment of the form
                    //    VarExpr = ValueExpr
                    // requires VarExpr to be classified as a reference
                    // A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1)
                    // and the type of the non-compound operation to be assignable to the type of VarExpr.
                    if (checkReferenceExpression(left, ts.Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access, ts.Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access)
                        && (!ts.isIdentifier(left) || ts.unescapeLeadingUnderscores(left.escapedText) !== "exports")) {
                        // to avoid cascading errors check assignability only if 'isReference' check succeeded and no errors were reported
                        checkTypeAssignableToAndOptionallyElaborate(valueType, leftType, left, right);
                    }
                }
            }
            function isAssignmentDeclaration(kind) {
                var _a;
                switch (kind) {
                    case 2 /* ModuleExports */:
                        return true;
                    case 1 /* ExportsProperty */:
                    case 5 /* Property */:
                    case 6 /* Prototype */:
                    case 3 /* PrototypeProperty */:
                    case 4 /* ThisProperty */:
                        var symbol = getSymbolOfNode(left);
                        var init = ts.getAssignedExpandoInitializer(right);
                        return !!init && ts.isObjectLiteralExpression(init) &&
                            !!((_a = symbol === null || symbol === void 0 ? void 0 : symbol.exports) === null || _a === void 0 ? void 0 : _a.size);
                    default:
                        return false;
                }
            }
            /**
             * Returns true if an error is reported
             */
            function reportOperatorErrorUnless(typesAreCompatible) {
                if (!typesAreCompatible(leftType, rightType)) {
                    reportOperatorError(typesAreCompatible);
                    return true;
                }
                return false;
            }
            function reportOperatorError(isRelated) {
                var _a;
                var wouldWorkWithAwait = false;
                var errNode = errorNode || operatorToken;
                if (isRelated) {
                    var awaitedLeftType = getAwaitedType(leftType);
                    var awaitedRightType = getAwaitedType(rightType);
                    wouldWorkWithAwait = !(awaitedLeftType === leftType && awaitedRightType === rightType)
                        && !!(awaitedLeftType && awaitedRightType)
                        && isRelated(awaitedLeftType, awaitedRightType);
                }
                var effectiveLeft = leftType;
                var effectiveRight = rightType;
                if (!wouldWorkWithAwait && isRelated) {
                    _a = getBaseTypesIfUnrelated(leftType, rightType, isRelated), effectiveLeft = _a[0], effectiveRight = _a[1];
                }
                var _b = getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight), leftStr = _b[0], rightStr = _b[1];
                if (!tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr)) {
                    errorAndMaybeSuggestAwait(errNode, wouldWorkWithAwait, ts.Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, ts.tokenToString(operatorToken.kind), leftStr, rightStr);
                }
            }
            function tryGiveBetterPrimaryError(errNode, maybeMissingAwait, leftStr, rightStr) {
                var typeName;
                switch (operatorToken.kind) {
                    case 36 /* EqualsEqualsEqualsToken */:
                    case 34 /* EqualsEqualsToken */:
                        typeName = "false";
                        break;
                    case 37 /* ExclamationEqualsEqualsToken */:
                    case 35 /* ExclamationEqualsToken */:
                        typeName = "true";
                }
                if (typeName) {
                    return errorAndMaybeSuggestAwait(errNode, maybeMissingAwait, ts.Diagnostics.This_condition_will_always_return_0_since_the_types_1_and_2_have_no_overlap, typeName, leftStr, rightStr);
                }
                return undefined;
            }
        }
        function getBaseTypesIfUnrelated(leftType, rightType, isRelated) {
            var effectiveLeft = leftType;
            var effectiveRight = rightType;
            var leftBase = getBaseTypeOfLiteralType(leftType);
            var rightBase = getBaseTypeOfLiteralType(rightType);
            if (!isRelated(leftBase, rightBase)) {
                effectiveLeft = leftBase;
                effectiveRight = rightBase;
            }
            return [effectiveLeft, effectiveRight];
        }
        function checkYieldExpression(node) {
            // Grammar checking
            if (produceDiagnostics) {
                if (!(node.flags & 8192 /* YieldContext */)) {
                    grammarErrorOnFirstToken(node, ts.Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body);
                }
                if (isInParameterInitializerBeforeContainingFunction(node)) {
                    error(node, ts.Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer);
                }
            }
            var func = ts.getContainingFunction(node);
            if (!func)
                return anyType;
            var functionFlags = ts.getFunctionFlags(func);
            if (!(functionFlags & 1 /* Generator */)) {
                // If the user's code is syntactically correct, the func should always have a star. After all, we are in a yield context.
                return anyType;
            }
            var isAsync = (functionFlags & 2 /* Async */) !== 0;
            if (node.asteriskToken) {
                // Async generator functions prior to ESNext require the __await, __asyncDelegator,
                // and __asyncValues helpers
                if (isAsync && languageVersion < 99 /* ESNext */) {
                    checkExternalEmitHelpers(node, 26624 /* AsyncDelegatorIncludes */);
                }
                // Generator functions prior to ES2015 require the __values helper
                if (!isAsync && languageVersion < 2 /* ES2015 */ && compilerOptions.downlevelIteration) {
                    checkExternalEmitHelpers(node, 256 /* Values */);
                }
            }
            // There is no point in doing an assignability check if the function
            // has no explicit return type because the return type is directly computed
            // from the yield expressions.
            var returnType = getReturnTypeFromAnnotation(func);
            var iterationTypes = returnType && getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync);
            var signatureYieldType = iterationTypes && iterationTypes.yieldType || anyType;
            var signatureNextType = iterationTypes && iterationTypes.nextType || anyType;
            var resolvedSignatureNextType = isAsync ? getAwaitedType(signatureNextType) || anyType : signatureNextType;
            var yieldExpressionType = node.expression ? checkExpression(node.expression) : undefinedWideningType;
            var yieldedType = getYieldedTypeOfYieldExpression(node, yieldExpressionType, resolvedSignatureNextType, isAsync);
            if (returnType && yieldedType) {
                checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType, node.expression || node, node.expression);
            }
            if (node.asteriskToken) {
                var use = isAsync ? 19 /* AsyncYieldStar */ : 17 /* YieldStar */;
                return getIterationTypeOfIterable(use, 1 /* Return */, yieldExpressionType, node.expression)
                    || anyType;
            }
            else if (returnType) {
                return getIterationTypeOfGeneratorFunctionReturnType(2 /* Next */, returnType, isAsync)
                    || anyType;
            }
            var type = getContextualIterationType(2 /* Next */, func);
            if (!type) {
                type = anyType;
                if (produceDiagnostics && noImplicitAny && !ts.expressionResultIsUnused(node)) {
                    var contextualType = getContextualType(node);
                    if (!contextualType || isTypeAny(contextualType)) {
                        error(node, ts.Diagnostics.yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation);
                    }
                }
            }
            return type;
        }
        function checkConditionalExpression(node, checkMode) {
            var type = checkTruthinessExpression(node.condition);
            checkTestingKnownTruthyCallableOrAwaitableType(node.condition, type, node.whenTrue);
            var type1 = checkExpression(node.whenTrue, checkMode);
            var type2 = checkExpression(node.whenFalse, checkMode);
            return getUnionType([type1, type2], 2 /* Subtype */);
        }
        function isTemplateLiteralContext(node) {
            var parent = node.parent;
            return ts.isParenthesizedExpression(parent) && isTemplateLiteralContext(parent) ||
                ts.isElementAccessExpression(parent) && parent.argumentExpression === node;
        }
        function checkTemplateExpression(node) {
            var texts = [node.head.text];
            var types = [];
            for (var _i = 0, _a = node.templateSpans; _i < _a.length; _i++) {
                var span = _a[_i];
                var type = checkExpression(span.expression);
                if (maybeTypeOfKind(type, 12288 /* ESSymbolLike */)) {
                    error(span.expression, ts.Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String);
                }
                texts.push(span.literal.text);
                types.push(isTypeAssignableTo(type, templateConstraintType) ? type : stringType);
            }
            return isConstContext(node) || isTemplateLiteralContext(node) || someType(getContextualType(node) || unknownType, isTemplateLiteralContextualType) ? getTemplateLiteralType(texts, types) : stringType;
        }
        function isTemplateLiteralContextualType(type) {
            return !!(type.flags & (128 /* StringLiteral */ | 134217728 /* TemplateLiteral */) ||
                type.flags & 58982400 /* InstantiableNonPrimitive */ && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, 402653316 /* StringLike */));
        }
        function getContextNode(node) {
            if (node.kind === 284 /* JsxAttributes */ && !ts.isJsxSelfClosingElement(node.parent)) {
                return node.parent.parent; // Needs to be the root JsxElement, so it encompasses the attributes _and_ the children (which are essentially part of the attributes)
            }
            return node;
        }
        function checkExpressionWithContextualType(node, contextualType, inferenceContext, checkMode) {
            var context = getContextNode(node);
            var saveContextualType = context.contextualType;
            var saveInferenceContext = context.inferenceContext;
            try {
                context.contextualType = contextualType;
                context.inferenceContext = inferenceContext;
                var type = checkExpression(node, checkMode | 1 /* Contextual */ | (inferenceContext ? 2 /* Inferential */ : 0));
                // We strip literal freshness when an appropriate contextual type is present such that contextually typed
                // literals always preserve their literal types (otherwise they might widen during type inference). An alternative
                // here would be to not mark contextually typed literals as fresh in the first place.
                var result = maybeTypeOfKind(type, 2944 /* Literal */) && isLiteralOfContextualType(type, instantiateContextualType(contextualType, node)) ?
                    getRegularTypeOfLiteralType(type) : type;
                return result;
            }
            finally {
                // In the event our operation is canceled or some other exception occurs, reset the contextual type
                // so that we do not accidentally hold onto an instance of the checker, as a Type created in the services layer
                // may hold onto the checker that created it.
                context.contextualType = saveContextualType;
                context.inferenceContext = saveInferenceContext;
            }
        }
        function checkExpressionCached(node, checkMode) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                if (checkMode && checkMode !== 0 /* Normal */) {
                    return checkExpression(node, checkMode);
                }
                // When computing a type that we're going to cache, we need to ignore any ongoing control flow
                // analysis because variables may have transient types in indeterminable states. Moving flowLoopStart
                // to the top of the stack ensures all transient types are computed from a known point.
                var saveFlowLoopStart = flowLoopStart;
                var saveFlowTypeCache = flowTypeCache;
                flowLoopStart = flowLoopCount;
                flowTypeCache = undefined;
                links.resolvedType = checkExpression(node, checkMode);
                flowTypeCache = saveFlowTypeCache;
                flowLoopStart = saveFlowLoopStart;
            }
            return links.resolvedType;
        }
        function isTypeAssertion(node) {
            node = ts.skipParentheses(node);
            return node.kind === 209 /* TypeAssertionExpression */ || node.kind === 227 /* AsExpression */;
        }
        function checkDeclarationInitializer(declaration, contextualType) {
            var initializer = ts.getEffectiveInitializer(declaration);
            var type = getQuickTypeOfExpression(initializer) ||
                (contextualType ? checkExpressionWithContextualType(initializer, contextualType, /*inferenceContext*/ undefined, 0 /* Normal */) : checkExpressionCached(initializer));
            return ts.isParameter(declaration) && declaration.name.kind === 200 /* ArrayBindingPattern */ &&
                isTupleType(type) && !type.target.hasRestElement && getTypeReferenceArity(type) < declaration.name.elements.length ?
                padTupleType(type, declaration.name) : type;
        }
        function padTupleType(type, pattern) {
            var patternElements = pattern.elements;
            var elementTypes = getTypeArguments(type).slice();
            var elementFlags = type.target.elementFlags.slice();
            for (var i = getTypeReferenceArity(type); i < patternElements.length; i++) {
                var e = patternElements[i];
                if (i < patternElements.length - 1 || !(e.kind === 201 /* BindingElement */ && e.dotDotDotToken)) {
                    elementTypes.push(!ts.isOmittedExpression(e) && hasDefaultValue(e) ? getTypeFromBindingElement(e, /*includePatternInType*/ false, /*reportErrors*/ false) : anyType);
                    elementFlags.push(2 /* Optional */);
                    if (!ts.isOmittedExpression(e) && !hasDefaultValue(e)) {
                        reportImplicitAny(e, anyType);
                    }
                }
            }
            return createTupleType(elementTypes, elementFlags, type.target.readonly);
        }
        function widenTypeInferredFromInitializer(declaration, type) {
            var widened = ts.getCombinedNodeFlags(declaration) & 2 /* Const */ || ts.isDeclarationReadonly(declaration) ? type : getWidenedLiteralType(type);
            if (ts.isInJSFile(declaration)) {
                if (isEmptyLiteralType(widened)) {
                    reportImplicitAny(declaration, anyType);
                    return anyType;
                }
                else if (isEmptyArrayLiteralType(widened)) {
                    reportImplicitAny(declaration, anyArrayType);
                    return anyArrayType;
                }
            }
            return widened;
        }
        function isLiteralOfContextualType(candidateType, contextualType) {
            if (contextualType) {
                if (contextualType.flags & 3145728 /* UnionOrIntersection */) {
                    var types = contextualType.types;
                    return ts.some(types, function (t) { return isLiteralOfContextualType(candidateType, t); });
                }
                if (contextualType.flags & 58982400 /* InstantiableNonPrimitive */) {
                    // If the contextual type is a type variable constrained to a primitive type, consider
                    // this a literal context for literals of that primitive type. For example, given a
                    // type parameter 'T extends string', infer string literal types for T.
                    var constraint = getBaseConstraintOfType(contextualType) || unknownType;
                    return maybeTypeOfKind(constraint, 4 /* String */) && maybeTypeOfKind(candidateType, 128 /* StringLiteral */) ||
                        maybeTypeOfKind(constraint, 8 /* Number */) && maybeTypeOfKind(candidateType, 256 /* NumberLiteral */) ||
                        maybeTypeOfKind(constraint, 64 /* BigInt */) && maybeTypeOfKind(candidateType, 2048 /* BigIntLiteral */) ||
                        maybeTypeOfKind(constraint, 4096 /* ESSymbol */) && maybeTypeOfKind(candidateType, 8192 /* UniqueESSymbol */) ||
                        isLiteralOfContextualType(candidateType, constraint);
                }
                // If the contextual type is a literal of a particular primitive type, we consider this a
                // literal context for all literals of that primitive type.
                return !!(contextualType.flags & (128 /* StringLiteral */ | 4194304 /* Index */ | 134217728 /* TemplateLiteral */ | 268435456 /* StringMapping */) && maybeTypeOfKind(candidateType, 128 /* StringLiteral */) ||
                    contextualType.flags & 256 /* NumberLiteral */ && maybeTypeOfKind(candidateType, 256 /* NumberLiteral */) ||
                    contextualType.flags & 2048 /* BigIntLiteral */ && maybeTypeOfKind(candidateType, 2048 /* BigIntLiteral */) ||
                    contextualType.flags & 512 /* BooleanLiteral */ && maybeTypeOfKind(candidateType, 512 /* BooleanLiteral */) ||
                    contextualType.flags & 8192 /* UniqueESSymbol */ && maybeTypeOfKind(candidateType, 8192 /* UniqueESSymbol */));
            }
            return false;
        }
        function isConstContext(node) {
            var parent = node.parent;
            return ts.isAssertionExpression(parent) && ts.isConstTypeReference(parent.type) ||
                (ts.isParenthesizedExpression(parent) || ts.isArrayLiteralExpression(parent) || ts.isSpreadElement(parent)) && isConstContext(parent) ||
                (ts.isPropertyAssignment(parent) || ts.isShorthandPropertyAssignment(parent) || ts.isTemplateSpan(parent)) && isConstContext(parent.parent);
        }
        function checkExpressionForMutableLocation(node, checkMode, contextualType, forceTuple) {
            var type = checkExpression(node, checkMode, forceTuple);
            return isConstContext(node) ? getRegularTypeOfLiteralType(type) :
                isTypeAssertion(node) ? type :
                    getWidenedLiteralLikeTypeForContextualType(type, instantiateContextualType(arguments.length === 2 ? getContextualType(node) : contextualType, node));
        }
        function checkPropertyAssignment(node, checkMode) {
            // Do not use hasDynamicName here, because that returns false for well known symbols.
            // We want to perform checkComputedPropertyName for all computed properties, including
            // well known symbols.
            if (node.name.kind === 160 /* ComputedPropertyName */) {
                checkComputedPropertyName(node.name);
            }
            return checkExpressionForMutableLocation(node.initializer, checkMode);
        }
        function checkObjectLiteralMethod(node, checkMode) {
            // Grammar checking
            checkGrammarMethod(node);
            // Do not use hasDynamicName here, because that returns false for well known symbols.
            // We want to perform checkComputedPropertyName for all computed properties, including
            // well known symbols.
            if (node.name.kind === 160 /* ComputedPropertyName */) {
                checkComputedPropertyName(node.name);
            }
            var uninstantiatedType = checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
            return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
        }
        function instantiateTypeWithSingleGenericCallSignature(node, type, checkMode) {
            if (checkMode && checkMode & (2 /* Inferential */ | 8 /* SkipGenericFunctions */)) {
                var callSignature = getSingleSignature(type, 0 /* Call */, /*allowMembers*/ true);
                var constructSignature = getSingleSignature(type, 1 /* Construct */, /*allowMembers*/ true);
                var signature = callSignature || constructSignature;
                if (signature && signature.typeParameters) {
                    var contextualType = getApparentTypeOfContextualType(node, 2 /* NoConstraints */);
                    if (contextualType) {
                        var contextualSignature = getSingleSignature(getNonNullableType(contextualType), callSignature ? 0 /* Call */ : 1 /* Construct */, /*allowMembers*/ false);
                        if (contextualSignature && !contextualSignature.typeParameters) {
                            if (checkMode & 8 /* SkipGenericFunctions */) {
                                skippedGenericFunction(node, checkMode);
                                return anyFunctionType;
                            }
                            var context = getInferenceContext(node);
                            // We have an expression that is an argument of a generic function for which we are performing
                            // type argument inference. The expression is of a function type with a single generic call
                            // signature and a contextual function type with a single non-generic call signature. Now check
                            // if the outer function returns a function type with a single non-generic call signature and
                            // if some of the outer function type parameters have no inferences so far. If so, we can
                            // potentially add inferred type parameters to the outer function return type.
                            var returnType = context.signature && getReturnTypeOfSignature(context.signature);
                            var returnSignature = returnType && getSingleCallOrConstructSignature(returnType);
                            if (returnSignature && !returnSignature.typeParameters && !ts.every(context.inferences, hasInferenceCandidates)) {
                                // Instantiate the signature with its own type parameters as type arguments, possibly
                                // renaming the type parameters to ensure they have unique names.
                                var uniqueTypeParameters = getUniqueTypeParameters(context, signature.typeParameters);
                                var instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters);
                                // Infer from the parameters of the instantiated signature to the parameters of the
                                // contextual signature starting with an empty set of inference candidates.
                                var inferences_3 = ts.map(context.inferences, function (info) { return createInferenceInfo(info.typeParameter); });
                                applyToParameterTypes(instantiatedSignature, contextualSignature, function (source, target) {
                                    inferTypes(inferences_3, source, target, /*priority*/ 0, /*contravariant*/ true);
                                });
                                if (ts.some(inferences_3, hasInferenceCandidates)) {
                                    // We have inference candidates, indicating that one or more type parameters are referenced
                                    // in the parameter types of the contextual signature. Now also infer from the return type.
                                    applyToReturnTypes(instantiatedSignature, contextualSignature, function (source, target) {
                                        inferTypes(inferences_3, source, target);
                                    });
                                    // If the type parameters for which we produced candidates do not have any inferences yet,
                                    // we adopt the new inference candidates and add the type parameters of the expression type
                                    // to the set of inferred type parameters for the outer function return type.
                                    if (!hasOverlappingInferences(context.inferences, inferences_3)) {
                                        mergeInferences(context.inferences, inferences_3);
                                        context.inferredTypeParameters = ts.concatenate(context.inferredTypeParameters, uniqueTypeParameters);
                                        return getOrCreateTypeFromSignature(instantiatedSignature);
                                    }
                                }
                            }
                            return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context));
                        }
                    }
                }
            }
            return type;
        }
        function skippedGenericFunction(node, checkMode) {
            if (checkMode & 2 /* Inferential */) {
                // We have skipped a generic function during inferential typing. Obtain the inference context and
                // indicate this has occurred such that we know a second pass of inference is be needed.
                var context = getInferenceContext(node);
                context.flags |= 4 /* SkippedGenericFunction */;
            }
        }
        function hasInferenceCandidates(info) {
            return !!(info.candidates || info.contraCandidates);
        }
        function hasOverlappingInferences(a, b) {
            for (var i = 0; i < a.length; i++) {
                if (hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i])) {
                    return true;
                }
            }
            return false;
        }
        function mergeInferences(target, source) {
            for (var i = 0; i < target.length; i++) {
                if (!hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i])) {
                    target[i] = source[i];
                }
            }
        }
        function getUniqueTypeParameters(context, typeParameters) {
            var result = [];
            var oldTypeParameters;
            var newTypeParameters;
            for (var _i = 0, typeParameters_2 = typeParameters; _i < typeParameters_2.length; _i++) {
                var tp = typeParameters_2[_i];
                var name = tp.symbol.escapedName;
                if (hasTypeParameterByName(context.inferredTypeParameters, name) || hasTypeParameterByName(result, name)) {
                    var newName = getUniqueTypeParameterName(ts.concatenate(context.inferredTypeParameters, result), name);
                    var symbol = createSymbol(262144 /* TypeParameter */, newName);
                    var newTypeParameter = createTypeParameter(symbol);
                    newTypeParameter.target = tp;
                    oldTypeParameters = ts.append(oldTypeParameters, tp);
                    newTypeParameters = ts.append(newTypeParameters, newTypeParameter);
                    result.push(newTypeParameter);
                }
                else {
                    result.push(tp);
                }
            }
            if (newTypeParameters) {
                var mapper = createTypeMapper(oldTypeParameters, newTypeParameters);
                for (var _a = 0, newTypeParameters_1 = newTypeParameters; _a < newTypeParameters_1.length; _a++) {
                    var tp = newTypeParameters_1[_a];
                    tp.mapper = mapper;
                }
            }
            return result;
        }
        function hasTypeParameterByName(typeParameters, name) {
            return ts.some(typeParameters, function (tp) { return tp.symbol.escapedName === name; });
        }
        function getUniqueTypeParameterName(typeParameters, baseName) {
            var len = baseName.length;
            while (len > 1 && baseName.charCodeAt(len - 1) >= 48 /* _0 */ && baseName.charCodeAt(len - 1) <= 57 /* _9 */)
                len--;
            var s = baseName.slice(0, len);
            for (var index = 1; true; index++) {
                var augmentedName = s + index;
                if (!hasTypeParameterByName(typeParameters, augmentedName)) {
                    return augmentedName;
                }
            }
        }
        function getReturnTypeOfSingleNonGenericCallSignature(funcType) {
            var signature = getSingleCallSignature(funcType);
            if (signature && !signature.typeParameters) {
                return getReturnTypeOfSignature(signature);
            }
        }
        function getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) {
            var funcType = checkExpression(expr.expression);
            var nonOptionalType = getOptionalExpressionType(funcType, expr.expression);
            var returnType = getReturnTypeOfSingleNonGenericCallSignature(funcType);
            return returnType && propagateOptionalTypeMarker(returnType, expr, nonOptionalType !== funcType);
        }
        /**
         * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
         * with computing the type and may not fully check all contained sub-expressions for errors.
         */
        function getTypeOfExpression(node) {
            // Don't bother caching types that require no flow analysis and are quick to compute.
            var quickType = getQuickTypeOfExpression(node);
            if (quickType) {
                return quickType;
            }
            // If a type has been cached for the node, return it.
            if (node.flags & 67108864 /* TypeCached */ && flowTypeCache) {
                var cachedType = flowTypeCache[getNodeId(node)];
                if (cachedType) {
                    return cachedType;
                }
            }
            var startInvocationCount = flowInvocationCount;
            var type = checkExpression(node);
            // If control flow analysis was required to determine the type, it is worth caching.
            if (flowInvocationCount !== startInvocationCount) {
                var cache = flowTypeCache || (flowTypeCache = []);
                cache[getNodeId(node)] = type;
                ts.setNodeFlags(node, node.flags | 67108864 /* TypeCached */);
            }
            return type;
        }
        function getQuickTypeOfExpression(node) {
            var expr = ts.skipParentheses(node);
            // Optimize for the common case of a call to a function with a single non-generic call
            // signature where we can just fetch the return type without checking the arguments.
            if (ts.isCallExpression(expr) && expr.expression.kind !== 106 /* SuperKeyword */ && !ts.isRequireCall(expr, /*checkArgumentIsStringLiteralLike*/ true) && !isSymbolOrSymbolForCall(expr)) {
                var type = ts.isCallChain(expr) ? getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) :
                    getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression));
                if (type) {
                    return type;
                }
            }
            else if (ts.isAssertionExpression(expr) && !ts.isConstTypeReference(expr.type)) {
                return getTypeFromTypeNode(expr.type);
            }
            else if (node.kind === 8 /* NumericLiteral */ || node.kind === 10 /* StringLiteral */ ||
                node.kind === 110 /* TrueKeyword */ || node.kind === 95 /* FalseKeyword */) {
                return checkExpression(node);
            }
            return undefined;
        }
        /**
         * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
         * with computing the type and may not fully check all contained sub-expressions for errors.
         * It is intended for uses where you know there is no contextual type,
         * and requesting the contextual type might cause a circularity or other bad behaviour.
         * It sets the contextual type of the node to any before calling getTypeOfExpression.
         */
        function getContextFreeTypeOfExpression(node) {
            var links = getNodeLinks(node);
            if (links.contextFreeType) {
                return links.contextFreeType;
            }
            var saveContextualType = node.contextualType;
            node.contextualType = anyType;
            try {
                var type = links.contextFreeType = checkExpression(node, 4 /* SkipContextSensitive */);
                return type;
            }
            finally {
                // In the event our operation is canceled or some other exception occurs, reset the contextual type
                // so that we do not accidentally hold onto an instance of the checker, as a Type created in the services layer
                // may hold onto the checker that created it.
                node.contextualType = saveContextualType;
            }
        }
        function checkExpression(node, checkMode, forceTuple) {
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("check" /* Check */, "checkExpression", { kind: node.kind, pos: node.pos, end: node.end });
            var saveCurrentNode = currentNode;
            currentNode = node;
            instantiationCount = 0;
            var uninstantiatedType = checkExpressionWorker(node, checkMode, forceTuple);
            var type = instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
            if (isConstEnumObjectType(type)) {
                checkConstEnumAccess(node, type);
            }
            currentNode = saveCurrentNode;
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            return type;
        }
        function checkConstEnumAccess(node, type) {
            // enum object type for const enums are only permitted in:
            // - 'left' in property access
            // - 'object' in indexed access
            // - target in rhs of import statement
            var ok = (node.parent.kind === 204 /* PropertyAccessExpression */ && node.parent.expression === node) ||
                (node.parent.kind === 205 /* ElementAccessExpression */ && node.parent.expression === node) ||
                ((node.kind === 79 /* Identifier */ || node.kind === 159 /* QualifiedName */) && isInRightSideOfImportOrExportAssignment(node) ||
                    (node.parent.kind === 179 /* TypeQuery */ && node.parent.exprName === node)) ||
                (node.parent.kind === 273 /* ExportSpecifier */); // We allow reexporting const enums
            if (!ok) {
                error(node, ts.Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query);
            }
            if (compilerOptions.isolatedModules) {
                ts.Debug