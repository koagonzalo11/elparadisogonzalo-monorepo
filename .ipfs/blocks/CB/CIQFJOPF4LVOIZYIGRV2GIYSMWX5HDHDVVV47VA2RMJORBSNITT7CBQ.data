;
}

function isEmptyNode(node) {
  return (!node.children || node.children.length === 0) && !hasComments(node);
}

function hasComments(node) {
  return hasLeadingComments(node) || hasMiddleComments(node) || hasIndicatorComment(node) || hasTrailingComment$2(node) || hasEndComments(node);
}

function hasLeadingComments(node) {
  return node && node.leadingComments && node.leadingComments.length !== 0;
}

function hasMiddleComments(node) {
  return node && node.middleComments && node.middleComments.length !== 0;
}

function hasIndicatorComment(node) {
  return node && node.indicatorComment;
}

function hasTrailingComment$2(node) {
  return node && node.trailingComment;
}

function hasEndComments(node) {
  return node && node.endComments && node.endComments.length !== 0;
}
/**
 * " a   b c   d e   f " -> [" a   b", "c   d", "e   f "]
 */


function splitWithSingleSpace(text) {
  var parts = [];
  var lastPart = undefined;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = text.split(/( +)/g)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var part = _step.value;

      if (part !== " ") {
        if (lastPart === " ") {
          parts.push(part);
        } else {
          parts.push((parts.pop() || "") + part);
        }
      } else if (lastPart === undefined) {
        parts.unshift("");
      }

      lastPart = part;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (lastPart === " ") {
    parts.push((parts.pop() || "") + " ");
  }

  if (parts[0] === "") {
    parts.shift();
    parts.unshift(" " + (parts.shift() || ""));
  }

  return parts;
}

function getFlowScalarLineContents(nodeType, content, options) {
  var rawLineContents = content.split("\n").map(function (lineContent, index, lineContents) {
    return index === 0 && index === lineContents.length - 1 ? lineContent : index !== 0 && index !== lineContents.length - 1 ? lineContent.trim() : index === 0 ? lineContent.trimRight() : lineContent.trimLeft();
  });

  if (options.proseWrap === "preserve") {
    return rawLineContents.map(function (lineContent) {
      return lineContent.length === 0 ? [] : [lineContent];
    });
  }

  return rawLineContents.map(function (lineContent) {
    return lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent);
  }).reduce(function (reduced, lineContentWords, index) {
    return index !== 0 && rawLineContents[index - 1].length !== 0 && lineContentWords.length !== 0 && !( // trailing backslash in quoteDouble should be preserved
    nodeType === "quoteDouble" && getLast$4(getLast$4(reduced)).endsWith("\\")) ? reduced.concat([reduced.pop().concat(lineContentWords)]) : reduced.concat([lineContentWords]);
  }, []).map(function (lineContentWords) {
    return options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords;
  });
}

function getBlockValueLineContents(node, _ref) {
  var parentIndent = _ref.parentIndent,
      isLastDescendant = _ref.isLastDescendant,
      options = _ref.options;
  var content = node.position.start.line === node.position.end.line ? "" : options.originalText.slice(node.position.start.offset, node.position.end.offset) // exclude open line `>` or `|`
  .match(/^[^\n]*?\n([\s\S]*)$/)[1];
  var leadingSpaceCount = node.indent === null ? function (match) {
    return match ? match[1].length : Infinity;
  }(content.match(/^( *)\S/m)) : node.indent - 1 + parentIndent;
  var rawLineContents = content.split("\n").map(function (lineContent) {
    return lineContent.slice(leadingSpaceCount);
  });

  if (options.proseWrap === "preserve" || node.type === "blockLiteral") {
    return removeUnnecessaryTrailingNewlines(rawLineContents.map(function (lineContent) {
      return lineContent.length === 0 ? [] : [lineContent];
    }));
  }

  return removeUnnecessaryTrailingNewlines(rawLineContents.map(function (lineContent) {
    return lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent);
  }).reduce(function (reduced, lineContentWords, index) {
    return index !== 0 && rawLineContents[index - 1].length !== 0 && lineContentWords.length !== 0 && !/^\s/.test(lineContentWords[0]) && !/^\s|\s$/.test(getLast$4(reduced)) ? reduced.concat([reduced.pop().concat(lineContentWords)]) : reduced.concat([lineContentWords]);
  }, []).map(function (lineContentWords) {
    return lineContentWords.reduce(function (reduced, word) {
      return (// disallow trailing spaces
        reduced.length !== 0 && /\s$/.test(getLast$4(reduced)) ? reduced.concat(reduced.pop() + " " + word) : reduced.concat(word)
      );
    }, []);
  }).map(function (lineContentWords) {
    return options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords;
  }));

  function removeUnnecessaryTrailingNewlines(lineContents) {
    if (node.chomping === "keep") {
      return getLast$4(lineContents).length === 0 ? lineContents.slice(0, -1) : lineContents;
    }

    var trailingNewlineCount = 0;

    for (var i = lineContents.length - 1; i >= 0; i--) {
      if (lineContents[i].length === 0) {
        trailingNewlineCount++;
      } else {
        break;
      }
    }

    return trailingNewlineCount === 0 ? lineContents : trailingNewlineCount >= 2 && !isLastDescendant ? // next empty line
    lineContents.slice(0, -(trailingNewlineCount - 1)) : lineContents.slice(0, -trailingNewlineCount);
  }
}

var utils$6 = {
  getLast: getLast$4,
  getAncestorCount,
  isNode: isNode$1,
  isEmptyNode,
  mapNode,
  defineShortcut,
  isNextLineEmpty: isNextLineEmpty$5,
  isLastDescendantNode,
  getBlockValueLineContents,
  getFlowScalarLineContents,
  getLastDescendantNode: getLastDescendantNode$1,
  hasPrettierIgnore: hasPrettierIgnore$5,
  hasLeadingComments,
  hasMiddleComments,
  hasIndicatorComment,
  hasTrailingComment: hasTrailingComment$2,
  hasEndComments
};

var insertPragma$9 = pragma$5.insertPragma,
    isPragma$1 = pragma$5.isPragma;
var getAncestorCount$1 = utils$6.getAncestorCount,
    getBlockValueLineContents$1 = utils$6.getBlockValueLineContents,
    getFlowScalarLineContents$1 = utils$6.getFlowScalarLineContents,
    getLast$5 = utils$6.getLast,
    getLastDescendantNode$2 = utils$6.getLastDescendantNode,
    hasLeadingComments$1 = utils$6.hasLeadingComments,
    hasMiddleComments$1 = utils$6.hasMiddleComments,
    hasIndicatorComment$1 = utils$6.hasIndicatorComment,
    hasTrailingComment$3 = utils$6.hasTrailingComment,
    hasEndComments$1 = utils$6.hasEndComments,
    hasPrettierIgnore$6 = utils$6.hasPrettierIgnore,
    isLastDescendantNode$1 = utils$6.isLastDescendantNode,
    isNextLineEmpty$6 = utils$6.isNextLineEmpty,
    isNode$2 = utils$6.isNode,
    isEmptyNode$1 = utils$6.isEmptyNode,
    defineShortcut$1 = utils$6.defineShortcut,
    mapNode$1 = utils$6.mapNode;
var docBuilders$2 = doc.builders;
var conditionalGroup$2 = docBuilders$2.conditionalGroup,
    breakParent$5 = docBuilders$2.breakParent,
    concat$h = docBuilders$2.concat,
    dedent$3 = docBuilders$2.dedent,
    dedentToRoot$3 = docBuilders$2.dedentToRoot,
    fill$6 = docBuilders$2.fill,
    group$g = docBuilders$2.group,
    hardline$d = docBuilders$2.hardline,
    ifBreak$8 = docBuilders$2.ifBreak,
    join$c = docBuilders$2.join,
    line$9 = docBuilders$2.line,
    lineSuffix$2 = docBuilders$2.lineSuffix,
    literalline$7 = docBuilders$2.literalline,
    markAsRoot$5 = docBuilders$2.markAsRoot,
    softline$8 = docBuilders$2.softline;
var replaceEndOfLineWith$3 = util.replaceEndOfLineWith;

function preprocess$3(ast) {
  return mapNode$1(ast, defineShortcuts);
}

function defineShortcuts(node) {
  switch (node.type) {
    case "document":
      defineShortcut$1(node, "head", function () {
        return node.children[0];
      });
      defineShortcut$1(node, "body", function () {
        return node.children[1];
      });
      break;

    case "documentBody":
    case "sequenceItem":
    case "flowSequenceItem":
    case "mappingKey":
    case "mappingValue":
      defineShortcut$1(node, "content", function () {
        return node.children[0];
      });
      break;

    case "mappingItem":
    case "flowMappingItem":
      defineShortcut$1(node, "key", function () {
        return node.children[0];
      });
      defineShortcut$1(node, "value", function () {
        return node.children[1];
      });
      break;
  }

  return node;
}

function genericPrint$6(path, options, print) {
  var node = path.getValue();
  var parentNode = path.getParentNode();
  var tag = !node.tag ? "" : path.call(print, "tag");
  var anchor = !node.anchor ? "" : path.call(print, "anchor");
  var nextEmptyLine = isNode$2(node, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !isLastDescendantNode$1(path) ? printNextEmptyLine(path, options.originalText) : "";
  return concat$h([node.type !== "mappingValue" && hasLeadingComments$1(node) ? concat$h([join$c(hardline$d, path.map(print, "leadingComments")), hardline$d]) : "", tag, tag && anchor ? " " : "", anchor, tag || anchor ? isNode$2(node, ["sequence", "mapping"]) && !hasMiddleComments$1(node) ? hardline$d : " " : "", hasMiddleComments$1(node) ? concat$h([node.middleComments.length === 1 ? "" : hardline$d, join$c(hardline$d, path.map(print, "middleComments")), hardline$d]) : "", hasPrettierIgnore$6(path) ? concat$h(replaceEndOfLineWith$3(options.originalText.slice(node.position.start.offset, node.position.end.offset), literalline$7)) : group$g(_print(node, parentNode, path, options, print)), hasTrailingComment$3(node) && !isNode$2(node, ["document", "documentHead"]) ? lineSuffix$2(concat$h([node.type === "mappingValue" && !node.content ? "" : " ", parentNode.type === "mappingKey" && path.getParentNode(2).type === "mapping" && isInlineNode$1(node) ? "" : breakParent$5, path.call(print, "trailingComment")])) : "", nextEmptyLine, hasEndComments$1(node) && !isNode$2(node, ["documentHead", "documentBody"]) ? align$3(node.type === "sequenceItem" ? 2 : 0, concat$h([hardline$d, join$c(hardline$d, path.map(print, "endComments"))])) : ""]);
}

function _print(node, parentNode, path, options, print) {
  switch (node.type) {
    case "root":
      return concat$h([join$c(hardline$d, path.map(function (childPath, index) {
        var document = node.children[index];
        var nextDocument = node.children[index + 1];
        return concat$h([print(childPath), shouldPrintDocumentEndMarker(document, nextDocument) ? concat$h([hardline$d, "...", hasTrailingComment$3(document) ? concat$h([" ", path.call(print, "trailingComment")]) : ""]) : !nextDocument || hasTrailingComment$3(nextDocument.head) ? "" : concat$h([hardline$d, "---"])]);
      }, "children")), node.children.length === 0 || function (lastDescendantNode) {
        return isNode$2(lastDescendantNode, ["blockLiteral", "blockFolded"]) && lastDescendantNode.chomping === "keep";
      }(getLastDescendantNode$2(node)) ? "" : hardline$d]);

    case "document":
      {
        var nextDocument = parentNode.children[path.getName() + 1];
        return join$c(hardline$d, [shouldPrintDocumentHeadEndMarker(node, nextDocument, parentNode, options) === "head" ? join$c(hardline$d, [node.head.children.length === 0 && node.head.endComments.length === 0 ? "" : path.call(print, "head"), concat$h(["---", hasTrailingComment$3(node.head) ? concat$h([" ", path.call(print, "head", "trailingComment")]) : ""])].filter(Boolean)) : "", shouldPrintDocumentBody(node) ? path.call(print, "body") : ""].filter(Boolean));
      }

    case "documentHead":
      return join$c(hardline$d, [].concat(path.map(print, "children"), path.map(print, "endComments")));

    case "documentBody":
      {
        var children = join$c(hardline$d, path.map(print, "children")).parts;
        var endComments = join$c(hardline$d, path.map(print, "endComments")).parts;
        var separator = children.length === 0 || endComments.length === 0 ? "" : function (lastDescendantNode) {
          return isNode$2(lastDescendantNode, ["blockFolded", "blockLiteral"]) ? lastDescendantNode.chomping === "keep" ? // there's already a newline printed at the end of blockValue (chomping=keep, lastDescendant=true)
          "" : // an extra newline for better readability
          concat$h([hardline$d, hardline$d]) : hardline$d;
        }(getLastDescendantNode$2(node));
        return concat$h([].concat(children, separator, endComments));
      }

    case "directive":
      return concat$h(["%", join$c(" ", [node.name].concat(node.parameters))]);

    case "comment":
      return concat$h(["#", node.value]);

    case "alias":
      return concat$h(["*", node.value]);

    case "tag":
      return options.originalText.slice(node.position.start.offset, node.position.end.offset);

    case "anchor":
      return concat$h(["&", node.value]);

    case "plain":
      return printFlowScalarContent(node.type, options.originalText.slice(node.position.start.offset, node.position.end.offset), options);

    case "quoteDouble":
    case "quoteSingle":
      {
        var singleQuote = "'";
        var doubleQuote = '"';
        var raw = options.originalText.slice(node.position.start.offset + 1, node.position.end.offset - 1);

        if (node.type === "quoteSingle" && raw.includes("\\") || node.type === "quoteDouble" && /\\[^"]/.test(raw)) {
          // only quoteDouble can use escape chars
          // and quoteSingle do not need to escape backslashes
          var originalQuote = node.type === "quoteDouble" ? doubleQuote : singleQuote;
          return concat$h([originalQuote, printFlowScalarContent(node.type, raw, options), originalQuote]);
        } else if (raw.includes(doubleQuote)) {
          return concat$h([singleQuote, printFlowScalarContent(node.type, node.type === "quoteDouble" ? raw // double quote needs to be escaped by backslash in quoteDouble
          .replace(/\\"/g, doubleQuote).replace(/'/g, singleQuote.repeat(2)) : raw, options), singleQuote]);
        }

        if (raw.includes(singleQuote)) {
          return concat$h([doubleQuote, printFlowScalarContent(node.type, node.type === "quoteSingle" ? // single quote needs to be escaped by 2 single quotes in quoteSingle
          raw.replace(/''/g, singleQuote) : raw, options), doubleQuote]);
        }

        var quote = options.singleQuote ? singleQuote : doubleQuote;
        return concat$h([quote, printFlowScalarContent(node.type, raw, options), quote]);
      }

    case "blockFolded":
    case "blockLiteral":
      {
        var parentIndent = getAncestorCount$1(path, function (ancestorNode) {
          return isNode$2(ancestorNode, ["sequence", "mapping"]);
        });
        var isLastDescendant = isLastDescendantNode$1(path);
        return concat$h([node.type === "blockFolded" ? ">" : "|", node.indent === null ? "" : node.indent.toString(), node.chomping === "clip" ? "" : node.chomping === "keep" ? "+" : "-", hasIndicatorComment$1(node) ? concat$h([" ", path.call(print, "indicatorComment")]) : "", (node.indent === null ? dedent$3 : dedentToRoot$3)(align$3(node.indent === null ? options.tabWidth : node.indent - 1 + parentIndent, concat$h(getBlockValueLineContents$1(node, {
          parentIndent,
          isLastDescendant,
          options
        }).reduce(function (reduced, lineWords, index, lineContents) {
          return reduced.concat(index === 0 ? hardline$d : "", fill$6(join$c(line$9, lineWords).parts), index !== lineContents.length - 1 ? lineWords.length === 0 ? hardline$d : markAsRoot$5(literalline$7) : node.chomping === "keep" && isLastDescendant ? lineWords.length === 0 ? dedentToRoot$3(hardline$d) : dedentToRoot$3(literalline$7) : "");
        }, []))))]);
      }

    case "sequence":
      return join$c(hardline$d, path.map(print, "children"));

    case "sequenceItem":
      return concat$h(["- ", align$3(2, !node.content ? "" : path.call(print, "content"))]);

    case "mappingKey":
      return !node.content ? "" : path.call(print, "content");

    case "mappingValue":
      return !node.content ? "" : path.call(print, "content");

    case "mapping":
      return join$c(hardline$d, path.map(print, "children"));

    case "mappingItem":
    case "flowMappingItem":
      {
        var isEmptyMappingKey = isEmptyNode$1(node.key);
        var isEmptyMappingValue = isEmptyNode$1(node.value);

        if (isEmptyMappingKey && isEmptyMappingValue) {
          return concat$h([": "]);
        }

        var key = path.call(print, "key");
        var value = path.call(print, "value");

        if (isEmptyMappingValue) {
          return node.type === "flowMappingItem" && parentNode.type === "flowMapping" ? key : node.type === "mappingItem" && isAbsolutelyPrintedAsSingleLineNode(node.key.content, options) && !hasTrailingComment$3(node.key.content) && (!parentNode.tag || parentNode.tag.value !== "tag:yaml.org,2002:set") ? concat$h([key, needsSpaceInFrontOfMappingValue(node) ? " " : "", ":"]) : concat$h(["? ", align$3(2, key)]);
        }

        if (isEmptyMappingKey) {
          return concat$h([": ", align$3(2, value)]);
        }

        var groupId = Symbol("mappingKey");
        var forceExplicitKey = hasLeadingComments$1(node.value) || !isInlineNode$1(node.key.content);
        return forceExplicitKey ? concat$h(["? ", align$3(2, key), hardline$d, join$c("", path.map(print, "value", "leadingComments").map(function (comment) {
          return concat$h([comment, hardline$d]);
        })), ": ", align$3(2, value)]) : // force singleline
        isSingleLineNode(node.key.content) && !hasLeadingComments$1(node.key.content) && !hasMiddleComments$1(node.key.content) && !hasTrailingComment$3(node.key.content) && !hasEndComments$1(node.key) && !hasLeadingComments$1(node.value.content) && !hasMiddleComments$1(node.value.content) && !hasEndComments$1(node.value) && isAbsolutelyPrintedAsSingleLineNode(node.value.content, options) ? concat$h([key, needsSpaceInFrontOfMappingValue(node) ? " " : "", ": ", value]) : conditionalGroup$2([concat$h([group$g(concat$h([ifBreak$8("? "), group$g(align$3(2, key), {
          id: groupId
        })])), ifBreak$8(concat$h([hardline$d, ": ", align$3(2, value)]), indent(concat$h([needsSpaceInFrontOfMappingValue(node) ? " " : "", ":", hasLeadingComments$1(node.value.content) || hasEndComments$1(node.value) && node.value.content && !isNode$2(node.value.content, ["mapping", "sequence"]) || parentNode.type === "mapping" && hasTrailingComment$3(node.key.content) && isInlineNode$1(node.value.content) || isNode$2(node.value.content, ["mapping", "sequence"]) && node.value.content.tag === null && node.value.content.anchor === null ? hardline$d : !node.value.content ? "" : line$9, value])), {
          groupId
        })])]);
      }

    case "flowMapping":
    case "flowSequence":
      {
        var openMarker = node.type === "flowMapping" ? "{" : "[";
        var closeMarker = node.type === "flowMapping" ? "}" : "]";
        var bracketSpacing = node.type === "flowMapping" && node.children.length !== 0 && options.bracketSpacing ? line$9 : softline$8;

        var isLastItemEmptyMappingItem = node.children.length !== 0 && function (lastItem) {
          return lastItem.type === "flowMappingItem" && isEmptyNode$1(lastItem.key) && isEmptyNode$1(lastItem.value);
        }(getLast$5(node.children));

        return concat$h([openMarker, indent(concat$h([bracketSpacing, concat$h(path.map(function (childPath, index) {
          return concat$h([print(childPath), index === node.children.length - 1 ? "" : concat$h([",", line$9, node.children[index].position.start.line !== node.children[index + 1].position.start.line ? printNextEmptyLine(childPath, options.originalText) : ""])]);
        }, "children")), ifBreak$8(",", "")])), isLastItemEmptyMappingItem ? "" : bracketSpacing, closeMarker]);
      }

    case "flowSequenceItem":
      return path.call(print, "content");
    // istanbul ignore next

    default:
      throw new Error(`Unexpected node type ${node.type}`);
  }

  function indent(doc) {
    return docBuilders$2.align(" ".repeat(options.tabWidth), doc);
  }
}

function align$3(n, doc) {
  return typeof n === "number" && n > 0 ? docBuilders$2.align(" ".repeat(n), doc) : docBuilders$2.align(n, doc);
}

function isInlineNode$1(node) {
  if (!node) {
    return true;
  }

  switch (node.type) {
    case "plain":
    case "quoteDouble":
    case "quoteSingle":
    case "alias":
    case "flowMapping":
    case "flowSequence":
      return true;

    default:
      return false;
  }
}

function isSingleLineNode(node) {
  if (!node) {
    return true;
  }

  switch (node.type) {
    case "plain":
    case "quoteDouble":
    case "quoteSingle":
      return node.position.start.line === node.position.end.line;

    case "alias":
      return true;

    default:
      return false;
  }
}

function shouldPrintDocumentBody(document) {
  return document.body.children.length !== 0 || hasEndComments$1(document.body);
}

function shouldPrintDocumentEndMarker(document, nextDocument) {
  return (
    /**
     *... # trailingComment
     */
    hasTrailingComment$3(document) || nextDocument && (
    /**
     * ...
     * %DIRECTIVE
     * ---
     */
    nextDocument.head.children.length !== 0 ||
    /**
     * ...
     * # endComment
     * ---
     */
    hasEndComments$1(nextDocument.head))
  );
}

function shouldPrintDocumentHeadEndMarker(document, nextDocument, root, options) {
  if (
  /**
   * ---
   * preserve the first document head end marker
   */
  root.children[0] === document && /---(\s|$)/.test(options.originalText.slice(options.locStart(document), options.locStart(document) + 4)) ||
  /**
   * %DIRECTIVE
   * ---
   */
  document.head.children.length !== 0 ||
  /**
   * # end comment
   * ---
   */
  hasEndComments$1(document.head) ||
  /**
   * --- # trailing comment
   */
  hasTrailingComment$3(document.head)) {
    return "head";
  }

  if (shouldPrintDocumentEndMarker(document, nextDocument)) {
    return false;
  }

  return nextDocument ? "root" : false;
}

function isAbsolutelyPrintedAsSingleLineNode(node, options) {
  if (!node) {
    return true;
  }

  switch (node.type) {
    case "plain":
    case "quoteSingle":
    case "quoteDouble":
      break;

    case "alias":
      return true;

    default:
      return false;
  }

  if (options.proseWrap === "preserve") {
    return node.position.start.line === node.position.end.line;
  }

  if ( // backslash-newline
  /\\$/m.test(options.originalText.slice(node.position.start.offset, node.position.end.offset))) {
    return false;
  }

  switch (options.proseWrap) {
    case "never":
      return node.value.indexOf("\n") === -1;

    case "always":
      return !/[\n ]/.test(node.value);
    // istanbul ignore next

    default:
      return false;
  }
}

function needsSpaceInFrontOfMappingValue(node) {
  return node.key.content && node.key.content.type === "alias";
}

function printNextEmptyLine(path, originalText) {
  var node = path.getValue();
  var root = path.stack[0];
  root.isNextEmptyLinePrintedChecklist = root.isNextEmptyLinePrintedChecklist || [];

  if (!root.isNextEmptyLinePrintedChecklist[node.position.end.line]) {
    if (isNextLineEmpty$6(node, originalText)) {
      root.isNextEmptyLinePrintedChecklist[node.position.end.line] = true;
      return softline$8;
    }
  }

  return "";
}

function printFlowScalarContent(nodeType, content, options) {
  var lineContents = getFlowScalarLineContents$1(nodeType, content, options);
  return join$c(hardline$d, lineContents.map(function (lineContentWords) {
    return fill$6(join$c(line$9, lineContentWords).parts);
  }));
}

function clean$7(node, newNode
/*, parent */
) {
  if (isNode$2(newNode)) {
    delete newNode.position;

    switch (newNode.type) {
      case "comment":
        // insert pragma
        if (isPragma$1(newNode.value)) {
          return null;
        }

        break;

      case "quoteDouble":
      case "quoteSingle":
        newNode.type = "quote";
        break;
    }
  }
}

var printerYaml = {
  preprocess: preprocess$3,
  print: genericPrint$6,
  massageAstNode: clean$7,
  insertPragma: insertPragma$9
};

var options$7 = {
  bracketSpacing: commonOptions.bracketSpacing,
  singleQuote: commonOptions.singleQuote,
  proseWrap: commonOptions.proseWrap
};

var name$i = "YAML";
var type$g = "data";
var tmScope$g = "source.yaml";
var aliases$6 = [
	"yml"
];
var extensions$g = [
	".yml",
	".mir",
	".reek",
	".rviz",
	".sublime-syntax",
	".syntax",
	".yaml",
	".yaml-tmlanguage",
	".yml.mysql"
];
var filenames$4 = [
	".clang-format",
	".clang-tidy",
	".gemrc",
	"glide.lock"
];
var aceMode$g = "yaml";
var codemirrorMode$c = "yaml";
var codemirrorMimeType$c = "text/x-yaml";
var languageId$g = 407;
var YAML = {
	name: name$i,
	type: type$g,
	tmScope: tmScope$g,
	aliases: aliases$6,
	extensions: extensions$g,
	filenames: filenames$4,
	aceMode: aceMode$g,
	codemirrorMode: codemirrorMode$c,
	codemirrorMimeType: codemirrorMimeType$c,
	languageId: languageId$g
};

var YAML$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$i,
  type: type$g,
  tmScope: tmScope$g,
  aliases: aliases$6,
  extensions: extensions$g,
  filenames: filenames$4,
  aceMode: aceMode$g,
  codemirrorMode: codemirrorMode$c,
  codemirrorMimeType: codemirrorMimeType$c,
  languageId: languageId$g,
  'default': YAML
});

var require$$0$7 = getCjsExportFromNamespace(YAML$1);

var languages$6 = [createLanguage(require$$0$7, function (data) {
  return Object.assign(data, {
    since: "1.14.0",
    parsers: ["yaml"],
    vscodeLanguageIds: ["yaml"]
  });
})];
var languageYaml = {
  languages: languages$6,
  printers: {
    yaml: printerYaml
  },
  options: options$7
};

// plugin will look for `eval("require")()` and transform to `require()` in the bundle,
// and rewrite the paths to require from the top-level.
// We need to list the parsers and getters so we can load them only when necessary.


var internalPlugins = [// JS
languageJs, {
  parsers: {
    // JS - Babel
    get babel() {
      return require("./parser-babylon").parsers.babel;
    },

    get "babel-flow"() {
      return require("./parser-babylon").parsers["babel-flow"];
    },

    get babylon() {
      return require("./parser-babylon").parsers.babel;
    },

    get json() {
      return require("./parser-babylon").parsers.json;
    },

    get json5() {
      return require("./parser-babylon").parsers.json5;
    },

    get "json-stringify"() {
      return require("./parser-babylon").parsers["json-stringify"];
    },

    get __js_expression() {
      return require("./parser-babylon").parsers.__js_expression;
    },

    get __vue_expression() {
      return require("./parser-babylon").parsers.__vue_expression;
    },

    get __vue_event_binding() {
      return require("./parser-babylon").parsers.__vue_event_binding;
    },

    // JS - Flow
    get flow() {
      return require("./parser-flow").parsers.flow;
    },

    // JS - TypeScript
    get typescript() {
      return require("./parser-typescript").parsers.typescript;
    },

    /**
     * TODO: Remove this old alias in a major version
     */
    get "typescript-eslint"() {
      return require("./parser-typescript").parsers.typescript;
    },

    // JS - Angular Action
    get __ng_action() {
      return require("./parser-angular").parsers.__ng_action;
    },

    // JS - Angular Binding
    get __ng_binding() {
      return require("./parser-angular").parsers.__ng_binding;
    },

    // JS - Angular Interpolation
    get __ng_interpolation() {
      return require("./parser-angular").parsers.__ng_interpolation;
    },

    // JS - Angular Directive
    get __ng_directive() {
      return require("./parser-angular").parsers.__ng_directive;
    }

  }
}, // CSS
languageCss, {
  parsers: {
    // TODO: switch these to just `postcss` and use `language` instead.
    get css() {
      return require("./parser-postcss").parsers.css;
    },

    get less() {
      return require("./parser-postcss").parsers.css;
    },

    get scss() {
      return require("./parser-postcss").parsers.css;
    }

  }
}, // Handlebars
languageHandlebars, {
  parsers: {
    get glimmer() {
      return require("./parser-glimmer").parsers.glimmer;
    }

  }
}, // GraphQL
languageGraphql, {
  parsers: {
    get graphql() {
      return require("./parser-graphql").parsers.graphql;
    }

  }
}, // Markdown
languageMarkdown, {
  parsers: {
    get remark() {
      return require("./parser-markdown").parsers.remark;
    },

    // TODO: Delete this in 2.0
    get markdown() {
      return require("./parser-markdown").parsers.remark;
    },

    get mdx() {
      return require("./parser-markdown").parsers.mdx;
    }

  }
}, languageHtml, {
  parsers: {
    // HTML
    get html() {
      return require("./parser-html").parsers.html;
    },

    // Vue
    get vue() {
      return require("./parser-html").parsers.vue;
    },

    // Angular
    get angular() {
      return require("./parser-html").parsers.angular;
    },

    // Lightning Web Components
    get lwc() {
      return require("./parser-html").parsers.lwc;
    }

  }
}, // YAML
languageYaml, {
  parsers: {
    get yaml() {
      return require("./parser-yaml").parsers.yaml;
    }

  }
}];

var partition = function partition(array, fn) {
  var a = [];
  var b = [];
  array.forEach(function (item) {
    if (fn(item)) {
      a.push(item);
    } else {
      b.push(item);
    }
  });
  return [a, b];
};

function loadPlugins(plugins, pluginSearchDirs) {
  if (!plugins) {
    plugins = [];
  }

  if (!pluginSearchDirs) {
    pluginSearchDirs = [];
  } // unless pluginSearchDirs are provided, auto-load plugins from node_modules that are parent to Prettier


  if (!pluginSearchDirs.length) {
    var autoLoadDir = thirdParty.findParentDir(__dirname, "node_modules");

    if (autoLoadDir) {
      pluginSearchDirs = [autoLoadDir];
    }
  }

  var _partition = partition(plugins, function (plugin) {
    return typeof plugin === "string";
  }),
      _partition2 = _slicedToArray(_partition, 2),
      externalPluginNames = _partition2[0],
      externalPluginInstances = _partition2[1];

  var externalManualLoadPluginInfos = externalPluginNames.map(function (pluginName) {
    var requirePath;

    try {
      // try local files
      requirePath = resolve.sync(path$2.resolve(process.cwd(), pluginName));
    } catch (e) {
      // try node modules
      requirePath = resolve.sync(pluginName, {
        basedir: process.cwd()
      });
    }

    return {
      name: pluginName,
      requirePath
    };
  });
  var externalAutoLoadPluginInfos = pluginSearchDirs.map(function (pluginSearchDir) {
    var resolvedPluginSearchDir = path$2.resolve(process.cwd(), pluginSearchDir);
    var nodeModulesDir = path$2.resolve(resolvedPluginSearchDir, "node_modules"); // In some fringe cases (ex: files "mounted" as virtual directories), the
    // isDirectory(resolvedPluginSearchDir) check might be false even though
    // the node_modules actually exists.

    if (!isDirectory(nodeModulesDir) && !isDirectory(resolvedPluginSearchDir)) {
      throw new Error(`${pluginSearchDir} does not exist or is not a directory`);
    }

    return findPluginsInNodeModules(nodeModulesDir).map(function (pluginName) {
      return {
        name: pluginName,
        requirePath: resolve.sync(pluginName, {
          basedir: resolvedPluginSearchDir
        })
      };
    });
  }).reduce(function (a, b) {
    return a.concat(b);
  }, []);
  var externalPlugins = lodash_uniqby(externalManualLoadPluginInfos.concat(externalAutoLoadPluginInfos), "requirePath").map(function (externalPluginInfo) {
    return Object.assign({
      name: externalPluginInfo.name
    }, require(externalPluginInfo.requirePath));
  }).concat(externalPluginInstances);
  return internalPlugins.concat(externalPlugins);
}

function findPluginsInNodeModules(nodeModulesDir) {
  var pluginPackageJsonPaths = globby.sync(["prettier-plugin-*/package.json", "@*/prettier-plugin-*/package.json", "@prettier/plugin-*/package.json"], {
    cwd: nodeModulesDir
  });
  return pluginPackageJsonPaths.map(path$2.dirname);
}

function isDirectory(dir) {
  try {
    return fs$1.statSync(dir).isDirectory();
  } catch (e) {
    return false;
  }
}

var loadPlugins_1 = loadPlugins;

var version$3 = require$$0.version;
var getSupportInfo$2 = support.getSupportInfo; // Luckily `opts` is always the 2nd argument

function _withPlugins(fn) {
  return function () {
    var args = Array.from(arguments);
    var opts = args[1] || {};
    args[1] = Object.assign({}, opts, {
      plugins: loadPlugins_1(opts.plugins, opts.pluginSearchDirs)
    });
    return fn.apply(null, args);
  };
}

function withPlugins(fn) {
  var resultingFn = _withPlugins(fn);

  if (fn.sync) {
    resultingFn.sync = _withPlugins(fn.sync);
  }

  return resultingFn;
}

var formatWithCursor = withPlugins(core.formatWithCursor);
var src$1 = {
  formatWithCursor,

  format(text, opts) {
    return formatWithCursor(text, opts).formatted;
  },

  check: function check(text, opts) {
    var formatted = formatWithCursor(text, opts).formatted;
    return formatted === text;
  },
  doc,
  resolveConfig: resolveConfig_1.resolveConfig,
  resolveConfigFile: resolveConfig_1.resolveConfigFile,
  clearConfigCache: resolveConfig_1.clearCache,
  getFileInfo: withPlugins(getFileInfo_1),
  getSupportInfo: withPlugins(getSupportInfo$2),
  version: version$3,
  util: utilShared,

  /* istanbul ignore next */
  __debug: {
    parse: withPlugins(core.parse),
    formatAST: withPlugins(core.formatAST),
    formatDoc: withPlugins(core.formatDoc),
    printToDoc: withPlugins(core.printToDoc),
    printDocToString: withPlugins(core.printDocToString)
  }
};

var prettier = src$1;

module.exports = prettier;
