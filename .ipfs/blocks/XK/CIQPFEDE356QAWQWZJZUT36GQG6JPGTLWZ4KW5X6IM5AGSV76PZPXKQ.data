, function (t) { return getIndexTypeOfType(t, indexType); })), ts.some(types, function (t) { return getIndexInfoOfType(t, indexType).isReadonly; })));
                    }
                };
                for (var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++) {
                    var info = sourceInfos_1[_i];
                    _loop_11(info);
                }
                return result;
            }
            return ts.emptyArray;
        }
        function resolveUnionTypeMembers(type) {
            var callSignatures = getUnionSignatures(ts.map(type.types, function (t) { return t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(t, 0); }));
            var constructSignatures = getUnionSignatures(ts.map(type.types, function (t) { return getSignaturesOfType(t, 1); }));
            var indexInfos = getUnionIndexInfos(type.types);
            setStructuredTypeMembers(type, emptySymbols, callSignatures, constructSignatures, indexInfos);
        }
        function intersectTypes(type1, type2) {
            return !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]);
        }
        function findMixins(types) {
            var constructorTypeCount = ts.countWhere(types, function (t) { return getSignaturesOfType(t, 1).length > 0; });
            var mixinFlags = ts.map(types, isMixinConstructorType);
            if (constructorTypeCount > 0 && constructorTypeCount === ts.countWhere(mixinFlags, function (b) { return b; })) {
                var firstMixinIndex = mixinFlags.indexOf(true);
                mixinFlags[firstMixinIndex] = false;
            }
            return mixinFlags;
        }
        function includeMixinType(type, types, mixinFlags, index) {
            var mixedTypes = [];
            for (var i = 0; i < types.length; i++) {
                if (i === index) {
                    mixedTypes.push(type);
                }
                else if (mixinFlags[i]) {
                    mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], 1)[0]));
                }
            }
            return getIntersectionType(mixedTypes);
        }
        function resolveIntersectionTypeMembers(type) {
            var callSignatures;
            var constructSignatures;
            var indexInfos;
            var types = type.types;
            var mixinFlags = findMixins(types);
            var mixinCount = ts.countWhere(mixinFlags, function (b) { return b; });
            var _loop_12 = function (i) {
                var t = type.types[i];
                if (!mixinFlags[i]) {
                    var signatures = getSignaturesOfType(t, 1);
                    if (signatures.length && mixinCount > 0) {
                        signatures = ts.map(signatures, function (s) {
                            var clone = cloneSignature(s);
                            clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i);
                            return clone;
                        });
                    }
                    constructSignatures = appendSignatures(constructSignatures, signatures);
                }
                callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, 0));
                indexInfos = ts.reduceLeft(getIndexInfosOfType(t), function (infos, newInfo) { return appendIndexInfo(infos, newInfo, false); }, indexInfos);
            };
            for (var i = 0; i < types.length; i++) {
                _loop_12(i);
            }
            setStructuredTypeMembers(type, emptySymbols, callSignatures || ts.emptyArray, constructSignatures || ts.emptyArray, indexInfos || ts.emptyArray);
        }
        function appendSignatures(signatures, newSignatures) {
            var _loop_13 = function (sig) {
                if (!signatures || ts.every(signatures, function (s) { return !compareSignaturesIdentical(s, sig, false, false, false, compareTypesIdentical); })) {
                    signatures = ts.append(signatures, sig);
                }
            };
            for (var _i = 0, newSignatures_1 = newSignatures; _i < newSignatures_1.length; _i++) {
                var sig = newSignatures_1[_i];
                _loop_13(sig);
            }
            return signatures;
        }
        function appendIndexInfo(indexInfos, newInfo, union) {
            if (indexInfos) {
                for (var i = 0; i < indexInfos.length; i++) {
                    var info = indexInfos[i];
                    if (info.keyType === newInfo.keyType) {
                        indexInfos[i] = createIndexInfo(info.keyType, union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]), union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly);
                        return indexInfos;
                    }
                }
            }
            return ts.append(indexInfos, newInfo);
        }
        function resolveAnonymousTypeMembers(type) {
            var symbol = getMergedSymbol(type.symbol);
            if (type.target) {
                setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                var members = createInstantiatedSymbolTable(getPropertiesOfObjectType(type.target), type.mapper, false);
                var callSignatures = instantiateSignatures(getSignaturesOfType(type.target, 0), type.mapper);
                var constructSignatures = instantiateSignatures(getSignaturesOfType(type.target, 1), type.mapper);
                var indexInfos = instantiateIndexInfos(getIndexInfosOfType(type.target), type.mapper);
                setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
            }
            else if (symbol.flags & 2048) {
                setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                var members = getMembersOfSymbol(symbol);
                var callSignatures = getSignaturesOfSymbol(members.get("__call"));
                var constructSignatures = getSignaturesOfSymbol(members.get("__new"));
                var indexInfos = getIndexInfosOfSymbol(symbol);
                setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
            }
            else {
                var members = emptySymbols;
                var indexInfos = void 0;
                if (symbol.exports) {
                    members = getExportsOfSymbol(symbol);
                    if (symbol === globalThisSymbol) {
                        var varsOnly_1 = new ts.Map();
                        members.forEach(function (p) {
                            if (!(p.flags & 418)) {
                                varsOnly_1.set(p.escapedName, p);
                            }
                        });
                        members = varsOnly_1;
                    }
                }
                var baseConstructorIndexInfo = void 0;
                setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                if (symbol.flags & 32) {
                    var classType = getDeclaredTypeOfClassOrInterface(symbol);
                    var baseConstructorType = getBaseConstructorTypeOfClass(classType);
                    if (baseConstructorType.flags & (524288 | 2097152 | 8650752)) {
                        members = ts.createSymbolTable(getNamedOrIndexSignatureMembers(members));
                        addInheritedMembers(members, getPropertiesOfType(baseConstructorType));
                    }
                    else if (baseConstructorType === anyType) {
                        baseConstructorIndexInfo = createIndexInfo(stringType, anyType, false);
                    }
                }
                var indexSymbol = getIndexSymbolFromSymbolTable(members);
                if (indexSymbol) {
                    indexInfos = getIndexInfosOfIndexSymbol(indexSymbol);
                }
                else {
                    if (baseConstructorIndexInfo) {
                        indexInfos = ts.append(indexInfos, baseConstructorIndexInfo);
                    }
                    if (symbol.flags & 384 && (getDeclaredTypeOfSymbol(symbol).flags & 32 ||
                        ts.some(type.properties, function (prop) { return !!(getTypeOfSymbol(prop).flags & 296); }))) {
                        indexInfos = ts.append(indexInfos, enumNumberIndexInfo);
                    }
                }
                setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, indexInfos || ts.emptyArray);
                if (symbol.flags & (16 | 8192)) {
                    type.callSignatures = getSignaturesOfSymbol(symbol);
                }
                if (symbol.flags & 32) {
                    var classType_1 = getDeclaredTypeOfClassOrInterface(symbol);
                    var constructSignatures = symbol.members ? getSignaturesOfSymbol(symbol.members.get("__constructor")) : ts.emptyArray;
                    if (symbol.flags & 16) {
                        constructSignatures = ts.addRange(constructSignatures.slice(), ts.mapDefined(type.callSignatures, function (sig) { return isJSConstructor(sig.declaration) ?
                            createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType_1, undefined, sig.minArgumentCount, sig.flags & 39) :
                            undefined; }));
                    }
                    if (!constructSignatures.length) {
                        constructSignatures = getDefaultConstructSignatures(classType_1);
                    }
                    type.constructSignatures = constructSignatures;
                }
            }
        }
        function replaceIndexedAccess(instantiable, type, replacement) {
            return instantiateType(instantiable, createTypeMapper([type.indexType, type.objectType], [getNumberLiteralType(0), createTupleType([replacement])]));
        }
        function resolveReverseMappedTypeMembers(type) {
            var indexInfo = getIndexInfoOfType(type.source, stringType);
            var modifiers = getMappedTypeModifiers(type.mappedType);
            var readonlyMask = modifiers & 1 ? false : true;
            var optionalMask = modifiers & 4 ? 0 : 16777216;
            var indexInfos = indexInfo ? [createIndexInfo(stringType, inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType), readonlyMask && indexInfo.isReadonly)] : ts.emptyArray;
            var members = ts.createSymbolTable();
            for (var _i = 0, _a = getPropertiesOfType(type.source); _i < _a.length; _i++) {
                var prop = _a[_i];
                var checkFlags = 8192 | (readonlyMask && isReadonlySymbol(prop) ? 8 : 0);
                var inferredProp = createSymbol(4 | prop.flags & optionalMask, prop.escapedName, checkFlags);
                inferredProp.declarations = prop.declarations;
                inferredProp.nameType = getSymbolLinks(prop).nameType;
                inferredProp.propertyType = getTypeOfSymbol(prop);
                if (type.constraintType.type.flags & 8388608
                    && type.constraintType.type.objectType.flags & 262144
                    && type.constraintType.type.indexType.flags & 262144) {
                    var newTypeParam = type.constraintType.type.objectType;
                    var newMappedType = replaceIndexedAccess(type.mappedType, type.constraintType.type, newTypeParam);
                    inferredProp.mappedType = newMappedType;
                    inferredProp.constraintType = getIndexType(newTypeParam);
                }
                else {
                    inferredProp.mappedType = type.mappedType;
                    inferredProp.constraintType = type.constraintType;
                }
                members.set(prop.escapedName, inferredProp);
            }
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, indexInfos);
        }
        function getLowerBoundOfKeyType(type) {
            if (type.flags & 4194304) {
                var t = getApparentType(type.type);
                return isGenericTupleType(t) ? getKnownKeysOfTupleType(t) : getIndexType(t);
            }
            if (type.flags & 16777216) {
                if (type.root.isDistributive) {
                    var checkType = type.checkType;
                    var constraint = getLowerBoundOfKeyType(checkType);
                    if (constraint !== checkType) {
                        return getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper));
                    }
                }
                return type;
            }
            if (type.flags & 1048576) {
                return mapType(type, getLowerBoundOfKeyType);
            }
            if (type.flags & 2097152) {
                return getIntersectionType(ts.sameMap(type.types, getLowerBoundOfKeyType));
            }
            return type;
        }
        function getIsLateCheckFlag(s) {
            return ts.getCheckFlags(s) & 4096;
        }
        function resolveMappedTypeMembers(type) {
            var members = ts.createSymbolTable();
            var indexInfos;
            setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            var typeParameter = getTypeParameterFromMappedType(type);
            var constraintType = getConstraintTypeFromMappedType(type);
            var nameType = getNameTypeFromMappedType(type.target || type);
            var templateType = getTemplateTypeFromMappedType(type.target || type);
            var modifiersType = getApparentType(getModifiersTypeFromMappedType(type));
            var templateModifiers = getMappedTypeModifiers(type);
            var include = keyofStringsOnly ? 128 : 8576;
            if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                for (var _i = 0, _a = getPropertiesOfType(modifiersType); _i < _a.length; _i++) {
                    var prop = _a[_i];
                    addMemberForKeyType(getLiteralTypeFromProperty(prop, include));
                }
                if (modifiersType.flags & 1) {
                    addMemberForKeyType(stringType);
                }
                else {
                    for (var _b = 0, _c = getIndexInfosOfType(modifiersType); _b < _c.length; _b++) {
                        var info = _c[_b];
                        if (!keyofStringsOnly || info.keyType.flags & (4 | 134217728)) {
                            addMemberForKeyType(info.keyType);
                        }
                    }
                }
            }
            else {
                forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
            }
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, indexInfos || ts.emptyArray);
            function addMemberForKeyType(keyType) {
                var propNameType = nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType;
                forEachType(propNameType, function (t) { return addMemberForKeyTypeWorker(keyType, t); });
            }
            function addMemberForKeyTypeWorker(keyType, propNameType) {
                if (isTypeUsableAsPropertyName(propNameType)) {
                    var propName = getPropertyNameFromType(propNameType);
                    var existingProp = members.get(propName);
                    if (existingProp) {
                        existingProp.nameType = getUnionType([existingProp.nameType, propNameType]);
                        existingProp.keyType = getUnionType([existingProp.keyType, keyType]);
                    }
                    else {
                        var modifiersProp = isTypeUsableAsPropertyName(keyType) ? getPropertyOfType(modifiersType, getPropertyNameFromType(keyType)) : undefined;
                        var isOptional = !!(templateModifiers & 4 ||
                            !(templateModifiers & 8) && modifiersProp && modifiersProp.flags & 16777216);
                        var isReadonly = !!(templateModifiers & 1 ||
                            !(templateModifiers & 2) && modifiersProp && isReadonlySymbol(modifiersProp));
                        var stripOptional = strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags & 16777216;
                        var lateFlag = modifiersProp ? getIsLateCheckFlag(modifiersProp) : 0;
                        var prop = createSymbol(4 | (isOptional ? 16777216 : 0), propName, lateFlag | 262144 | (isReadonly ? 8 : 0) | (stripOptional ? 524288 : 0));
                        prop.mappedType = type;
                        prop.nameType = propNameType;
                        prop.keyType = keyType;
                        if (modifiersProp) {
                            prop.syntheticOrigin = modifiersProp;
                            prop.declarations = nameType ? undefined : modifiersProp.declarations;
                        }
                        members.set(propName, prop);
                    }
                }
                else if (isValidIndexKeyType(propNameType) || propNameType.flags & (1 | 32)) {
                    var indexKeyType = propNameType.flags & (1 | 4) ? stringType :
                        propNameType.flags & (8 | 32) ? numberType :
                            propNameType;
                    var propType = instantiateType(templateType, appendTypeMapping(type.mapper, typeParameter, keyType));
                    var indexInfo = createIndexInfo(indexKeyType, propType, !!(templateModifiers & 1));
                    indexInfos = appendIndexInfo(indexInfos, indexInfo, true);
                }
            }
        }
        function getTypeOfMappedSymbol(symbol) {
            if (!symbol.type) {
                var mappedType = symbol.mappedType;
                if (!pushTypeResolution(symbol, 0)) {
                    mappedType.containsError = true;
                    return errorType;
                }
                var templateType = getTemplateTypeFromMappedType(mappedType.target || mappedType);
                var mapper = appendTypeMapping(mappedType.mapper, getTypeParameterFromMappedType(mappedType), symbol.keyType);
                var propType = instantiateType(templateType, mapper);
                var type = strictNullChecks && symbol.flags & 16777216 && !maybeTypeOfKind(propType, 32768 | 16384) ? getOptionalType(propType, true) :
                    symbol.checkFlags & 524288 ? removeMissingOrUndefinedType(propType) :
                        propType;
                if (!popTypeResolution()) {
                    error(currentNode, ts.Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbolToString(symbol), typeToString(mappedType));
                    type = errorType;
                }
                symbol.type = type;
            }
            return symbol.type;
        }
        function getTypeParameterFromMappedType(type) {
            return type.typeParameter ||
                (type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfNode(type.declaration.typeParameter)));
        }
        function getConstraintTypeFromMappedType(type) {
            return type.constraintType ||
                (type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType);
        }
        function getNameTypeFromMappedType(type) {
            return type.declaration.nameType ?
                type.nameType || (type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper)) :
                undefined;
        }
        function getTemplateTypeFromMappedType(type) {
            return type.templateType ||
                (type.templateType = type.declaration.type ?
                    instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), true, !!(getMappedTypeModifiers(type) & 4)), type.mapper) :
                    errorType);
        }
        function getConstraintDeclarationForMappedType(type) {
            return ts.getEffectiveConstraintOfTypeParameter(type.declaration.typeParameter);
        }
        function isMappedTypeWithKeyofConstraintDeclaration(type) {
            var constraintDeclaration = getConstraintDeclarationForMappedType(type);
            return constraintDeclaration.kind === 191 &&
                constraintDeclaration.operator === 139;
        }
        function getModifiersTypeFromMappedType(type) {
            if (!type.modifiersType) {
                if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                    type.modifiersType = instantiateType(getTypeFromTypeNode(getConstraintDeclarationForMappedType(type).type), type.mapper);
                }
                else {
                    var declaredType = getTypeFromMappedTypeNode(type.declaration);
                    var constraint = getConstraintTypeFromMappedType(declaredType);
                    var extendedConstraint = constraint && constraint.flags & 262144 ? getConstraintOfTypeParameter(constraint) : constraint;
                    type.modifiersType = extendedConstraint && extendedConstraint.flags & 4194304 ? instantiateType(extendedConstraint.type, type.mapper) : unknownType;
                }
            }
            return type.modifiersType;
        }
        function getMappedTypeModifiers(type) {
            var declaration = type.declaration;
            return (declaration.readonlyToken ? declaration.readonlyToken.kind === 40 ? 2 : 1 : 0) |
                (declaration.questionToken ? declaration.questionToken.kind === 40 ? 8 : 4 : 0);
        }
        function getMappedTypeOptionality(type) {
            var modifiers = getMappedTypeModifiers(type);
            return modifiers & 8 ? -1 : modifiers & 4 ? 1 : 0;
        }
        function getCombinedMappedTypeOptionality(type) {
            var optionality = getMappedTypeOptionality(type);
            var modifiersType = getModifiersTypeFromMappedType(type);
            return optionality || (isGenericMappedType(modifiersType) ? getMappedTypeOptionality(modifiersType) : 0);
        }
        function isPartialMappedType(type) {
            return !!(ts.getObjectFlags(type) & 32 && getMappedTypeModifiers(type) & 4);
        }
        function isGenericMappedType(type) {
            return !!(ts.getObjectFlags(type) & 32) && isGenericIndexType(getConstraintTypeFromMappedType(type));
        }
        function resolveStructuredTypeMembers(type) {
            if (!type.members) {
                if (type.flags & 524288) {
                    if (type.objectFlags & 4) {
                        resolveTypeReferenceMembers(type);
                    }
                    else if (type.objectFlags & 3) {
                        resolveClassOrInterfaceMembers(type);
                    }
                    else if (type.objectFlags & 1024) {
                        resolveReverseMappedTypeMembers(type);
                    }
                    else if (type.objectFlags & 16) {
                        resolveAnonymousTypeMembers(type);
                    }
                    else if (type.objectFlags & 32) {
                        resolveMappedTypeMembers(type);
                    }
                }
                else if (type.flags & 1048576) {
                    resolveUnionTypeMembers(type);
                }
                else if (type.flags & 2097152) {
                    resolveIntersectionTypeMembers(type);
                }
            }
            return type;
        }
        function getPropertiesOfObjectType(type) {
            if (type.flags & 524288) {
                return resolveStructuredTypeMembers(type).properties;
            }
            return ts.emptyArray;
        }
        function getPropertyOfObjectType(type, name) {
            if (type.flags & 524288) {
                var resolved = resolveStructuredTypeMembers(type);
                var symbol = resolved.members.get(name);
                if (symbol && symbolIsValue(symbol)) {
                    return symbol;
                }
            }
        }
        function getPropertiesOfUnionOrIntersectionType(type) {
            if (!type.resolvedProperties) {
                var members = ts.createSymbolTable();
                for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
                    var current = _a[_i];
                    for (var _b = 0, _c = getPropertiesOfType(current); _b < _c.length; _b++) {
                        var prop = _c[_b];
                        if (!members.has(prop.escapedName)) {
                            var combinedProp = getPropertyOfUnionOrIntersectionType(type, prop.escapedName);
                            if (combinedProp) {
                                members.set(prop.escapedName, combinedProp);
                            }
                        }
                    }
                    if (type.flags & 1048576 && getIndexInfosOfType(current).length === 0) {
                        break;
                    }
                }
                type.resolvedProperties = getNamedMembers(members);
            }
            return type.resolvedProperties;
        }
        function getPropertiesOfType(type) {
            type = getReducedApparentType(type);
            return type.flags & 3145728 ?
                getPropertiesOfUnionOrIntersectionType(type) :
                getPropertiesOfObjectType(type);
        }
        function isTypeInvalidDueToUnionDiscriminant(contextualType, obj) {
            var list = obj.properties;
            return list.some(function (property) {
                var nameType = property.name && getLiteralTypeFromPropertyName(property.name);
                var name = nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;
                var expected = name === undefined ? undefined : getTypeOfPropertyOfType(contextualType, name);
                return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected);
            });
        }
        function getAllPossiblePropertiesOfTypes(types) {
            var unionType = getUnionType(types);
            if (!(unionType.flags & 1048576)) {
                return getAugmentedPropertiesOfType(unionType);
            }
            var props = ts.createSymbolTable();
            for (var _i = 0, types_4 = types; _i < types_4.length; _i++) {
                var memberType = types_4[_i];
                for (var _a = 0, _b = getAugmentedPropertiesOfType(memberType); _a < _b.length; _a++) {
                    var escapedName = _b[_a].escapedName;
                    if (!props.has(escapedName)) {
                        var prop = createUnionOrIntersectionProperty(unionType, escapedName);
                        if (prop)
                            props.set(escapedName, prop);
                    }
                }
            }
            return ts.arrayFrom(props.values());
        }
        function getConstraintOfType(type) {
            return type.flags & 262144 ? getConstraintOfTypeParameter(type) :
                type.flags & 8388608 ? getConstraintOfIndexedAccess(type) :
                    type.flags & 16777216 ? getConstraintOfConditionalType(type) :
                        getBaseConstraintOfType(type);
        }
        function getConstraintOfTypeParameter(typeParameter) {
            return hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : undefined;
        }
        function getConstraintOfIndexedAccess(type) {
            return hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(type) : undefined;
        }
        function getSimplifiedTypeOrConstraint(type) {
            var simplified = getSimplifiedType(type, false);
            return simplified !== type ? simplified : getConstraintOfType(type);
        }
        function getConstraintFromIndexedAccess(type) {
            var indexConstraint = getSimplifiedTypeOrConstraint(type.indexType);
            if (indexConstraint && indexConstraint !== type.indexType) {
                var indexedAccess = getIndexedAccessTypeOrUndefined(type.objectType, indexConstraint, type.accessFlags);
                if (indexedAccess) {
                    return indexedAccess;
                }
            }
            var objectConstraint = getSimplifiedTypeOrConstraint(type.objectType);
            if (objectConstraint && objectConstraint !== type.objectType) {
                return getIndexedAccessTypeOrUndefined(objectConstraint, type.indexType, type.accessFlags);
            }
            return undefined;
        }
        function getDefaultConstraintOfConditionalType(type) {
            if (!type.resolvedDefaultConstraint) {
                var trueConstraint = getInferredTrueTypeFromConditionalType(type);
                var falseConstraint = getFalseTypeFromConditionalType(type);
                type.resolvedDefaultConstraint = isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]);
            }
            return type.resolvedDefaultConstraint;
        }
        function getConstraintOfDistributiveConditionalType(type) {
            if (type.root.isDistributive && type.restrictiveInstantiation !== type) {
                var simplified = getSimplifiedType(type.checkType, false);
                var constraint = simplified === type.checkType ? getConstraintOfType(simplified) : simplified;
                if (constraint && constraint !== type.checkType) {
                    var instantiated = getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper));
                    if (!(instantiated.flags & 131072)) {
                        return instantiated;
                    }
                }
            }
            return undefined;
        }
        function getConstraintFromConditionalType(type) {
            return getConstraintOfDistributiveConditionalType(type) || getDefaultConstraintOfConditionalType(type);
        }
        function getConstraintOfConditionalType(type) {
            return hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(type) : undefined;
        }
        function getEffectiveConstraintOfIntersection(types, targetIsUnion) {
            var constraints;
            var hasDisjointDomainType = false;
            for (var _i = 0, types_5 = types; _i < types_5.length; _i++) {
                var t = types_5[_i];
                if (t.flags & 465829888) {
                    var constraint = getConstraintOfType(t);
                    while (constraint && constraint.flags & (262144 | 4194304 | 16777216)) {
                        constraint = getConstraintOfType(constraint);
                    }
                    if (constraint) {
                        constraints = ts.append(constraints, constraint);
                        if (targetIsUnion) {
                            constraints = ts.append(constraints, t);
                        }
                    }
                }
                else if (t.flags & 469892092) {
                    hasDisjointDomainType = true;
                }
            }
            if (constraints && (targetIsUnion || hasDisjointDomainType)) {
                if (hasDisjointDomainType) {
                    for (var _a = 0, types_6 = types; _a < types_6.length; _a++) {
                        var t = types_6[_a];
                        if (t.flags & 469892092) {
                            constraints = ts.append(constraints, t);
                        }
                    }
                }
                return getIntersectionType(constraints);
            }
            return undefined;
        }
        function getBaseConstraintOfType(type) {
            if (type.flags & (58982400 | 3145728 | 134217728 | 268435456)) {
                var constraint = getResolvedBaseConstraint(type);
                return constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : undefined;
            }
            return type.flags & 4194304 ? keyofConstraintType : undefined;
        }
        function getBaseConstraintOrType(type) {
            return getBaseConstraintOfType(type) || type;
        }
        function hasNonCircularBaseConstraint(type) {
            return getResolvedBaseConstraint(type) !== circularConstraintType;
        }
        function getResolvedBaseConstraint(type) {
            if (type.resolvedBaseConstraint) {
                return type.resolvedBaseConstraint;
            }
            var stack = [];
            return type.resolvedBaseConstraint = getTypeWithThisArgument(getImmediateBaseConstraint(type), type);
            function getImmediateBaseConstraint(t) {
                if (!t.immediateBaseConstraint) {
                    if (!pushTypeResolution(t, 4)) {
                        return circularConstraintType;
                    }
                    var result = void 0;
                    if (stack.length < 10 || stack.length < 50 && !isDeeplyNestedType(t, stack, stack.length)) {
                        stack.push(t);
                        result = computeBaseConstraint(getSimplifiedType(t, false));
                        stack.pop();
                    }
                    if (!popTypeResolution()) {
                        if (t.flags & 262144) {
                            var errorNode = getConstraintDeclaration(t);
                            if (errorNode) {
                                var diagnostic = error(errorNode, ts.Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(t));
                                if (currentNode && !ts.isNodeDescendantOf(errorNode, currentNode) && !ts.isNodeDescendantOf(currentNode, errorNode)) {
                                    ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(currentNode, ts.Diagnostics.Circularity_originates_in_type_at_this_location));
                                }
                            }
                        }
                        result = circularConstraintType;
                    }
                    t.immediateBaseConstraint = result || noConstraintType;
                }
                return t.immediateBaseConstraint;
            }
            function getBaseConstraint(t) {
                var c = getImmediateBaseConstraint(t);
                return c !== noConstraintType && c !== circularConstraintType ? c : undefined;
            }
            function computeBaseConstraint(t) {
                if (t.flags & 262144) {
                    var constraint = getConstraintFromTypeParameter(t);
                    return t.isThisType || !constraint ?
                        constraint :
                        getBaseConstraint(constraint);
                }
                if (t.flags & 3145728) {
                    var types = t.types;
                    var baseTypes = [];
                    var different = false;
                    for (var _i = 0, types_7 = types; _i < types_7.length; _i++) {
                        var type_3 = types_7[_i];
                        var baseType = getBaseConstraint(type_3);
                        if (baseType) {
                            if (baseType !== type_3) {
                                different = true;
                            }
                            baseTypes.push(baseType);
                        }
                        else {
                            different = true;
                        }
                    }
                    if (!different) {
                        return t;
                    }
                    return t.flags & 1048576 && baseTypes.length === types.length ? getUnionType(baseTypes) :
                        t.flags & 2097152 && baseTypes.length ? getIntersectionType(baseTypes) :
                            undefined;
                }
                if (t.flags & 4194304) {
                    return keyofConstraintType;
                }
                if (t.flags & 134217728) {
                    var types = t.types;
                    var constraints = ts.mapDefined(types, getBaseConstraint);
                    return constraints.length === types.length ? getTemplateLiteralType(t.texts, constraints) : stringType;
                }
                if (t.flags & 268435456) {
                    var constraint = getBaseConstraint(t.type);
                    return constraint ? getStringMappingType(t.symbol, constraint) : stringType;
                }
                if (t.flags & 8388608) {
                    var baseObjectType = getBaseConstraint(t.objectType);
                    var baseIndexType = getBaseConstraint(t.indexType);
                    var baseIndexedAccess = baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, t.accessFlags);
                    return baseIndexedAccess && getBaseConstraint(baseIndexedAccess);
                }
                if (t.flags & 16777216) {
                    var constraint = getConstraintFromConditionalType(t);
                    return constraint && getBaseConstraint(constraint);
                }
                if (t.flags & 33554432) {
                    return getBaseConstraint(t.substitute);
                }
                return t;
            }
        }
        function getApparentTypeOfIntersectionType(type) {
            return type.resolvedApparentType || (type.resolvedApparentType = getTypeWithThisArgument(type, type, true));
        }
        function getResolvedTypeParameterDefault(typeParameter) {
            if (!typeParameter.default) {
                if (typeParameter.target) {
                    var targetDefault = getResolvedTypeParameterDefault(typeParameter.target);
                    typeParameter.default = targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType;
                }
                else {
                    typeParameter.default = resolvingDefaultType;
                    var defaultDeclaration = typeParameter.symbol && ts.forEach(typeParameter.symbol.declarations, function (decl) { return ts.isTypeParameterDeclaration(decl) && decl.default; });
                    var defaultType = defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType;
                    if (typeParameter.default === resolvingDefaultType) {
                        typeParameter.default = defaultType;
                    }
                }
            }
            else if (typeParameter.default === resolvingDefaultType) {
                typeParameter.default = circularConstraintType;
            }
            return typeParameter.default;
        }
        function getDefaultFromTypeParameter(typeParameter) {
            var defaultType = getResolvedTypeParameterDefault(typeParameter);
            return defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined;
        }
        function hasNonCircularTypeParameterDefault(typeParameter) {
            return getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType;
        }
        function hasTypeParameterDefault(typeParameter) {
            return !!(typeParameter.symbol && ts.forEach(typeParameter.symbol.declarations, function (decl) { return ts.isTypeParameterDeclaration(decl) && decl.default; }));
        }
        function getApparentTypeOfMappedType(type) {
            return type.resolvedApparentType || (type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type));
        }
        function getResolvedApparentTypeOfMappedType(type) {
            var typeVariable = getHomomorphicTypeVariable(type);
            if (typeVariable && !type.declaration.nameType) {
                var constraint = getConstraintOfTypeParameter(typeVariable);
                if (constraint && (isArrayType(constraint) || isTupleType(constraint))) {
                    return instantiateType(type, prependTypeMapping(typeVariable, constraint, type.mapper));
                }
            }
            return type;
        }
        function getApparentType(type) {
            var t = type.flags & 465829888 ? getBaseConstraintOfType(type) || unknownType : type;
            return ts.getObjectFlags(t) & 32 ? getApparentTypeOfMappedType(t) :
                t.flags & 2097152 ? getApparentTypeOfIntersectionType(t) :
                    t.flags & 402653316 ? globalStringType :
                        t.flags & 296 ? globalNumberType :
                            t.flags & 2112 ? getGlobalBigIntType(languageVersion >= 7) :
                                t.flags & 528 ? globalBooleanType :
                                    t.flags & 12288 ? getGlobalESSymbolType(languageVersion >= 2) :
                                        t.flags & 67108864 ? emptyObjectType :
                                            t.flags & 4194304 ? keyofConstraintType :
                                                t.flags & 2 && !strictNullChecks ? emptyObjectType :
                                                    t;
        }
        function getReducedApparentType(type) {
            return getReducedType(getApparentType(getReducedType(type)));
        }
        function createUnionOrIntersectionProperty(containingType, name, skipObjectFunctionPropertyAugment) {
            var _a, _b;
            var singleProp;
            var propSet;
            var indexTypes;
            var isUnion = containingType.flags & 1048576;
            var optionalFlag = isUnion ? 0 : 16777216;
            var syntheticFlag = 4;
            var checkFlags = 0;
            var mergedInstantiations = false;
            for (var _i = 0, _c = containingType.types; _i < _c.length; _i++) {
                var current = _c[_i];
                var type = getApparentType(current);
                if (!(type === errorType || type.flags & 131072)) {
                    var prop = getPropertyOfType(type, name, skipObjectFunctionPropertyAugment);
                    var modifiers = prop ? ts.getDeclarationModifierFlagsFromSymbol(prop) : 0;
                    if (prop) {
                        if (isUnion) {
                            optionalFlag |= (prop.flags & 16777216);
                        }
                        else {
                            optionalFlag &= prop.flags;
                        }
                        if (!singleProp) {
                            singleProp = prop;
                        }
                        else if (prop !== singleProp) {
                            var isInstantiation = (getTargetSymbol(prop) || prop) === (getTargetSymbol(singleProp) || singleProp);
                            if (isInstantiation && compareProperties(singleProp, prop, function (a, b) { return a === b ? -1 : 0; }) === -1) {
                                mergedInstantiations = !!singleProp.parent && !!ts.length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent));
                            }
                            else {
                                if (!propSet) {
                                    propSet = new ts.Map();
                                    propSet.set(getSymbolId(singleProp), singleProp);
                                }
                                var id = getSymbolId(prop);
                                if (!propSet.has(id)) {
                                    propSet.set(id, prop);
                                }
                            }
                        }
                        checkFlags |= (isReadonlySymbol(prop) ? 8 : 0) |
                            (!(modifiers & 24) ? 256 : 0) |
                            (modifiers & 16 ? 512 : 0) |
                            (modifiers & 8 ? 1024 : 0) |
                            (modifiers & 32 ? 2048 : 0);
                        if (!isPrototypeProperty(prop)) {
                            syntheticFlag = 2;
                        }
                    }
                    else if (isUnion) {
                        var indexInfo = !isLateBoundName(name) && getApplicableIndexInfoForName(type, name);
                        if (indexInfo) {
                            checkFlags |= 32 | (indexInfo.isReadonly ? 8 : 0);
                            indexTypes = ts.append(indexTypes, isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type);
                        }
                        else if (isObjectLiteralType(type) && !(ts.getObjectFlags(type) & 4194304)) {
                            checkFlags |= 32;
                            indexTypes = ts.append(indexTypes, undefinedType);
                        }
                        else {
                            checkFlags |= 16;
                        }
                    }
                }
            }
            if (!singleProp || isUnion && (propSet || checkFlags & 48) && checkFlags & (1024 | 512)) {
                return undefined;
            }
            if (!propSet && !(checkFlags & 16) && !indexTypes) {
                if (mergedInstantiations) {
                    var clone_1 = createSymbolWithType(singleProp, singleProp.type);
                    clone_1.parent = (_b = (_a = singleProp.valueDeclaration) === null || _a === void 0 ? void 0 : _a.symbol) === null || _b === void 0 ? void 0 : _b.parent;
                    clone_1.containingType = containingType;
                    clone_1.mapper = singleProp.mapper;
                    return clone_1;
                }
                else {
                    return singleProp;
                }
            }
            var props = propSet ? ts.arrayFrom(propSet.values()) : [singleProp];
            var declarations;
            var firstType;
            var nameType;
            var propTypes = [];
            var firstValueDeclaration;
            var hasNonUniformValueDeclaration = false;
            for (var _d = 0, props_1 = props; _d < props_1.length; _d++) {
                var prop = props_1[_d];
                if (!firstValueDeclaration) {
                    firstValueDeclaration = prop.valueDeclaration;
                }
                else if (prop.valueDeclaration && prop.valueDeclaration !== firstValueDeclaration) {
                    hasNonUniformValueDeclaration = true;
                }
                declarations = ts.addRange(declarations, prop.declarations);
                var type = getTypeOfSymbol(prop);
                if (!firstType) {
                    firstType = type;
                    nameType = getSymbolLinks(prop).nameType;
                }
                else if (type !== firstType) {
                    checkFlags |= 64;
                }
                if (isLiteralType(type)) {
                    checkFlags |= 128;
                }
                if (type.flags & 131072) {
                    checkFlags |= 131072;
                }
                propTypes.push(type);
            }
            ts.addRange(propTypes, indexTypes);
            var result = createSymbol(4 | optionalFlag, name, syntheticFlag | checkFlags);
            result.containingType = containingType;
            if (!hasNonUniformValueDeclaration && firstValueDeclaration) {
                result.valueDeclaration = firstValueDeclaration;
                if (firstValueDeclaration.symbol.parent) {
                    result.parent = firstValueDeclaration.symbol.parent;
                }
            }
            result.declarations = declarations;
            result.nameType = nameType;
            if (propTypes.length > 2) {
                result.checkFlags |= 65536;
                result.deferralParent = containingType;
                result.deferralConstituents = propTypes;
            }
            else {
                result.type = isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes);
            }
            return result;
        }
        function getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment) {
            var _a, _b;
            var property = ((_a = type.propertyCacheWithoutObjectFunctionPropertyAugment) === null || _a === void 0 ? void 0 : _a.get(name)) ||
                !skipObjectFunctionPropertyAugment ? (_b = type.propertyCache) === null || _b === void 0 ? void 0 : _b.get(name) : undefined;
            if (!property) {
                property = createUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
                if (property) {
                    var properties = skipObjectFunctionPropertyAugment ? type.propertyCacheWithoutObjectFunctionPropertyAugment || (type.propertyCacheWithoutObjectFunctionPropertyAugment = ts.createSymbolTable()) : type.propertyCache || (type.propertyCache = ts.createSymbolTable());
                    properties.set(name, property);
                }
            }
            return property;
        }
        function getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment) {
            var property = getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
            return property && !(ts.getCheckFlags(property) & 16) ? property : undefined;
        }
        function getReducedType(type) {
            if (type.flags & 1048576 && type.objectFlags & 33554432) {
                return type.resolvedReducedType || (type.resolvedReducedType = getReducedUnionType(type));
            }
            else if (type.flags & 2097152) {
                if (!(type.objectFlags & 33554432)) {
                    type.objectFlags |= 33554432 |
                        (ts.some(getPropertiesOfUnionOrIntersectionType(type), isNeverReducedProperty) ? 67108864 : 0);
                }
                return type.objectFlags & 67108864 ? neverType : type;
            }
            return type;
        }
        function getReducedUnionType(unionType) {
            var reducedTypes = ts.sameMap(unionType.types, getReducedType);
            if (reducedTypes === unionType.types) {
                return unionType;
            }
            var reduced = getUnionType(reducedTypes);
            if (reduced.flags & 1048576) {
                reduced.resolvedReducedType = reduced;
            }
            return reduced;
        }
        function isNeverReducedProperty(prop) {
            return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop);
        }
        function isDiscriminantWithNeverType(prop) {
            return !(prop.flags & 16777216) &&
                (ts.getCheckFlags(prop) & (192 | 131072)) === 192 &&
                !!(getTypeOfSymbol(prop).flags & 131072);
        }
        function isConflictingPrivateProperty(prop) {
            return !prop.valueDeclaration && !!(ts.getCheckFlags(prop) & 1024);
        }
        function elaborateNeverIntersection(errorInfo, type) {
            if (type.flags & 2097152 && ts.getObjectFlags(type) & 67108864) {
                var neverProp = ts.find(getPropertiesOfUnionOrIntersectionType(type), isDiscriminantWithNeverType);
                if (neverProp) {
                    return ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, typeToString(type, undefined, 536870912), symbolToString(neverProp));
                }
                var privateProp = ts.find(getPropertiesOfUnionOrIntersectionType(type), isConflictingPrivateProperty);
                if (privateProp) {
                    return ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, typeToString(type, undefined, 536870912), symbolToString(privateProp));
                }
            }
            return errorInfo;
        }
        function getPropertyOfType(type, name, skipObjectFunctionPropertyAugment) {
            type = getReducedApparentType(type);
            if (type.flags & 524288) {
                var resolved = resolveStructuredTypeMembers(type);
                var symbol = resolved.members.get(name);
                if (symbol && symbolIsValue(symbol)) {
                    return symbol;
                }
                if (skipObjectFunctionPropertyAugment)
                    return undefined;
                var functionType = resolved === anyFunctionType ? globalFunctionType :
                    resolved.callSignatures.length ? globalCallableFunctionType :
                        resolved.constructSignatures.length ? globalNewableFunctionType :
                            undefined;
                if (functionType) {
                    var symbol_1 = getPropertyOfObjectType(functionType, name);
                    if (symbol_1) {
                        return symbol_1;
                    }
                }
                return getPropertyOfObjectType(globalObjectType, name);
            }
            if (type.flags & 3145728) {
                return getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment);
            }
            return undefined;
        }
        function getSignaturesOfStructuredType(type, kind) {
            if (type.flags & 3670016) {
                var resolved = resolveStructuredTypeMembers(type);
                return kind === 0 ? resolved.callSignatures : resolved.constructSignatures;
            }
            return ts.emptyArray;
        }
        function getSignaturesOfType(type, kind) {
            return getSignaturesOfStructuredType(getReducedApparentType(type), kind);
        }
        function findIndexInfo(indexInfos, keyType) {
            return ts.find(indexInfos, function (info) { return info.keyType === keyType; });
        }
        function findApplicableIndexInfo(indexInfos, keyType) {
            var stringIndexInfo;
            var applicableInfo;
            var applicableInfos;
            for (var _i = 0, indexInfos_1 = indexInfos; _i < indexInfos_1.length; _i++) {
                var info = indexInfos_1[_i];
                if (info.keyType === stringType) {
                    stringIndexInfo = info;
                }
                else if (isApplicableIndexType(keyType, info.keyType)) {
                    if (!applicableInfo) {
                        applicableInfo = info;
                    }
                    else {
                        (applicableInfos || (applicableInfos = [applicableInfo])).push(info);
                    }
                }
            }
            return applicableInfos ? createIndexInfo(unknownType, getIntersectionType(ts.map(applicableInfos, function (info) { return info.type; })), ts.reduceLeft(applicableInfos, function (isReadonly, info) { return isReadonly && info.isReadonly; }, true)) :
                applicableInfo ? applicableInfo :
                    stringIndexInfo && isApplicableIndexType(keyType, stringType) ? stringIndexInfo :
                        undefined;
        }
        function isApplicableIndexType(source, target) {
            return isTypeAssignableTo(source, target) ||
                target === stringType && isTypeAssignableTo(source, numberType) ||
                target === numberType && !!(source.flags & 128) && isNumericLiteralName(source.value);
        }
        function getIndexInfosOfStructuredType(type) {
            if (type.flags & 3670016) {
                var resolved = resolveStructuredTypeMembers(type);
                return resolved.indexInfos;
            }
            return ts.emptyArray;
        }
        function getIndexInfosOfType(type) {
            return getIndexInfosOfStructuredType(getReducedApparentType(type));
        }
        function getIndexInfoOfType(type, keyType) {
            return findIndexInfo(getIndexInfosOfType(type), keyType);
        }
        function getIndexTypeOfType(type, keyType) {
            var _a;
            return (_a = getIndexInfoOfType(type, keyType)) === null || _a === void 0 ? void 0 : _a.type;
        }
        function getApplicableIndexInfos(type, keyType) {
            return getIndexInfosOfType(type).filter(function (info) { return isApplicableIndexType(keyType, info.keyType); });
        }
        function getApplicableIndexInfo(type, keyType) {
            return findApplicableIndexInfo(getIndexInfosOfType(type), keyType);
        }
        function getApplicableIndexInfoForName(type, name) {
            return getApplicableIndexInfo(type, isLateBoundName(name) ? esSymbolType : getStringLiteralType(ts.unescapeLeadingUnderscores(name)));
        }
        function getTypeParametersFromDeclaration(declaration) {
            var result;
            for (var _i = 0, _a = ts.getEffectiveTypeParameterDeclarations(declaration); _i < _a.length; _i++) {
                var node = _a[_i];
                result = ts.appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol));
            }
            return result;
        }
        function symbolsToArray(symbols) {
            var result = [];
            symbols.forEach(function (symbol, id) {
                if (!isReservedMemberName(id)) {
                    result.push(symbol);
                }
            });
            return result;
        }
        function isJSDocOptionalParameter(node) {
            return ts.isInJSFile(node) && (node.type && node.type.kind === 311
                || ts.getJSDocParameterTags(node).some(function (_a) {
                    var isBracketed = _a.isBracketed, typeExpression = _a.typeExpression;
                    return isBracketed || !!typeExpression && typeExpression.type.kind === 311;
                }));
        }
        function tryFindAmbientModule(moduleName, withAugmentations) {
            if (ts.isExternalModuleNameRelative(moduleName)) {
                return undefined;
            }
            var symbol = getSymbol(globals, '"' + moduleName + '"', 512);
            return symbol && withAugmentations ? getMergedSymbol(symbol) : symbol;
        }
        function isOptionalParameter(node) {
            if (ts.hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isJSDocOptionalParameter(node)) {
                return true;
            }
            if (node.initializer) {
                var signature = getSignatureFromDeclaration(node.parent);
                var parameterIndex = node.parent.parameters.indexOf(node);
                ts.Debug.assert(parameterIndex >= 0);
                return parameterIndex >= getMinArgumentCount(signature, 1 | 2);
            }
            var iife = ts.getImmediatelyInvokedFunctionExpression(node.parent);
            if (iife) {
                return !node.type &&
                    !node.dotDotDotToken &&
                    node.parent.parameters.indexOf(node) >= iife.arguments.length;
            }
            return false;
        }
        function isOptionalPropertyDeclaration(node) {
            return ts.isPropertyDeclaration(node) && node.questionToken;
        }
        function isOptionalJSDocPropertyLikeTag(node) {
            if (!ts.isJSDocPropertyLikeTag(node)) {
                return false;
            }
            var isBracketed = node.isBracketed, typeExpression = node.typeExpression;
            return isBracketed || !!typeExpression && typeExpression.type.kind === 311;
        }
        function createTypePredicate(kind, parameterName, parameterIndex, type) {
            return { kind: kind, parameterName: parameterName, parameterIndex: parameterIndex, type: type };
        }
        function getMinTypeArgumentCount(typeParameters) {
            var minTypeArgumentCount = 0;
            if (typeParameters) {
                for (var i = 0; i < typeParameters.length; i++) {
                    if (!hasTypeParameterDefault(typeParameters[i])) {
                        minTypeArgumentCount = i + 1;
                    }
                }
            }
            return minTypeArgumentCount;
        }
        function fillMissingTypeArguments(typeArguments, typeParameters, minTypeArgumentCount, isJavaScriptImplicitAny) {
            var numTypeParameters = ts.length(typeParameters);
            if (!numTypeParameters) {
                return [];
            }
            var numTypeArguments = ts.length(typeArguments);
            if (isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters)) {
                var result = typeArguments ? typeArguments.slice() : [];
                for (var i = numTypeArguments; i < numTypeParameters; i++) {
                    result[i] = errorType;
                }
                var baseDefaultType = getDefaultTypeArgumentType(isJavaScriptImplicitAny);
                for (var i = numTypeArguments; i < numTypeParameters; i++) {
                    var defaultType = getDefaultFromTypeParameter(typeParameters[i]);
                    if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) {
                        defaultType = anyType;
                    }
                    result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters, result)) : baseDefaultType;
                }
                result.length = typeParameters.length;
                return result;
            }
            return typeArguments && typeArguments.slice();
        }
        function getSignatureFromDeclaration(declaration) {
            var links = getNodeLinks(declaration);
            if (!links.resolvedSignature) {
                var parameters = [];
                var flags = 0;
                var minArgumentCount = 0;
                var thisParameter = void 0;
                var hasThisParameter = false;
                var iife = ts.getImmediatelyInvokedFunctionExpression(declaration);
                var isJSConstructSignature = ts.isJSDocConstructSignature(declaration);
                var isUntypedSignatureInJSFile = !iife &&
                    ts.isInJSFile(declaration) &&
                    ts.isValueSignatureDeclaration(declaration) &&
                    !ts.hasJSDocParameterTags(declaration) &&
                    !ts.getJSDocType(declaration);
                if (isUntypedSignatureInJSFile) {
                    flags |= 32;
                }
                for (var i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {
                    var param = declaration.parameters[i];
                    var paramSymbol = param.symbol;
                    var type = ts.isJSDocParameterTag(param) ? (param.typeExpression && param.typeExpression.type) : param.type;
                    if (paramSymbol && !!(paramSymbol.flags & 4) && !ts.isBindingPattern(param.name)) {
                        var resolvedSymbol = resolveName(param, paramSymbol.escapedName, 111551, undefined, undefined, false);
                        paramSymbol = resolvedSymbol;
                    }
                    if (i === 0 && paramSymbol.escapedName === "this") {
                        hasThisParameter = true;
                        thisParameter = param.symbol;
                    }
                    else {
                        parameters.push(paramSymbol);
                    }
                    if (type && type.kind === 194) {
                        flags |= 2;
                    }
                    var isOptionalParameter_1 = isOptionalJSDocPropertyLikeTag(param) ||
                        param.initializer || param.questionToken || ts.isRestParameter(param) ||
                        iife && parameters.length > iife.arguments.length && !type ||
                        isJSDocOptionalParameter(param);
                    if (!isOptionalParameter_1) {
                        minArgumentCount = parameters.length;
                    }
                }
                if ((declaration.kind === 170 || declaration.kind === 171) &&
                    hasBindableName(declaration) &&
                    (!hasThisParameter || !thisParameter)) {
                    var otherKind = declaration.kind === 170 ? 171 : 170;
                    var other = ts.getDeclarationOfKind(getSymbolOfNode(declaration), otherKind);
                    if (other) {
                        thisParameter = getAnnotatedAccessorThisParameter(other);
                    }
                }
                var classType = declaration.kind === 169 ?
                    getDeclaredTypeOfClassOrInterface(getMergedSymbol(declaration.parent.symbol))
                    : undefined;
                var typeParameters = classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration);
                if (ts.hasRestParameter(declaration) || ts.isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters)) {
                    flags |= 1;
                }
                if (ts.isConstructorTypeNode(declaration) && ts.hasSyntacticModifier(declaration, 128) ||
                    ts.isConstructorDeclaration(declaration) && ts.hasSyntacticModifier(declaration.parent, 128)) {
                    flags |= 4;
                }
                links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, undefined, undefined, minArgumentCount, flags);
            }
            return links.resolvedSignature;
        }
        function maybeAddJsSyntheticRestParameter(declaration, parameters) {
            if (ts.isJSDocSignature(declaration) || !containsArgumentsReference(declaration)) {
                return false;
            }
            var lastParam = ts.lastOrUndefined(declaration.parameters);
            var lastParamTags = lastParam ? ts.getJSDocParameterTags(lastParam) : ts.getJSDocTags(declaration).filter(ts.isJSDocParameterTag);
            var lastParamVariadicType = ts.firstDefined(lastParamTags, function (p) {
                return p.typeExpression && ts.isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : undefined;
            });
            var syntheticArgsSymbol = createSymbol(3, "args", 32768);
            syntheticArgsSymbol.type = lastParamVariadicType ? createArrayType(getTypeFromTypeNode(lastParamVariadicType.type)) : anyArrayType;
            if (lastParamVariadicType) {
                parameters.pop();
            }
            parameters.push(syntheticArgsSymbol);
            return true;
        }
        function getSignatureOfTypeTag(node) {
            if (!(ts.isInJSFile(node) && ts.isFunctionLikeDeclaration(node)))
                return undefined;
            var typeTag = ts.getJSDocTypeTag(node);
            return (typeTag === null || typeTag === void 0 ? void 0 : typeTag.typeExpression) && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
        }
        function getReturnTypeOfTypeTag(node) {
            var signature = getSignatureOfTypeTag(node);
            return signature && getReturnTypeOfSignature(signature);
        }
        function containsArgumentsReference(declaration) {
            var links = getNodeLinks(declaration);
            if (links.containsArgumentsReference === undefined) {
                if (links.flags & 8192) {
                    links.containsArgumentsReference = true;
                }
                else {
                    links.containsArgumentsReference = traverse(declaration.body);
                }
            }
            return links.containsArgumentsReference;
            function traverse(node) {
                if (!node)
                    return false;
                switch (node.kind) {
                    case 79:
                        return node.escapedText === argumentsSymbol.escapedName && getResolvedSymbol(node) === argumentsSymbol;
                    case 165:
                    case 167:
                    case 170:
                    case 171:
                        return node.name.kind === 160
                            && traverse(node.name);
                    case 204:
                    case 205:
                        return traverse(node.expression);
                    default:
                        return !ts.nodeStartsNewLexicalEnvironment(node) && !ts.isPartOfTypeNode(node) && !!ts.forEachChild(node, traverse);
                }
            }
        }
        function getSignaturesOfSymbol(symbol) {
            if (!symbol || !symbol.declarations)
                return ts.emptyArray;
            var result = [];
            for (var i = 0; i < symbol.declarations.length; i++) {
                var decl = symbol.declarations[i];
                if (!ts.isFunctionLike(decl))
                    continue;
                if (i > 0 && decl.body) {
                    var previous = symbol.declarations[i - 1];
                    if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) {
                        continue;
                    }
                }
                result.push(getSignatureFromDeclaration(decl));
            }
            return result;
        }
        function resolveExternalModuleTypeByLiteral(name) {
            var moduleSym = resolveExternalModuleName(name, name);
            if (moduleSym) {
                var resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
                if (resolvedModuleSymbol) {
                    return getTypeOfSymbol(resolvedModuleSymbol);
                }
            }
            return anyType;
        }
        function getThisTypeOfSignature(signature) {
            if (signature.thisParameter) {
                return getTypeOfSymbol(signature.thisParameter);
            }
        }
        function getTypePredicateOfSignature(signature) {
            if (!signature.resolvedTypePredicate) {
                if (signature.target) {
                    var targetTypePredicate = getTypePredicateOfSignature(signature.target);
                    signature.resolvedTypePredicate = targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper) : noTypePredicate;
                }
                else if (signature.compositeSignatures) {
                    signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate;
                }
                else {
                    var type = signature.declaration && ts.getEffectiveReturnTypeNode(signature.declaration);
                    var jsdocPredicate = void 0;
                    if (!type && ts.isInJSFile(signature.declaration)) {
                        var jsdocSignature = getSignatureOfTypeTag(signature.declaration);
                        if (jsdocSignature && signature !== jsdocSignature) {
                            jsdocPredicate = getTypePredicateOfSignature(jsdocSignature);
                        }
                    }
                    signature.resolvedTypePredicate = type && ts.isTypePredicateNode(type) ?
                        createTypePredicateFromTypePredicateNode(type, signature) :
                        jsdocPredicate || noTypePredicate;
                }
                ts.Debug.assert(!!signature.resolvedTypePredicate);
            }
            return signature.resolvedTypePredicate === noTypePredicate ? undefined : signature.resolvedTypePredicate;
        }
        function createTypePredicateFromTypePredicateNode(node, signature) {
            var parameterName = node.parameterName;
            var type = node.type && getTypeFromTypeNode(node.type);
            return parameterName.kind === 190 ?
                createTypePredicate(node.assertsModifier ? 2 : 0, undefined, undefined, type) :
                createTypePredicate(node.assertsModifier ? 3 : 1, parameterName.escapedText, ts.findIndex(signature.parameters, function (p) { return p.escapedName === parameterName.escapedText; }), type);
        }
        function getUnionOrIntersectionType(types, kind, unionReduction) {
            return kind !== 2097152 ? getUnionType(types, unionReduction) : getIntersectionType(types);
        }
        function getReturnTypeOfSignature(signature) {
            if (!signature.resolvedReturnType) {
                if (!pushTypeResolution(signature, 3)) {
                    return errorType;
                }
                var type = signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) :
                    signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(ts.map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, 2), signature.mapper) :
                        getReturnTypeFromAnnotation(signature.declaration) ||
                            (ts.nodeIsMissing(signature.declaration.body) ? anyType : getReturnTypeFromBody(signature.declaration));
                if (signature.flags & 8) {
                    type = addOptionalTypeMarker(type);
                }
                else if (signature.flags & 16) {
                    type = getOptionalType(type);
                }
                if (!popTypeResolution()) {
                    if (signature.declaration) {
                        var typeNode = ts.getEffectiveReturnTypeNode(signature.declaration);
                        if (typeNode) {
                            error(typeNode, ts.Diagnostics.Return_type_annotation_circularly_references_itself);
                        }
                        else if (noImplicitAny) {
                            var declaration = signature.declaration;
                            var name = ts.getNameOfDeclaration(declaration);
                            if (name) {
                                error(name, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, ts.declarationNameToString(name));
                            }
                            else {
                                error(declaration, ts.Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
                            }
                        }
                    }
                    type = anyType;
                }
                signature.resolvedReturnType = type;
            }
            return signature.resolvedReturnType;
        }
        function getReturnTypeFromAnnotation(declaration) {
            if (declaration.kind === 169) {
                return getDeclaredTypeOfClassOrInterface(getMergedSymbol(declaration.parent.symbol));
            }
            if (ts.isJSDocConstructSignature(declaration)) {
                return getTypeFromTypeNode(declaration.parameters[0].type);
            }
            var typeNode = ts.getEffectiveReturnTypeNode(declaration);
            if (typeNode) {
                return getTypeFromTypeNode(typeNode);
            }
            if (declaration.kind === 170 && hasBindableName(declaration)) {
                var jsDocType = ts.isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration);
                if (jsDocType) {
                    return jsDocType;
                }
                var setter = ts.getDeclarationOfKind(getSymbolOfNode(declaration), 171);
                var setterType = getAnnotatedAccessorType(setter);
                if (setterType) {
                    return setterType;
                }
            }
            return getReturnTypeOfTypeTag(declaration);
        }
        function isResolvingReturnTypeOfSignature(signature) {
            return !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, 3) >= 0;
        }
        function getRestTypeOfSignature(signature) {
            return tryGetRestTypeOfSignature(signature) || anyType;
        }
        function tryGetRestTypeOfSignature(signature) {
            if (signatureHasRestParameter(signature)) {
                var sigRestType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                var restType = isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType;
                return restType && getIndexTypeOfType(restType, numberType);
            }
            return undefined;
        }
        function getSignatureInstantiation(signature, typeArguments, isJavascript, inferredTypeParameters) {
            var instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript));
            if (inferredTypeParameters) {
                var returnSignature = getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature));
                if (returnSignature) {
                    var newReturnSignature = cloneSignature(returnSignature);
                    newReturnSignature.typeParameters = inferredTypeParameters;
                    var newInstantiatedSignature = cloneSignature(instantiatedSignature);
                    newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature);
                    return newInstantiatedSignature;
                }
            }
            return instantiatedSignature;
        }
        function getSignatureInstantiationWithoutFillingInTypeArguments(signature, typeArguments) {
            var instantiations = signature.instantiations || (signature.instantiations = new ts.Map());
            var id = getTypeListId(typeArguments);
            var instantiation = instantiations.get(id);
            if (!instantiation) {
                instantiations.set(id, instantiation = createSignatureInstantiation(signature, typeArguments));
            }
            return instantiation;
        }
        function createSignatureInstantiation(signature, typeArguments) {
            return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments), true);
        }
        function createSignatureTypeMapper(signature, typeArguments) {
            return createTypeMapper(signature.typeParameters, typeArguments);
        }
        function getErasedSignature(signature) {
            return signature.typeParameters ?
                signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) :
                signature;
        }
        function createErasedSignature(signature) {
            return instantiateSignature(signature, createTypeEraser(signature.typeParameters), true);
        }
        function getCanonicalSignature(signature) {
            return signature.typeParameters ?
                signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) :
                signature;
        }
        function createCanonicalSignature(signature) {
            return getSignatureInstantiation(signature, ts.map(signature.typeParameters, function (tp) { return tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp; }), ts.isInJSFile(signature.declaration));
        }
        function getBaseSignature(signature) {
            var typeParameters = signature.typeParameters;
            if (typeParameters) {
                if (signature.baseSignatureCache) {
                    return signature.baseSignatureCache;
                }
                var typeEraser = createTypeEraser(typeParameters);
                var baseConstraintMapper_1 = createTypeMapper(typeParameters, ts.map(typeParameters, function (tp) { return getConstraintOfTypeParameter(tp) || unknownType; }));
                var baseConstraints = ts.map(typeParameters, function (tp) { return instantiateType(tp, baseConstraintMapper_1) || unknownType; });
                for (var i = 0; i < typeParameters.length - 1; i++) {
                    baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper_1);
                }
                baseConstraints = instantiateTypes(baseConstraints, typeEraser);
                return signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), true);
            }
            return signature;
        }
        function getOrCreateTypeFromSignature(signature) {
            if (!signature.isolatedSignatureType) {
                var kind = signature.declaration ? signature.declaration.kind : 0;
                var isConstructor = kind === 169 || kind === 173 || kind === 178;
                var type = createObjectType(16);
                type.members = emptySymbols;
                type.properties = ts.emptyArray;
                type.callSignatures = !isConstructor ? [signature] : ts.emptyArray;
                type.constructSignatures = isConstructor ? [signature] : ts.emptyArray;
                type.indexInfos = ts.emptyArray;
                signature.isolatedSignatureType = type;
            }
            return signature.isolatedSignatureType;
        }
        function getIndexSymbol(symbol) {
            return symbol.members ? getIndexSymbolFromSymbolTable(symbol.members) : undefined;
        }
        function getIndexSymbolFromSymbolTable(symbolTable) {
            return symbolTable.get("__index");
        }
        function createIndexInfo(keyType, type, isReadonly, declaration) {
            return { keyType: keyType, type: type, isReadonly: isReadonly, declaration: declaration };
        }
        function getIndexInfosOfSymbol(symbol) {
            var indexSymbol = getIndexSymbol(symbol);
            return indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol) : ts.emptyArray;
        }
        function getIndexInfosOfIndexSymbol(indexSymbol) {
            if (indexSymbol.declarations) {
                var indexInfos_2 = [];
                var _loop_14 = function (declaration) {
                    if (declaration.parameters.length === 1) {
                        var parameter = declaration.parameters[0];
                        if (parameter.type) {
                            forEachType(getTypeFromTypeNode(parameter.type), function (keyType) {
                                if (isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos_2, keyType)) {
                                    indexInfos_2.push(createIndexInfo(keyType, declaration.type ? getTypeFromTypeNode(declaration.type) : anyType, ts.hasEffectiveModifier(declaration, 64), declaration));
                                }
                            });
                        }
                    }
                };
                for (var _i = 0, _a = indexSymbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    _loop_14(declaration);
                }
                return indexInfos_2;
            }
            return ts.emptyArray;
        }
        function isValidIndexKeyType(type) {
            return !!(type.flags & (4 | 8 | 4096)) || isPatternLiteralType(type) ||
                !!(type.flags & 2097152) && !isGenericIndexType(type) && !isGenericObjectType(type) && ts.some(type.types, isValidIndexKeyType);
        }
        function getConstraintDeclaration(type) {
            return ts.mapDefined(ts.filter(type.symbol && type.symbol.declarations, ts.isTypeParameterDeclaration), ts.getEffectiveConstraintOfTypeParameter)[0];
        }
        function getInferredTypeParameterConstraint(typeParameter) {
            var _a;
            var inferences;
            if ((_a = typeParameter.symbol) === null || _a === void 0 ? void 0 : _a.declarations) {
                for (var _i = 0, _b = typeParameter.symbol.declarations; _i < _b.length; _i++) {
                    var declaration = _b[_i];
                    if (declaration.parent.kind === 188) {
                        var _c = ts.walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent), _d = _c[0], childTypeParameter = _d === void 0 ? declaration.parent : _d, grandParent = _c[1];
                        if (grandParent.kind === 176) {
                            var typeReference = grandParent;
                            var typeParameters = getTypeParametersForTypeReference(typeReference);
                            if (typeParameters) {
                                var index = typeReference.typeArguments.indexOf(childTypeParameter);
                                if (index < typeParameters.length) {
                                    var declaredConstraint = getConstraintOfTypeParameter(typeParameters[index]);
                                    if (declaredConstraint) {
                                        var mapper = createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReference, typeParameters));
                                        var constraint = instantiateType(declaredConstraint, mapper);
                                        if (constraint !== typeParameter) {
                                            inferences = ts.append(inferences, constraint);
                                        }
                                    }
                                }
                            }
                        }
                        else if (grandParent.kind === 162 && grandParent.dotDotDotToken ||
                            grandParent.kind === 184 ||
                            grandParent.kind === 195 && grandParent.dotDotDotToken) {
                            inferences = ts.append(inferences, createArrayType(unknownType));
                        }
                        else if (grandParent.kind === 197) {
                            inferences = ts.append(inferences, stringType);
                        }
                        else if (grandParent.kind === 161 && grandParent.parent.kind === 193) {
                            inferences = ts.append(inferences, keyofConstraintType);
                        }
                        else if (grandParent.kind === 193 && grandParent.type &&
                            ts.skipParentheses(grandParent.type) === declaration.parent && grandParent.parent.kind === 187 &&
                            grandParent.parent.extendsType === grandParent && grandParent.parent.checkType.kind === 193 &&
                            grandParent.parent.checkType.type) {
                            var checkMappedType_1 = grandParent.parent.checkType;
                            var nodeType = getTypeFromTypeNode(checkMappedType_1.type);
                            inferences = ts.append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfNode(checkMappedType_1.typeParameter)), checkMappedType_1.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType_1.typeParameter.constraint) : keyofConstraintType)));
                        }
                    }
                }
            }
            return inferences && getIntersectionType(inferences);
        }
        function getConstraintFromTypeParameter(typeParameter) {
            if (!typeParameter.constraint) {
                if (typeParameter.target) {
                    var targetConstraint = getConstraintOfTypeParameter(typeParameter.target);
                    typeParameter.constraint = targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType;
                }
                else {
                    var constraintDeclaration = getConstraintDeclaration(typeParameter);
                    if (!constraintDeclaration) {
                        typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType;
                    }
                    else {
                        var type = getTypeFromTypeNode(constraintDeclaration);
                        if (type.flags & 1 && type !== errorType) {
                            type = constraintDeclaration.parent.parent.kind === 193 ? keyofConstraintType : unknownType;
                        }
                        typeParameter.constraint = type;
                    }
                }
            }
            return typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint;
        }
        function getParentSymbolOfTypeParameter(typeParameter) {
            var tp = ts.getDeclarationOfKind(typeParameter.symbol, 161);
            var host = ts.isJSDocTemplateTag(tp.parent) ? ts.getHostSignatureFromJSDoc(tp.parent) : tp.parent;
            return host && getSymbolOfNode(host);
        }
        function getTypeListId(types) {
            var result = "";
            if (types) {
                var length_4 = types.length;
                var i = 0;
                while (i < length_4) {
                    var startId = types[i].id;
                    var count = 1;
                    while (i + count < length_4 && types[i + count].id === startId + count) {
                        count++;
                    }
                    if (result.length) {
                        result += ",";
                    }
                    result += startId;
                    if (count > 1) {
                        result += ":" + count;
                    }
                    i += count;
                }
            }
            return result;
        }
        function getAliasId(aliasSymbol, aliasTypeArguments) {
            return aliasSymbol ? "@" + getSymbolId(aliasSymbol) + (aliasTypeArguments ? ":" + getTypeListId(aliasTypeArguments) : "") : "";
        }
        function getPropagatingFlagsOfTypes(types, excludeKinds) {
            var result = 0;
            for (var _i = 0, types_8 = types; _i < types_8.length; _i++) {
                var type = types_8[_i];
                if (!(type.flags & excludeKinds)) {
                    result |= ts.getObjectFlags(type);
                }
            }
            return result & 917504;
        }
        function createTypeReference(target, typeArguments) {
            var id = getTypeListId(typeArguments);
            var type = target.instantiations.get(id);
            if (!type) {
                type = createObjectType(4, target.symbol);
                target.instantiations.set(id, type);
                type.objectFlags |= typeArguments ? getPropagatingFlagsOfTypes(typeArguments, 0) : 0;
                type.target = target;
                type.resolvedTypeArguments = typeArguments;
            }
            return type;
        }
        function cloneTypeReference(source) {
            var type = createType(source.flags);
            type.symbol = source.symbol;
            type.objectFlags = source.objectFlags;
            type.target = source.target;
            type.resolvedTypeArguments = source.resolvedTypeArguments;
            return type;
        }
        function createDeferredTypeReference(target, node, mapper, aliasSymbol, aliasTypeArguments) {
            if (!aliasSymbol) {
                aliasSymbol = getAliasSymbolForTypeNode(node);
                var localAliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                aliasTypeArguments = mapper ? instantiateTypes(localAliasTypeArguments, mapper) : localAliasTypeArguments;
            }
            var type = createObjectType(4, target.symbol);
            type.target = target;
            type.node = node;
            type.mapper = mapper;
            type.aliasSymbol = aliasSymbol;
            type.aliasTypeArguments = aliasTypeArguments;
            return type;
        }
        function getTypeArguments(type) {
            var _a, _b;
            if (!type.resolvedTypeArguments) {
                if (!pushTypeResolution(type, 6)) {
                    return ((_a = type.target.localTypeParameters) === null || _a === void 0 ? void 0 : _a.map(function () { return errorType; })) || ts.emptyArray;
                }
                var node = type.node;
                var typeArguments = !node ? ts.emptyArray :
                    node.kind === 176 ? ts.concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments(node, type.target.localTypeParameters)) :
                        node.kind === 181 ? [getTypeFromTypeNode(node.elementType)] :
                            ts.map(node.elements, getTypeFromTypeNode);
                if (popTypeResolution()) {
                    type.resolvedTypeArguments = type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments;
                }
                else {
                    type.resolvedTypeArguments = ((_b = type.target.localTypeParameters) === null || _b === void 0 ? void 0 : _b.map(function () { return errorType; })) || ts.emptyArray;
                    error(type.node || currentNode, type.target.symbol ? ts.Diagnostics.Type_arguments_for_0_circularly_reference_themselves : ts.Diagnostics.Tuple_type_arguments_circularly_reference_themselves, type.target.symbol && symbolToString(type.target.symbol));
                }
            }
            return type.resolvedTypeArguments;
        }
        function getTypeReferenceArity(type) {
            return ts.length(type.target.typeParameters);
        }
        function getTypeFromClassOrInterfaceReference(node, symbol) {
            var type = getDeclaredTypeOfSymbol(getMergedSymbol(symbol));
            var typeParameters = type.localTypeParameters;
            if (typeParameters) {
                var numTypeArguments = ts.length(node.typeArguments);
                var minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
                var isJs = ts.isInJSFile(node);
                var isJsImplicitAny = !noImplicitAny && isJs;
                if (!isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length)) {
                    var missingAugmentsTag = isJs && ts.isExpressionWithTypeArguments(node) && !ts.isJSDocAugmentsTag(node.parent);
                    var diag = minTypeArgumentCount === typeParameters.length ?
                        missingAugmentsTag ?
                            ts.Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag :
                            ts.Diagnostics.Generic_type_0_requires_1_type_argument_s :
                        missingAugmentsTag ?
                            ts.Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag :
                            ts.Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments;
                    var typeStr = typeToString(type, undefined, 2);
                    error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length);
                    if (!isJs) {
                        return errorType;
                    }
                }
                if (node.kind === 176 && isDeferredTypeReferenceNode(node, ts.length(node.typeArguments) !== typeParameters.length)) {
                    return createDeferredTypeReference(type, node, undefined);
                }
                var typeArguments = ts.concatenate(type.outerTypeParameters, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs));
                return createTypeReference(type, typeArguments);
            }
            return checkNoTypeArguments(node, symbol) ? type : errorType;
        }
        function getTypeAliasInstantiation(symbol, typeArguments, aliasSymbol, aliasTypeArguments) {
            var type = getDeclaredTypeOfSymbol(symbol);
            if (type === intrinsicMarkerType && intrinsicTypeKinds.has(symbol.escapedName) && typeArguments && typeArguments.length === 1) {
                return getStringMappingType(symbol, typeArguments[0]);
            }
            var links = getSymbolLinks(symbol);
            var typeParameters = links.typeParameters;
            var id = getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
            var instantiation = links.instantiations.get(id);
            if (!instantiation) {
                links.instantiations.set(id, instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), ts.isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments));
            }
            return instantiation;
        }
        function getTypeFromTypeAliasReference(node, symbol) {
            var type = getDeclaredTypeOfSymbol(symbol);
            var typeParameters = getSymbolLinks(symbol).typeParameters;
            if (typeParameters) {
                var numTypeArguments = ts.length(node.typeArguments);
                var minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
                if (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
                    error(node, minTypeArgumentCount === typeParameters.length ?
                        ts.Diagnostics.Generic_type_0_requires_1_type_argument_s :
                        ts.Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments, symbolToString(symbol), minTypeArgumentCount, typeParameters.length);
                    return errorType;
                }
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                var newAliasSymbol = aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)) ? aliasSymbol : undefined;
                return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, getTypeArgumentsForAliasSymbol(newAliasSymbol));
            }
            return checkNoTypeArguments(node, symbol) ? type : errorType;
        }
        function isLocalTypeAlias(symbol) {
            var _a;
            var declaration = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isTypeAlias);
            return !!(declaration && ts.getContainingFunction(declaration));
        }
        function getTypeReferenceName(node) {
            switch (node.kind) {
                case 176:
                    return node.typeName;
                case 226:
                    var expr = node.expression;
                    if (ts.isEntityNameExpression(expr)) {
                        return expr;
                    }
            }
            return undefined;
        }
        function resolveTypeReferenceName(typeReferenceName, meaning, ignoreErrors) {
            if (!typeReferenceName) {
                return unknownSymbol;
            }
            return resolveEntityName(typeReferenceName, meaning, ignoreErrors) || unknownSymbol;
        }
        function getTypeReferenceType(node, symbol) {
            if (symbol === unknownSymbol) {
                return errorType;
            }
            symbol = getExpandoSymbol(symbol) || symbol;
            if (symbol.flags & (32 | 64)) {
                return getTypeFromClassOrInterfaceReference(node, symbol);
            }
            if (symbol.flags & 524288) {
                return getTypeFromTypeAliasReference(node, symbol);
            }
            var res = tryGetDeclaredTypeOfSymbol(symbol);
            if (res) {
                return checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(res) : errorType;
            }
            if (symbol.flags & 111551 && isJSDocTypeReference(node)) {
                var jsdocType = getTypeFromJSDocValueReference(node, symbol);
                if (jsdocType) {
                    return jsdocType;
                }
                else {
                    resolveTypeReferenceName(getTypeReferenceName(node), 788968);
                    return getTypeOfSymbol(symbol);
                }
            }
            return errorType;
        }
        function getTypeFromJSDocValueReference(node, symbol) {
            var links = getNodeLinks(node);
            if (!links.resolvedJSDocType) {
                var valueType = getTypeOfSymbol(symbol);
                var typeType = valueType;
                if (symbol.valueDeclaration) {
                    var isImportTypeWithQualifier = node.kind === 198 && node.qualifier;
                    if (valueType.symbol && valueType.symbol !== symbol && isImportTypeWithQualifier) {
                        typeType = getTypeReferenceType(node, valueType.symbol);
                    }
                }
                links.resolvedJSDocType = typeType;
            }
            return links.resolvedJSDocType;
        }
        function getSubstitutionType(baseType, substitute) {
            if (substitute.flags & 3 || substitute === baseType) {
                return baseType;
            }
            var id = getTypeId(baseType) + ">" + getTypeId(substitute);
            var cached = substitutionTypes.get(id);
            if (cached) {
                return cached;
            }
            var result = createType(33554432);
            result.baseType = baseType;
            result.substitute = substitute;
            substitutionTypes.set(id, result);
            return result;
        }
        function isUnaryTupleTypeNode(node) {
            return node.kind === 182 && node.elements.length === 1;
        }
        function getImpliedConstraint(type, checkNode, extendsNode) {
            return isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode) ? getImpliedConstraint(type, checkNode.elements[0], extendsNode.elements[0]) :
                getActualTypeVariable(getTypeFromTypeNode(checkNode)) === type ? getTypeFromTypeNode(extendsNode) :
                    undefined;
        }
        function getConditionalFlowTypeOfType(type, node) {
            var constraints;
            var covariant = true;
            while (node && !ts.isStatement(node) && node.kind !== 315) {
                var parent = node.parent;
                if (parent.kind === 162) {
                    covariant = !covariant;
                }
                if ((covariant || type.flags & 8650752) && parent.kind === 187 && node === parent.trueType) {
                    var constraint = getImpliedConstraint(type, parent.checkType, parent.extendsType);
                    if (constraint) {
                        constraints = ts.append(constraints, constraint);
                    }
                }
                node = parent;
            }
            return constraints ? getSubstitutionType(type, getIntersectionType(ts.append(constraints, type))) : type;
        }
        function isJSDocTypeReference(node) {
            return !!(node.flags & 4194304) && (node.kind === 176 || node.kind === 198);
        }
        function checkNoTypeArguments(node, symbol) {
            if (node.typeArguments) {
                error(node, ts.Diagnostics.Type_0_is_not_generic, symbol ? symbolToString(symbol) : node.typeName ? ts.declarationNameToString(node.typeName) : anon);
                return false;
            }
            return true;
        }
        function getIntendedTypeFromJSDocTypeReference(node) {
            if (ts.isIdentifier(node.typeName)) {
                var typeArgs = node.typeArguments;
                switch (node.typeName.escapedText) {
                    case "String":
                        checkNoTypeArguments(node);
                        return stringType;
                    case "Number":
                        checkNoTypeArguments(node);
                        return numberType;
                    case "Boolean":
                        checkNoTypeArguments(node);
                        return booleanType;
                    case "Void":
                        checkNoTypeArguments(node);
                        return voidType;
                    case "Undefined":
                        checkNoTypeArguments(node);
                        return undefinedType;
                    case "Null":
                        checkNoTypeArguments(node);
                        return nullType;
                    case "Function":
                    case "function":
                        checkNoTypeArguments(node);
                        return globalFunctionType;
                    case "array":
                        return (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : undefined;
                    case "promise":
                        return (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(anyType) : undefined;
                    case "Object":
                        if (typeArgs && typeArgs.length === 2) {
                            if (ts.isJSDocIndexSignature(node)) {
                                var indexed = getTypeFromTypeNode(typeArgs[0]);
                                var target = getTypeFromTypeNode(typeArgs[1]);
                                var indexInfo = indexed === stringType || indexed === numberType ? [createIndexInfo(indexed, target, false)] : ts.emptyArray;
                                return createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, indexInfo);
                            }
                            return anyType;
                        }
                        checkNoTypeArguments(node);
                        return !noImplicitAny ? anyType : undefined;
                }
            }
        }
        function getTypeFromJSDocNullableTypeNode(node) {
            var type = getTypeFromTypeNode(node.type);
            return strictNullChecks ? getNullableType(type, 65536) : type;
        }
        function getTypeFromTypeReference(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                if (ts.isConstTypeReference(node) && ts.isAssertionExpression(node.parent)) {
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = checkExpressionCached(node.parent.expression);
                }
                var symbol = void 0;
                var type = void 0;
                var meaning = 788968;
                if (isJSDocTypeReference(node)) {
                    type = getIntendedTypeFromJSDocTypeReference(node);
                    if (!type) {
                        symbol = resolveTypeReferenceName(getTypeReferenceName(node), meaning, true);
                        if (symbol === unknownSymbol) {
                            symbol = resolveTypeReferenceName(getTypeReferenceName(node), meaning | 111551);
                        }
                        else {
                            resolveTypeReferenceName(getTypeReferenceName(node), meaning);
                        }
                        type = getTypeReferenceType(node, symbol);
                    }
                }
                if (!type) {
                    symbol = resolveTypeReferenceName(getTypeReferenceName(node), meaning);
                    type = getTypeReferenceType(node, symbol);
                }
                links.resolvedSymbol = symbol;
                links.resolvedType = type;
            }
            return links.resolvedType;
        }
        function typeArgumentsFromTypeReferenceNode(node) {
            return ts.map(node.typeArguments, getTypeFromTypeNode);
        }
        function getTypeFromTypeQueryNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var type = ts.isThisIdentifier(node.exprName) ? checkThisExpression(node.exprName) : checkExpression(node.exprName);
                links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type));
            }
            return links.resolvedType;
        }
        function getTypeOfGlobalSymbol(symbol, arity) {
            function getTypeDeclaration(symbol) {
                var declarations = symbol.declarations;
                if (declarations) {
                    for (var _i = 0, declarations_3 = declarations; _i < declarations_3.length; _i++) {
                        var declaration = declarations_3[_i];
                        switch (declaration.kind) {
                            case 255:
                            case 256:
                            case 258:
                                return declaration;
                        }
                    }
                }
            }
            if (!symbol) {
                return arity ? emptyGenericType : emptyObjectType;
            }
            var type = getDeclaredTypeOfSymbol(symbol);
            if (!(type.flags & 524288)) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_be_a_class_or_interface_type, ts.symbolName(symbol));
                return arity ? emptyGenericType : emptyObjectType;
            }
            if (ts.length(type.typeParameters) !== arity) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_have_1_type_parameter_s, ts.symbolName(symbol), arity);
                return arity ? emptyGenericType : emptyObjectType;
            }
            return type;
        }
        function getGlobalValueSymbol(name, reportErrors) {
            return getGlobalSymbol(name, 111551, reportErrors ? ts.Diagnostics.Cannot_find_global_value_0 : undefined);
        }
        function getGlobalTypeSymbol(name, reportErrors) {
            return getGlobalSymbol(name, 788968, reportErrors ? ts.Diagnostics.Cannot_find_global_type_0 : undefined);
        }
        function getGlobalSymbol(name, meaning, diagnostic) {
            return resolveName(undefined, name, meaning, diagnostic, name, false);
        }
        function getGlobalType(name, arity, reportErrors) {
            var symbol = getGlobalTypeSymbol(name, reportErrors);
            return symbol || reportErrors ? getTypeOfGlobalSymbol(symbol, arity) : undefined;
        }
        function getGlobalTypedPropertyDescriptorType() {
            return deferredGlobalTypedPropertyDescriptorType || (deferredGlobalTypedPropertyDescriptorType = getGlobalType("TypedPropertyDescriptor", 1, true)) || emptyGenericType;
        }
        function getGlobalTemplateStringsArrayType() {
            return deferredGlobalTemplateStringsArrayType || (deferredGlobalTemplateStringsArrayType = getGlobalType("TemplateStringsArray", 0, true)) || emptyObjectType;
        }
        function getGlobalImportMetaType() {
            return deferredGlobalImportMetaType || (deferredGlobalImportMetaType = getGlobalType("ImportMeta", 0, true)) || emptyObjectType;
        }
        function getGlobalImportMetaExpressionType() {
            if (!deferredGlobalImportMetaExpressionType) {
                var symbol = createSymbol(0, "ImportMetaExpression");
                var importMetaType = getGlobalImportMetaType();
                var metaPropertySymbol = createSymbol(4, "meta", 8);
                metaPropertySymbol.parent = symbol;
                metaPropertySymbol.type = importMetaType;
                var members = ts.createSymbolTable([metaPropertySymbol]);
                symbol.members = members;
                deferredGlobalImportMetaExpressionType = createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            }
            return deferredGlobalImportMetaExpressionType;
        }
        function getGlobalESSymbolConstructorSymbol(reportErrors) {
            return deferredGlobalESSymbolConstructorSymbol || (deferredGlobalESSymbolConstructorSymbol = getGlobalValueSymbol("Symbol", reportErrors));
        }
        function getGlobalESSymbolConstructorTypeSymbol(reportErrors) {
            return deferredGlobalESSymbolConstructorTypeSymbol || (deferredGlobalESSymbolConstructorTypeSymbol = getGlobalTypeSymbol("SymbolConstructor", reportErrors));
        }
        function getGlobalESSymbolType(reportErrors) {
            return deferredGlobalESSymbolType || (deferredGlobalESSymbolType = getGlobalType("Symbol", 0, reportErrors)) || emptyObjectType;
        }
        function getGlobalPromiseType(reportErrors) {
            return deferredGlobalPromiseType || (deferredGlobalPromiseType = getGlobalType("Promise", 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalPromiseLikeType(reportErrors) {
            return deferredGlobalPromiseLikeType || (deferredGlobalPromiseLikeType = getGlobalType("PromiseLike", 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalPromiseConstructorSymbol(reportErrors) {
            return deferredGlobalPromiseConstructorSymbol || (deferredGlobalPromiseConstructorSymbol = getGlobalValueSymbol("Promise", reportErrors));
        }
        function getGlobalPromiseConstructorLikeType(reportErrors) {
            return deferredGlobalPromiseConstructorLikeType || (deferredGlobalPromiseConstructorLikeType = getGlobalType("PromiseConstructorLike", 0, reportErrors)) || emptyObjectType;
        }
        function getGlobalAsyncIterableType(reportErrors) {
            return deferredGlobalAsyncIterableType || (deferredGlobalAsyncIterableType = getGlobalType("AsyncIterable", 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalAsyncIteratorType(reportErrors) {
            return deferredGlobalAsyncIteratorType || (deferredGlobalAsyncIteratorType = getGlobalType("AsyncIterator", 3, reportErrors)) || emptyGenericType;
        }
        function getGlobalAsyncIterableIteratorType(reportErrors) {
            return deferredGlobalAsyncIterableIteratorType || (deferredGlobalAsyncIterableIteratorType = getGlobalType("AsyncIterableIterator", 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalAsyncGeneratorType(reportErrors) {
            return deferredGlobalAsyncGeneratorType || (deferredGlobalAsyncGeneratorType = getGlobalType("AsyncGenerator", 3, reportErrors)) || emptyGenericType;
        }
        function getGlobalIterableType(reportErrors) {
            return deferredGlobalIterableType || (deferredGlobalIterableType = getGlobalType("Iterable", 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalIteratorType(reportErrors) {
            return deferredGlobalIteratorType || (deferredGlobalIteratorType = getGlobalType("Iterator", 3, reportErrors)) || emptyGenericType;
        }
        function getGlobalIterableIteratorType(reportErrors) {
            return deferredGlobalIterableIteratorType || (deferredGlobalIterableIteratorType = getGlobalType("IterableIterator", 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalGeneratorType(reportErrors) {
            return deferredGlobalGeneratorType || (deferredGlobalGeneratorType = getGlobalType("Generator", 3, reportErrors)) || emptyGenericType;
        }
        function getGlobalIteratorYieldResultType(reportErrors) {
            return deferredGlobalIteratorYieldResultType || (deferredGlobalIteratorYieldResultType = getGlobalType("IteratorYieldResult", 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalIteratorReturnResultType(reportErrors) {
            return deferredGlobalIteratorReturnResultType || (deferredGlobalIteratorReturnResultType = getGlobalType("IteratorReturnResult", 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalTypeOrUndefined(name, arity) {
            if (arity === void 0) { arity = 0; }
            var symbol = getGlobalSymbol(name, 788968, undefined);
            return symbol && getTypeOfGlobalSymbol(symbol, arity);
        }
        function getGlobalExtractSymbol() {
            return deferredGlobalExtractSymbol || (deferredGlobalExtractSymbol = getGlobalSymbol("Extract", 524288, ts.Diagnostics.Cannot_find_global_type_0));
        }
        function getGlobalOmitSymbol() {
            return deferredGlobalOmitSymbol || (deferredGlobalOmitSymbol = getGlobalSymbol("Omit", 524288, ts.Diagnostics.Cannot_find_global_type_0));
        }
        function getGlobalBigIntType(reportErrors) {
            return deferredGlobalBigIntType || (deferredGlobalBigIntType = getGlobalType("BigInt", 0, reportErrors)) || emptyObjectType;
        }
        function createTypeFromGenericGlobalType(genericGlobalType, typeArguments) {
            return genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType;
        }
        function createTypedPropertyDescriptorType(propertyType) {
            return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType(), [propertyType]);
        }
        function createIterableType(iteratedType) {
            return createTypeFromGenericGlobalType(getGlobalIterableType(true), [iteratedType]);
        }
        function createArrayType(elementType, readonly) {
            return createTypeFromGenericGlobalType(readonly ? globalReadonlyArrayType : globalArrayType, [elementType]);
        }
        function getTupleElementFlags(node) {
            switch (node.kind) {
                case 183:
                    return 2;
                case 184:
                    return getRestTypeElementFlags(node);
                case 195:
                    return node.questionToken ? 2 :
                        node.dotDotDotToken ? getRestTypeElementFlags(node) :
                            1;
                default:
                    return 1;
            }
        }
        function getRestTypeElementFlags(node) {
            return getArrayElementTypeNode(node.type) ? 4 : 8;
        }
        function getArrayOrTupleTargetType(node) {
            var readonly = isReadonlyTypeOperator(node.parent);
            var elementType = getArrayElementTypeNode(node);
            if (elementType) {
                return readonly ? globalReadonlyArrayType : globalArrayType;
            }
            var elementFlags = ts.map(node.elements, getTupleElementFlags);
            var missingName = ts.some(node.elements, function (e) { return e.kind !== 195; });
            return getTupleTargetType(elementFlags, readonly, missingName ? undefined : node.elements);
        }
        function isDeferredTypeReferenceNode(node, hasDefaultTypeArguments) {
            return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && (node.kind === 181 ? mayResolveTypeAlias(node.elementType) :
                node.kind === 182 ? ts.some(node.elements, mayResolveTypeAlias) :
                    hasDefaultTypeArguments || ts.some(node.typeArguments, mayResolveTypeAlias));
        }
        function isResolvedByTypeAlias(node) {
            var parent = node.parent;
            switch (parent.kind) {
                case 189:
                case 195:
                case 176:
                case 185:
                case 186:
                case 192:
                case 187:
                case 191:
                case 181:
                case 182:
                    return isResolvedByTypeAlias(parent);
                case 257:
                    return true;
            }
            return false;
        }
        function mayResolveTypeAlias(node) {
            switch (node.kind) {
                case 176:
                    return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node.typeName, 788968).flags & 524288);
                case 179:
                    return true;
                case 191:
                    return node.operator !== 152 && mayResolveTypeAlias(node.type);
                case 189:
                case 183:
                case 195:
                case 311:
                case 309:
                case 310:
                case 304:
                    return mayResolveTypeAlias(node.type);
                case 184:
                    return node.type.kind !== 181 || mayResolveTypeAlias(node.type.elementType);
                case 185:
                case 186:
                    return ts.some(node.types, mayResolveTypeAlias);
                case 192:
                    return mayResolveTypeAlias(node.objectType) || mayResolveTypeAlias(node.indexType);
                case 187:
                    return mayResolveTypeAlias(node.checkType) || mayResolveTypeAlias(node.extendsType) ||
                        mayResolveTypeAlias(node.trueType) || mayResolveTypeAlias(node.falseType);
            }
            return false;
        }
        function getTypeFromArrayOrTupleTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var target = getArrayOrTupleTargetType(node);
                if (target === emptyGenericType) {
                    links.resolvedType = emptyObjectType;
                }
                else if (!(node.kind === 182 && ts.some(node.elements, function (e) { return !!(getTupleElementFlags(e) & 8); })) && isDeferredTypeReferenceNode(node)) {
                    links.resolvedType = node.kind === 182 && node.elements.length === 0 ? target :
                        createDeferredTypeReference(target, node, undefined);
                }
                else {
                    var elementTypes = node.kind === 181 ? [getTypeFromTypeNode(node.elementType)] : ts.map(node.elements, getTypeFromTypeNode);
                    links.resolvedType = createNormalizedTypeReference(target, elementTypes);
                }
            }
            return links.resolvedType;
        }
        function isReadonlyTypeOperator(node) {
            return ts.isTypeOperatorNode(node) && node.operator === 143;
        }
        function createTupleType(elementTypes, elementFlags, readonly, namedMemberDeclarations) {
            if (readonly === void 0) { readonly = false; }
            var tupleTarget = getTupleTargetType(elementFlags || ts.map(elementTypes, function (_) { return 1; }), readonly, namedMemberDeclarations);
            return tupleTarget === emptyGenericType ? emptyObjectType :
                elementTypes.length ? createNormalizedTypeReference(tupleTarget, elementTypes) :
                    tupleTarget;
        }
        function getTupleTargetType(elementFlags, readonly, namedMemberDeclarations) {
            if (elementFlags.length === 1 && elementFlags[0] & 4) {
                return readonly ? globalReadonlyArrayType : globalArrayType;
            }
            var key = ts.map(elementFlags, function (f) { return f & 1 ? "#" : f & 2 ? "?" : f & 4 ? "." : "*"; }).join() +
                (readonly ? "R" : "") +
                (namedMemberDeclarations && namedMemberDeclarations.length ? "," + ts.map(namedMemberDeclarations, getNodeId).join(",") : "");
            var type = tupleTypes.get(key);
            if (!type) {
                tupleTypes.set(key, type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations));
            }
            return type;
        }
        function createTupleTargetType(elementFlags, readonly, namedMemberDeclarations) {
            var arity = elementFlags.length;
            var minLength = ts.countWhere(elementFlags, function (f) { return !!(f & (1 | 8)); });
            var typeParameters;
            var properties = [];
            var combinedFlags = 0;
            if (arity) {
                typeParameters = new Array(arity);
                for (var i = 0; i < arity; i++) {
                    var typeParameter = typeParameters[i] = createTypeParameter();
                    var flags = elementFlags[i];
                    combinedFlags |= flags;
                    if (!(combinedFlags & 12)) {
                        var property = createSymbol(4 | (flags & 2 ? 16777216 : 0), "" + i, readonly ? 8 : 0);
                        property.tupleLabelDeclaration = namedMemberDeclarations === null || namedMemberDeclarations === void 0 ? void 0 : namedMemberDeclarations[i];
                        property.type = typeParameter;
                        properties.push(property);
                    }
                }
            }
            var fixedLength = properties.length;
            var lengthSymbol = createSymbol(4, "length");
            if (combinedFlags & 12) {
                lengthSymbol.type = numberType;
            }
            else {
                var literalTypes = [];
                for (var i = minLength; i <= arity; i++)
                    literalTypes.push(getNumberLiteralType(i));
                lengthSymbol.type = getUnionType(literalTypes);
            }
            properties.push(lengthSymbol);
            var type = createObjectType(8 | 4);
            type.typeParameters = typeParameters;
            type.outerTypeParameters = undefined;
            type.localTypeParameters = typeParameters;
            type.instantiations = new ts.Map();
            type.instantiations.set(getTypeListId(type.typeParameters), type);
            type.target = type;
            type.resolvedTypeArguments = type.typeParameters;
            type.thisType = createTypeParameter();
            type.thisType.isThisType = true;
            type.thisType.constraint = type;
            type.declaredProperties = properties;
            type.declaredCallSignatures = ts.emptyArray;
            type.declaredConstructSignatures = ts.emptyArray;
            type.declaredIndexInfos = ts.emptyArray;
            type.elementFlags = elementFlags;
            type.minLength = minLength;
            type.fixedLength = fixedLength;
            type.hasRestElement = !!(combinedFlags & 12);
            type.combinedFlags = combinedFlags;
            type.readonly = readonly;
            type.labeledElementDeclarations = namedMemberDeclarations;
            return type;
        }
        function createNormalizedTypeReference(target, typeArguments) {
            return target.objectFlags & 8 ? createNormalizedTupleType(target, typeArguments) : createTypeReference(target, typeArguments);
        }
        function createNormalizedTupleType(target, elementTypes) {
            var _a, _b, _c;
            if (!(target.combinedFlags & 14)) {
                return createTypeReference(target, elementTypes);
            }
            if (target.combinedFlags & 8) {
                var unionIndex_1 = ts.findIndex(elementTypes, function (t, i) { return !!(target.elementFlags[i] & 8 && t.flags & (131072 | 1048576)); });
                if (unionIndex_1 >= 0) {
                    return checkCrossProductUnion(ts.map(elementTypes, function (t, i) { return target.elementFlags[i] & 8 ? t : unknownType; })) ?
                        mapType(elementTypes[unionIndex_1], function (t) { return createNormalizedTupleType(target, ts.replaceElement(elementTypes, unionIndex_1, t)); }) :
                        errorType;
                }
            }
            var expandedTypes = [];
            var expandedFlags = [];
            var expandedDeclarations = [];
            var lastRequiredIndex = -1;
            var firstRestIndex = -1;
            var lastOptionalOrRestIndex = -1;
            var _loop_15 = function (i) {
                var type = elementTypes[i];
                var flags = target.elementFlags[i];
                if (flags & 8) {
                    if (type.flags & 58982400 || isGenericMappedType(type)) {
                        addElement(type, 8, (_a = target.labeledElementDeclarations) === null || _a === void 0 ? void 0 : _a[i]);
                    }
                    else if (isTupleType(type)) {
                        var elements = getTypeArguments(type);
                        if (elements.length + expandedTypes.length >= 10000) {
                            error(currentNode, ts.isPartOfTypeNode(currentNode)
                                ? ts.Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent
                                : ts.Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent);
                            return { value: errorType };
                        }
                        ts.forEach(elements, function (t, n) { var _a; return addElement(t, type.target.elementFlags[n], (_a = type.target.labeledElementDeclarations) === null || _a === void 0 ? void 0 : _a[n]); });
                    }
                    else {
                        addElement(isArrayLikeType(type) && getIndexTypeOfType(type, numberType) || errorType, 4, (_b = target.labeledElementDeclarations) === null || _b === void 0 ? void 0 : _b[i]);
                    }
                }
                else {
                    addElement(type, flags, (_c = target.labeledElementDeclarations) === null || _c === void 0 ? void 0 : _c[i]);
                }
            };
            for (var i = 0; i < elementTypes.length; i++) {
                var state_4 = _loop_15(i);
                if (typeof state_4 === "object")
                    return state_4.value;
            }
            for (var i = 0; i < lastRequiredIndex; i++) {
                if (expandedFlags[i] & 2)
                    expandedFlags[i] = 1;
            }
            if (firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex) {
                expandedTypes[firstRestIndex] = getUnionType(ts.sameMap(expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex + 1), function (t, i) { return expandedFlags[firstRestIndex + i] & 8 ? getIndexedAccessType(t, numberType) : t; }));
                expandedTypes.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
                expandedFlags.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
                expandedDeclarations === null || expandedDeclarations === void 0 ? void 0 : expandedDeclarations.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
            }
            var tupleTarget = getTupleTargetType(expandedFlags, target.readonly, expandedDeclarations);
            return tupleTarget === emptyGenericType ? emptyObjectType :
                expandedFlags.length ? createTypeReference(tupleTarget, expandedTypes) :
                    tupleTarget;
            function addElement(type, flags, declaration) {
                if (flags & 1) {
                    lastRequiredIndex = expandedFlags.length;
                }
                if (flags & 4 && firstRestIndex < 0) {
                    firstRestIndex = expandedFlags.length;
                }
                if (flags & (2 | 4)) {
                    lastOptionalOrRestIndex = expandedFlags.length;
                }
                expandedTypes.push(type);
                expandedFlags.push(flags);
                if (expandedDeclarations && declaration) {
                    expandedDeclarations.push(declaration);
                }
                else {
                    expandedDeclarations = undefined;
                }
            }
        }
        function sliceTupleType(type, index, endSkipCount) {
            if (endSkipCount === void 0) { endSkipCount = 0; }
            var target = type.target;
            var endIndex = getTypeReferenceArity(type) - endSkipCount;
            return index > target.fixedLength ? getRestArrayTypeOfTupleType(type) || createTupleType(ts.emptyArray) :
                createTupleType(getTypeArguments(type).slice(index, endIndex), target.elementFlags.slice(index, endIndex), false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex));
        }
        function getKnownKeysOfTupleType(type) {
            return getUnionType(ts.append(ts.arrayOf(type.target.fixedLength, function (i) { return getStringLiteralType("" + i); }), getIndexType(type.target.readonly ? globalReadonlyArrayType : globalArrayType)));
        }
        function getStartElementCount(type, flags) {
            var index = ts.findIndex(type.elementFlags, function (f) { return !(f & flags); });
            return index >= 0 ? index : type.elementFlags.length;
        }
        function getEndElementCount(type, flags) {
            return type.elementFlags.length - ts.findLastIndex(type.elementFlags, function (f) { return !(f & flags); }) - 1;
        }
        function getTypeFromOptionalTypeNode(node) {
            return addOptionality(getTypeFromTypeNode(node.type), true);
        }
        function getTypeId(type) {
            return type.id;
        }
        function containsType(types, type) {
            return ts.binarySearch(types, type, getTypeId, ts.compareValues) >= 0;
        }
        function insertType(types, type) {
            var index = ts.binarySearch(types, type, getTypeId, ts.compareValues);
            if (index < 0) {
                types.splice(~index, 0, type);
                return true;
            }
            return false;
        }
        function addTypeToUnion(typeSet, includes, type) {
            var flags = type.flags;
            if (flags & 1048576) {
                return addTypesToUnion(typeSet, includes | (isNamedUnionType(type) ? 1048576 : 0), type.types);
            }
            if (!(flags & 131072)) {
                includes |= flags & 205258751;
                if (flags & 469499904)
                    includes |= 262144;
                if (type === wildcardType)
                    includes |= 8388608;
                if (!strictNullChecks && flags & 98304) {
                    if (!(ts.getObjectFlags(type) & 131072))
                        includes |= 4194304;
                }
                else {
                    var len = typeSet.length;
                    var index = len && type.id > typeSet[len - 1].id ? ~len : ts.binarySearch(typeSet, type, getTypeId, ts.compareValues);
                    if (index < 0) {
                        typeSet.splice(~index, 0, type);
                    }
                }
            }
            return includes;
        }
        function addTypesToUnion(typeSet, includes, types) {
            for (var _i = 0, types_9 = types; _i < types_9.length; _i++) {
                var type = types_9[_i];
                includes = addTypeToUnion(typeSet, includes, type);
            }
            return includes;
        }
        function removeSubtypes(types, hasObjectTypes) {
            var id = getTypeListId(types);
            var match = subtypeReductionCache.get(id);
            if (match) {
                return match;
            }
            var hasEmptyObject = hasObjectTypes && ts.some(types, function (t) { return !!(t.flags & 524288) && !isGenericMappedType(t) && isEmptyResolvedType(resolveStructuredTypeMembers(t)); });
            var len = types.length;
            var i = len;
            var count = 0;
            while (i > 0) {
                i--;
                var source = types[i];
                if (hasEmptyObject || source.flags & 469499904) {
                    var keyProperty = source.flags & (524288 | 2097152 | 58982400) ?
                        ts.find(getPropertiesOfType(source), function (p) { return isUnitType(getTypeOfSymbol(p)); }) :
                        undefined;
                    var keyPropertyType = keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty));
                    for (var _i = 0, types_10 = types; _i < types_10.length; _i++) {
                        var target = types_10[_i];
                        if (source !== target) {
                            if (count === 100000) {
                                var estimatedCount = (count / (len - i)) * len;
                                if (estimatedCount > 1000000) {
                                    ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes", "removeSubtypes_DepthLimit", { typeIds: types.map(function (t) { return t.id; }) });
                                    error(currentNode, ts.Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
                                    return undefined;
                                }
                            }
                            count++;
                            if (keyProperty && target.flags & (524288 | 2097152 | 58982400)) {
                                var t = getTypeOfPropertyOfType(target, keyProperty.escapedName);
                                if (t && isUnitType(t) && getRegularTypeOfLiteralType(t) !== keyPropertyType) {
                                    continue;
                                }
                            }
                            if (isTypeRelatedTo(source, target, strictSubtypeRelation) && (!(ts.getObjectFlags(getTargetType(source)) & 1) ||
                                !(ts.getObjectFlags(getTargetType(target)) & 1) ||
                                isTypeDerivedFrom(source, target))) {
                                ts.orderedRemoveItemAt(types, i);
                                break;
                            }
                        }
                    }
                }
            }
            subtypeReductionCache.set(id, types);
            return types;
        }
        function removeRedundantLiteralTypes(types, includes, reduceVoidUndefined) {
            var i = types.length;
            while (i > 0) {
                i--;
                var t = types[i];
                var flags = t.flags;
                var remove = flags & (128 | 134217728 | 268435456) && includes & 4 ||
                    flags & 256 && includes & 8 ||
                    flags & 2048 && includes & 64 ||
                    flags & 8192 && includes & 4096 ||
                    reduceVoidUndefined && flags & 32768 && includes & 16384 ||
                    isFreshLiteralType(t) && containsType(types, t.regularType);
                if (remove) {
                    ts.orderedRemoveItemAt(types, i);
                }
            }
        }
        function removeStringLiteralsMatchedByTemplateLiterals(types) {
            var templates = ts.filter(types, isPatternLiteralType);
            if (templates.length) {
                var i = types.length;
                var _loop_16 = function () {
                    i--;
                    var t = types[i];
                    if (t.flags & 128 && ts.some(templates, function (template) { return isTypeSubtypeOf(t, template); })) {
                        ts.orderedRemoveItemAt(types, i);
                    }
                };
                while (i > 0) {
                    _loop_16();
                }
            }
        }
        function isNamedUnionType(type) {
            return !!(type.flags & 1048576 && (type.aliasSymbol || type.origin));
        }
        function addNamedUnions(namedUnions, types) {
            for (var _i = 0, types_11 = types; _i < types_11.length; _i++) {
                var t = types_11[_i];
                if (t.flags & 1048576) {
                    var origin = t.origin;
                    if (t.aliasSymbol || origin && !(origin.flags & 1048576)) {
                        ts.pushIfUnique(namedUnions, t);
                    }
                    else if (origin && origin.flags & 1048576) {
                        addNamedUnions(namedUnions, origin.types);
                    }
                }
            }
        }
        function createOriginUnionOrIntersectionType(flags, types) {
            var result = createOriginType(flags);
            result.types = types;
            return result;
        }
        function getUnionType(types, unionReduction, aliasSymbol, aliasTypeArguments, origin) {
            if (unionReduction === void 0) { unionReduction = 1; }
            if (types.length === 0) {
                return neverType;
            }
            if (types.length === 1) {
                return types[0];
            }
            var typeSet = [];
            var includes = addTypesToUnion(typeSet, 0, types);
            if (unionReduction !== 0) {
                if (includes & 3) {
                    return includes & 1 ? includes & 8388608 ? wildcardType : anyType : unknownType;
                }
                if (exactOptionalPropertyTypes && includes & 32768) {
                    var missingIndex = ts.binarySearch(typeSet, missingType, getTypeId, ts.compareValues);
                    if (missingIndex >= 0 && containsType(typeSet, undefinedType)) {
                        ts.orderedRemoveItemAt(typeSet, missingIndex);
                    }
                }
                if (includes & (2944 | 8192 | 134217728 | 268435456) || includes & 16384 && includes & 32768) {
                    removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & 2));
                }
                if (includes & 128 && includes & 134217728) {
                    removeStringLiteralsMatchedByTemplateLiterals(typeSet);
                }
                if (unionReduction === 2) {
                    typeSet = removeSubtypes(typeSet, !!(includes & 524288));
                    if (!typeSet) {
                        return errorType;
                    }
                }
                if (typeSet.length === 0) {
                    return includes & 65536 ? includes & 4194304 ? nullType : nullWideningType :
                        includes & 32768 ? includes & 4194304 ? undefinedType : undefinedWideningType :
                            neverType;
                }
            }
            if (!origin && includes & 1048576) {
                var namedUnions = [];
                addNamedUnions(namedUnions, types);
                var reducedTypes = [];
                var _loop_17 = function (t) {
                    if (!ts.some(namedUnions, function (union) { return containsType(union.types, t); })) {
                        reducedTypes.push(t);
                    }
                };
                for (var _i = 0, typeSet_1 = typeSet; _i < typeSet_1.length; _i++) {
                    var t = typeSet_1[_i];
                    _loop_17(t);
                }
                if (!aliasSymbol && namedUnions.length === 1 && reducedTypes.length === 0) {
                    return namedUnions[0];
                }
                var namedTypesCount = ts.reduceLeft(namedUnions, function (sum, union) { return sum + union.types.length; }, 0);
                if (namedTypesCount + reducedTypes.length === typeSet.length) {
                    for (var _a = 0, namedUnions_1 = namedUnions; _a < namedUnions_1.length; _a++) {
                        var t = namedUnions_1[_a];
                        insertType(reducedTypes, t);
                    }
                    origin = createOriginUnionOrIntersectionType(1048576, reducedTypes);
                }
            }
            var objectFlags = (includes & 468598819 ? 0 : 65536) |
                (includes & 2097152 ? 33554432 : 0);
            return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin);
        }
        function getUnionOrIntersectionTypePredicate(signatures, kind) {
            var first;
            var types = [];
            for (var _i = 0, signatures_6 = signatures; _i < signatures_6.length; _i++) {
                var sig = signatures_6[_i];
                var pred = getTypePredicateOfSignature(sig);
                if (!pred || pred.kind === 2 || pred.kind === 3) {
                    if (kind !== 2097152) {
                        continue;
                    }
                    else {
                        return;
                    }
                }
                if (first) {
                    if (!typePredicateKindsMatch(first, pred)) {
                        return undefined;
                    }
                }
                else {
                    first = pred;
                }
                types.push(pred.type);
            }
            if (!first) {
                return undefined;
            }
            var compositeType = getUnionOrIntersectionType(types, kind);
            return createTypePredicate(first.kind, first.parameterName, first.parameterIndex, compositeType);
        }
        function typePredicateKindsMatch(a, b) {
            return a.kind === b.kind && a.parameterIndex === b.parameterIndex;
        }
        function getUnionTypeFromSortedList(types, objectFlags, aliasSymbol, aliasTypeArguments, origin) {
            if (types.length === 0) {
                return neverType;
            }
            if (types.length === 1) {
                return types[0];
            }
            var typeKey = !origin ? getTypeListId(types) :
                origin.flags & 1048576 ? "|" + getTypeListId(origin.types) :
                    origin.flags & 2097152 ? "&" + getTypeListId(origin.types) :
                        "#" + origin.type.id + "|" + getTypeListId(types);
            var id = typeKey + getAliasId(aliasSymbol, aliasTypeArguments);
            var type = unionTypes.get(id);
            if (!type) {
                type = createType(1048576);
                type.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types, 98304);
                type.types = types;
                type.origin = origin;
                type.aliasSymbol = aliasSymbol;
                type.aliasTypeArguments = aliasTypeArguments;
                if (types.length === 2 && types[0].flags & 512 && types[1].flags & 512) {
                    type.flags |= 16;
                    type.intrinsicName = "boolean";
                }
                unionTypes.set(id, type);
            }
            return type;
        }
        function getTypeFromUnionTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                links.resolvedType = getUnionType(ts.map(node.types, getTypeFromTypeNode), 1, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
            }
            return links.resolvedType;
        }
        function addTypeToIntersection(typeSet, includes, type) {
            var flags = type.flags;
            if (flags & 2097152) {
                return addTypesToIntersection(typeSet, includes, type.types);
            }
            if (isEmptyAnonymousObjectType(type)) {
                if (!(includes & 16777216)) {
                    includes |= 16777216;
                    typeSet.set(type.id.toString(), type);
                }
            }
            else {
                if (flags & 3) {
                    if (type === wildcardType)
                        includes |= 8388608;
                }
                else if ((strictNullChecks || !(flags & 98304)) && !typeSet.has(type.id.toString())) {
                    if (type.flags & 109440 && includes & 109440) {
                        includes |= 67108864;
                    }
                    typeSet.set(type.id.toString(), type);
                }
                includes |= flags & 205258751;
            }
            return includes;
        }
        function addTypesToIntersection(typeSet, includes, types) {
            for (var _i = 0, types_12 = types; _i < types_12.length; _i++) {
                var type = types_12[_i];
                includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type));
            }
            return includes;
        }
        function removeRedundantPrimitiveTypes(types, includes) {
            var i = types.length;
            while (i > 0) {
                i--;
                var t = types[i];
                var remove = t.flags & 4 && includes & 128 ||
                    t.flags & 8 && includes & 256 ||
                    t.flags & 64 && includes & 2048 ||
                    t.flags & 4096 && includes & 8192;
                if (remove) {
                    ts.orderedRemoveItemAt(types, i);
                }
            }
        }
        function eachUnionContains(unionTypes, type) {
            for (var _i = 0, unionTypes_1 = unionTypes; _i < unionTypes_1.length; _i++) {
                var u = unionTypes_1[_i];
                if (!containsType(u.types, type)) {
                    var primitive = type.flags & 128 ? stringType :
                        type.flags & 256 ? numberType :
                            type.flags & 2048 ? bigintType :
                                type.flags & 8192 ? esSymbolType :
                                    undefined;
                    if (!primitive || !containsType(u.types, primitive)) {
                        return false;
                    }
                }
            }
            return true;
        }
        function extractRedundantTemplateLiterals(types) {
            var i = types.length;
            var literals = ts.filter(types, function (t) { return !!(t.flags & 128); });
            while (i > 0) {
                i--;
                var t = types[i];
                if (!(t.flags & 134217728))
                    continue;
                for (var _i = 0, literals_1 = literals; _i < literals_1.length; _i++) {
                    var t2 = literals_1[_i];
                    if (isTypeSubtypeOf(t2, t)) {
                        ts.orderedRemoveItemAt(types, i);
                        break;
                    }
                    else if (isPatternLiteralType(t)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function extractIrreducible(types, flag) {
            if (ts.every(types, function (t) { return !!(t.flags & 1048576) && ts.some(t.types, function (tt) { return !!(tt.flags & flag); }); })) {
                for (var i = 0; i < types.length; i++) {
                    types[i] = filterType(types[i], function (t) { return !(t.flags & flag); });
                }
                return true;
            }
            return false;
        }
        function intersectUnionsOfPrimitiveTypes(types) {
            var unionTypes;
            var index = ts.findIndex(types, function (t) { return !!(ts.getObjectFlags(t) & 65536); });
            if (index < 0) {
                return false;
            }
            var i = index + 1;
            while (i < types.length) {
                var t = types[i];
                if (ts.getObjectFlags(t) & 65536) {
                    (unionTypes || (unionTypes = [types[index]])).push(t);
                    ts.orderedRemoveItemAt(types, i);
                }
                else {
                    i++;
                }
            }
            if (!unionTypes) {
                return false;
            }
            var checked = [];
            var result = [];
            for (var _i = 0, unionTypes_2 = unionTypes; _i < unionTypes_2.length; _i++) {
                var u = unionTypes_2[_i];
                for (var _a = 0, _b = u.types; _a < _b.length; _a++) {
                    var t = _b[_a];
                    if (insertType(checked, t)) {
                        if (eachUnionContains(unionTypes, t)) {
                            insertType(result, t);
                        }
                    }
                }
            }
            types[index] = getUnionTypeFromSortedList(result, 65536);
            return true;
        }
        function createIntersectionType(types, aliasSymbol, aliasTypeArguments) {
            var result = createType(2097152);
            result.objectFlags = getPropagatingFlagsOfTypes(types, 98304);
            result.types = types;
            result.aliasSymbol = aliasSymbol;
            result.aliasTypeArguments = aliasTypeArguments;
            return result;
        }
        function getIntersectionType(types, aliasSymbol, aliasTypeArguments) {
            var typeMembershipMap = new ts.Map();
            var includes = addTypesToIntersection(typeMembershipMap, 0, types);
            var typeSet = ts.arrayFrom(typeMembershipMap.values());
            if (includes & 131072) {
                return ts.contains(typeSet, silentNeverType) ? silentNeverType : neverType;
            }
            if (strictNullChecks && includes & 98304 && includes & (524288 | 67108864 | 16777216) ||
                includes & 67108864 && includes & (469892092 & ~67108864) ||
                includes & 402653316 && includes & (469892092 & ~402653316) ||
                includes & 296 && includes & (469892092 & ~296) ||
                includes & 2112 && includes & (469892092 & ~2112) ||
                includes & 12288 && includes & (469892092 & ~12288) ||
                includes & 49152 && includes & (469892092 & ~49152)) {
                return neverType;
            }
            if (includes & 134217728 && includes & 128 && extractRedundantTemplateLiterals(typeSet)) {
                return neverType;
            }
            if (includes & 1) {
                return includes & 8388608 ? wildcardType : anyType;
            }
            if (!strictNullChecks && includes & 98304) {
                return includes & 32768 ? undefinedType : nullType;
            }
            if (includes & 4 && includes & 128 ||
                includes & 8 && includes & 256 ||
                includes & 64 && includes & 2048 ||
                includes & 4096 && includes & 8192) {
                removeRedundantPrimitiveTypes(typeSet, includes);
            }
            if (includes & 16777216 && includes & 524288) {
                ts.orderedRemoveItemAt(typeSet, ts.findIndex(typeSet, isEmptyAnonymousObjectType));
            }
            if (typeSet.length === 0) {
                return unknownType;
            }
            if (typeSet.length === 1) {
                return typeSet[0];
            }
            var id = getTypeListId(typeSet) + getAliasId(aliasSymbol, aliasTypeArguments);
            var result = intersectionTypes.get(id);
            if (!result) {
                if (includes & 1048576) {
                    if (intersectUnionsOfPrimitiveTypes(typeSet)) {
                        result = getIntersectionType(typeSet, aliasSymbol, aliasTypeArguments);
                    }
                    else if (extractIrreducible(typeSet, 32768)) {
                        result = getUnionType([getIntersectionType(typeSet), undefinedType], 1, aliasSymbol, aliasTypeArguments);
                    }
                    else if (extractIrreducible(typeSet, 65536)) {
                        result = getUnionType([getIntersectionType(typeSet), nullType], 1, aliasSymbol, aliasTypeArguments);
                    }
                    else {
                        if (!checkCrossProductUnion(typeSet)) {
                            return errorType;
                        }
                        var constituents = getCrossProductIntersections(typeSet);
                        var origin = ts.some(constituents, function (t) { return !!(t.flags & 2097152); }) ? createOriginUnionOrIntersectionType(2097152, typeSet) : undefined;
                        result = getUnionType(constituents, 1, aliasSymbol, aliasTypeArguments, origin);
                    }
                }
                else {
                    result = createIntersectionType(typeSet, aliasSymbol, aliasTypeArguments);
                }
                intersectionTypes.set(id, result);
            }
            return result;
        }
        function getCrossProductUnionSize(types) {
            return ts.reduceLeft(types, function (n, t) { return t.flags & 1048576 ? n * t.types.length : t.flags & 131072 ? 0 : n; }, 1);
        }
        function checkCrossProductUnion(types) {
            var size = getCrossProductUnionSize(types);
            if (size >= 100000) {
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes", "checkCrossProductUnion_DepthLimit", { typeIds: types.map(function (t) { return t.id; }), size: size });
                error(currentNode, ts.Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
                return false;
            }
            return true;
        }
        function getCrossProductIntersections(types) {
            var count = getCrossProductUnionSize(types);
            var intersections = [];
            for (var i = 0; i < count; i++) {
                var constituents = types.slice();
                var n = i;
                for (var j = types.length - 1; j >= 0; j--) {
                    if (types[j].flags & 1048576) {
                        var sourceTypes = types[j].types;
                        var length_5 = sourceTypes.length;
                        constituents[j] = sourceTypes[n % length_5];
                        n = Math.floor(n / length_5);
                    }
                }
                var t = getIntersectionType(constituents);
                if (!(t.flags & 131072))
                    intersections.push(t);
            }
            return intersections;
        }
        function getTypeFromIntersectionTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                links.resolvedType = getIntersectionType(ts.map(node.types, getTypeFromTypeNode), aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
            }
            return links.resolvedType;
        }
        function createIndexType(type, stringsOnly) {
            var result = createType(4194304);
            result.type = type;
            result.stringsOnly = stringsOnly;
            return result;
        }
        function createOriginIndexType(type) {
            var result = createOriginType(4194304);
            result.type = type;
            return result;
        }
        function getIndexTypeForGenericType(type, stringsOnly) {
            return stringsOnly ?
                type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(type, true)) :
                type.resolvedIndexType || (type.resolvedIndexType = createIndexType(type, false));
        }
        function instantiateTypeAsMappedNameType(nameType, type, t) {
            return instantiateType(nameType, appendTypeMapping(type.mapper, getTypeParameterFromMappedType(type), t));
        }
        function getIndexTypeForMappedType(type, noIndexSignatures) {
            var constraint = filterType(getConstraintTypeFromMappedType(type), function (t) { return !(noIndexSignatures && t.flags & (1 | 4)); });
            var nameType = type.declaration.nameType && getTypeFromTypeNode(type.declaration.nameType);
            var properties = nameType && everyType(constraint, function (t) { return !!(t.flags & (4 | 8 | 131072)); }) && getPropertiesOfType(getApparentType(getModifiersTypeFromMappedType(type)));
            return nameType ?
                getUnionType([mapType(constraint, function (t) { return instantiateTypeAsMappedNameType(nameType, type, t); }), mapType(getUnionType(ts.map(properties || ts.emptyArray, function (p) { return getLiteralTypeFromProperty(p, 8576); })), function (t) { return instantiateTypeAsMappedNameType(nameType, type, t); })]) :
                constraint;
        }
        function hasDistributiveNameType(mappedType) {
            var typeVariable = getTypeParameterFromMappedType(mappedType);
            return isDistributive(getNameTypeFromMappedType(mappedType) || typeVariable);
            function isDistributive(type) {
                return type.flags & (3 | 131068 | 131072 | 262144 | 524288 | 67108864) ? true :
                    type.flags & 16777216 ? type.root.isDistributive && type.checkType === typeVariable :
                        type.flags & (3145728 | 134217728) ? ts.every(type.types, isDistributive) :
                            type.flags & 8388608 ? isDistributive(type.objectType) && isDistributive(type.indexType) :
                                type.flags & 33554432 ? isDistributive(type.substitute) :
                                    type.flags & 268435456 ? isDistributive(type.type) :
                                        false;
            }
        }
        function getLiteralTypeFromPropertyName(name) {
            if (ts.isPrivateIdentifier(name)) {
                return neverType;
            }
            return ts.isIdentifier(name) ? getStringLiteralType(ts.unescapeLeadingUnderscores(name.escapedText)) :
                getRegularTypeOfLiteralType(ts.isComputedPropertyName(name) ? checkComputedPropertyName(name) : checkExpression(name));
        }
        function getLiteralTypeFromProperty(prop, include, includeNonPublic) {
            if (includeNonPublic || !(ts.getDeclarationModifierFlagsFromSymbol(prop) & 24)) {
                var type = getSymbolLinks(getLateBoundSymbol(prop)).nameType;
                if (!type) {
                    var name = ts.getNameOfDeclaration(prop.valueDeclaration);
                    type = prop.escapedName === "default" ? getStringLiteralType("default") :
                        name && getLiteralTypeFromPropertyName(name) || (!ts.isKnownSymbol(prop) ? getStringLiteralType(ts.symbolName(prop)) : undefined);
                }
                if (type && type.flags & include) {
                    return type;
                }
            }
            return neverType;
        }
        function getLiteralTypeFromProperties(type, include, includeOrigin) {
            var origin = includeOrigin && (ts.getObjectFlags(type) & (3 | 4) || type.aliasSymbol) ? createOriginIndexType(type) : undefined;
            var propertyTypes = ts.map(getPropertiesOfType(type), function (prop) { return getLiteralTypeFromProperty(prop, include); });
            var indexKeyTypes = ts.map(getIndexInfosOfType(type), function (info) { return info !== enumNumberIndexInfo && info.keyType.flags & include ?
                info.keyType === stringType && include & 8 ? stringOrNumberType : info.keyType : neverType; });
            return getUnionType(ts.concatenate(propertyTypes, indexKeyTypes), 1, undefined, undefined, origin);
        }
        function getIndexType(type, stringsOnly, noIndexSignatures) {
            if (stringsOnly === void 0) { stringsOnly = keyofStringsOnly; }
            type = getReducedType(type);
            return type.flags & 1048576 ? getIntersectionType(ts.map(type.types, function (t) { return getIndexType(t, stringsOnly, noIndexSignatures); })) :
                type.flags & 2097152 ? getUnionType(ts.map(type.types, function (t) { return getIndexType(t, stringsOnly, noIndexSignatures); })) :
                    type.flags & 58982400 || isGenericTupleType(type) || isGenericMappedType(type) && !hasDistributiveNameType(type) ? getIndexTypeForGenericType(type, stringsOnly) :
                        ts.getObjectFlags(type) & 32 ? getIndexTypeForMappedType(type, noIndexSignatures) :
                            type === wildcardType ? wildcardType :
                                type.flags & 2 ? neverType :
                                    type.flags & (1 | 131072) ? keyofConstraintType :
                                        getLiteralTypeFromProperties(type, (noIndexSignatures ? 128 : 402653316) | (stringsOnly ? 0 : 296 | 12288), stringsOnly === keyofStringsOnly && !noIndexSignatures);
        }
        function getExtractStringType(type) {
            if (keyofStringsOnly) {
                return type;
            }
            var extractTypeAlias = getGlobalExtractSymbol();
            return extractTypeAlias ? getTypeAliasInstantiation(extractTypeAlias, [type, stringType]) : stringType;
        }
        function getIndexTypeOrString(type) {
            var indexType = getExtractStringType(getIndexType(type));
            return indexType.flags & 131072 ? stringType : indexType;
        }
        function getTypeFromTypeOperatorNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                switch (node.operator) {
                    case 139:
                        links.resolvedType = getIndexType(getTypeFromTypeNode(node.type));
                        break;
                    case 152:
                        links.resolvedType = node.type.kind === 149
                            ? getESSymbolLikeTypeForNode(ts.walkUpParenthesizedTypes(node.parent))
                            : errorType;
                        break;
                    case 143:
                        links.resolvedType = getTypeFromTypeNode(node.type);
                        break;
                    default:
                        throw ts.Debug.assertNever(node.operator);
                }
            }
            return links.resolvedType;
        }
        function getTypeFromTemplateTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getTemplateLiteralType(__spreadArray([node.head.text], ts.map(node.templateSpans, function (span) { return span.literal.text; }), true), ts.map(node.templateSpans, function (span) { return getTypeFromTypeNode(span.type); }));
            }
            return links.resolvedType;
        }
        function getTemplateLiteralType(texts, types) {
            var unionIndex = ts.findIndex(types, function (t) { return !!(t.flags & (131072 | 1048576)); });
            if (unionIndex >= 0) {
                return checkCrossProductUnion(types) ?
                    mapType(types[unionIndex], function (t) { return getTemplateLiteralType(texts, ts.replaceElement(types, unionIndex, t)); }) :
                    errorType;
            }
            if (ts.contains(types, wildcardType)) {
                return wildcardType;
            }
            var newTypes = [];
            var newTexts = [];
            var text = texts[0];
            if (!addSpans(texts, types)) {
                return stringType;
            }
            if (newTypes.length === 0) {
                return getStringLiteralType(text);
            }
            newTexts.push(text);
            if (ts.every(newTexts, function (t) { return t === ""; }) && ts.every(newTypes, function (t) { return !!(t.flags & 4); })) {
                return stringType;
            }
            var id = getTypeListId(newTypes) + "|" + ts.map(newTexts, function (t) { return t.length; }).join(",") + "|" + newTexts.join("");
            var type = templateLiteralTypes.get(id);
            if (!type) {
                templateLiteralTypes.set(id, type = createTemplateLiteralType(newTexts, newTypes));
            }
            return type;
            function addSpans(texts, types) {
                for (var i = 0; i < types.length; i++) {
                    var t = types[i];
                    if (t.flags & (2944 | 65536 | 32768)) {
                        text += getTemplateStringForType(t) || "";
                        text += texts[i + 1];
                    }
                    else if (t.flags & 134217728) {
                        text += t.texts[0];
                        if (!addSpans(t.texts, t.types))
                            return false;
                        text += texts[i + 1];
                    }
                    else if (isGenericIndexType(t) || isPatternLiteralPlaceholderType(t)) {
                        newTypes.push(t);
                        newTexts.push(text);
                        text = texts[i + 1];
                    }
                    else {
                        return false;
                    }
                }
                return true;
            }
        }
        function getTemplateStringForType(type) {
            return type.flags & 128 ? type.value :
                type.flags & 256 ? "" + type.value :
                    type.flags & 2048 ? ts.pseudoBigIntToString(type.value) :
                        type.flags & (512 | 98304) ? type.intrinsicName :
                            undefined;
        }
        function createTemplateLiteralType(texts, types) {
            var type = createType(134217728);
            type.texts = texts;
            type.types = types;
            return type;
        }
        function getStringMappingType(symbol, type) {
            return type.flags & (1048576 | 131072) ? mapType(type, function (t) { return getStringMappingType(symbol, t); }) :
                isGenericIndexType(type) ? getStringMappingTypeForGenericType(symbol, type) :
                    type.flags & 128 ? getStringLiteralType(applyStringMapping(symbol, type.value)) :
                        type;
        }
        function applyStringMapping(symbol, str) {
            switch (intrinsicTypeKinds.get(symbol.escapedName)) {
                case 0: return str.toUpperCase();
                case 1: return str.toLowerCase();
                case 2: return str.charAt(0).toUpperCase() + str.slice(1);
                case 3: return str.charAt(0).toLowerCase() + str.slice(1);
            }
            return str;
        }
        function getStringMappingTypeForGenericType(symbol, type) {
            var id = getSymbolId(symbol) + "," + getTypeId(type);
            var result = stringMappingTypes.get(id);
            if (!result) {
                stringMappingTypes.set(id, result = createStringMappingType(symbol, type));
            }
            return result;
        }
        function createStringMappingType(symbol, type) {
            var result = createType(268435456);
            result.symbol = symbol;
            result.type = type;
            return result;
        }
        function createIndexedAccessType(objectType, indexType, accessFlags, aliasSymbol, aliasTypeArguments) {
            var type = createType(8388608);
            type.objectType = objectType;
            type.indexType = indexType;
            type.accessFlags = accessFlags;
            type.aliasSymbol = aliasSymbol;
            type.aliasTypeArguments = aliasTypeArguments;
            return type;
        }
        function isJSLiteralType(type) {
            if (noImplicitAny) {
                return false;
            }
            if (ts.getObjectFlags(type) & 8192) {
                return true;
            }
            if (type.flags & 1048576) {
                return ts.every(type.types, isJSLiteralType);
            }
            if (type.flags & 2097152) {
                return ts.some(type.types, isJSLiteralType);
            }
            if (type.flags & 465829888) {
                var constraint = getResolvedBaseConstraint(type);
                return constraint !== type && isJSLiteralType(constraint);
            }
            return false;
        }
        function getPropertyNameFromIndex(indexType, accessNode) {
            return isTypeUsableAsPropertyName(indexType) ?
                getPropertyNameFromType(indexType) :
                accessNode && ts.isPropertyName(accessNode) ?
                    ts.getPropertyNameForPropertyNameNode(accessNode) :
                    undefined;
        }
        function isUncalledFunctionReference(node, symbol) {
            if (symbol.flags & (16 | 8192)) {
                var parent = ts.findAncestor(node.parent, function (n) { return !ts.isAccessExpression(n); }) || node.parent;
                if (ts.isCallLikeExpression(parent)) {
                    return ts.isCallOrNewExpression(parent) && ts.isIdentifier(node) && hasMatchingArgument(parent, node);
                }
                return ts.every(symbol.declarations, function (d) { return !ts.isFunctionLike(d) || !!(ts.getCombinedNodeFlags(d) & 134217728); });
            }
            return true;
        }
        function getPropertyTypeForIndexType(originalObjectType, objectType, indexType, fullIndexType, accessNode, accessFlags) {
            var _a;
            var accessExpression = accessNode && accessNode.kind === 205 ? accessNode : undefined;
            var propName = accessNode && ts.isPrivateIdentifier(accessNode) ? undefined : getPropertyNameFromIndex(indexType, accessNode);
            if (propName !== undefined) {
                if (accessFlags & 256) {
                    return getTypeOfPropertyOfContextualType(objectType, propName) || anyType;
                }
                var prop = getPropertyOfType(objectType, propName);
                if (prop) {
                    if (accessFlags & 64 && accessNode && prop.declarations && getDeclarationNodeFlagsFromSymbol(prop) & 134217728 && isUncalledFunctionReference(accessNode, prop)) {
                        var deprecatedNode = (_a = accessExpression === null || accessExpression === void 0 ? void 0 : accessExpression.argumentExpression) !== null && _a !== void 0 ? _a : (ts.isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode);
                        addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName);
                    }
                    if (accessExpression) {
                        markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol));
                        if (isAssignmentToReadonlyEntity(accessExpression, prop, ts.getAssignmentTargetKind(accessExpression))) {
                            error(accessExpression.argumentExpression, ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop));
                            return undefined;
                        }
                        if (accessFlags & 8) {
                            getNodeLinks(accessNode).resolvedSymbol = prop;
                        }
                        if (isThisPropertyAccessInConstructor(accessExpression, prop)) {
                            return autoType;
                        }
                    }
                    var propType = getTypeOfSymbol(prop);
                    return accessExpression && ts.getAssignmentTargetKind(accessExpression) !== 1 ?
                        getFlowTypeOfReference(accessExpression, propType) :
                        propType;
                }
                if (everyType(objectType, isTupleType) && isNumericLiteralName(propName) && +propName >= 0) {
                    if (accessNode && everyType(objectType, function (t) { return !t.target.hasRestElement; }) && !(accessFlags & 16)) {
                        var indexNode = getIndexNodeForAccessExpression(accessNode);
                        if (isTupleType(objectType)) {
                            error(indexNode, ts.Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), ts.unescapeLeadingUnderscores(propName));
                        }
                        else {
                            error(indexNode, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.unescapeLeadingUnderscores(propName), typeToString(objectType));
                        }
                    }
                    errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType));
                    return mapType(objectType, function (t) {
                        var restType = getRestTypeOfTupleType(t) || undefinedType;
                        return accessFlags & 1 ? getUnionType([restType, undefinedType]) : restType;
                    });
                }
            }
            if (!(indexType.flags & 98304) && isTypeAssignableToKind(indexType, 402653316 | 296 | 12288)) {
                if (objectType.flags & (1 | 131072)) {
                    return objectType;
                }
                var indexInfo = getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType);
                if (indexInfo) {
                    if (accessFlags & 2 && indexInfo.keyType !== numberType) {
                        if (accessExpression) {
                            error(accessExpression, ts.Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType));
                        }
                        return undefined;
                    }
                    if (accessNode && indexInfo.keyType === stringType && !isTypeAssignableToKind(indexType, 4 | 8)) {
                        var indexNode = getIndexNodeForAccessExpression(accessNode);
                        error(indexNode, ts.Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
                        return accessFlags & 1 ? getUnionType([indexInfo.type, undefinedType]) : indexInfo.type;
                    }
                    errorIfWritingToReadonlyIndex(indexInfo);
                    return accessFlags & 1 ? getUnionType([indexInfo.type, undefinedType]) : indexInfo.type;
                }
                if (indexType.flags & 131072) {
                    return neverType;
                }
                if (isJSLiteralType(objectType)) {
                    return anyType;
                }
                if (accessExpression && !isConstEnumObjectType(objectType)) {
                    if (isObjectLiteralType(objectType)) {
                        if (noImplicitAny && indexType.flags & (128 | 256)) {
                            diagnostics.add(ts.createDiagnosticForNode(accessExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType)));
                            return undefinedType;
                        }
                        else if (indexType.flags & (8 | 4)) {
                            var types = ts.map(objectType.properties, function (property) {
                                return getTypeOfSymbol(property);
                            });
                            return getUnionType(ts.append(types, undefinedType));
                        }
                    }
                    if (objectType.symbol === globalThisSymbol && propName !== undefined && globalThisSymbol.exports.has(propName) && (globalThisSymbol.exports.get(propName).flags & 418)) {
                        error(accessExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.unescapeLeadingUnderscores(propName), typeToString(objectType));
                    }
                    else if (noImplicitAny && !compilerOptions.suppressImplicitAnyIndexErrors && !(accessFlags & 128)) {
                        if (propName !== undefined && typeHasStaticProperty(propName, objectType)) {
                            var typeName = typeToString(objectType);
                            error(accessExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName + "[" + ts.getTextOfNode(accessExpression.argumentExpression) + "]");
                        }
                        else if (getIndexTypeOfType(objectType, numberType)) {
                            error(accessExpression.argumentExpression, ts.Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number);
                        }
                        else {
                            var suggestion = void 0;
                            if (propName !== undefined && (suggestion = getSuggestionForNonexistentProperty(propName, objectType))) {
                                if (suggestion !== undefined) {
                                    error(accessExpression.argumentExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(objectType), suggestion);
                                }
                            }
                            else {
                                var suggestion_1 = getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType);
                                if (suggestion_1 !== undefined) {
                                    error(accessExpression, ts.Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion_1);
                                }
                                else {
                                    var errorInfo = void 0;
                                    if (indexType.flags & 1024) {
                                        errorInfo = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "[" + typeToString(indexType) + "]", typeToString(objectType));
                                    }
                                    else if (indexType.flags & 8192) {
                                        var symbolName_2 = getFullyQualifiedName(indexType.symbol, accessExpression);
                                        errorInfo = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "[" + symbolName_2 + "]", typeToString(objectType));
                                    }
                                    else if (indexType.flags & 128) {
                                        errorInfo = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType));
                                    }
                                    else if (indexType.flags & 256) {
                                        errorInfo = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType));
                                    }
                                    else if (indexType.flags & (8 | 4)) {
                                        errorInfo = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType));
                                    }
                                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1, typeToString(fullIndexType), typeToString(objectType));
                                    diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(accessExpression, errorInfo));
                                }
                            }
                        }
                    }
                    return undefined;
                }
            }
            if (isJSLiteralType(objectType)) {
                return anyType;
            }
            if (accessNode) {
                var indexNode = getIndexNodeForAccessExpression(accessNode);
                if (indexType.flags & (128 | 256)) {
                    error(indexNode, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "" + indexType.value, typeToString(objectType));
                }
                else if (indexType.flags & (4 | 8)) {
                    error(indexNode, ts.Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType));
                }
                else {
                    error(indexNode, ts.Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
                }
            }
            if (isTypeAny(indexType)) {
                return indexType;
            }
            return undefined;
            function errorIfWritingToReadonlyIndex(indexInfo) {
                if (indexInfo && indexInfo.isReadonly && accessExpression && (ts.isAssignmentTarget(accessExpression) || ts.isDeleteTarget(accessExpression))) {
                    error(accessExpression, ts.Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
                }
            }
        }
        function getIndexNodeForAccessExpression(accessNode) {
            return accessNode.kind === 205 ? accessNode.argumentExpression :
                accessNode.kind === 192 ? accessNode.indexType :
                    accessNode.kind === 160 ? accessNode.expression :
                        accessNode;
        }
        function isPatternLiteralPlaceholderType(type) {
            return !!(type.flags & (1 | 4 | 8 | 64));
        }
        function isPatternLiteralType(type) {
            return !!(type.flags & 134217728) && ts.every(type.types, isPatternLiteralPlaceholderType);
        }
        function isGenericType(type) {
            return !!getGenericObjectFlags(type);
        }
        function isGenericObjectType(type) {
            return !!(getGenericObjectFlags(type) & 8388608);
        }
        function isGenericIndexType(type) {
            return !!(getGenericObjectFlags(type) & 16777216);
        }
        function getGenericObjectFlags(type) {
            if (type.flags & 3145728) {
                if (!(type.objectFlags & 4194304)) {
                    type.objectFlags |= 4194304 |
                        ts.reduceLeft(type.types, function (flags, t) { return flags | getGenericObjectFlags(t); }, 0);
                }
                return type.objectFlags & 25165824;
            }
            if (type.flags & 33554432) {
                if (!(type.objectFlags & 4194304)) {
                    type.objectFlags |= 4194304 |
                        getGenericObjectFlags(type.substitute) | getGenericObjectFlags(type.baseType);
                }
                return type.objectFlags & 25165824;
            }
            return (type.flags & 58982400 || isGenericMappedType(type) || isGenericTupleType(type) ? 8388608 : 0) |
                (type.flags & (58982400 | 4194304 | 134217728 | 268435456) && !isPatternLiteralType(type) ? 16777216 : 0);
        }
        function isThisTypeParameter(type) {
            return !!(type.flags & 262144 && type.isThisType);
        }
        function getSimplifiedType(type, writing) {
            return type.flags & 8388608 ? getSimplifiedIndexedAccessType(type, writing) :
                type.flags & 16777216 ? getSimplifiedConditionalType(type, writing) :
                    type;
        }
        function distributeIndexOverObjectType(objectType, indexType, writing) {
            if (objectType.flags & 3145728) {
                var types = ts.map(objectType.types, function (t) { return getSimplifiedType(getIndexedAccessType(t, indexType), writing); });
                return objectType.flags & 2097152 || writing ? getIntersectionType(types) : getUnionType(types);
            }
        }
        function distributeObjectOverIndexType(objectType, indexType, writing) {
            if (indexType.flags & 1048576) {
                var types = ts.map(indexType.types, function (t) { return getSimplifiedType(getIndexedAccessType(objectType, t), writing); });
                return writing ? getIntersectionType(types) : getUnionType(types);
            }
        }
        function getSimplifiedIndexedAccessType(type, writing) {
            var cache = writing ? "simplifiedForWriting" : "simplifiedForReading";
            if (type[cache]) {
                return type[cache] === circularConstraintType ? type : type[cache];
            }
            type[cache] = circularConstraintType;
            var objectType = getSimplifiedType(type.objectType, writing);
            var indexType = getSimplifiedType(type.indexType, writing);
            var distributedOverIndex = distributeObjectOverIndexType(objectType, indexType, writing);
            if (distributedOverIndex) {
                return type[cache] = distributedOverIndex;
            }
            if (!(indexType.flags & 465829888)) {
                var distributedOverObject = distributeIndexOverObjectType(objectType, indexType, writing);
                if (distributedOverObject) {
                    return type[cache] = distributedOverObject;
                }
            }
            if (isGenericTupleType(objectType) && indexType.flags & 296) {
                var elementType = getElementTypeOfSliceOfTupleType(objectType, indexType.flags & 8 ? 0 : objectType.target.fixedLength, 0, writing);
                if (elementType) {
                    return type[cache] = elementType;
                }
            }
            if (isGenericMappedType(objectType)) {
                return type[cache] = mapType(substituteIndexedMappedType(objectType, type.indexType), function (t) { return getSimplifiedType(t, writing); });
            }
            return type[cache] = type;
        }
        function isConditionalTypeAlwaysTrueDisregardingInferTypes(type) {
            var extendsInferParamMapper = type.root.inferTypeParameters && createTypeMapper(type.root.inferTypeParameters, ts.map(type.root.inferTypeParameters, function () { return wildcardType; }));
            var checkType = type.checkType;
            var extendsType = type.extendsType;
            return isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(instantiateType(extendsType, extendsInferParamMapper)));
        }
        function getSimplifiedConditionalType(type, writing) {
            var checkType = type.checkType;
            var extendsType = type.extendsType;
            var trueType = getTrueTypeFromConditionalType(type);
            var falseType = getFalseTypeFromConditionalType(type);
            if (falseType.flags & 131072 && getActualTypeVariable(trueType) === getActualTypeVariable(checkType)) {
                if (checkType.flags & 1 || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) {
                    return getSimplifiedType(trueType, writing);
                }
                else if (isIntersectionEmpty(checkType, extendsType)) {
                    return neverType;
                }
            }
            else if (trueType.flags & 131072 && getActualTypeVariable(falseType) === getActualTypeVariable(checkType)) {
                if (!(checkType.flags & 1) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) {
                    return neverType;
                }
                else if (checkType.flags & 1 || isIntersectionEmpty(checkType, extendsType)) {
                    return getSimplifiedType(falseType, writing);
                }
            }
            return type;
        }
        function isIntersectionEmpty(type1, type2) {
            return !!(getUnionType([intersectTypes(type1, type2), neverType]).flags & 131072);
        }
        function substituteIndexedMappedType(objectType, index) {
            var mapper = createTypeMapper([getTypeParameterFromMappedType(objectType)], [index]);
            var templateMapper = combineTypeMappers(objectType.mapper, mapper);
            return instantiateType(getTemplateTypeFromMappedType(objectType), templateMapper);
        }
        function getIndexedAccessType(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) {
            if (accessFlags === void 0) { accessFlags = 0; }
            return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || (accessNode ? errorType : unknownType);
        }
        function indexTypeLessThan(indexType, limit) {
            return everyType(indexType, function (t) {
                if (t.flags & 384) {
                    var propName = getPropertyNameFromType(t);
                    if (isNumericLiteralName(propName)) {
                        var index = +propName;
                        return index >= 0 && index < limit;
                    }
                }
                return false;
            });
        }
        function getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) {
            if (accessFlags === void 0) { accessFlags = 0; }
            if (objectType === wildcardType || indexType === wildcardType) {
                return wildcardType;
            }
            if (isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & 98304) && isTypeAssignableToKind(indexType, 4 | 8)) {
                indexType = stringType;
            }
            if (compilerOptions.noUncheckedIndexedAccess && accessFlags & 32)
                accessFlags |= 1;
            if (isGenericIndexType(indexType) || (accessNode && accessNode.kind !== 192 ?
                isGenericTupleType(objectType) && !indexTypeLessThan(indexType, objectType.target.fixedLength) :
                isGenericObjectType(objectType) && !(isTupleType(objectType) && indexTypeLessThan(indexType, objectType.target.fixedLength)))) {
                if (objectType.flags & 3) {
                    return objectType;
                }
                var persistentAccessFlags = accessFlags & 1;
                var id = objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments);
                var type = indexedAccessTypes.get(id);
                if (!type) {
                    indexedAccessTypes.set(id, type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments));
                }
                return type;
            }
            var apparentObjectType = getReducedApparentType(objectType);
            if (indexType.flags & 1048576 && !(indexType.flags & 16)) {
                var propTypes = [];
                var wasMissingProp = false;
                for (var _i = 0, _a = indexType.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    var propType = getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags | (wasMissingProp ? 128 : 0));
                    if (propType) {
                        propTypes.push(propType);
                    }
                    else if (!accessNode) {
                        return undefined;
                    }
                    else {
                        wasMissingProp = true;
                    }
                }
                if (wasMissingProp) {
                    return undefined;
                }
                return accessFlags & 4
                    ? getIntersectionType(propTypes, aliasSymbol, aliasTypeArguments)
                    : getUnionType(propTypes, 1, aliasSymbol, aliasTypeArguments);
            }
            return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, accessFlags | 8 | 64);
        }
        function getTypeFromIndexedAccessTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var objectType = getTypeFromTypeNode(node.objectType);
                var indexType = getTypeFromTypeNode(node.indexType);
                var potentialAlias = getAliasSymbolForTypeNode(node);
                var resolved = getIndexedAccessType(objectType, indexType, 0, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias));
                links.resolvedType = resolved.flags & 8388608 &&
                    resolved.objectType === objectType &&
                    resolved.indexType === indexType ?
                    getConditionalFlowTypeOfType(resolved, node) : resolved;
            }
            return links.resolvedType;
        }
        function getTypeFromMappedTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var type = createObjectType(32, node.symbol);
                type.declaration = node;
                type.aliasSymbol = getAliasSymbolForTypeNode(node);
                type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type.aliasSymbol);
                links.resolvedType = type;
                getConstraintTypeFromMappedType(type);
            }
            return links.resolvedType;
        }
        function getActualTypeVariable(type) {
            if (type.flags & 33554432) {
                return type.baseType;
            }
            if (type.flags & 8388608 && (type.objectType.flags & 33554432 ||
                type.indexType.flags & 33554432)) {
                return getIndexedAccessType(getActualTypeVariable(type.objectType), getActualTypeVariable(type.indexType));
            }
            return type;
        }
        function isTypicalNondistributiveConditional(root) {
            return !root.isDistributive && isSingletonTupleType(root.node.checkType) && isSingletonTupleType(root.node.extendsType);
        }
        function isSingletonTupleType(node) {
            return ts.isTupleTypeNode(node) && ts.length(node.elements) === 1 && !ts.isOptionalTypeNode(node.elements[0]) && !ts.isRestTypeNode(node.elements[0]);
        }
        function unwrapNondistributiveConditionalTuple(root, type) {
            return isTypicalNondistributiveConditional(root) && isTupleType(type) ? getTypeArguments(type)[0] : type;
        }
        function getConditionalType(root, mapper, aliasSymbol, aliasTypeArguments) {
            var result;
            var extraTypes;
            while (true) {
                var isUnwrapped = isTypicalNondistributiveConditional(root);
                var checkType = instantiateType(unwrapNondistributiveConditionalTuple(root, getActualTypeVariable(root.checkType)), mapper);
                var checkTypeInstantiable = isGenericType(checkType);
                var extendsType = instantiateType(unwrapNondistributiveConditionalTuple(root, root.extendsType), mapper);
                if (checkType === wildcardType || extendsType === wildcardType) {
                    return wildcardType;
                }
                var combinedMapper = void 0;
                if (root.inferTypeParameters) {
                    var context = createInferenceContext(root.inferTypeParameters, undefined, 0);
                    if (!checkTypeInstantiable) {
                        inferTypes(context.inferences, checkType, extendsType, 512 | 1024);
                    }
                    combinedMapper = mapper ? combineTypeMappers(context.mapper, mapper) : context.mapper;
                }
                var inferredExtendsType = combinedMapper ? instantiateType(unwrapNondistributiveConditionalTuple(root, root.extendsType), combinedMapper) : extendsType;
                if (!checkTypeInstantiable && !isGenericType(inferredExtendsType)) {
                    if (!(inferredExtendsType.flags & 3) && ((checkType.flags & 1 && !isUnwrapped) || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType)))) {
                        if (checkType.flags & 1 && !isUnwrapped) {
                            (extraTypes || (extraTypes = [])).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper));
                        }
                        var falseType_1 = getTypeFromTypeNode(root.node.falseType);
                        if (falseType_1.flags & 16777216) {
                            var newRoot = falseType_1.root;
                            if (newRoot.node.parent === root.node && (!newRoot.isDistributive || newRoot.checkType === root.checkType)) {
                                root = newRoot;
                                continue;
                            }
                        }
                        result = instantiateType(falseType_1, mapper);
                        break;
                    }
                    if (inferredExtendsType.flags & 3 || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType))) {
                        result = instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper);
                        break;
                    }
                }
                result = createType(16777216);
                result.root = root;
                result.checkType = instantiateType(root.checkType, mapper);
                result.extendsType = instantiateType(root.extendsType, mapper);
                result.mapper = mapper;
                result.combinedMapper = combinedMapper;
                result.aliasSymbol = aliasSymbol || root.aliasSymbol;
                result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(root.aliasTypeArguments, mapper);
                break;
            }
            return extraTypes ? getUnionType(ts.append(extraTypes, result)) : result;
        }
        function getTrueTypeFromConditionalType(type) {
            return type.resolvedTrueType || (type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper));
        }
        function getFalseTypeFromConditionalType(type) {
            return type.resolvedFalseType || (type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper));
        }
        function getInferredTrueTypeFromConditionalType(type) {
            return type.resolvedInferredTrueType || (type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type));
        }
        function getInferTypeParameters(node) {
            var result;
            if (node.locals) {
                node.locals.forEach(function (symbol) {
                    if (symbol.flags & 262144) {
                        result = ts.append(result, getDeclaredTypeOfSymbol(symbol));
                    }
                });
            }
            return result;
        }
        function getTypeFromConditionalTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var checkType = getTypeFromTypeNode(node.checkType);
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                var aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                var allOuterTypeParameters = getOuterTypeParameters(node, true);
                var outerTypeParameters = aliasTypeArguments ? allOuterTypeParameters : ts.filter(allOuterTypeParameters, function (tp) { return isTypeParameterPossiblyReferenced(tp, node); });
                var root = {
                    node: node,
                    checkType: checkType,
                    extendsType: getTypeFromTypeNode(node.extendsType),
                    isDistributive: !!(checkType.flags & 262144),
                    inferTypeParameters: getInferTypeParameters(node),
                    outerTypeParameters: outerTypeParameters,
                    instantiations: undefined,
                    aliasSymbol: aliasSymbol,
                    aliasTypeArguments: aliasTypeArguments
                };
                links.resolvedType = getConditionalType(root, undefined);
                if (outerTypeParameters) {
                    root.instantiations = new ts.Map();
                    root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType);
                }
            }
            return links.resolvedType;
        }
        function getTypeFromInferTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node.typeParameter));
            }
            return links.resolvedType;
        }
        function getIdentifierChain(node) {
            if (ts.isIdentifier(node)) {
                return [node];
            }
            else {
                return ts.append(getIdentifierChain(node.left), node.right);
            }
        }
        function getTypeFromImportTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                if (node.isTypeOf && node.typeArguments) {
                    error(node, ts.Diagnostics.Type_arguments_cannot_be_used_here);
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = errorType;
                }
                if (!ts.isLiteralImportTypeNode(node)) {
                    error(node.argument, ts.Diagnostics.String_literal_expected);
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = errorType;
                }
                var targetMeaning = node.isTypeOf ? 111551 : node.flags & 4194304 ? 111551 | 788968 : 788968;
                var innerModuleSymbol = resolveExternalModuleName(node, node.argument.literal);
                if (!innerModuleSymbol) {
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = errorType;
                }
                var moduleSymbol = resolveExternalModuleSymbol(innerModuleSymbol, false);
                if (!ts.nodeIsMissing(node.qualifier)) {
                    var nameStack = getIdentifierChain(node.qualifier);
                    var currentNamespace = moduleSymbol;
                    var current = void 0;
                    while (current = nameStack.shift()) {
                        var meaning = nameStack.length ? 1920 : targetMeaning;
                        var mergedResolvedSymbol = getMergedSymbol(resolveSymbol(currentNamespace));
                        var next = node.isTypeOf
                            ? getPropertyOfType(getTypeOfSymbol(mergedResolvedSymbol), current.escapedText)
                            : getSymbol(getExportsOfSymbol(mergedResolvedSymbol), current.escapedText, meaning);
                        if (!next) {
                            error(current, ts.Diagnostics.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(currentNamespace), ts.declarationNameToString(current));
                            return links.resolvedType = errorType;
                        }
                        getNodeLinks(current).resolvedSymbol = next;
                        getNodeLinks(current.parent).resolvedSymbol = next;
                        currentNamespace = next;
                    }
                    links.resolvedType = resolveImportSymbolType(node, links, currentNamespace, targetMeaning);
                }
                else {
                    if (moduleSymbol.flags & targetMeaning) {
                        links.resolvedType = resolveImportSymbolType(node, links, moduleSymbol, targetMeaning);
                    }
                    else {
                        var errorMessage = targetMeaning === 111551
                            ? ts.Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here
                            : ts.Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0;
                        error(node, errorMessage, node.argument.literal.text);
                        links.resolvedSymbol = unknownSymbol;
                        links.resolvedType = errorType;
                    }
                }
            }
            return links.resolvedType;
        }
        function resolveImportSymbolType(node, links, symbol, meaning) {
            var resolvedSymbol = resolveSymbol(symbol);
            links.resolvedSymbol = resolvedSymbol;
            if (meaning === 111551) {
                return getTypeOfSymbol(symbol);
            }
            else {
                return getTypeReferenceType(node, resolvedSymbol);
            }
        }
        function getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                if (getMembersOfSymbol(node.symbol).size === 0 && !aliasSymbol) {
                    links.resolvedType = emptyTypeLiteralType;
                }
                else {
                    var type = createObjectType(16, node.symbol);
                    type.aliasSymbol = aliasSymbol;
                    type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                    if (ts.isJSDocTypeLiteral(node) && node.isArrayType) {
                        type = createArrayType(type);
                    }
                    links.resolvedType = type;
                }
            }
            return links.resolvedType;
        }
        function getAliasSymbolForTypeNode(node) {
            var host = node.parent;
            while (ts.isParenthesizedTypeNode(host) || ts.isJSDocTypeExpression(host) || ts.isTypeOperatorNode(host) && host.operator === 143) {
                host = host.parent;
            }
            return ts.isTypeAlias(host) ? getSymbolOfNode(host) : undefined;
        }
        function getTypeArgumentsForAliasSymbol(symbol) {
            return symbol ? getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) : undefined;
        }
        function isNonGenericObjectType(type) {
            return !!(type.flags & 524288) && !isGenericMappedType(type);
        }
        function isEmptyObjectTypeOrSpreadsIntoEmptyObject(type) {
            return isEmptyObjectType(type) || !!(type.flags & (65536 | 32768 | 528 | 296 | 2112 | 402653316 | 1056 | 67108864 | 4194304));
        }
        function tryMergeUnionOfObjectTypeAndEmptyObject(type, readonly) {
            if (!(type.flags & 1048576)) {
                return type;
            }
            if (ts.every(type.types, isEmptyObjectTypeOrSpreadsIntoEmptyObject)) {
                return ts.find(type.types, isEmptyObjectType) || emptyObjectType;
            }
            var firstType = ts.find(type.types, function (t) { return !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t); });
            if (!firstType) {
                return type;
            }
            var secondType = ts.find(type.types, function (t) { return t !== firstType && !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t); });
            if (secondType) {
                return type;
            }
            return getAnonymousPartialType(firstType);
            function getAnonymousPartialType(type) {
                var members = ts.createSymbolTable();
                for (var _i = 0, _a = getPropertiesOfType(type); _i < _a.length; _i++) {
                    var prop = _a[_i];
                    if (ts.getDeclarationModifierFlagsFromSymbol(prop) & (8 | 16)) {
                    }
                    else if (isSpreadableProperty(prop)) {
                        var isSetonlyAccessor = prop.flags & 65536 && !(prop.flags & 32768);
                        var flags = 4 | 16777216;
                        var result = createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop) | (readonly ? 8 : 0));
                        result.type = isSetonlyAccessor ? undefinedType : addOptionality(getTypeOfSymbol(prop), true);
                        result.declarations = prop.declarations;
                        result.nameType = getSymbolLinks(prop).nameType;
                        result.syntheticOrigin = prop;
                        members.set(prop.escapedName, result);
                    }
                }
                var spread = createAnonymousType(type.symbol, members, ts.emptyArray, ts.emptyArray, getIndexInfosOfType(type));
                spread.objectFlags |= 128 | 262144;
                return spread;
            }
        }
        function getSpreadType(left, right, symbol, objectFlags, readonly) {
            if (left.flags & 1 || right.flags & 1) {
                return anyType;
            }
            if (left.flags & 2 || right.flags & 2) {
                return unknownType;
            }
            if (left.flags & 131072) {
                return right;
            }
            if (right.flags & 131072) {
                return left;
            }
            left = tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly);
            if (left.flags & 1048576) {
                return checkCrossProductUnion([left, right])
                    ? mapType(left, function (t) { return getSpreadType(t, right, symbol, objectFlags, readonly); })
                    : errorType;
            }
            right = tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly);
            if (right.flags & 1048576) {
                return checkCrossProductUnion([left, right])
                    ? mapType(right, function (t) { return getSpreadType(left, t, symbol, objectFlags, readonly); })
                    : errorType;
            }
            if (right.flags & (528 | 296 | 2112 | 402653316 | 1056 | 67108864 | 4194304)) {
                return left;
            }
            if (isGenericObjectType(left) || isGenericObjectType(right)) {
                if (isEmptyObjectType(left)) {
                    return right;
                }
                if (left.flags & 2097152) {
                    var types = left.types;
                    var lastLeft = types[types.length - 1];
                    if (isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right)) {
                        return getIntersectionType(ts.concatenate(types.slice(0, types.length - 1), [getSpreadType(lastLeft, right, symbol, objectFlags, readonly)]));
                    }
                }
                return getIntersectionType([left, right]);
            }
            var members = ts.createSymbolTable();
            var skippedPrivateMembers = new ts.Set();
            var indexInfos = left === emptyObjectType ? getIndexInfosOfType(right) : getUnionIndexInfos([left, right]);
            for (var _i = 0, _a = getPropertiesOfType(right); _i < _a.length; _i++) {
                var rightProp = _a[_i];
                if (ts.getDeclarationModifierFlagsFromSymbol(rightProp) & (8 | 16)) {
                    skippedPrivateMembers.add(rightProp.escapedName);
                }
                else if (isSpreadableProperty(rightProp)) {
                    members.set(rightProp.escapedName, getSpreadSymbol(rightProp, readonly));
                }
            }
            for (var _b = 0, _c = getPropertiesOfType(left); _b < _c.length; _b++) {
                var leftProp = _c[_b];
                if (skippedPrivateMembers.has(leftProp.escapedName) || !isSpreadableProperty(leftProp)) {
                    continue;
                }
                if (members.has(leftProp.escapedName)) {
                    var rightProp = members.get(leftProp.escapedName);
                    var rightType = getTypeOfSymbol(rightProp);
                    if (rightProp.flags & 16777216) {
                        var declarations = ts.concatenate(leftProp.declarations, rightProp.declarations);
                        var flags = 4 | (leftProp.flags & 16777216);
                        var result = createSymbol(flags, leftProp.escapedName);
                        result.type = getUnionType([getTypeOfSymbol(leftProp), removeMissingOrUndefinedType(rightType)]);
                        result.leftSpread = leftProp;
                        result.rightSpread = rightProp;
                        result.declarations = declarations;
                        result.nameType = getSymbolLinks(leftProp).nameType;
                        members.set(leftProp.escapedName, result);
                    }
                }
                else {
                    members.set(leftProp.escapedName, getSpreadSymbol(leftProp, readonly));
                }
            }
            var spread = createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, ts.sameMap(indexInfos, function (info) { return getIndexInfoWithReadonly(info, readonly); }));
            spread.objectFlags |= 128 | 262144 | 4194304 | objectFlags;
            return spread;
        }
        function isSpreadableProperty(prop) {
            var _a;
            return !ts.some(prop.declarations, ts.isPrivateIdentifierClassElementDeclaration) &&
                (!(prop.flags & (8192 | 32768 | 65536)) ||
                    !((_a = prop.declarations) === null || _a === void 0 ? void 0 : _a.some(function (decl) { return ts.isClassLike(decl.parent); })));
        }
        function getSpreadSymbol(prop, readonly) {
            var isSetonlyAccessor = prop.flags & 65536 && !(prop.flags & 32768);
            if (!isSetonlyAccessor && readonly === isReadonlySymbol(prop)) {
                return prop;
            }
            var flags = 4 | (prop.flags & 16777216);
            var result = createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop) | (readonly ? 8 : 0));
            result.type = isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop);
            result.declarations = prop.declarations;
            result.nameType = getSymbolLinks(prop).nameType;
            result.syntheticOrigin = prop;
            return result;
        }
        function getIndexInfoWithReadonly(info, readonly) {
            return info.isReadonly !== readonly ? createIndexInfo(info.keyType, info.type, readonly, info.declaration) : info;
        }
        function createLiteralType(flags, value, symbol, regularType) {
            var type = createType(flags);
            type.symbol = symbol;
            type.value = value;
            type.regularType = regularType || type;
            return type;
        }
        function getFreshTypeOfLiteralType(type) {
            if (type.flags & 2944) {
                if (!type.freshType) {
                    var freshType = createLiteralType(type.flags, type.value, type.symbol, type);
                    freshType.freshType = freshType;
                    type.freshType = freshType;
                }
                return type.freshType;
            }
            return type;
        }
        function getRegularTypeOfLiteralType(type) {
            return type.flags & 2944 ? type.regularType :
                type.flags & 1048576 ? (type.regularType || (type.regularType = mapType(type, getRegularTypeOfLiteralType))) :
                    type;
        }
        function isFreshLiteralType(type) {
            return !!(type.flags & 2944) && type.freshType === type;
        }
        function getStringLiteralType(value) {
            var type;
            return stringLiteralTypes.get(value) ||
                (stringLiteralTypes.set(value, type = createLiteralType(128, value)), type);
        }
        function getNumberLiteralType(value) {
            var type;
            return numberLiteralTypes.get(value) ||
                (numberLiteralTypes.set(value, type = createLiteralType(256, value)), type);
        }
        function getBigIntLiteralType(value) {
            var type;
            var key = ts.pseudoBigIntToString(value);
            return bigIntLiteralTypes.get(key) ||
                (bigIntLiteralTypes.set(key, type = createLiteralType(2048, value)), type);
        }
        function getEnumLiteralType(value, enumId, symbol) {
            var type;
            var qualifier = typeof value === "string" ? "@" : "#";
            var key = enumId + qualifier + value;
            var flags = 1024 | (typeof value === "string" ? 128 : 256);
            return enumLiteralTypes.get(key) ||
                (enumLiteralTypes.set(key, type = createLiteralType(flags, value, symbol)), type);
        }
        function getTypeFromLiteralTypeNode(node) {
            if (node.literal.kind === 104) {
                return nullType;
            }
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal));
            }
            return links.resolvedType;
        }
        function createUniqueESSymbolType(symbol) {
            var type = createType(8192);
            type.symbol = symbol;
            type.escapedName = "__@" + type.symbol.escapedName + "@" + getSymbolId(type.symbol);
            return type;
        }
        function getESSymbolLikeTypeForNode(node) {
            if (ts.isValidESSymbolDeclaration(node)) {
                var symbol = getSymbolOfNode(node);
                var links = getSymbolLinks(symbol);
                return links.uniqueESSymbolType || (links.uniqueESSymbolType = createUniqueESSymbolType(symbol));
            }
            return esSymbolType;
        }
        function getThisType(node) {
            var container = ts.getThisContainer(node, false);
            var parent = container && container.parent;
            if (parent && (ts.isClassLike(parent) || parent.kind === 256)) {
                if (!ts.isStatic(container) &&
                    (!ts.isConstructorDeclaration(container) || ts.isNodeDescendantOf(node, container.body))) {
                    return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent)).thisType;
                }
            }
            if (parent && ts.isObjectLiteralExpression(parent) && ts.isBinaryExpression(parent.parent) && ts.getAssignmentDeclarationKind(parent.parent) === 6) {
                return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent.parent.left).parent).thisType;
            }
            var host = node.flags & 4194304 ? ts.getHostSignatureFromJSDoc(node) : undefined;
            if (host && ts.isFunctionExpression(host) && ts.isBinaryExpression(host.parent) && ts.getAssignmentDeclarationKind(host.parent) === 3) {
                return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(host.parent.left).parent).thisType;
            }
            if (isJSConstructor(container) && ts.isNodeDescendantOf(node, container.body)) {
                return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(container)).thisType;
            }
            error(node, ts.Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface);
            return errorType;
        }
        function getTypeFromThisTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getThisType(node);
            }
            return links.resolvedType;
        }
        function getTypeFromRestTypeNode(node) {
            return getTypeFromTypeNode(getArrayElementTypeNode(node.type) || node.type);
        }
        function getArrayElementTypeNode(node) {
            switch (node.kind) {
                case 189:
                    return getArrayElementTypeNode(node.type);
                case 182:
                    if (node.elements.length === 1) {
                        node = node.elements[0];
                        if (node.kind === 184 || node.kind === 195 && node.dotDotDotToken) {
                            return getArrayElementTypeNode(node.type);
                        }
                    }
                    break;
                case 181:
                    return node.elementType;
            }
            return undefined;
        }
        function getTypeFromNamedTupleTypeNode(node) {
            var links = getNodeLinks(node);
            return links.resolvedType || (links.resolvedType =
                node.dotDotDotToken ? getTypeFromRestTypeNode(node) :
                    addOptionality(getTypeFromTypeNode(node.type), true, !!node.questionToken));
        }
        function getTypeFromTypeNode(node) {
            return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node);
        }
        function getTypeFromTypeNodeWorker(node) {
            switch (node.kind) {
                case 129:
                case 307:
                case 308:
                    return anyType;
                case 153:
                    return unknownType;
                case 148:
                    return stringType;
                case 145:
                    return numberType;
                case 156:
                    return bigintType;
                case 132:
                    return booleanType;
                case 149:
                    return esSymbolType;
                case 114:
                    return voidType;
                case 151:
                    return undefinedType;
                case 104:
                    return nullType;
                case 142:
                    return neverType;
                case 146:
                    return node.flags & 131072 && !noImplicitAny ? anyType : nonPrimitiveType;
                case 137:
                    return intrinsicMarkerType;
                case 190:
                case 108:
                    return getTypeFromThisTypeNode(node);
                case 194:
                    return getTypeFromLiteralTypeNode(node);
                case 176:
                    return getTypeFromTypeReference(node);
                case 175:
                    return node.assertsModifier ? voidType : booleanType;
                case 226:
                    return getTypeFromTypeReference(node);
                case 179:
                    return getTypeFromTypeQueryNode(node);
                case 181:
                case 182:
                    return getTypeFromArrayOrTupleTypeNode(node);
                case 183:
                    return getTypeFromOptionalTypeNode(node);
                case 185:
                    return getTypeFromUnionTypeNode(node);
                case 186:
                    return getTypeFromIntersectionTypeNode(node);
                case 309:
                    return getTypeFromJSDocNullableTypeNode(node);
                case 311:
                    return addOptionality(getTypeFromTypeNode(node.type));
                case 195:
                    return getTypeFromNamedTupleTypeNode(node);
                case 189:
                case 310:
                case 304:
                    return getTypeFromTypeNode(node.type);
                case 184:
                    return getTypeFromRestTypeNode(node);
                case 313:
                    return getTypeFromJSDocVariadicType(node);
                case 177:
                case 178:
                case 180:
                case 317:
                case 312:
                case 318:
                    return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
                case 191:
                    return getTypeFromTypeOperatorNode(node);
                case 192:
                    return getTypeFromIndexedAccessTypeNode(node);
                case 193:
                    return getTypeFromMappedTypeNode(node);
                case 187:
                    return getTypeFromConditionalTypeNode(node);
                case 188:
                    return getTypeFromInferTypeNode(node);
                case 196:
                    return getTypeFromTemplateTypeNode(node);
                case 198:
                    return getTypeFromImportTypeNode(node);
                case 79:
                case 159:
                case 204:
                    var symbol = getSymbolAtLocation(node);
                    return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
                default:
                    return errorType;
            }
        }
        function instantiateList(items, mapper, instantiator) {
            if (items && items.length) {
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    var mapped = instantiator(item, mapper);
                    if (item !== mapped) {
                        var result = i === 0 ? [] : items.slice(0, i);
                        result.push(mapped);
                        for (i++; i < items.length; i++) {
                            result.push(instantiator(items[i], mapper));
                        }
                        return result;
                    }
                }
            }
            return items;
        }
        function instantiateTypes(types, mapper) {
            return instantiateList(types, mapper, instantiateType);
        }
        function instantiateSignatures(signatures, mapper) {
            return instantiateList(signatures, mapper, instantiateSignature);
        }
        function instantiateIndexInfos(indexInfos, mapper) {
            return instantiateList(indexInfos, mapper, instantiateIndexInfo);
        }
        function createTypeMapper(sources, targets) {
            return sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) : makeArrayTypeMapper(sources, targets);
        }
        function getMappedType(type, mapper) {
            switch (mapper.kind) {
                case 0:
                    return type === mapper.source ? mapper.target : type;
                case 1:
                    var sources = mapper.sources;
                    var targets = mapper.targets;
                    for (var i = 0; i < sources.length; i++) {
                        if (type === sources[i]) {
                            return targets ? targets[i] : anyType;
                        }
                    }
                    return type;
                case 2:
                    return mapper.func(type);
                case 3:
                case 4:
                    var t1 = getMappedType(type, mapper.mapper1);
                    return t1 !== type && mapper.kind === 3 ? instantiateType(t1, mapper.mapper2) : getMappedType(t1, mapper.mapper2);
            }
        }
        function makeUnaryTypeMapper(source, target) {
            return { kind: 0, source: source, target: target };
        }
        function makeArrayTypeMapper(sources, targets) {
            return { kind: 1, sources: sources, targets: targets };
        }
        function makeFunctionTypeMapper(func) {
            return { kind: 2, func: func };
        }
        function makeCompositeTypeMapper(kind, mapper1, mapper2) {
            return { kind: kind, mapper1: mapper1, mapper2: mapper2 };
        }
        function createTypeEraser(sources) {
            return createTypeMapper(sources, undefined);
        }
        function createBackreferenceMapper(context, index) {
            return makeFunctionTypeMapper(function (t) { return ts.findIndex(context.inferences, function (info) { return info.typeParameter === t; }) >= index ? unknownType : t; });
        }
        function combineTypeMappers(mapper1, mapper2) {
            return mapper1 ? makeCompositeTypeMapper(3, mapper1, mapper2) : mapper2;
        }
        function mergeTypeMappers(mapper1, mapper2) {
            return mapper1 ? makeCompositeTypeMapper(4, mapper1, mapper2) : mapper2;
        }
        function prependTypeMapping(source, target, mapper) {
            return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(4, makeUnaryTypeMapper(source, target), mapper);
        }
        function appendTypeMapping(mapper, source, target) {
            return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(4, mapper, makeUnaryTypeMapper(source, target));
        }
        function getRestrictiveTypeParameter(tp) {
            return tp.constraint === unknownType ? tp : tp.restrictiveInstantiation || (tp.restrictiveInstantiation = createTypeParameter(tp.symbol),
                tp.restrictiveInstantiation.constraint = unknownType,
                tp.restrictiveInstantiation);
        }
        function cloneTypeParameter(typeParameter) {
            var result = createTypeParameter(typeParameter.symbol);
            result.target = typeParameter;
            return result;
        }
        function instantiateTypePredicate(predicate, mapper) {
            return createTypePredicate(predicate.kind, predicate.parameterName, predicate.parameterIndex, instantiateType(predicate.type, mapper));
        }
        function instantiateSignature(signature, mapper, eraseTypeParameters) {
            var freshTypeParameters;
            if (signature.typeParameters && !eraseTypeParameters) {
                freshTypeParameters = ts.map(signature.typeParameters, cloneTypeParameter);
                mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);
                for (var _i = 0, freshTypeParameters_1 = freshTypeParameters; _i < freshTypeParameters_1.length; _i++) {
                    var tp = freshTypeParameters_1[_i];
                    tp.mapper = mapper;
                }
            }
            var result = createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper), instantiateList(signature.parameters, mapper, instantiateSymbol), undefined, undefined, signature.minArgumentCount, signature.flags & 39);
            result.target = signature;
            result.mapper = mapper;
            return result;
        }
        function instantiateSymbol(symbol, mapper) {
            var links = getSymbolLinks(symbol);
            if (links.type && !couldContainTypeVariables(links.type)) {
                return symbol;
            }
            if (ts.getCheckFlags(symbol) & 1) {
                symbol = links.target;
                mapper = combineTypeMappers(links.mapper, mapper);
            }
            var result = createSymbol(symbol.flags, symbol.escapedName, 1 | ts.getCheckFlags(symbol) & (8 | 4096 | 16384 | 32768));
            result.declarations = symbol.declarations;
            result.parent = symbol.parent;
            result.target = symbol;
            result.mapper = mapper;
            if (symbol.valueDeclaration) {
                result.valueDeclaration = symbol.valueDeclaration;
            }
            if (links.nameType) {
                result.nameType = links.nameType;
            }
            return result;
        }
        function getObjectTypeInstantiation(type, mapper, aliasSymbol, aliasTypeArguments) {
            var declaration = type.objectFlags & 4 ? type.node : type.symbol.declarations[0];
            var links = getNodeLinks(declaration);
            var target = type.objectFlags & 4 ? links.resolvedType :
                type.objectFlags & 64 ? type.target : type;
            var typeParameters = links.outerTypeParameters;
            if (!typeParameters) {
                var outerTypeParameters = getOuterTypeParameters(declaration, true);
                if (isJSConstructor(declaration)) {
                    var templateTagParameters = getTypeParametersFromDeclaration(declaration);
                    outerTypeParameters = ts.addRange(outerTypeParameters, templateTagParameters);
                }
                typeParameters = outerTypeParameters || ts.emptyArray;
                var allDeclarations_1 = type.objectFlags & 4 ? [declaration] : type.symbol.declarations;
                typeParameters = (target.objectFlags & 4 || target.symbol.flags & 8192 || target.symbol.flags & 2048) && !target.aliasTypeArguments ?
                    ts.filter(typeParameters, function (tp) { return ts.some(allDeclarations_1, function (d) { return isTypeParameterPossiblyReferenced(tp, d); }); }) :
                    typeParameters;
                links.outerTypeParameters = typeParameters;
            }
            if (typeParameters.length) {
                var combinedMapper_1 = combineTypeMappers(type.mapper, mapper);
                var typeArguments = ts.map(typeParameters, function (t) { return getMappedType(t, combinedMapper_1); });
                var newAliasSymbol = aliasSymbol || type.aliasSymbol;
                var newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
                var id = getTypeListId(typeArguments) + getAliasId(newAliasSymbol, newAliasTypeArguments);
                if (!target.instantiations) {
                    target.instantiations = new ts.Map();
                    target.instantiations.set(getTypeListId(typeParameters) + getAliasId(target.aliasSymbol, target.aliasTypeArguments), target);
                }
                var result = target.instantiations.get(id);
                if (!result) {
                    var newMapper = createTypeMapper(typeParameters, typeArguments);
                    result = target.objectFlags & 4 ? createDeferredTypeReference(type.target, type.node, newMapper, newAliasSymbol, newAliasTypeArguments) :
                        target.objectFlags & 32 ? instantiateMappedType(target, newMapper, newAliasSymbol, newAliasTypeArguments) :
                            instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments);
                    target.instantiations.set(id, result);
                }
                return result;
            }
            return type;
        }
        function maybeTypeParameterReference(node) {
            return !(node.parent.kind === 176 && node.parent.typeArguments && node === node.parent.typeName ||
                node.parent.kind === 198 && node.parent.typeArguments && node === node.parent.qualifier);
        }
        function isTypeParameterPossiblyReferenced(tp, node) {
            if (tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length === 1) {
                var container = tp.symbol.declarations[0].parent;
                for (var n = node; n !== container; n = n.parent) {
                    if (!n || n.kind === 233 || n.kind === 187 && ts.forEachChild(n.extendsType, containsReference)) {
                        return true;
                    }
                }
                return containsReference(node);
            }
            return true;
            function containsReference(node) {
                switch (node.kind) {
                    case 190:
                        return !!tp.isThisType;
                    case 79:
                        return !tp.isThisType && ts.isPartOfTypeNode(node) && maybeTypeParameterReference(node) &&
                            getTypeFromTypeNodeWorker(node) === tp;
                    case 179:
                        return true;
                    case 167:
                    case 166:
                        return !node.type && !!node.body ||
                            ts.some(node.typeParameters, containsReference) ||
                            ts.some(node.parameters, containsReference) ||
                            !!node.type && containsReference(node.type);
                }
                return !!ts.forEachChild(node, containsReference);
            }
        }
        function getHomomorphicTypeVariable(type) {
            var constraintType = getConstraintTypeFromMappedType(type);
            if (constraintType.flags & 4194304) {
                var typeVariable = getActualTypeVariable(constraintType.type);
                if (typeVariable.flags & 262144) {
                    return typeVariable;
                }
            }
            return undefined;
        }
        function instantiateMappedType(type, mapper, aliasSymbol, aliasTypeArguments) {
            var typeVariable = getHomomorphicTypeVariable(type);
            if (typeVariable) {
                var mappedTypeVariable = instantiateType(typeVariable, mapper);
                if (typeVariable !== mappedTypeVariable) {
                    return mapTypeWithAlias(getReducedType(mappedTypeVariable), function (t) {
                        if (t.flags & (3 | 58982400 | 524288 | 2097152) && t !== wildcardType && t !== errorType) {
                            if (!type.declaration.nameType) {
                                if (isArrayType(t)) {
                                    return instantiateMappedArrayType(t, type, prependTypeMapping(typeVariable, t, mapper));
                                }
                                if (isGenericTupleType(t)) {
                                    return instantiateMappedGenericTupleType(t, type, typeVariable, mapper);
                                }
                                if (isTupleType(t)) {
                                    return instantiateMappedTupleType(t, type, prependTypeMapping(typeVariable, t, mapper));
                                }
                            }
                            return instantiateAnonymousType(type, prependTypeMapping(typeVariable, t, mapper));
                        }
                        return t;
                    }, aliasSymbol, aliasTypeArguments);
                }
            }
            return instantiateType(getConstraintTypeFromMappedType(type), mapper) === wildcardType ? wildcardType : instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments);
        }
        function getModifiedReadonlyState(state, modifiers) {
            return modifiers & 1 ? true : modifiers & 2 ? false : state;
        }
        function instantiateMappedGenericTupleType(tupleType, mappedType, typeVariable, mapper) {
            var elementFlags = tupleType.target.elementFlags;
            var elementTypes = ts.map(getTypeArguments(tupleType), function (t, i) {
                var singleton = elementFlags[i] & 8 ? t :
                    elementFlags[i] & 4 ? createArrayType(t) :
                        createTupleType([t], [elementFlags[i]]);
                return instantiateMappedType(mappedType, prependTypeMapping(typeVariable, singleton, mapper));
            });
            var newReadonly = getModifiedReadonlyState(tupleType.target.readonly, getMappedTypeModifiers(mappedType));
            return createTupleType(elementTypes, ts.map(elementTypes, function (_) { return 8; }), newReadonly);
        }
        function instantiateMappedArrayType(arrayType, mappedType, mapper) {
            var elementType = instantiateMappedTypeTemplate(mappedType, numberType, true, mapper);
            return elementType === errorType ? errorType :
                createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType)));
        }
        function instantiateMappedTupleType(tupleType, mappedType, mapper) {
            var elementFlags = tupleType.target.elementFlags;
            var elementTypes = ts.map(getTypeArguments(tupleType), function (_, i) {
                return instantiateMappedTypeTemplate(mappedType, getStringLiteralType("" + i), !!(elementFlags[i] & 2), mapper);
            });
            var modifiers = getMappedTypeModifiers(mappedType);
            var newTupleModifiers = modifiers & 4 ? ts.map(elementFlags, function (f) { return f & 1 ? 2 : f; }) :
                modifiers & 8 ? ts.map(elementFlags, function (f) { return f & 2 ? 1 : f; }) :
                    elementFlags;
            var newReadonly = getModifiedReadonlyState(tupleType.target.readonly, modifiers);
            return ts.contains(elementTypes, errorType) ? errorType :
                createTupleType(elementTypes, newTupleModifiers, newReadonly, tupleType.target.labeledElementDeclarations);
        }
        function instantiateMappedTypeTemplate(type, key, isOptional, mapper) {
            var templateMapper = appendTypeMapping(mapper, getTypeParameterFromMappedType(type), key);
            var propType = instantiateType(getTemplateTypeFromMappedType(type.target || type), templateMapper);
            var modifiers = getMappedTypeModifiers(type);
            return strictNullChecks && modifiers & 4 && !maybeTypeOfKind(propType, 32768 | 16384) ? getOptionalType(propType, true) :
                strictNullChecks && modifiers & 8 && isOptional ? getTypeWithFacts(propType, 524288) :
                    propType;
        }
        function instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments) {
            var result = createObjectType(type.objectFlags | 64, type.symbol);
            if (type.objectFlags & 32) {
                result.declaration = type.declaration;
                var origTypeParameter = getTypeParameterFromMappedType(type);
                var freshTypeParameter = cloneTypeParameter(origTypeParameter);
                result.typeParameter = freshTypeParameter;
                mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper);
                freshTypeParameter.mapper = mapper;
            }
            result.target = type;
            result.mapper = mapper;
            result.aliasSymbol = aliasSymbol || type.aliasSymbol;
            result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
            return result;
        }
        function getConditionalTypeInstantiation(type, mapper, aliasSymbol, aliasTypeArguments) {
            var root = type.root;
            if (root.outerTypeParameters) {
                var typeArguments = ts.map(root.outerTypeParameters, function (t) { return getMappedType(t, mapper); });
                var id = getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
                var result = root.instantiations.get(id);
                if (!result) {
                    var newMapper = createTypeMapper(root.outerTypeParameters, typeArguments);
                    result = instantiateConditionalType(root, newMapper, aliasSymbol, aliasTypeArguments);
                    root.instantiations.set(id, result);
                }
                return result;
            }
            return type;
        }
        function instantiateConditionalType(root, mapper, aliasSymbol, aliasTypeArguments) {
            if (root.isDistributive) {
                var checkType_1 = root.checkType;
                var instantiatedType = getMappedType(checkType_1, mapper);
                if (checkType_1 !== instantiatedType && instantiatedType.flags & (1048576 | 131072)) {
                    return mapTypeWithAlias(instantiatedType, function (t) { return getConditionalType(root, prependTypeMapping(checkType_1, t, mapper)); }, aliasSymbol, aliasTypeArguments);
                }
            }
            return getConditionalType(root, mapper, aliasSymbol, aliasTypeArguments);
        }
        function instantiateType(type, mapper) {
            return type && mapper ? instantiateTypeWithAlias(type, mapper, undefined, undefined) : type;
        }
        function instantiateTypeWithAlias(type, mapper, aliasSymbol, aliasTypeArguments) {
            if (!couldContainTypeVariables(type)) {
                return type;
            }
            if (instantiationDepth === 50 || instantiationCount >= 5000000) {
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes", "instantiateType_DepthLimit", { typeId: type.id, instantiationDepth: instantiationDepth, instantiationCount: instantiationCount });
                error(currentNode, ts.Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
                return errorType;
            }
            totalInstantiationCount++;
            instantiationCount++;
            instantiationDepth++;
            var result = instantiateTypeWorker(type, mapper, aliasSymbol, aliasTypeArguments);
            instantiationDepth--;
            return result;
        }
        function instantiateTypeWorker(type, mapper, aliasSymbol, aliasTypeArguments) {
            var flags = type.flags;
            if (flags & 262144) {
                return getMappedType(type, mapper);
            }
            if (flags & 524288) {
                var objectFlags = type.objectFlags;
                if (objectFlags & (4 | 16 | 32)) {
                    if (objectFlags & 4 && !type.node) {
                        var resolvedTypeArguments = type.resolvedTypeArguments;
                        var newTypeArguments = instantiateTypes(resolvedTypeArguments, mapper);
                        return newTypeArguments !== resolvedTypeArguments ? createNormalizedTypeReference(type.target, newTypeArguments) : type;
                    }
                    if (objectFlags & 1024) {
                        return instantiateReverseMappedType(type, mapper);
                    }
                    return getObjectTypeInstantiation(type, mapper, aliasSymbol, aliasTypeArguments);
                }
                return type;
            }
            if (flags & 3145728) {
                var origin = type.flags & 1048576 ? type.origin : undefined;
                var types = origin && origin.flags & 3145728 ? origin.types : type.types;
                var newTypes = instantiateTypes(types, mapper);
                if (newTypes === types && aliasSymbol === type.aliasSymbol) {
                    return type;
                }
                var newAliasSymbol = aliasSymbol || type.aliasSymbol;
                var newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
                return flags & 2097152 || origin && origin.flags & 2097152 ?
                    getIntersectionType(newTypes, newAliasSymbol, newAliasTypeArguments) :
                    getUnionType(newTypes, 1, newAliasSymbol, newAliasTypeArguments);
            }
            if (flags & 4194304) {
                return getIndexType(instantiateType(type.type, mapper));
            }
            if (flags & 134217728) {
                return getTemplateLiteralType(type.texts, instantiateTypes(type.types, mapper));
            }
            if (flags & 268435456) {
                return getStringMappingType(type.symbol, instantiateType(type.type, mapper));
            }
            if (flags & 8388608) {
                var newAliasSymbol = aliasSymbol || type.aliasSymbol;
                var newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
                return getIndexedAccessType(instantiateType(type.objectType, mapper), instantiateType(type.indexType, mapper), type.accessFlags, undefined, newAliasSymbol, newAliasTypeArguments);
            }
            if (flags & 16777216) {
                return getConditionalTypeInstantiation(type, combineTypeMappers(type.mapper, mapper), aliasSymbol, aliasTypeArguments);
            }
            if (flags & 33554432) {
                var maybeVariable = instantiateType(type.baseType, mapper);
                if (maybeVariable.flags & 8650752) {
                    return getSubstitutionType(maybeVariable, instantiateType(type.substitute, mapper));
                }
                else {
                    var sub = instantiateType(type.substitute, mapper);
                    if (sub.flags & 3 || isTypeAssignableTo(getRestrictiveInstantiation(maybeVariable), getRestrictiveInstantiation(sub))) {
                        return maybeVariable;
                    }
                    return sub;
                }
            }
            return type;
        }
        function instantiateReverseMappedType(type, mapper) {
            var innerMappedType = instantiateType(type.mappedType, mapper);
            if (!(ts.getObjectFlags(innerMappedType) & 32)) {
                return type;
            }
            var innerIndexType = instantiateType(type.constraintType, mapper);
            if (!(innerIndexType.flags & 4194304)) {
                return type;
            }
            var instantiated = inferTypeForHomomorphicMappedType(instantiateType(type.source, mapper), innerMappedType, innerIndexType);
            if (instantiated) {
                return instantiated;
            }
            return type;
        }
        function getPermissiveInstantiation(type) {
            return type.flags & (131068 | 3 | 131072) ? type :
                type.permissiveInstantiation || (type.permissiveInstantiation = instantiateType(type, permissiveMapper));
        }
        function getRestrictiveInstantiation(type) {
            if (type.flags & (131068 | 3 | 131072)) {
                return type;
            }
            if (type.restrictiveInstantiation) {
                return type.restrictiveInstantiation;
            }
            type.restrictiveInstantiation = instantiateType(type, restrictiveMapper);
            type.restrictiveInstantiation.restrictiveInstantiation = type.restrictiveInstantiation;
            return type.restrictiveInstantiation;
        }
        function instantiateIndexInfo(info, mapper) {
            return createIndexInfo(info.keyType, instantiateType(info.type, mapper), info.isReadonly, info.declaration);
        }
        function isContextSensitive(node) {
            ts.Debug.assert(node.kind !== 167 || ts.isObjectLiteralMethod(node));
            switch (node.kind) {
                case 211:
                case 212:
                case 167:
                case 254:
                    return isContextSensitiveFunctionLikeDeclaration(node);
                case 203:
                    return ts.some(node.properties, isContextSensitive);
                case 202:
                    return ts.some(node.elements, isContextSensitive);
                case 220:
                    return isContextSensitive(node.whenTrue) ||
                        isContextSensitive(node.whenFalse);
                case 219:
                    return (node.operatorToken.kind === 56 || node.operatorToken.kind === 60) &&
                        (isContextSensitive(node.left) || isContextSensitive(node.right));
                case 291:
                    return isContextSensitive(node.initializer);
                case 210:
                    return isContextSensitive(node.expression);
                case 284:
                    return ts.some(node.properties, isContextSensitive) || ts.isJsxOpeningElement(node.parent) && ts.some(node.parent.parent.children, isContextSensitive);
                case 283: {
                    var initializer = node.initializer;
                    return !!initializer && isContextSensitive(initializer);
                }
                case 286: {
                    var expression = node.expression;
                    return !!expression && isContextSensitive(expression);
                }
            }
            return false;
        }
        function isContextSensitiveFunctionLikeDeclaration(node) {
            return (!ts.isFunctionDeclaration(node) || ts.isInJSFile(node) && !!getTypeForDeclarationFromJSDocComment(node)) &&
                (ts.hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node));
        }
        function hasContextSensitiveReturnExpression(node) {
            return !node.typeParameters && !ts.getEffectiveReturnTypeNode(node) && !!node.body && node.body.kind !== 233 && isContextSensitive(node.body);
        }
        function isContextSensitiveFunctionOrObjectLiteralMethod(func) {
            return (ts.isInJSFile(func) && ts.isFunctionDeclaration(func) || isFunctionExpressionOrArrowFunction(func) || ts.isObjectLiteralMethod(func)) &&
                isContextSensitiveFunctionLikeDeclaration(func);
        }
        function getTypeWithoutSignatures(type) {
            if (type.flags & 524288) {
                var resolved = resolveStructuredTypeMembers(type);
                if (resolved.constructSignatures.length || resolved.callSignatures.length) {
                    var result = createObjectType(16, type.symbol);
                    result.members = resolved.members;
                    result.properties = resolved.properties;
                    result.callSignatures = ts.emptyArray;
                    result.constructSignatures = ts.emptyArray;
                    result.indexInfos = ts.emptyArray;
                    return result;
                }
            }
            else if (type.flags & 2097152) {
                return getIntersectionType(ts.map(type.types, getTypeWithoutSignatures));
            }
            return type;
        }
        function isTypeIdenticalTo(source, target) {
            return isTypeRelatedTo(source, target, identityRelation);
        }
        function compareTypesIdentical(source, target) {
            return isTypeRelatedTo(source, target, identityRelation) ? -1 : 0;
        }
        function compareTypesAssignable(source, target) {
            return isTypeRelatedTo(source, target, assignableRelation) ? -1 : 0;
        }
        function compareTypesSubtypeOf(source, target) {
            return isTypeRelatedTo(source, target, subtypeRelation) ? -1 : 0;
        }
        function isTypeSubtypeOf(source, target) {
            return isTypeRelatedTo(source, target, subtypeRelation);
        }
        function isTypeAssignableTo(source, target) {
            return isTypeRelatedTo(source, target, assignableRelation);
        }
        function isTypeDerivedFrom(source, target) {
            return source.flags & 1048576 ? ts.every(source.types, function (t) { return isTypeDerivedFrom(t, target); }) :
                target.flags & 1048576 ? ts.some(target.types, function (t) { return isTypeDerivedFrom(source, t); }) :
                    source.flags & 58982400 ? isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target) :
                        target === globalObjectType ? !!(source.flags & (524288 | 67108864)) :
                            target === globalFunctionType ? !!(source.flags & 524288) && isFunctionObjectType(source) :
                                hasBaseType(source, getTargetType(target)) || (isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType));
        }
        function isTypeComparableTo(source, target) {
            return isTypeRelatedTo(source, target, comparableRelation);
        }
        function areTypesComparable(type1, type2) {
            return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1);
        }
        function checkTypeAssignableTo(source, target, errorNode, headMessage, containingMessageChain, errorOutputObject) {
            return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject);
        }
        function checkTypeAssignableToAndOptionallyElaborate(source, target, errorNode, expr, headMessage, containingMessageChain) {
            return checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain, undefined);
        }
        function checkTypeRelatedToAndOptionallyElaborate(source, target, relation, errorNode, expr, headMessage, containingMessageChain, errorOutputContainer) {
            if (isTypeRelatedTo(source, target, relation))
                return true;
            if (!errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)) {
                return checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer);
            }
            return false;
        }
        function isOrHasGenericConditional(type) {
            return !!(type.flags & 16777216 || (type.flags & 2097152 && ts.some(type.types, isOrHasGenericConditional)));
        }
        function elaborateError(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
            if (!node || isOrHasGenericConditional(target))
                return false;
            if (!checkTypeRelatedTo(source, target, relation, undefined)
                && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)) {
                return true;
            }
            switch (node.kind) {
                case 286:
                case 210:
                    return elaborateError(node.expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
                case 219:
                    switch (node.operatorToken.kind) {
                        case 63:
                        case 27:
                            return elaborateError(node.right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
                    }
                    break;
                case 203:
                    return elaborateObjectLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer);
                case 202:
                    return elaborateArrayLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer);
                case 284:
                    return elaborateJsxComponents(node, source, target, relation, containingMessageChain, errorOutputContainer);
                case 212:
                    return elaborateArrowFunction(node, source, target, relation, containingMessageChain, errorOutputContainer);
            }
            return false;
        }
        function elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
            var callSignatures = getSignaturesOfType(source, 0);
            var constructSignatures = getSignaturesOfType(source, 1);
            for (var _i = 0, _a = [constructSignatures, callSignatures]; _i < _a.length; _i++) {
                var signatures = _a[_i];
                if (ts.some(signatures, function (s) {
                    var returnType = getReturnTypeOfSignature(s);
                    return !(returnType.flags & (1 | 131072)) && checkTypeRelatedTo(returnType, target, relation, undefined);
                })) {
                    var resultObj = 