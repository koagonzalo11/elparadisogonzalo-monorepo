   break;

      case "BinaryExpression":
      case "LogicalExpression":
        if (name === "right") {
          return path.callParent(isFollowedByRightBracket);
        }

        break;

      case "ConditionalExpression":
        if (name === "alternate") {
          return path.callParent(isFollowedByRightBracket);
        }

        break;

      case "UnaryExpression":
        if (parent.prefix) {
          return path.callParent(isFollowedByRightBracket);
        }

        break;
    }

    return false;
  }

  function shouldWrapFunctionForExportDefault(path, options) {
    var node = path.getValue();
    var parent = path.getParentNode();

    if (node.type === "FunctionExpression" || node.type === "ClassExpression") {
      return parent.type === "ExportDefaultDeclaration" || // in some cases the function is already wrapped
      // (e.g. `export default (function() {})();`)
      // in this case we don't need to add extra parens
      !needsParens(path, options);
    }

    if (!hasNakedLeftSide$1(node) || parent.type !== "ExportDefaultDeclaration" && needsParens(path, options)) {
      return false;
    }

    return path.call.apply(path, [function (childPath) {
      return shouldWrapFunctionForExportDefault(childPath, options);
    }].concat(getLeftSidePathName$1(path, node)));
  }

  var needsParens_1 = needsParens;

  var _require$$0$builders$6 = doc.builders,
      concat$c = _require$$0$builders$6.concat,
      join$8 = _require$$0$builders$6.join,
      line$6 = _require$$0$builders$6.line;

  function printHtmlBinding(path, options, print) {
    var node = path.getValue();

    if (options.__onHtmlBindingRoot && path.getName() === null) {
      options.__onHtmlBindingRoot(node);
    }

    if (node.type !== "File") {
      return;
    }

    if (options.__isVueForBindingLeft) {
      return path.call(function (functionDeclarationPath) {
        var _functionDeclarationP = functionDeclarationPath.getValue(),
            params = _functionDeclarationP.params;

        return concat$c([params.length > 1 ? "(" : "", join$8(concat$c([",", line$6]), functionDeclarationPath.map(print, "params")), params.length > 1 ? ")" : ""]);
      }, "program", "body", 0);
    }

    if (options.__isVueSlotScope) {
      return path.call(function (functionDeclarationPath) {
        return join$8(concat$c([",", line$6]), functionDeclarationPath.map(print, "params"));
      }, "program", "body", 0);
    }
  } // based on https://github.com/prettier/prettier/blob/master/src/language-html/syntax-vue.js isVueEventBindingExpression()


  function isVueEventBindingExpression$2(node) {
    switch (node.type) {
      case "MemberExpression":
        switch (node.property.type) {
          case "Identifier":
          case "NumericLiteral":
          case "StringLiteral":
            return isVueEventBindingExpression$2(node.object);
        }

        return false;

      case "Identifier":
        return true;

      default:
        return false;
    }
  }

  var htmlBinding = {
    isVueEventBindingExpression: isVueEventBindingExpression$2,
    printHtmlBinding: printHtmlBinding
  };

  function preprocess$1(ast, options) {
    switch (options.parser) {
      case "json":
      case "json5":
      case "json-stringify":
      case "__js_expression":
      case "__vue_expression":
        return Object.assign({}, ast, {
          type: options.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot",
          node: ast,
          comments: []
        });

      default:
        return ast;
    }
  }

  var preprocess_1$1 = preprocess$1;

  var getParentExportDeclaration$1 = util.getParentExportDeclaration,
      isExportDeclaration$1 = util.isExportDeclaration,
      shouldFlatten$1 = util.shouldFlatten,
      getNextNonSpaceNonCommentCharacter$1 = util.getNextNonSpaceNonCommentCharacter,
      hasNewline$4 = util.hasNewline,
      hasNewlineInRange$2 = util.hasNewlineInRange,
      getLast$2 = util.getLast,
      getStringWidth$2 = util.getStringWidth,
      printString$2 = util.printString,
      printNumber$2 = util.printNumber,
      hasIgnoreComment$4 = util.hasIgnoreComment,
      hasNodeIgnoreComment$2 = util.hasNodeIgnoreComment,
      getPenultimate$1 = util.getPenultimate,
      startsWithNoLookaheadToken$1 = util.startsWithNoLookaheadToken,
      getIndentSize$1 = util.getIndentSize,
      matchAncestorTypes$1 = util.matchAncestorTypes,
      getPreferredQuote$1 = util.getPreferredQuote;
  var isNextLineEmpty$4 = utilShared.isNextLineEmpty,
      isNextLineEmptyAfterIndex$1 = utilShared.isNextLineEmptyAfterIndex,
      getNextNonSpaceNonCommentCharacterIndex$2 = utilShared.getNextNonSpaceNonCommentCharacterIndex;
  var insertPragma$7 = pragma.insertPragma;
  var printHtmlBinding$1 = htmlBinding.printHtmlBinding,
      isVueEventBindingExpression$3 = htmlBinding.isVueEventBindingExpression;
  var classChildNeedsASIProtection$1 = utils$4.classChildNeedsASIProtection,
      classPropMayCauseASIProblems$1 = utils$4.classPropMayCauseASIProblems,
      conditionalExpressionChainContainsJSX$1 = utils$4.conditionalExpressionChainContainsJSX,
      getFlowVariance$1 = utils$4.getFlowVariance,
      getLeftSidePathName$2 = utils$4.getLeftSidePathName,
      getTypeScriptMappedTypeModifier$1 = utils$4.getTypeScriptMappedTypeModifier,
      hasDanglingComments$1 = utils$4.hasDanglingComments,
      hasFlowAnnotationComment$1 = utils$4.hasFlowAnnotationComment,
      hasFlowShorthandAnnotationComment$2 = utils$4.hasFlowShorthandAnnotationComment,
      hasLeadingComment$3 = utils$4.hasLeadingComment,
      hasLeadingOwnLineComment$1 = utils$4.hasLeadingOwnLineComment,
      hasNakedLeftSide$2 = utils$4.hasNakedLeftSide,
      hasNewlineBetweenOrAfterDecorators$1 = utils$4.hasNewlineBetweenOrAfterDecorators,
      hasNgSideEffect$1 = utils$4.hasNgSideEffect,
      hasPrettierIgnore$3 = utils$4.hasPrettierIgnore,
      hasTrailingComment$1 = utils$4.hasTrailingComment,
      identity$2 = utils$4.identity,
      isBinaryish$1 = utils$4.isBinaryish,
      isCallOrOptionalCallExpression$1 = utils$4.isCallOrOptionalCallExpression,
      isEmptyJSXElement$1 = utils$4.isEmptyJSXElement,
      isFlowAnnotationComment$1 = utils$4.isFlowAnnotationComment,
      isFunctionCompositionArgs$1 = utils$4.isFunctionCompositionArgs,
      isFunctionNotation$1 = utils$4.isFunctionNotation,
      isFunctionOrArrowExpression$1 = utils$4.isFunctionOrArrowExpression,
      isGetterOrSetter$1 = utils$4.isGetterOrSetter,
      isJestEachTemplateLiteral$1 = utils$4.isJestEachTemplateLiteral,
      isJSXNode$1 = utils$4.isJSXNode,
      isJSXWhitespaceExpression$1 = utils$4.isJSXWhitespaceExpression,
      isLastStatement$1 = utils$4.isLastStatement,
      isLiteral$1 = utils$4.isLiteral,
      isLongCurriedCallExpression$1 = utils$4.isLongCurriedCallExpression,
      isMeaningfulJSXText$1 = utils$4.isMeaningfulJSXText,
      isMemberExpressionChain$1 = utils$4.isMemberExpressionChain,
      isMemberish$1 = utils$4.isMemberish,
      isNgForOf$1 = utils$4.isNgForOf,
      isNumericLiteral$1 = utils$4.isNumericLiteral,
      isObjectType$1 = utils$4.isObjectType,
      isObjectTypePropertyAFunction$1 = utils$4.isObjectTypePropertyAFunction,
      isSimpleFlowType$1 = utils$4.isSimpleFlowType,
      isSimpleTemplateLiteral$1 = utils$4.isSimpleTemplateLiteral,
      isStringLiteral$1 = utils$4.isStringLiteral,
      isStringPropSafeToCoerceToIdentifier$1 = utils$4.isStringPropSafeToCoerceToIdentifier,
      isTemplateOnItsOwnLine$1 = utils$4.isTemplateOnItsOwnLine,
      isTestCall$1 = utils$4.isTestCall,
      isTheOnlyJSXElementInMarkdown$1 = utils$4.isTheOnlyJSXElementInMarkdown,
      isTSXFile$1 = utils$4.isTSXFile,
      isTypeAnnotationAFunction$1 = utils$4.isTypeAnnotationAFunction,
      matchJsxWhitespaceRegex$1 = utils$4.matchJsxWhitespaceRegex,
      needsHardlineAfterDanglingComment$1 = utils$4.needsHardlineAfterDanglingComment,
      rawText$1 = utils$4.rawText,
      returnArgumentHasLeadingComment$1 = utils$4.returnArgumentHasLeadingComment;
  var needsQuoteProps = new WeakMap();
  var _require$$5$builders = doc.builders,
      concat$d = _require$$5$builders.concat,
      join$9 = _require$$5$builders.join,
      line$7 = _require$$5$builders.line,
      hardline$9 = _require$$5$builders.hardline,
      softline$6 = _require$$5$builders.softline,
      literalline$4 = _require$$5$builders.literalline,
      group$b = _require$$5$builders.group,
      indent$7 = _require$$5$builders.indent,
      align$1 = _require$$5$builders.align,
      conditionalGroup$1 = _require$$5$builders.conditionalGroup,
      fill$4 = _require$$5$builders.fill,
      ifBreak$6 = _require$$5$builders.ifBreak,
      breakParent$3 = _require$$5$builders.breakParent,
      lineSuffixBoundary$1 = _require$$5$builders.lineSuffixBoundary,
      addAlignmentToDoc$2 = _require$$5$builders.addAlignmentToDoc,
      dedent$2 = _require$$5$builders.dedent,
      _require$$5$utils = doc.utils,
      willBreak$1 = _require$$5$utils.willBreak,
      isLineNext$1 = _require$$5$utils.isLineNext,
      isEmpty$1 = _require$$5$utils.isEmpty,
      removeLines$2 = _require$$5$utils.removeLines,
      printDocToString$1 = doc.printer.printDocToString;
  var uid = 0;

  function shouldPrintComma$1(options, level) {
    level = level || "es5";

    switch (options.trailingComma) {
      case "all":
        if (level === "all") {
          return true;
        }

      // fallthrough

      case "es5":
        if (level === "es5") {
          return true;
        }

      // fallthrough

      case "none":
      default:
        return false;
    }
  }

  function genericPrint$3(path, options, printPath, args) {
    var node = path.getValue();
    var needsParens = false;
    var linesWithoutParens = printPathNoParens(path, options, printPath, args);

    if (!node || isEmpty$1(linesWithoutParens)) {
      return linesWithoutParens;
    }

    var parentExportDecl = getParentExportDeclaration$1(path);
    var decorators = [];

    if (node.type === "ClassMethod" || node.type === "ClassPrivateMethod" || node.type === "ClassProperty" || node.type === "TSAbstractClassProperty" || node.type === "ClassPrivateProperty" || node.type === "MethodDefinition" || node.type === "TSAbstractMethodDefinition") ; else if (node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration and the decorator
    // was written before the export, the export will be responsible
    // for printing the decorators.
    !(parentExportDecl && options.locStart(parentExportDecl, {
      ignoreDecorators: true
    }) > options.locStart(node.decorators[0]))) {
      var shouldBreak = node.type === "ClassExpression" || node.type === "ClassDeclaration" || hasNewlineBetweenOrAfterDecorators$1(node, options);
      var separator = shouldBreak ? hardline$9 : line$7;
      path.each(function (decoratorPath) {
        var decorator = decoratorPath.getValue();

        if (decorator.expression) {
          decorator = decorator.expression;
        } else {
          decorator = decorator.callee;
        }

        decorators.push(printPath(decoratorPath), separator);
      }, "decorators");

      if (parentExportDecl) {
        decorators.unshift(hardline$9);
      }
    } else if (isExportDeclaration$1(node) && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0 && // Only print decorators here if they were written before the export,
    // otherwise they are printed by the node.declaration
    options.locStart(node, {
      ignoreDecorators: true
    }) > options.locStart(node.declaration.decorators[0])) {
      // Export declarations are responsible for printing any decorators
      // that logically apply to node.declaration.
      path.each(function (decoratorPath) {
        var decorator = decoratorPath.getValue();
        var prefix = decorator.type === "Decorator" ? "" : "@";
        decorators.push(prefix, printPath(decoratorPath), hardline$9);
      }, "declaration", "decorators");
    } else {
      // Nodes with decorators can't have parentheses, so we can avoid
      // computing pathNeedsParens() except in this case.
      needsParens = needsParens_1(path, options);
    }

    var parts = [];

    if (needsParens) {
      parts.unshift("(");
    }

    parts.push(linesWithoutParens);

    if (needsParens) {
      var _node = path.getValue();

      if (hasFlowShorthandAnnotationComment$2(_node)) {
        parts.push(" /*");
        parts.push(_node.trailingComments[0].value.trimLeft());
        parts.push("*/");
        _node.trailingComments[0].printed = true;
      }

      parts.push(")");
    }

    if (decorators.length > 0) {
      return group$b(concat$d(decorators.concat(parts)));
    }

    return concat$d(parts);
  }

  function printDecorators(path, options, print) {
    var node = path.getValue();
    return group$b(concat$d([join$9(line$7, path.map(print, "decorators")), hasNewlineBetweenOrAfterDecorators$1(node, options) ? hardline$9 : line$7]));
  }
  /**
   * The following is the shared logic for
   * ternary operators, namely ConditionalExpression
   * and TSConditionalType
   * @typedef {Object} OperatorOptions
   * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.
   * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.
   * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.
   * @property {string} conditionalNodeType - The type of the conditional expression node, ie "ConditionalExpression" or "TSConditionalType".
   * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg "consequent".
   * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg "alternate".
   * @property {string} testNodePropertyName - The property at which the test node can be found on the main node, eg "test".
   * @property {boolean} breakNested - Whether to break all nested ternaries when one breaks.
   * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.
   * @param {Options} options - Prettier options
   * @param {Function} print - Print function to call recursively
   * @param {OperatorOptions} operatorOptions
   * @returns Doc
   */


  function printTernaryOperator(path, options, print, operatorOptions) {
    var node = path.getValue();
    var testNode = node[operatorOptions.testNodePropertyName];
    var consequentNode = node[operatorOptions.consequentNodePropertyName];
    var alternateNode = node[operatorOptions.alternateNodePropertyName];
    var parts = []; // We print a ConditionalExpression in either "JSX mode" or "normal mode".
    // See tests/jsx/conditional-expression.js for more info.

    var jsxMode = false;
    var parent = path.getParentNode();
    var forceNoIndent = parent.type === operatorOptions.conditionalNodeType; // Find the outermost non-ConditionalExpression parent, and the outermost
    // ConditionalExpression parent. We'll use these to determine if we should
    // print in JSX mode.

    var currentParent;
    var previousParent;
    var i = 0;

    do {
      previousParent = currentParent || node;
      currentParent = path.getParentNode(i);
      i++;
    } while (currentParent && currentParent.type === operatorOptions.conditionalNodeType);

    var firstNonConditionalParent = currentParent || parent;
    var lastConditionalParent = previousParent;

    if (operatorOptions.shouldCheckJsx && (isJSXNode$1(testNode) || isJSXNode$1(consequentNode) || isJSXNode$1(alternateNode) || conditionalExpressionChainContainsJSX$1(lastConditionalParent))) {
      jsxMode = true;
      forceNoIndent = true; // Even though they don't need parens, we wrap (almost) everything in
      // parens when using ?: within JSX, because the parens are analogous to
      // curly braces in an if statement.

      var wrap = function wrap(doc) {
        return concat$d([ifBreak$6("(", ""), indent$7(concat$d([softline$6, doc])), softline$6, ifBreak$6(")", "")]);
      }; // The only things we don't wrap are:
      // * Nested conditional expressions in alternates
      // * null


      var isNull = function isNull(node) {
        return node.type === "NullLiteral" || node.type === "Literal" && node.value === null;
      };

      parts.push(" ? ", isNull(consequentNode) ? path.call(print, operatorOptions.consequentNodePropertyName) : wrap(path.call(print, operatorOptions.consequentNodePropertyName)), " : ", alternateNode.type === operatorOptions.conditionalNodeType || isNull(alternateNode) ? path.call(print, operatorOptions.alternateNodePropertyName) : wrap(path.call(print, operatorOptions.alternateNodePropertyName)));
    } else {
      // normal mode
      var part = concat$d([line$7, "? ", consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak$6("", "(") : "", align$1(2, path.call(print, operatorOptions.consequentNodePropertyName)), consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak$6("", ")") : "", line$7, ": ", alternateNode.type === operatorOptions.conditionalNodeType ? path.call(print, operatorOptions.alternateNodePropertyName) : align$1(2, path.call(print, operatorOptions.alternateNodePropertyName))]);
      parts.push(parent.type !== operatorOptions.conditionalNodeType || parent[operatorOptions.alternateNodePropertyName] === node ? part : options.useTabs ? dedent$2(indent$7(part)) : align$1(Math.max(0, options.tabWidth - 2), part));
    } // We want a whole chain of ConditionalExpressions to all
    // break if any of them break. That means we should only group around the
    // outer-most ConditionalExpression.


    var maybeGroup = function maybeGroup(doc) {
      return operatorOptions.breakNested ? parent === firstNonConditionalParent ? group$b(doc) : doc : group$b(doc);
    }; // Break the closing paren to keep the chain right after it:
    // (a
    //   ? b
    //   : c
    // ).call()


    var breakClosingParen = !jsxMode && (parent.type === "MemberExpression" || parent.type === "OptionalMemberExpression" || parent.type === "NGPipeExpression" && parent.left === node && operatorOptions.breakNested) && !parent.computed;
    return maybeGroup(concat$d([].concat(function (testDoc) {
      return (
        /**
         *     a
         *       ? b
         *       : multiline
         *         test
         *         node
         *       ^^ align(2)
         *       ? d
         *       : e
         */
        parent.type === operatorOptions.conditionalNodeType && parent[operatorOptions.alternateNodePropertyName] === node ? align$1(2, testDoc) : testDoc
      );
    }(concat$d(operatorOptions.beforeParts())), forceNoIndent ? concat$d(parts) : indent$7(concat$d(parts)), operatorOptions.afterParts(breakClosingParen))));
  }

  function printPathNoParens(path, options, print, args) {
    var n = path.getValue();
    var semi = options.semi ? ";" : "";

    if (!n) {
      return "";
    }

    if (typeof n === "string") {
      return n;
    }

    var htmlBinding = printHtmlBinding$1(path, options, print);

    if (htmlBinding) {
      return htmlBinding;
    }

    var parts = [];

    switch (n.type) {
      case "JsExpressionRoot":
        return path.call(print, "node");

      case "JsonRoot":
        return concat$d([path.call(print, "node"), hardline$9]);

      case "File":
        // Print @babel/parser's InterpreterDirective here so that
        // leading comments on the `Program` node get printed after the hashbang.
        if (n.program && n.program.interpreter) {
          parts.push(path.call(function (programPath) {
            return programPath.call(print, "interpreter");
          }, "program"));
        }

        parts.push(path.call(print, "program"));
        return concat$d(parts);

      case "Program":
        // Babel 6
        if (n.directives) {
          path.each(function (childPath) {
            parts.push(print(childPath), semi, hardline$9);

            if (isNextLineEmpty$4(options.originalText, childPath.getValue(), options)) {
              parts.push(hardline$9);
            }
          }, "directives");
        }

        parts.push(path.call(function (bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        }, "body"));
        parts.push(comments.printDanglingComments(path, options,
        /* sameIndent */
        true)); // Only force a trailing newline if there were any contents.

        if (n.body.length || n.comments) {
          parts.push(hardline$9);
        }

        return concat$d(parts);
      // Babel extension.

      case "EmptyStatement":
        return "";

      case "ExpressionStatement":
        // Detect Flow-parsed directives
        if (n.directive) {
          return concat$d([nodeStr(n.expression, options, true), semi]);
        }

        if (options.parser === "__vue_event_binding") {
          var parent = path.getParentNode();

          if (parent.type === "Program" && parent.body.length === 1 && parent.body[0] === n) {
            return concat$d([path.call(print, "expression"), isVueEventBindingExpression$3(n.expression) ? ";" : ""]);
          }
        } // Do not append semicolon after the only JSX element in a program


        return concat$d([path.call(print, "expression"), isTheOnlyJSXElementInMarkdown$1(options, path) ? "" : semi]);
      // Babel extension.

      case "ParenthesizedExpression":
        return concat$d(["(", path.call(print, "expression"), ")"]);

      case "AssignmentExpression":
        return printAssignment(n.left, path.call(print, "left"), concat$d([" ", n.operator]), n.right, path.call(print, "right"), options);

      case "BinaryExpression":
      case "LogicalExpression":
      case "NGPipeExpression":
        {
          var _parent = path.getParentNode();

          var parentParent = path.getParentNode(1);
          var isInsideParenthesis = n !== _parent.body && (_parent.type === "IfStatement" || _parent.type === "WhileStatement" || _parent.type === "SwitchStatement" || _parent.type === "DoWhileStatement");

          var _parts = printBinaryishExpressions(path, print, options,
          /* isNested */
          false, isInsideParenthesis); //   if (
          //     this.hasPlugin("dynamicImports") && this.lookahead().type === tt.parenLeft
          //   ) {
          //
          // looks super weird, we want to break the children if the parent breaks
          //
          //   if (
          //     this.hasPlugin("dynamicImports") &&
          //     this.lookahead().type === tt.parenLeft
          //   ) {


          if (isInsideParenthesis) {
            return concat$d(_parts);
          } // Break between the parens in
          // unaries or in a member or specific call expression, i.e.
          //
          //   (
          //     a &&
          //     b &&
          //     c
          //   ).call()


          if ((_parent.type === "CallExpression" || _parent.type === "OptionalCallExpression") && _parent.callee === n || _parent.type === "UnaryExpression" || (_parent.type === "MemberExpression" || _parent.type === "OptionalMemberExpression") && !_parent.computed) {
            return group$b(concat$d([indent$7(concat$d([softline$6, concat$d(_parts)])), softline$6]));
          } // Avoid indenting sub-expressions in some cases where the first sub-expression is already
          // indented accordingly. We should indent sub-expressions where the first case isn't indented.


          var shouldNotIndent = _parent.type === "ReturnStatement" || _parent.type === "JSXExpressionContainer" && parentParent.type === "JSXAttribute" || n.type !== "NGPipeExpression" && (_parent.type === "NGRoot" && options.parser === "__ng_binding" || _parent.type === "NGMicrosyntaxExpression" && parentParent.type === "NGMicrosyntax" && parentParent.body.length === 1) || n === _parent.body && _parent.type === "ArrowFunctionExpression" || n !== _parent.body && _parent.type === "ForStatement" || _parent.type === "ConditionalExpression" && parentParent.type !== "ReturnStatement" && parentParent.type !== "CallExpression" && parentParent.type !== "OptionalCallExpression";
          var shouldIndentIfInlining = _parent.type === "AssignmentExpression" || _parent.type === "VariableDeclarator" || _parent.type === "ClassProperty" || _parent.type === "TSAbstractClassProperty" || _parent.type === "ClassPrivateProperty" || _parent.type === "ObjectProperty" || _parent.type === "Property";
          var samePrecedenceSubExpression = isBinaryish$1(n.left) && shouldFlatten$1(n.operator, n.left.operator);

          if (shouldNotIndent || shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(n) && shouldIndentIfInlining) {
            return group$b(concat$d(_parts));
          }

          if (_parts.length === 0) {
            return "";
          } // If the right part is a JSX node, we include it in a separate group to
          // prevent it breaking the whole chain, so we can print the expression like:
          //
          //   foo && bar && (
          //     <Foo>
          //       <Bar />
          //     </Foo>
          //   )


          var hasJSX = isJSXNode$1(n.right);
          var rest = concat$d(hasJSX ? _parts.slice(1, -1) : _parts.slice(1));
          var groupId = Symbol("logicalChain-" + ++uid);
          var chain = group$b(concat$d([// Don't include the initial expression in the indentation
          // level. The first item is guaranteed to be the first
          // left-most expression.
          _parts.length > 0 ? _parts[0] : "", indent$7(rest)]), {
            id: groupId
          });

          if (!hasJSX) {
            return chain;
          }

          var jsxPart = getLast$2(_parts);
          return group$b(concat$d([chain, ifBreak$6(indent$7(jsxPart), jsxPart, {
            groupId: groupId
          })]));
        }

      case "AssignmentPattern":
        return concat$d([path.call(print, "left"), " = ", path.call(print, "right")]);

      case "TSTypeAssertion":
        {
          var shouldBreakAfterCast = !(n.expression.type === "ArrayExpression" || n.expression.type === "ObjectExpression");
          var castGroup = group$b(concat$d(["<", indent$7(concat$d([softline$6, path.call(print, "typeAnnotation")])), softline$6, ">"]));
          var exprContents = concat$d([ifBreak$6("("), indent$7(concat$d([softline$6, path.call(print, "expression")])), softline$6, ifBreak$6(")")]);

          if (shouldBreakAfterCast) {
            return conditionalGroup$1([concat$d([castGroup, path.call(print, "expression")]), concat$d([castGroup, group$b(exprContents, {
              shouldBreak: true
            })]), concat$d([castGroup, path.call(print, "expression")])]);
          }

          return group$b(concat$d([castGroup, path.call(print, "expression")]));
        }

      case "OptionalMemberExpression":
      case "MemberExpression":
        {
          var _parent2 = path.getParentNode();

          var firstNonMemberParent;
          var i = 0;

          do {
            firstNonMemberParent = path.getParentNode(i);
            i++;
          } while (firstNonMemberParent && (firstNonMemberParent.type === "MemberExpression" || firstNonMemberParent.type === "OptionalMemberExpression" || firstNonMemberParent.type === "TSNonNullExpression"));

          var shouldInline = firstNonMemberParent && (firstNonMemberParent.type === "NewExpression" || firstNonMemberParent.type === "BindExpression" || firstNonMemberParent.type === "VariableDeclarator" && firstNonMemberParent.id.type !== "Identifier" || firstNonMemberParent.type === "AssignmentExpression" && firstNonMemberParent.left.type !== "Identifier") || n.computed || n.object.type === "Identifier" && n.property.type === "Identifier" && _parent2.type !== "MemberExpression" && _parent2.type !== "OptionalMemberExpression";
          return concat$d([path.call(print, "object"), shouldInline ? printMemberLookup(path, options, print) : group$b(indent$7(concat$d([softline$6, printMemberLookup(path, options, print)])))]);
        }

      case "MetaProperty":
        return concat$d([path.call(print, "meta"), ".", path.call(print, "property")]);

      case "BindExpression":
        if (n.object) {
          parts.push(path.call(print, "object"));
        }

        parts.push(group$b(indent$7(concat$d([softline$6, printBindExpressionCallee(path, options, print)]))));
        return concat$d(parts);

      case "Identifier":
        {
          return concat$d([n.name, printOptionalToken(path), printTypeAnnotation(path, options, print)]);
        }

      case "V8IntrinsicIdentifier":
        return concat$d(["%", n.name]);

      case "SpreadElement":
      case "SpreadElementPattern":
      case "RestProperty":
      case "SpreadProperty":
      case "SpreadPropertyPattern":
      case "RestElement":
      case "ObjectTypeSpreadProperty":
        return concat$d(["...", path.call(print, "argument"), printTypeAnnotation(path, options, print)]);

      case "FunctionDeclaration":
      case "FunctionExpression":
        parts.push(printFunctionDeclaration(path, print, options));

        if (!n.body) {
          parts.push(semi);
        }

        return concat$d(parts);

      case "ArrowFunctionExpression":
        {
          if (n.async) {
            parts.push("async ");
          }

          if (shouldPrintParamsWithoutParens(path, options)) {
            parts.push(path.call(print, "params", 0));
          } else {
            parts.push(group$b(concat$d([printFunctionParams(path, print, options,
            /* expandLast */
            args && (args.expandLastArg || args.expandFirstArg),
            /* printTypeParams */
            true), printReturnType(path, print, options)])));
          }

          var dangling = comments.printDanglingComments(path, options,
          /* sameIndent */
          true, function (comment) {
            var nextCharacter = getNextNonSpaceNonCommentCharacterIndex$2(options.originalText, comment, options);
            return options.originalText.substr(nextCharacter, 2) === "=>";
          });

          if (dangling) {
            parts.push(" ", dangling);
          }

          parts.push(" =>");
          var body = path.call(function (bodyPath) {
            return print(bodyPath, args);
          }, "body"); // We want to always keep these types of nodes on the same line
          // as the arrow.

          if (!hasLeadingOwnLineComment$1(options.originalText, n.body, options) && (n.body.type === "ArrayExpression" || n.body.type === "ObjectExpression" || n.body.type === "BlockStatement" || isJSXNode$1(n.body) || isTemplateOnItsOwnLine$1(n.body, options.originalText, options) || n.body.type === "ArrowFunctionExpression" || n.body.type === "DoExpression")) {
            return group$b(concat$d([concat$d(parts), " ", body]));
          } // We handle sequence expressions as the body of arrows specially,
          // so that the required parentheses end up on their own lines.


          if (n.body.type === "SequenceExpression") {
            return group$b(concat$d([concat$d(parts), group$b(concat$d([" (", indent$7(concat$d([softline$6, body])), softline$6, ")"]))]));
          } // if the arrow function is expanded as last argument, we are adding a
          // level of indentation and need to add a softline to align the closing )
          // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)
          // we should align the expression's closing } with the line with the opening {.


          var shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === "JSXExpressionContainer") && !(n.comments && n.comments.length);
          var printTrailingComma = args && args.expandLastArg && shouldPrintComma$1(options, "all"); // In order to avoid confusion between
          // a => a ? a : a
          // a <= a ? a : a

          var shouldAddParens = n.body.type === "ConditionalExpression" && !startsWithNoLookaheadToken$1(n.body,
          /* forbidFunctionAndClass */
          false);
          return group$b(concat$d([concat$d(parts), group$b(concat$d([indent$7(concat$d([line$7, shouldAddParens ? ifBreak$6("", "(") : "", body, shouldAddParens ? ifBreak$6("", ")") : ""])), shouldAddSoftLine ? concat$d([ifBreak$6(printTrailingComma ? "," : ""), softline$6]) : ""]))]));
        }

      case "YieldExpression":
        parts.push("yield");

        if (n.delegate) {
          parts.push("*");
        }

        if (n.argument) {
          parts.push(" ", path.call(print, "argument"));
        }

        return concat$d(parts);

      case "AwaitExpression":
        {
          parts.push("await ", path.call(print, "argument"));

          var _parent3 = path.getParentNode();

          if ((_parent3.type === "CallExpression" || _parent3.type === "OptionalCallExpression") && _parent3.callee === n || (_parent3.type === "MemberExpression" || _parent3.type === "OptionalMemberExpression") && _parent3.object === n) {
            return group$b(concat$d([indent$7(concat$d([softline$6, concat$d(parts)])), softline$6]));
          }

          return concat$d(parts);
        }

      case "ImportSpecifier":
        if (n.importKind) {
          parts.push(path.call(print, "importKind"), " ");
        }

        parts.push(path.call(print, "imported"));

        if (n.local && n.local.name !== n.imported.name) {
          parts.push(" as ", path.call(print, "local"));
        }

        return concat$d(parts);

      case "ExportSpecifier":
        parts.push(path.call(print, "local"));

        if (n.exported && n.exported.name !== n.local.name) {
          parts.push(" as ", path.call(print, "exported"));
        }

        return concat$d(parts);

      case "ImportNamespaceSpecifier":
        parts.push("* as ");
        parts.push(path.call(print, "local"));
        return concat$d(parts);

      case "ImportDefaultSpecifier":
        return path.call(print, "local");

      case "TSExportAssignment":
        return concat$d(["export = ", path.call(print, "expression"), semi]);

      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        return printExportDeclaration(path, options, print);

      case "ExportAllDeclaration":
        parts.push("export ");

        if (n.exportKind === "type") {
          parts.push("type ");
        }

        parts.push("* from ", path.call(print, "source"), semi);
        return concat$d(parts);

      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return path.call(print, "exported");

      case "ImportDeclaration":
        {
          parts.push("import ");

          if (n.importKind && n.importKind !== "value") {
            parts.push(n.importKind + " ");
          }

          var standalones = [];
          var grouped = [];

          if (n.specifiers && n.specifiers.length > 0) {
            path.each(function (specifierPath) {
              var value = specifierPath.getValue();

              if (value.type === "ImportDefaultSpecifier" || value.type === "ImportNamespaceSpecifier") {
                standalones.push(print(specifierPath));
              } else {
                grouped.push(print(specifierPath));
              }
            }, "specifiers");

            if (standalones.length > 0) {
              parts.push(join$9(", ", standalones));
            }

            if (standalones.length > 0 && grouped.length > 0) {
              parts.push(", ");
            }

            if (grouped.length === 1 && standalones.length === 0 && n.specifiers && !n.specifiers.some(function (node) {
              return node.comments;
            })) {
              parts.push(concat$d(["{", options.bracketSpacing ? " " : "", concat$d(grouped), options.bracketSpacing ? " " : "", "}"]));
            } else if (grouped.length >= 1) {
              parts.push(group$b(concat$d(["{", indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, join$9(concat$d([",", line$7]), grouped)])), ifBreak$6(shouldPrintComma$1(options) ? "," : ""), options.bracketSpacing ? line$7 : softline$6, "}"])));
            }

            parts.push(" from ");
          } else if (n.importKind && n.importKind === "type" || // import {} from 'x'
          /{\s*}/.test(options.originalText.slice(options.locStart(n), options.locStart(n.source)))) {
            parts.push("{} from ");
          }

          parts.push(path.call(print, "source"), semi);
          return concat$d(parts);
        }

      case "Import":
        return "import";

      case "TSModuleBlock":
      case "BlockStatement":
        {
          var naked = path.call(function (bodyPath) {
            return printStatementSequence(bodyPath, options, print);
          }, "body");
          var hasContent = n.body.find(function (node) {
            return node.type !== "EmptyStatement";
          });
          var hasDirectives = n.directives && n.directives.length > 0;

          var _parent4 = path.getParentNode();

          var _parentParent = path.getParentNode(1);

          if (!hasContent && !hasDirectives && !hasDanglingComments$1(n) && (_parent4.type === "ArrowFunctionExpression" || _parent4.type === "FunctionExpression" || _parent4.type === "FunctionDeclaration" || _parent4.type === "ObjectMethod" || _parent4.type === "ClassMethod" || _parent4.type === "ClassPrivateMethod" || _parent4.type === "ForStatement" || _parent4.type === "WhileStatement" || _parent4.type === "DoWhileStatement" || _parent4.type === "DoExpression" || _parent4.type === "CatchClause" && !_parentParent.finalizer || _parent4.type === "TSModuleDeclaration")) {
            return "{}";
          }

          parts.push("{"); // Babel 6

          if (hasDirectives) {
            path.each(function (childPath) {
              parts.push(indent$7(concat$d([hardline$9, print(childPath), semi])));

              if (isNextLineEmpty$4(options.originalText, childPath.getValue(), options)) {
                parts.push(hardline$9);
              }
            }, "directives");
          }

          if (hasContent) {
            parts.push(indent$7(concat$d([hardline$9, naked])));
          }

          parts.push(comments.printDanglingComments(path, options));
          parts.push(hardline$9, "}");
          return concat$d(parts);
        }

      case "ReturnStatement":
        parts.push("return");

        if (n.argument) {
          if (returnArgumentHasLeadingComment$1(options, n.argument)) {
            parts.push(concat$d([" (", indent$7(concat$d([hardline$9, path.call(print, "argument")])), hardline$9, ")"]));
          } else if (n.argument.type === "LogicalExpression" || n.argument.type === "BinaryExpression" || n.argument.type === "SequenceExpression") {
            parts.push(group$b(concat$d([ifBreak$6(" (", " "), indent$7(concat$d([softline$6, path.call(print, "argument")])), softline$6, ifBreak$6(")")])));
          } else {
            parts.push(" ", path.call(print, "argument"));
          }
        }

        if (hasDanglingComments$1(n)) {
          parts.push(" ", comments.printDanglingComments(path, options,
          /* sameIndent */
          true));
        }

        parts.push(semi);
        return concat$d(parts);

      case "NewExpression":
      case "OptionalCallExpression":
      case "CallExpression":
        {
          var isNew = n.type === "NewExpression";
          var optional = printOptionalToken(path);

          if ( // We want to keep CommonJS- and AMD-style require calls, and AMD-style
          // define calls, as a unit.
          // e.g. `define(["some/lib", (lib) => {`
          !isNew && n.callee.type === "Identifier" && (n.callee.name === "require" || n.callee.name === "define") || // Template literals as single arguments
          n.arguments.length === 1 && isTemplateOnItsOwnLine$1(n.arguments[0], options.originalText, options) || // Keep test declarations on a single line
          // e.g. `it('long name', () => {`
          !isNew && isTestCall$1(n, path.getParentNode())) {
            return concat$d([isNew ? "new " : "", path.call(print, "callee"), optional, printFunctionTypeParameters(path, options, print), concat$d(["(", join$9(", ", path.map(print, "arguments")), ")"])]);
          } // Inline Flow annotation comments following Identifiers in Call nodes need to
          // stay with the Identifier. For example:
          //
          // foo /*:: <SomeGeneric> */(bar);
          //
          // Here, we ensure that such comments stay between the Identifier and the Callee.


          var isIdentifierWithFlowAnnotation = n.callee.type === "Identifier" && hasFlowAnnotationComment$1(n.callee.trailingComments);

          if (isIdentifierWithFlowAnnotation) {
            n.callee.trailingComments[0].printed = true;
          } // We detect calls on member lookups and possibly print them in a
          // special chain format. See `printMemberChain` for more info.


          if (!isNew && isMemberish$1(n.callee)) {
            return printMemberChain(path, options, print);
          }

          var contents = concat$d([isNew ? "new " : "", path.call(print, "callee"), optional, isIdentifierWithFlowAnnotation ? "/*:: ".concat(n.callee.trailingComments[0].value.substring(2).trim(), " */") : "", printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]); // We group here when the callee is itself a call expression.
          // See `isLongCurriedCallExpression` for more info.

          if (isCallOrOptionalCallExpression$1(n.callee)) {
            return group$b(contents);
          }

          return contents;
        }

      case "TSInterfaceDeclaration":
        if (n.declare) {
          parts.push("declare ");
        }

        parts.push(n.abstract ? "abstract " : "", printTypeScriptModifiers(path, options, print), "interface ", path.call(print, "id"), n.typeParameters ? path.call(print, "typeParameters") : "", " ");

        if (n.extends && n.extends.length) {
          parts.push(group$b(indent$7(concat$d([softline$6, "extends ", (n.extends.length === 1 ? identity$2 : indent$7)(join$9(concat$d([",", line$7]), path.map(print, "extends"))), " "]))));
        }

        parts.push(path.call(print, "body"));
        return concat$d(parts);

      case "ObjectTypeInternalSlot":
        return concat$d([n.static ? "static " : "", "[[", path.call(print, "id"), "]]", printOptionalToken(path), n.method ? "" : ": ", path.call(print, "value")]);

      case "ObjectExpression":
      case "ObjectPattern":
      case "ObjectTypeAnnotation":
      case "TSInterfaceBody":
      case "TSTypeLiteral":
        {
          var propertiesField;

          if (n.type === "TSTypeLiteral") {
            propertiesField = "members";
          } else if (n.type === "TSInterfaceBody") {
            propertiesField = "body";
          } else {
            propertiesField = "properties";
          }

          var isTypeAnnotation = n.type === "ObjectTypeAnnotation";
          var fields = [];

          if (isTypeAnnotation) {
            fields.push("indexers", "callProperties", "internalSlots");
          }

          fields.push(propertiesField);
          var firstProperty = fields.map(function (field) {
            return n[field][0];
          }).sort(function (a, b) {
            return options.locStart(a) - options.locStart(b);
          })[0];

          var _parent5 = path.getParentNode(0);

          var isFlowInterfaceLikeBody = isTypeAnnotation && _parent5 && (_parent5.type === "InterfaceDeclaration" || _parent5.type === "DeclareInterface" || _parent5.type === "DeclareClass") && path.getName() === "body";
          var shouldBreak = n.type === "TSInterfaceBody" || isFlowInterfaceLikeBody || n.type === "ObjectPattern" && _parent5.type !== "FunctionDeclaration" && _parent5.type !== "FunctionExpression" && _parent5.type !== "ArrowFunctionExpression" && _parent5.type !== "ObjectMethod" && _parent5.type !== "ClassMethod" && _parent5.type !== "ClassPrivateMethod" && _parent5.type !== "AssignmentPattern" && _parent5.type !== "CatchClause" && n.properties.some(function (property) {
            return property.value && (property.value.type === "ObjectPattern" || property.value.type === "ArrayPattern");
          }) || n.type !== "ObjectPattern" && firstProperty && hasNewlineInRange$2(options.originalText, options.locStart(n), options.locStart(firstProperty));
          var separator = isFlowInterfaceLikeBody ? ";" : n.type === "TSInterfaceBody" || n.type === "TSTypeLiteral" ? ifBreak$6(semi, ";") : ",";
          var leftBrace = n.exact ? "{|" : "{";
          var rightBrace = n.exact ? "|}" : "}"; // Unfortunately, things are grouped together in the ast can be
          // interleaved in the source code. So we need to reorder them before
          // printing them.

          var propsAndLoc = [];
          fields.forEach(function (field) {
            path.each(function (childPath) {
              var node = childPath.getValue();
              propsAndLoc.push({
                node: node,
                printed: print(childPath),
                loc: options.locStart(node)
              });
            }, field);
          });
          var separatorParts = [];
          var props = propsAndLoc.sort(function (a, b) {
            return a.loc - b.loc;
          }).map(function (prop) {
            var result = concat$d(separatorParts.concat(group$b(prop.printed)));
            separatorParts = [separator, line$7];

            if ((prop.node.type === "TSPropertySignature" || prop.node.type === "TSMethodSignature" || prop.node.type === "TSConstructSignatureDeclaration") && hasNodeIgnoreComment$2(prop.node)) {
              separatorParts.shift();
            }

            if (isNextLineEmpty$4(options.originalText, prop.node, options)) {
              separatorParts.push(hardline$9);
            }

            return result;
          });

          if (n.inexact) {
            props.push(concat$d(separatorParts.concat(group$b("..."))));
          }

          var lastElem = getLast$2(n[propertiesField]);
          var canHaveTrailingSeparator = !(lastElem && (lastElem.type === "RestProperty" || lastElem.type === "RestElement" || hasNodeIgnoreComment$2(lastElem) || n.inexact));
          var content;

          if (props.length === 0) {
            if (!hasDanglingComments$1(n)) {
              return concat$d([leftBrace, rightBrace, printTypeAnnotation(path, options, print)]);
            }

            content = group$b(concat$d([leftBrace, comments.printDanglingComments(path, options), softline$6, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]));
          } else {
            content = concat$d([leftBrace, indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, concat$d(props)])), ifBreak$6(canHaveTrailingSeparator && (separator !== "," || shouldPrintComma$1(options)) ? separator : ""), concat$d([options.bracketSpacing ? line$7 : softline$6, rightBrace]), printOptionalToken(path), printTypeAnnotation(path, options, print)]);
          } // If we inline the object as first argument of the parent, we don't want
          // to create another group so that the object breaks before the return
          // type


          var parentParentParent = path.getParentNode(2);

          if (n.type === "ObjectPattern" && _parent5 && shouldHugArguments(_parent5) && !n.decorators && _parent5.params[0] === n || shouldHugType(n) && parentParentParent && shouldHugArguments(parentParentParent) && parentParentParent.params[0].typeAnnotation && parentParentParent.params[0].typeAnnotation.typeAnnotation === n) {
            return content;
          }

          return group$b(content, {
            shouldBreak: shouldBreak
          });
        }
      // Babel 6

      case "ObjectProperty": // Non-standard AST node type.

      case "Property":
        if (n.method || n.kind === "get" || n.kind === "set") {
          return printMethod(path, options, print);
        }

        if (n.shorthand) {
          parts.push(path.call(print, "value"));
        } else {
          parts.push(printAssignment(n.key, printPropertyKey(path, options, print), ":", n.value, path.call(print, "value"), options));
        }

        return concat$d(parts);
      // Babel 6

      case "ClassMethod":
      case "ClassPrivateMethod":
      case "MethodDefinition":
      case "TSAbstractMethodDefinition":
        if (n.decorators && n.decorators.length !== 0) {
          parts.push(printDecorators(path, options, print));
        }

        if (n.accessibility) {
          parts.push(n.accessibility + " ");
        }

        if (n.static) {
          parts.push("static ");
        }

        if (n.type === "TSAbstractMethodDefinition") {
          parts.push("abstract ");
        }

        parts.push(printMethod(path, options, print));
        return concat$d(parts);

      case "ObjectMethod":
        return printMethod(path, options, print);

      case "Decorator":
        return concat$d(["@", path.call(print, "expression"), path.call(print, "callee")]);

      case "ArrayExpression":
      case "ArrayPattern":
        if (n.elements.length === 0) {
          if (!hasDanglingComments$1(n)) {
            parts.push("[]");
          } else {
            parts.push(group$b(concat$d(["[", comments.printDanglingComments(path, options), softline$6, "]"])));
          }
        } else {
          var _lastElem = getLast$2(n.elements);

          var canHaveTrailingComma = !(_lastElem && _lastElem.type === "RestElement"); // JavaScript allows you to have empty elements in an array which
          // changes its length based on the number of commas. The algorithm
          // is that if the last argument is null, we need to force insert
          // a comma to ensure JavaScript recognizes it.
          //   [,].length === 1
          //   [1,].length === 1
          //   [1,,].length === 2
          //
          // Note that getLast returns null if the array is empty, but
          // we already check for an empty array just above so we are safe

          var needsForcedTrailingComma = canHaveTrailingComma && _lastElem === null;

          var _shouldBreak = n.elements.length > 1 && n.elements.every(function (element, i, elements) {
            var elementType = element && element.type;

            if (elementType !== "ArrayExpression" && elementType !== "ObjectExpression") {
              return false;
            }

            var nextElement = elements[i + 1];

            if (nextElement && elementType !== nextElement.type) {
              return false;
            }

            var itemsKey = elementType === "ArrayExpression" ? "elements" : "properties";
            return element[itemsKey] && element[itemsKey].length > 1;
          });

          parts.push(group$b(concat$d(["[", indent$7(concat$d([softline$6, printArrayItems(path, options, "elements", print)])), needsForcedTrailingComma ? "," : "", ifBreak$6(canHaveTrailingComma && !needsForcedTrailingComma && shouldPrintComma$1(options) ? "," : ""), comments.printDanglingComments(path, options,
          /* sameIndent */
          true), softline$6, "]"]), {
            shouldBreak: _shouldBreak
          }));
        }

        parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));
        return concat$d(parts);

      case "SequenceExpression":
        {
          var _parent6 = path.getParentNode(0);

          if (_parent6.type === "ExpressionStatement" || _parent6.type === "ForStatement") {
            // For ExpressionStatements and for-loop heads, which are among
            // the few places a SequenceExpression appears unparenthesized, we want
            // to indent expressions after the first.
            var _parts2 = [];
            path.each(function (p) {
              if (p.getName() === 0) {
                _parts2.push(print(p));
              } else {
                _parts2.push(",", indent$7(concat$d([line$7, print(p)])));
              }
            }, "expressions");
            return group$b(concat$d(_parts2));
          }

          return group$b(concat$d([join$9(concat$d([",", line$7]), path.map(print, "expressions"))]));
        }

      case "ThisExpression":
        return "this";

      case "Super":
        return "super";

      case "NullLiteral":
        // Babel 6 Literal split
        return "null";

      case "RegExpLiteral":
        // Babel 6 Literal split
        return printRegex(n);

      case "NumericLiteral":
        // Babel 6 Literal split
        return printNumber$2(n.extra.raw);

      case "BigIntLiteral":
        // babel: n.extra.raw, typescript: n.raw, flow: n.bigint
        return (n.bigint || (n.extra ? n.extra.raw : n.raw)).toLowerCase();

      case "BooleanLiteral": // Babel 6 Literal split

      case "StringLiteral": // Babel 6 Literal split

      case "Literal":
        {
          if (n.regex) {
            return printRegex(n.regex);
          }

          if (typeof n.value === "number") {
            return printNumber$2(n.raw);
          }

          if (typeof n.value !== "string") {
            return "" + n.value;
          } // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2
          // See corresponding workaround in needs-parens.js


          var grandParent = path.getParentNode(1);
          var isTypeScriptDirective = options.parser === "typescript" && typeof n.value === "string" && grandParent && (grandParent.type === "Program" || grandParent.type === "BlockStatement");
          return nodeStr(n, options, isTypeScriptDirective);
        }

      case "Directive":
        return path.call(print, "value");
      // Babel 6

      case "DirectiveLiteral":
        return nodeStr(n, options);

      case "UnaryExpression":
        parts.push(n.operator);

        if (/[a-z]$/.test(n.operator)) {
          parts.push(" ");
        }

        if (n.argument.comments && n.argument.comments.length > 0) {
          parts.push(group$b(concat$d(["(", indent$7(concat$d([softline$6, path.call(print, "argument")])), softline$6, ")"])));
        } else {
          parts.push(path.call(print, "argument"));
        }

        return concat$d(parts);

      case "UpdateExpression":
        parts.push(path.call(print, "argument"), n.operator);

        if (n.prefix) {
          parts.reverse();
        }

        return concat$d(parts);

      case "ConditionalExpression":
        return printTernaryOperator(path, options, print, {
          beforeParts: function beforeParts() {
            return [path.call(print, "test")];
          },
          afterParts: function afterParts(breakClosingParen) {
            return [breakClosingParen ? softline$6 : ""];
          },
          shouldCheckJsx: true,
          conditionalNodeType: "ConditionalExpression",
          consequentNodePropertyName: "consequent",
          alternateNodePropertyName: "alternate",
          testNodePropertyName: "test",
          breakNested: true
        });

      case "VariableDeclaration":
        {
          var printed = path.map(function (childPath) {
            return print(childPath);
          }, "declarations"); // We generally want to terminate all variable declarations with a
          // semicolon, except when they in the () part of for loops.

          var parentNode = path.getParentNode();
          var isParentForLoop = parentNode.type === "ForStatement" || parentNode.type === "ForInStatement" || parentNode.type === "ForOfStatement" || parentNode.type === "ForAwaitStatement";
          var hasValue = n.declarations.some(function (decl) {
            return decl.init;
          });
          var firstVariable;

          if (printed.length === 1 && !n.declarations[0].comments) {
            firstVariable = printed[0];
          } else if (printed.length > 0) {
            // Indent first var to comply with eslint one-var rule
            firstVariable = indent$7(printed[0]);
          }

          parts = [n.declare ? "declare " : "", n.kind, firstVariable ? concat$d([" ", firstVariable]) : "", indent$7(concat$d(printed.slice(1).map(function (p) {
            return concat$d([",", hasValue && !isParentForLoop ? hardline$9 : line$7, p]);
          })))];

          if (!(isParentForLoop && parentNode.body !== n)) {
            parts.push(semi);
          }

          return group$b(concat$d(parts));
        }

      case "TSTypeAliasDeclaration":
        {
          if (n.declare) {
            parts.push("declare ");
          }

          var _printed = printAssignmentRight(n.id, n.typeAnnotation, n.typeAnnotation && path.call(print, "typeAnnotation"), options);

          parts.push("type ", path.call(print, "id"), path.call(print, "typeParameters"), " =", _printed, semi);
          return group$b(concat$d(parts));
        }

      case "VariableDeclarator":
        return printAssignment(n.id, path.call(print, "id"), " =", n.init, n.init && path.call(print, "init"), options);

      case "WithStatement":
        return group$b(concat$d(["with (", path.call(print, "object"), ")", adjustClause(n.body, path.call(print, "body"))]));

      case "IfStatement":
        {
          var con = adjustClause(n.consequent, path.call(print, "consequent"));
          var opening = group$b(concat$d(["if (", group$b(concat$d([indent$7(concat$d([softline$6, path.call(print, "test")])), softline$6])), ")", con]));
          parts.push(opening);

          if (n.alternate) {
            var commentOnOwnLine = hasTrailingComment$1(n.consequent) && n.consequent.comments.some(function (comment) {
              return comment.trailing && !comments$1.isBlockComment(comment);
            }) || needsHardlineAfterDanglingComment$1(n);
            var elseOnSameLine = n.consequent.type === "BlockStatement" && !commentOnOwnLine;
            parts.push(elseOnSameLine ? " " : hardline$9);

            if (hasDanglingComments$1(n)) {
              parts.push(comments.printDanglingComments(path, options, true), commentOnOwnLine ? hardline$9 : " ");
            }

            parts.push("else", group$b(adjustClause(n.alternate, path.call(print, "alternate"), n.alternate.type === "IfStatement")));
          }

          return concat$d(parts);
        }

      case "ForStatement":
        {
          var _body = adjustClause(n.body, path.call(print, "body")); // We want to keep dangling comments above the loop to stay consistent.
          // Any comment positioned between the for statement and the parentheses
          // is going to be printed before the statement.


          var _dangling = comments.printDanglingComments(path, options,
          /* sameLine */
          true);

          var printedComments = _dangling ? concat$d([_dangling, softline$6]) : "";

          if (!n.init && !n.test && !n.update) {
            return concat$d([printedComments, group$b(concat$d(["for (;;)", _body]))]);
          }

          return concat$d([printedComments, group$b(concat$d(["for (", group$b(concat$d([indent$7(concat$d([softline$6, path.call(print, "init"), ";", line$7, path.call(print, "test"), ";", line$7, path.call(print, "update")])), softline$6])), ")", _body]))]);
        }

      case "WhileStatement":
        return group$b(concat$d(["while (", group$b(concat$d([indent$7(concat$d([softline$6, path.call(print, "test")])), softline$6])), ")", adjustClause(n.body, path.call(print, "body"))]));

      case "ForInStatement":
        // Note: esprima can't actually parse "for each (".
        return group$b(concat$d([n.each ? "for each (" : "for (", path.call(print, "left"), " in ", path.call(print, "right"), ")", adjustClause(n.body, path.call(print, "body"))]));

      case "ForOfStatement":
      case "ForAwaitStatement":
        {
          // Babel 7 removed ForAwaitStatement in favor of ForOfStatement
          // with `"await": true`:
          // https://github.com/estree/estree/pull/138
          var isAwait = n.type === "ForAwaitStatement" || n.await;
          return group$b(concat$d(["for", isAwait ? " await" : "", " (", path.call(print, "left"), " of ", path.call(print, "right"), ")", adjustClause(n.body, path.call(print, "body"))]));
        }

      case "DoWhileStatement":
        {
          var clause = adjustClause(n.body, path.call(print, "body"));
          var doBody = group$b(concat$d(["do", clause]));
          parts = [doBody];

          if (n.body.type === "BlockStatement") {
            parts.push(" ");
          } else {
            parts.push(hardline$9);
          }

          parts.push("while (");
          parts.push(group$b(concat$d([indent$7(concat$d([softline$6, path.call(print, "test")])), softline$6])), ")", semi);
          return concat$d(parts);
        }

      case "DoExpression":
        return concat$d(["do ", path.call(print, "body")]);

      case "BreakStatement":
        parts.push("break");

        if (n.label) {
          parts.push(" ", path.call(print, "label"));
        }

        parts.push(semi);
        return concat$d(parts);

      case "ContinueStatement":
        parts.push("continue");

        if (n.label) {
          parts.push(" ", path.call(print, "label"));
        }

        parts.push(semi);
        return concat$d(parts);

      case "LabeledStatement":
        if (n.body.type === "EmptyStatement") {
          return concat$d([path.call(print, "label"), ":;"]);
        }

        return concat$d([path.call(print, "label"), ": ", path.call(print, "body")]);

      case "TryStatement":
        return concat$d(["try ", path.call(print, "block"), n.handler ? concat$d([" ", path.call(print, "handler")]) : "", n.finalizer ? concat$d([" finally ", path.call(print, "finalizer")]) : ""]);

      case "CatchClause":
        if (n.param) {
          var hasComments = n.param.comments && n.param.comments.some(function (comment) {
            return !comments$1.isBlockComment(comment) || comment.leading && hasNewline$4(options.originalText, options.locEnd(comment)) || comment.trailing && hasNewline$4(options.originalText, options.locStart(comment), {
              backwards: true
            });
          });
          var param = path.call(print, "param");
          return concat$d(["catch ", hasComments ? concat$d(["(", indent$7(concat$d([softline$6, param])), softline$6, ") "]) : concat$d(["(", param, ") "]), path.call(print, "body")]);
        }

        return concat$d(["catch ", path.call(print, "body")]);

      case "ThrowStatement":
        return concat$d(["throw ", path.call(print, "argument"), semi]);
      // Note: ignoring n.lexical because it has no printing consequences.

      case "SwitchStatement":
        return concat$d([group$b(concat$d(["switch (", indent$7(concat$d([softline$6, path.call(print, "discriminant")])), softline$6, ")"])), " {", n.cases.length > 0 ? indent$7(concat$d([hardline$9, join$9(hardline$9, path.map(function (casePath) {
          var caseNode = casePath.getValue();
          return concat$d([casePath.call(print), n.cases.indexOf(caseNode) !== n.cases.length - 1 && isNextLineEmpty$4(options.originalText, caseNode, options) ? hardline$9 : ""]);
        }, "cases"))])) : "", hardline$9, "}"]);

      case "SwitchCase":
        {
          if (n.test) {
            parts.push("case ", path.call(print, "test"), ":");
          } else {
            parts.push("default:");
          }

          var consequent = n.consequent.filter(function (node) {
            return node.type !== "EmptyStatement";
          });

          if (consequent.length > 0) {
            var cons = path.call(function (consequentPath) {
              return printStatementSequence(consequentPath, options, print);
            }, "consequent");
            parts.push(consequent.length === 1 && consequent[0].type === "BlockStatement" ? concat$d([" ", cons]) : indent$7(concat$d([hardline$9, cons])));
          }

          return concat$d(parts);
        }
      // JSX extensions below.

      case "DebuggerStatement":
        return concat$d(["debugger", semi]);

      case "JSXAttribute":
        parts.push(path.call(print, "name"));

        if (n.value) {
          var res;

          if (isStringLiteral$1(n.value)) {
            var raw = rawText$1(n.value); // Unescape all quotes so we get an accurate preferred quote

            var final = raw.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
            var quote = getPreferredQuote$1(final, options.jsxSingleQuote ? "'" : '"');

            var _escape = quote === "'" ? "&apos;" : "&quot;";

            final = final.slice(1, -1).replace(new RegExp(quote, "g"), _escape);
            res = concat$d([quote, final, quote]);
          } else {
            res = path.call(print, "value");
          }

          parts.push("=", res);
        }

        return concat$d(parts);

      case "JSXIdentifier":
        return "" + n.name;

      case "JSXNamespacedName":
        return join$9(":", [path.call(print, "namespace"), path.call(print, "name")]);

      case "JSXMemberExpression":
        return join$9(".", [path.call(print, "object"), path.call(print, "property")]);

      case "TSQualifiedName":
        return join$9(".", [path.call(print, "left"), path.call(print, "right")]);

      case "JSXSpreadAttribute":
      case "JSXSpreadChild":
        {
          return concat$d(["{", path.call(function (p) {
            var printed = concat$d(["...", print(p)]);
            var n = p.getValue();

            if (!n.comments || !n.comments.length) {
              return printed;
            }

            return concat$d([indent$7(concat$d([softline$6, comments.printComments(p, function () {
              return printed;
            }, options)])), softline$6]);
          }, n.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"]);
        }

      case "JSXExpressionContainer":
        {
          var _parent7 = path.getParentNode(0);

          var preventInline = _parent7.type === "JSXAttribute" && n.expression.comments && n.expression.comments.length > 0;

          var _shouldInline = !preventInline && (n.expression.type === "ArrayExpression" || n.expression.type === "ObjectExpression" || n.expression.type === "ArrowFunctionExpression" || n.expression.type === "CallExpression" || n.expression.type === "OptionalCallExpression" || n.expression.type === "FunctionExpression" || n.expression.type === "JSXEmptyExpression" || n.expression.type === "TemplateLiteral" || n.expression.type === "TaggedTemplateExpression" || n.expression.type === "DoExpression" || isJSXNode$1(_parent7) && (n.expression.type === "ConditionalExpression" || isBinaryish$1(n.expression)));

          if (_shouldInline) {
            return group$b(concat$d(["{", path.call(print, "expression"), lineSuffixBoundary$1, "}"]));
          }

          return group$b(concat$d(["{", indent$7(concat$d([softline$6, path.call(print, "expression")])), softline$6, lineSuffixBoundary$1, "}"]));
        }

      case "JSXFragment":
      case "JSXElement":
        {
          var elem = comments.printComments(path, function () {
            return printJSXElement(path, options, print);
          }, options);
          return maybeWrapJSXElementInParens(path, elem, options);
        }

      case "JSXOpeningElement":
        {
          var _n = path.getValue();

          var nameHasComments = _n.name && _n.name.comments && _n.name.comments.length > 0 || _n.typeParameters && _n.typeParameters.comments && _n.typeParameters.comments.length > 0; // Don't break self-closing elements with no attributes and no comments

          if (_n.selfClosing && !_n.attributes.length && !nameHasComments) {
            return concat$d(["<", path.call(print, "name"), path.call(print, "typeParameters"), " />"]);
          } // don't break up opening elements with a single long text attribute


          if (_n.attributes && _n.attributes.length === 1 && _n.attributes[0].value && isStringLiteral$1(_n.attributes[0].value) && !_n.attributes[0].value.value.includes("\n") && // We should break for the following cases:
          // <div
          //   // comment
          //   attr="value"
          // >
          // <div
          //   attr="value"
          //   // comment
          // >
          !nameHasComments && (!_n.attributes[0].comments || !_n.attributes[0].comments.length)) {
            return group$b(concat$d(["<", path.call(print, "name"), path.call(print, "typeParameters"), " ", concat$d(path.map(print, "attributes")), _n.selfClosing ? " />" : ">"]));
          }

          var lastAttrHasTrailingComments = _n.attributes.length && hasTrailingComment$1(getLast$2(_n.attributes));
          var bracketSameLine = // Simple tags (no attributes and no comment in tag name) should be
          // kept unbroken regardless of `jsxBracketSameLine`
          !_n.attributes.length && !nameHasComments || options.jsxBracketSameLine && ( // We should print the bracket in a new line for the following cases:
          // <div
          //   // comment
          // >
          // <div
          //   attr // comment
          // >
          !nameHasComments || _n.attributes.length) && !lastAttrHasTrailingComments; // We should print the opening element expanded if any prop value is a
          // string literal with newlines

          var _shouldBreak2 = _n.attributes && _n.attributes.some(function (attr) {
            return attr.value && isStringLiteral$1(attr.value) && attr.value.value.includes("\n");
          });

          return group$b(concat$d(["<", path.call(print, "name"), path.call(print, "typeParameters"), concat$d([indent$7(concat$d(path.map(function (attr) {
            return concat$d([line$7, print(attr)]);
          }, "attributes"))), _n.selfClosing ? line$7 : bracketSameLine ? ">" : softline$6]), _n.selfClosing ? "/>" : bracketSameLine ? "" : ">"]), {
            shouldBreak: _shouldBreak2
          });
        }

      case "JSXClosingElement":
        return concat$d(["</", path.call(print, "name"), ">"]);

      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        {
          var hasComment = n.comments && n.comments.length;
          var hasOwnLineComment = hasComment && !n.comments.every(comments$1.isBlockComment);
          var isOpeningFragment = n.type === "JSXOpeningFragment";
          return concat$d([isOpeningFragment ? "<" : "</", indent$7(concat$d([hasOwnLineComment ? hardline$9 : hasComment && !isOpeningFragment ? " " : "", comments.printDanglingComments(path, options, true)])), hasOwnLineComment ? hardline$9 : "", ">"]);
        }

      case "JSXText":
        /* istanbul ignore next */
        throw new Error("JSXTest should be handled by JSXElement");

      case "JSXEmptyExpression":
        {
          var requiresHardline = n.comments && !n.comments.every(comments$1.isBlockComment);
          return concat$d([comments.printDanglingComments(path, options,
          /* sameIndent */
          !requiresHardline), requiresHardline ? hardline$9 : ""]);
        }

      case "ClassBody":
        if (!n.comments && n.body.length === 0) {
          return "{}";
        }

        return concat$d(["{", n.body.length > 0 ? indent$7(concat$d([hardline$9, path.call(function (bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        }, "body")])) : comments.printDanglingComments(path, options), hardline$9, "}"]);

      case "ClassProperty":
      case "TSAbstractClassProperty":
      case "ClassPrivateProperty":
        {
          if (n.decorators && n.decorators.length !== 0) {
            parts.push(printDecorators(path, options, print));
          }

          if (n.accessibility) {
            parts.push(n.accessibility + " ");
          }

          if (n.declare) {
            parts.push("declare ");
          }

          if (n.static) {
            parts.push("static ");
          }

          if (n.type === "TSAbstractClassProperty") {
            parts.push("abstract ");
          }

          if (n.readonly) {
            parts.push("readonly ");
          }

          var variance = getFlowVariance$1(n);

          if (variance) {
            parts.push(variance);
          }

          parts.push(printPropertyKey(path, options, print), printOptionalToken(path), printTypeAnnotation(path, options, print));

          if (n.value) {
            parts.push(" =", printAssignmentRight(n.key, n.value, path.call(print, "value"), options));
          }

          parts.push(semi);
          return group$b(concat$d(parts));
        }

      case "ClassDeclaration":
      case "ClassExpression":
        if (n.declare) {
          parts.push("declare ");
        }

        parts.push(concat$d(printClass(path, options, print)));
        return concat$d(parts);

      case "TSInterfaceHeritage":
        parts.push(path.call(print, "expression"));

        if (n.typeParameters) {
          parts.push(path.call(print, "typeParameters"));
        }

        return concat$d(parts);

      case "TemplateElement":
        return join$9(literalline$4, n.value.raw.split(/\r?\n/g));

      case "TemplateLiteral":
        {
          var expressions = path.map(print, "expressions");

          var _parentNode = path.getParentNode();

          if (isJestEachTemplateLiteral$1(n, _parentNode)) {
            var _printed2 = printJestEachTemplateLiteral(n, expressions, options);

            if (_printed2) {
              return _printed2;
            }
          }

          var isSimple = isSimpleTemplateLiteral$1(n);

          if (isSimple) {
            expressions = expressions.map(function (doc) {
              return printDocToString$1(doc, Object.assign({}, options, {
                printWidth: Infinity
              })).formatted;
            });
          }

          parts.push(lineSuffixBoundary$1, "`");
          path.each(function (childPath) {
            var i = childPath.getName();
            parts.push(print(childPath));

            if (i < expressions.length) {
              // For a template literal of the following form:
              //   `someQuery {
              //     ${call({
              //       a,
              //       b,
              //     })}
              //   }`
              // the expression is on its own line (there is a \n in the previous
              // quasi literal), therefore we want to indent the JavaScript
              // expression inside at the beginning of ${ instead of the beginning
              // of the `.
              var tabWidth = options.tabWidth;
              var quasi = childPath.getValue();
              var indentSize = getIndentSize$1(quasi.value.raw, tabWidth);
              var _printed3 = expressions[i];

              if (!isSimple) {
                // Breaks at the template element boundaries (${ and }) are preferred to breaking
                // in the middle of a MemberExpression
                if (n.expressions[i].comments && n.expressions[i].comments.length || n.expressions[i].type === "MemberExpression" || n.expressions[i].type === "OptionalMemberExpression" || n.expressions[i].type === "ConditionalExpression") {
                  _printed3 = concat$d([indent$7(concat$d([softline$6, _printed3])), softline$6]);
                }
              }

              var aligned = indentSize === 0 && quasi.value.raw.endsWith("\n") ? align$1(-Infinity, _printed3) : addAlignmentToDoc$2(_printed3, indentSize, tabWidth);
              parts.push(group$b(concat$d(["${", aligned, lineSuffixBoundary$1, "}"])));
            }
          }, "quasis");
          parts.push("`");
          return concat$d(parts);
        }
      // These types are unprintable because they serve as abstract
      // supertypes for other (printable) types.

      case "TaggedTemplateExpression":
        return concat$d([path.call(print, "tag"), path.call(print, "typeParameters"), path.call(print, "quasi")]);

      case "Node":
      case "Printable":
      case "SourceLocation":
      case "Position":
      case "Statement":
      case "Function":
      case "Pattern":
      case "Expression":
      case "Declaration":
      case "Specifier":
      case "NamedSpecifier":
      case "Comment":
      case "MemberTypeAnnotation": // Flow

      case "Type":
        /* istanbul ignore next */
        throw new Error("unprintable type: " + JSON.stringify(n.type));
      // Type Annotations for Facebook Flow, typically stripped out or
      // transformed away before printing.

      case "TypeAnnotation":
      case "TSTypeAnnotation":
        if (n.typeAnnotation) {
          return path.call(print, "typeAnnotation");
        }
        /* istanbul ignore next */


        return "";

      case "TSTupleType":
      case "TupleTypeAnnotation":
        {
          var typesField = n.type === "TSTupleType" ? "elementTypes" : "types";
          return group$b(concat$d(["[", indent$7(concat$d([softline$6, printArrayItems(path, options, typesField, print)])), ifBreak$6(shouldPrintComma$1(options, "all") ? "," : ""), comments.printDanglingComments(path, options,
          /* sameIndent */
          true), softline$6, "]"]));
        }

      case "ExistsTypeAnnotation":
        return "*";

      case "EmptyTypeAnnotation":
        return "empty";

      case "AnyTypeAnnotation":
        return "any";

      case "MixedTypeAnnotation":
        return "mixed";

      case "ArrayTypeAnnotation":
        return concat$d([path.call(print, "elementType"), "[]"]);

      case "BooleanTypeAnnotation":
        return "boolean";

      case "BooleanLiteralTypeAnnotation":
        return "" + n.value;

      case "DeclareClass":
        return printFlowDeclaration(path, printClass(path, options, print));

      case "TSDeclareFunction":
        // For TypeScript the TSDeclareFunction node shares the AST
        // structure with FunctionDeclaration
        return concat$d([n.declare ? "declare " : "", printFunctionDeclaration(path, print, options), semi]);

      case "DeclareFunction":
        return printFlowDeclaration(path, ["function ", path.call(print, "id"), n.predicate ? " " : "", path.call(print, "predicate"), semi]);

      case "DeclareModule":
        return printFlowDeclaration(path, ["module ", path.call(print, "id"), " ", path.call(print, "body")]);

      case "DeclareModuleExports":
        return printFlowDeclaration(path, ["module.exports", ": ", path.call(print, "typeAnnotation"), semi]);

      case "DeclareVariable":
        return printFlowDeclaration(path, ["var ", path.call(print, "id"), semi]);

      case "DeclareExportAllDeclaration":
        return concat$d(["declare export * from ", path.call(print, "source")]);

      case "DeclareExportDeclaration":
        return concat$d(["declare ", printExportDeclaration(path, options, print)]);

      case "DeclareOpaqueType":
      case "OpaqueType":
        {
          parts.push("opaque type ", path.call(print, "id"), path.call(print, "typeParameters"));

          if (n.supertype) {
            parts.push(": ", path.call(print, "supertype"));
          }

          if (n.impltype) {
            parts.push(" = ", path.call(print, "impltype"));
          }

          parts.push(semi);

          if (n.type === "DeclareOpaqueType") {
            return printFlowDeclaration(path, parts);
          }

          return concat$d(parts);
        }

      case "EnumDeclaration":
        return concat$d(["enum ", path.call(print, "id"), " ", path.call(print, "body")]);

      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        {
          if (n.type === "EnumSymbolBody" || n.explicitType) {
            var type = null;

            switch (n.type) {
              case "EnumBooleanBody":
                type = "boolean";
                break;

              case "EnumNumberBody":
                type = "number";
                break;

              case "EnumStringBody":
                type = "string";
                break;

              case "EnumSymbolBody":
                type = "symbol";
                break;
            }

            parts.push("of ", type, " ");
          }

          if (n.members.length === 0) {
            parts.push(group$b(concat$d(["{", comments.printDanglingComments(path, options), softline$6, "}"])));
          } else {
            parts.push(group$b(concat$d(["{", indent$7(concat$d([hardline$9, printArrayItems(path, options, "members", print), shouldPrintComma$1(options) ? "," : ""])), comments.printDanglingComments(path, options,
            /* sameIndent */
            true), hardline$9, "}"])));
          }

          return concat$d(parts);
        }

      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
        return concat$d([path.call(print, "id"), " = ", _typeof(n.init) === "object" ? path.call(print, "init") : String(n.init)]);

      case "EnumDefaultedMember":
        return path.call(print, "id");

      case "FunctionTypeAnnotation":
      case "TSFunctionType":
        {
          // FunctionTypeAnnotation is ambiguous:
          // declare function foo(a: B): void; OR
          // var A: (a: B) => void;
          var _parent8 = path.getParentNode(0);

          var _parentParent2 = path.getParentNode(1);

          var _parentParentParent = path.getParentNode(2);

          var isArrowFunctionTypeAnnotation = n.type === "TSFunctionType" || !((_parent8.type === "ObjectTypeProperty" || _parent8.type === "ObjectTypeInternalSlot") && !getFlowVariance$1(_parent8) && !_parent8.optional && options.locStart(_parent8) === options.locStart(n) || _parent8.type === "ObjectTypeCallProperty" || _parentParentParent && _parentParentParent.type === "DeclareFunction");
          var needsColon = isArrowFunctionTypeAnnotation && (_parent8.type === "TypeAnnotation" || _parent8.type === "TSTypeAnnotation"); // Sadly we can't put it inside of FastPath::needsColon because we are
          // printing ":" as part of the expression and it would put parenthesis
          // around :(

          var needsParens = needsColon && isArrowFunctionTypeAnnotation && (_parent8.type === "TypeAnnotation" || _parent8.type === "TSTypeAnnotation") && _parentParent2.type === "ArrowFunctionExpression";

          if (isObjectTypePropertyAFunction$1(_parent8, options)) {
            isArrowFunctionTypeAnnotation = true;
            needsColon = true;
          }

          if (needsParens) {
            parts.push("(");
          }

          parts.push(printFunctionParams(path, print, options,
          /* expandArg */
          false,
          /* printTypeParams */
          true)); // The returnType is not wrapped in a TypeAnnotation, so the colon
          // needs to be added separately.

          if (n.returnType || n.predicate || n.typeAnnotation) {
            parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path.call(print, "returnType"), path.call(print, "predicate"), path.call(print, "typeAnnotation"));
          }

          if (needsParens) {
            parts.push(")");
          }

          return group$b(concat$d(parts));
        }

      case "TSRestType":
        return concat$d(["...", path.call(print, "typeAnnotation")]);

      case "TSOptionalType":
        return concat$d([path.call(print, "typeAnnotation"), "?"]);

      case "FunctionTypeParam":
        return concat$d([path.call(print, "name"), printOptionalToken(path), n.name ? ": " : "", path.call(print, "typeAnnotation")]);

      case "GenericTypeAnnotation":
        return concat$d([path.call(print, "id"), path.call(print, "typeParameters")]);

      case "DeclareInterface":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
        {
          if (n.type === "DeclareInterface" || n.declare) {
            parts.push("declare ");
          }

          parts.push("interface");

          if (n.type === "DeclareInterface" || n.type === "InterfaceDeclaration") {
            parts.push(" ", path.call(print, "id"), path.call(print, "typeParameters"));
          }

          if (n["extends"].length > 0) {
            parts.push(group$b(indent$7(concat$d([line$7, "extends ", (n.extends.length === 1 ? identity$2 : indent$7)(join$9(concat$d([",", line$7]), path.map(print, "extends")))]))));
          }

          parts.push(" ", path.call(print, "body"));
          return group$b(concat$d(parts));
        }

      case "ClassImplements":
      case "InterfaceExtends":
        return concat$d([path.call(print, "id"), path.call(print, "typeParameters")]);

      case "TSClassImplements":
        return concat$d([path.call(print, "expression"), path.call(print, "typeParameters")]);

      case "TSIntersectionType":
      case "IntersectionTypeAnnotation":
        {
          var types = path.map(print, "types");
          var result = [];
          var wasIndented = false;

          for (var _i = 0; _i < types.length; ++_i) {
            if (_i === 0) {
              result.push(types[_i]);
            } else if (isObjectType$1(n.types[_i - 1]) && isObjectType$1(n.types[_i])) {
              // If both are objects, don't indent
              result.push(concat$d([" & ", wasIndented ? indent$7(types[_i]) : types[_i]]));
            } else if (!isObjectType$1(n.types[_i - 1]) && !isObjectType$1(n.types[_i])) {
              // If no object is involved, go to the next line if it breaks
              result.push(indent$7(concat$d([" &", line$7, types[_i]])));
            } else {
              // If you go from object to non-object or vis-versa, then inline it
              if (_i > 1) {
                wasIndented = true;
              }

              result.push(" & ", _i > 1 ? indent$7(types[_i]) : types[_i]);
            }
          }

          return group$b(concat$d(result));
        }

      case "TSUnionType":
      case "UnionTypeAnnotation":
        {
          // single-line variation
          // A | B | C
          // multi-line variation
          // | A
          // | B
          // | C
          var _parent9 = path.getParentNode(); // If there's a leading comment, the parent is doing the indentation


          var shouldIndent = _parent9.type !== "TypeParameterInstantiation" && _parent9.type !== "TSTypeParameterInstantiation" && _parent9.type !== "GenericTypeAnnotation" && _parent9.type !== "TSTypeReference" && _parent9.type !== "TSTypeAssertion" && _parent9.type !== "TupleTypeAnnotation" && _parent9.type !== "TSTupleType" && !(_parent9.type === "FunctionTypeParam" && !_parent9.name) && !((_parent9.type === "TypeAlias" || _parent9.type === "VariableDeclarator" || _parent9.type === "TSTypeAliasDeclaration") && hasLeadingOwnLineComment$1(options.originalText, n, options)); // {
          //   a: string
          // } | null | void
          // should be inlined and not be printed in the multi-line variant

          var shouldHug = shouldHugType(n); // We want to align the children but without its comment, so it looks like
          // | child1
          // // comment
          // | child2

          var _printed4 = path.map(function (typePath) {
            var printedType = typePath.call(print);

            if (!shouldHug) {
              printedType = align$1(2, printedType);
            }

            return comments.printComments(typePath, function () {
              return printedType;
            }, options);
          }, "types");

          if (shouldHug) {
            return join$9(" | ", _printed4);
          }

          var shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment$1(options.originalText, n, options);
          var code = concat$d([ifBreak$6(concat$d([shouldAddStartLine ? line$7 : "", "| "])), join$9(concat$d([line$7, "| "]), _printed4)]);

          if (needsParens_1(path, options)) {
            return group$b(concat$d([indent$7(code), softline$6]));
          }

          if (_parent9.type === "TupleTypeAnnotation" && _parent9.types.length > 1 || _parent9.type === "TSTupleType" && _parent9.elementTypes.length > 1) {
            return group$b(concat$d([indent$7(concat$d([ifBreak$6(concat$d(["(", softline$6])), code])), softline$6, ifBreak$6(")")]));
          }

          return group$b(shouldIndent ? indent$7(code) : code);
        }

      case "NullableTypeAnnotation":
        return concat$d(["?", path.call(print, "typeAnnotation")]);

      case "TSNullKeyword":
      case "NullLiteralTypeAnnotation":
        return "null";

      case "ThisTypeAnnotation":
        return "this";

      case "NumberTypeAnnotation":
        return "number";

      case "ObjectTypeCallProperty":
        if (n.static) {
          parts.push("static ");
        }

        parts.push(path.call(print, "value"));
        return concat$d(parts);

      case "ObjectTypeIndexer":
        {
          var _variance = getFlowVariance$1(n);

          return concat$d([_variance || "", "[", path.call(print, "id"), n.id ? ": " : "", path.call(print, "key"), "]: ", path.call(print, "value")]);
        }

      case "ObjectTypeProperty":
        {
          var _variance2 = getFlowVariance$1(n);

          var modifier = "";

          if (n.proto) {
            modifier = "proto ";
          } else if (n.static) {
            modifier = "static ";
          }

          return concat$d([modifier, isGetterOrSetter$1(n) ? n.kind + " " : "", _variance2 || "", printPropertyKey(path, options, print), printOptionalToken(path), isFunctionNotation$1(n, options) ? "" : ": ", path.call(print, "value")]);
        }

      case "QualifiedTypeIdentifier":
        return concat$d([path.call(print, "qualification"), ".", path.call(print, "id")]);

      case "StringLiteralTypeAnnotation":
        return nodeStr(n, options);

      case "NumberLiteralTypeAnnotation":
        assert.strictEqual(_typeof(n.value), "number");

        if (n.extra != null) {
          return printNumber$2(n.extra.raw);
        }

        return printNumber$2(n.raw);

      case "StringTypeAnnotation":
        return "string";

      case "DeclareTypeAlias":
      case "TypeAlias":
        {
          if (n.type === "DeclareTypeAlias" || n.declare) {
            parts.push("declare ");
          }

          var _printed5 = printAssignmentRight(n.id, n.right, path.call(print, "right"), options);

          parts.push("type ", path.call(print, "id"), path.call(print, "typeParameters"), " =", _printed5, semi);
          return group$b(concat$d(parts));
        }

      case "TypeCastExpression":
        {
          var value = path.getValue(); // Flow supports a comment syntax for specifying type annotations: https://flow.org/en/docs/types/comments/.
          // Unfortunately, its parser doesn't differentiate between comment annotations and regular
          // annotations when producing an AST. So to preserve parentheses around type casts that use
          // the comment syntax, we need to hackily read the source itself to see if the code contains
          // a type annotation comment.
          //
          // Note that we're able to use the normal whitespace regex here because the Flow parser has
          // already deemed this AST node to be a type cast. Only the Babel parser needs the
          // non-line-break whitespace regex, which is why hasFlowShorthandAnnotationComment() is
          // implemented differently.

          var commentSyntax = value && value.typeAnnotation && value.typeAnnotation.range && options.originalText.substring(value.typeAnnotation.range[0]).match(/^\/\*\s*:/);
          return concat$d(["(", path.call(print, "expression"), commentSyntax ? " /*" : "", ": ", path.call(print, "typeAnnotation"), commentSyntax ? " */" : "", ")"]);
        }

      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
        {
          var _value = path.getValue();

          var commentStart = _value.range ? options.originalText.substring(0, _value.range[0]).lastIndexOf("/*") : -1; // As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here
          // because we know for sure that this is a type definition.

          var _commentSyntax = commentStart >= 0 && options.originalText.substring(commentStart).match(/^\/\*\s*::/);

          if (_commentSyntax) {
            return concat$d(["/*:: ", printTypeParameters(path, options, print, "params"), " */"]);
          }

          return printTypeParameters(path, options, print, "params");
        }

      case "TSTypeParameterDeclaration":
      case "TSTypeParameterInstantiation":
        return printTypeParameters(path, options, print, "params");

      case "TSTypeParameter":
      case "TypeParameter":
        {
          var _parent10 = path.getParentNode();

          if (_parent10.type === "TSMappedType") {
            parts.push("[", path.call(print, "name"));

            if (n.constraint) {
              parts.push(" in ", path.call(print, "constraint"));
            }

            parts.push("]");
            return concat$d(parts);
          }

          var _variance3 = getFlowVariance$1(n);

          if (_variance3) {
            parts.push(_variance3);
          }

          parts.push(path.call(print, "name"));

          if (n.bound) {
            parts.push(": ");
            parts.push(path.call(print, "bound"));
          }

          if (n.constraint) {
            parts.push(" extends ", path.call(print, "constraint"));
          }

          if (n["default"]) {
            parts.push(" = ", path.call(print, "default"));
          } // Keep comma if the file extension is .tsx and
          // has one type parameter that isn't extend with any types.
          // Because, otherwise formatted result will be invalid as tsx.


          var _grandParent = path.getNode(2);

          if (_parent10.params && _parent10.params.length === 1 && isTSXFile$1(options) && !n.constraint && _grandParent.type === "ArrowFunctionExpression") {
            parts.push(",");
          }

          return concat$d(parts);
        }

      case "TypeofTypeAnnotation":
        return concat$d(["typeof ", path.call(print, "argument")]);

      case "VoidTypeAnnotation":
        return "void";

      case "InferredPredicate":
        return "%checks";
      // Unhandled types below. If encountered, nodes of these types should
      // be either left alone or desugared into AST types that are fully
      // supported by the pretty-printer.

      case "DeclaredPredicate":
        return concat$d(["%checks(", path.call(print, "value"), ")"]);

      case "TSAbstractKeyword":
        return "abstract";

      case "TSAnyKeyword":
        return "any";

      case "TSAsyncKeyword":
        return "async";

      case "TSBooleanKeyword":
        return "boolean";

      case "TSBigIntKeyword":
        return "bigint";

      case "TSConstKeyword":
        return "const";

      case "TSDeclareKeyword":
        return "declare";

      case "TSExportKeyword":
        return "export";

      case "TSNeverKeyword":
        return "never";

      case "TSNumberKeyword":
        return "number";

      case "TSObjectKeyword":
        return "object";

      case "TSProtectedKeyword":
        return "protected";

      case "TSPrivateKeyword":
        return "private";

      case "TSPublicKeyword":
        return "public";

      case "TSReadonlyKeyword":
        return "readonly";

      case "TSSymbolKeyword":
        return "symbol";

      case "TSStaticKeyword":
        return "static";

      case "TSStringKeyword":
        return "string";

      case "TSUndefinedKeyword":
        return "undefined";

      case "TSUnknownKeyword":
        return "unknown";

      case "TSVoidKeyword":
        return "void";

      case "TSAsExpression":
        return concat$d([path.call(print, "expression"), " as ", path.call(print, "typeAnnotation")]);

      case "TSArrayType":
        return concat$d([path.call(print, "elementType"), "[]"]);

      case "TSPropertySignature":
        {
          if (n.export) {
            parts.push("export ");
          }

          if (n.accessibility) {
            parts.push(n.accessibility + " ");
          }

          if (n.static) {
            parts.push("static ");
          }

          if (n.readonly) {
            parts.push("readonly ");
          }

          parts.push(printPropertyKey(path, options, print), printOptionalToken(path));

          if (n.typeAnnotation) {
            parts.push(": ");
            parts.push(path.call(print, "typeAnnotation"));
          } // This isn't valid semantically, but it's in the AST so we can print it.


          if (n.initializer) {
            parts.push(" = ", path.call(print, "initializer"));
          }

          return concat$d(parts);
        }

      case "TSParameterProperty":
        if (n.accessibility) {
          parts.push(n.accessibility + " ");
        }

        if (n.export) {
          parts.push("export ");
        }

        if (n.static) {
          parts.push("static ");
        }

        if (n.readonly) {
          parts.push("readonly ");
        }

        parts.push(path.call(print, "parameter"));
        return concat$d(parts);

      case "TSTypeReference":
        return concat$d([path.call(print, "typeName"), printTypeParameters(path, options, print, "typeParameters")]);

      case "TSTypeQuery":
        return concat$d(["typeof ", path.call(print, "exprName")]);

      case "TSIndexSignature":
        {
          var _parent11 = path.getParentNode();

          return concat$d([n.export ? "export " : "", n.accessibility ? concat$d([n.accessibility, " "]) : "", n.static ? "static " : "", n.readonly ? "readonly " : "", "[", n.parameters ? concat$d(path.map(print, "parameters")) : "", "]: ", path.call(print, "typeAnnotation"), _parent11.type === "ClassBody" ? semi : ""]);
        }

      case "TSTypePredicate":
        return concat$d([n.asserts ? "asserts " : "", path.call(print, "parameterName"), n.typeAnnotation ? concat$d([" is ", path.call(print, "typeAnnotation")]) : ""]);

      case "TSNonNullExpression":
        return concat$d([path.call(print, "expression"), "!"]);

      case "TSThisType":
        return "this";

      case "TSImportType":
        return concat$d([!n.isTypeOf ? "" : "typeof ", "import(", path.call(print, "parameter"), ")", !n.qualifier ? "" : concat$d([".", path.call(print, "qualifier")]), printTypeParameters(path, options, print, "typeParameters")]);

      case "TSLiteralType":
        return path.call(print, "literal");

      case "TSIndexedAccessType":
        return concat$d([path.call(print, "objectType"), "[", path.call(print, "indexType"), "]"]);

      case "TSConstructSignatureDeclaration":
      case "TSCallSignatureDeclaration":
      case "TSConstructorType":
        {
          if (n.type !== "TSCallSignatureDeclaration") {
            parts.push("new ");
          }

          parts.push(group$b(printFunctionParams(path, print, options,
          /* expandArg */
          false,
          /* printTypeParams */
          true)));

          if (n.returnType) {
            var isType = n.type === "TSConstructorType";
            parts.push(isType ? " => " : ": ", path.call(print, "returnType"));
          }

          return concat$d(parts);
        }

      case "TSTypeOperator":
        return concat$d([n.operator, " ", path.call(print, "typeAnnotation")]);

      case "TSMappedType":
        {
          var _shouldBreak3 = hasNewlineInRange$2(options.originalText, options.locStart(n), options.locEnd(n));

          return group$b(concat$d(["{", indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, n.readonly ? concat$d([getTypeScriptMappedTypeModifier$1(n.readonly, "readonly"), " "]) : "", printTypeScriptModifiers(path, options, print), path.call(print, "typeParameter"), n.optional ? getTypeScriptMappedTypeModifier$1(n.optional, "?") : "", ": ", path.call(print, "typeAnnotation"), ifBreak$6(semi, "")])), comments.printDanglingComments(path, options,
          /* sameIndent */
          true), options.bracketSpacing ? line$7 : softline$6, "}"]), {
            shouldBreak: _shouldBreak3
          });
        }

      case "TSMethodSignature":
        parts.push(n.accessibility ? concat$d([n.accessibility, " "]) : "", n.export ? "export " : "", n.static ? "static " : "", n.readonly ? "readonly " : "", n.computed ? "[" : "", path.call(print, "key"), n.computed ? "]" : "", printOptionalToken(path), printFunctionParams(path, print, options,
        /* expandArg */
        false,
        /* printTypeParams */
        true));

        if (n.returnType) {
          parts.push(": ", path.call(print, "returnType"));
        }

        return group$b(concat$d(parts));

      case "TSNamespaceExportDeclaration":
        parts.push("export as namespace ", path.call(print, "id"));

        if (options.semi) {
          parts.push(";");
        }

        return group$b(concat$d(parts));

      case "TSEnumDeclaration":
        if (n.declare) {
          parts.push("declare ");
        }

        if (n.modifiers) {
          parts.push(printTypeScriptModifiers(path, options, print));
        }

        if (n.const) {
          parts.push("const ");
        }

        parts.push("enum ", path.call(print, "id"), " ");

        if (n.members.length === 0) {
          parts.push(group$b(concat$d(["{", comments.printDanglingComments(path, options), softline$6, "}"])));
        } else {
          parts.push(group$b(concat$d(["{", indent$7(concat$d([hardline$9, printArrayItems(path, options, "members", print), shouldPrintComma$1(options, "es5") ? "," : ""])), comments.printDanglingComments(path, options,
          /* sameIndent */
          true), hardline$9, "}"])));
        }

        return concat$d(parts);

      case "TSEnumMember":
        parts.push(path.call(print, "id"));

        if (n.initializer) {
          parts.push(" = ", path.call(print, "initializer"));
        }

        return concat$d(parts);

      case "TSImportEqualsDeclaration":
        if (n.isExport) {
          parts.push("export ");
        }

        parts.push("import ", path.call(print, "id"), " = ", path.call(print, "moduleReference"));

        if (options.semi) {
          parts.push(";");
        }

        return group$b(concat$d(parts));

      case "TSExternalModuleReference":
        return concat$d(["require(", path.call(print, "expression"), ")"]);

      case "TSModuleDeclaration":
        {
          var _parent12 = path.getParentNode();

          var isExternalModule = isLiteral$1(n.id);
          var parentIsDeclaration = _parent12.type === "TSModuleDeclaration";
          var bodyIsDeclaration = n.body && n.body.type === "TSModuleDeclaration";

          if (parentIsDeclaration) {
            parts.push(".");
          } else {
            if (n.declare) {
              parts.push("declare ");
            }

            parts.push(printTypeScriptModifiers(path, options, print));
            var textBetweenNodeAndItsId = options.originalText.slice(options.locStart(n), options.locStart(n.id)); // Global declaration looks like this:
            // (declare)? global { ... }

            var isGlobalDeclaration = n.id.type === "Identifier" && n.id.name === "global" && !/namespace|module/.test(textBetweenNodeAndItsId);

            if (!isGlobalDeclaration) {
              parts.push(isExternalModule || /(^|\s)module(\s|$)/.test(textBetweenNodeAndItsId) ? "module " : "namespace ");
            }
          }

          parts.push(path.call(print, "id"));

          if (bodyIsDeclaration) {
            parts.push(path.call(print, "body"));
          } else if (n.body) {
            parts.push(" ", group$b(path.call(print, "body")));
          } else {
            parts.push(semi);
          }

          return concat$d(parts);
        }

      case "PrivateName":
        return concat$d(["#", path.call(print, "id")]);

      case "TSConditionalType":
        return printTernaryOperator(path, options, print, {
          beforeParts: function beforeParts() {
            return [path.call(print, "checkType"), " ", "extends", " ", path.call(print, "extendsType")];
          },
          afterParts: function afterParts() {
            return [];
          },
          shouldCheckJsx: false,
          conditionalNodeType: "TSConditionalType",
          consequentNodePropertyName: "trueType",
          alternateNodePropertyName: "falseType",
          testNodePropertyName: "checkType",
          breakNested: true
        });

      case "TSInferType":
        return concat$d(["infer", " ", path.call(print, "typeParameter")]);

      case "InterpreterDirective":
        parts.push("#!", n.value, hardline$9);

        if (isNextLineEmpty$4(options.originalText, n, options)) {
          parts.push(hardline$9);
        }

        return concat$d(parts);

      case "NGRoot":
        return concat$d([].concat(path.call(print, "node"), !n.node.comments || n.node.comments.length === 0 ? [] : concat$d([" //", n.node.comments[0].value.trimRight()])));

      case "NGChainedExpression":
        return group$b(join$9(concat$d([";", line$7]), path.map(function (childPath) {
          return hasNgSideEffect$1(childPath) ? print(childPath) : concat$d(["(", print(childPath), ")"]);
        }, "expressions")));

      case "NGEmptyExpression":
        return "";

      case "NGQuotedExpression":
        return concat$d([n.prefix, ":", n.value]);

      case "NGMicrosyntax":
        return concat$d(path.map(function (childPath, index) {
          return concat$d([index === 0 ? "" : isNgForOf$1(childPath.getValue(), index, n) ? " " : concat$d([";", line$7]), print(childPath)]);
        }, "body"));

      case "NGMicrosyntaxKey":
        return /^[a-z_$][a-z0-9_$]*(-[a-z_$][a-z0-9_$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);

      case "NGMicrosyntaxExpression":
        return concat$d([path.call(print, "expression"), n.alias === null ? "" : concat$d([" as ", path.call(print, "alias")])]);

      case "NGMicrosyntaxKeyedExpression":
        {
          var index = path.getName();

          var _parentNode2 = path.getParentNode();

          var shouldNotPrintColon = isNgForOf$1(n, index, _parentNode2) || (index === 1 && (n.key.name === "then" || n.key.name === "else") || index === 2 && n.key.name === "else" && _parentNode2.body[index - 1].type === "NGMicrosyntaxKeyedExpression" && _parentNode2.body[index - 1].key.name === "then") && _parentNode2.body[0].type === "NGMicrosyntaxExpression";
          return concat$d([path.call(print, "key"), shouldNotPrintColon ? " " : ": ", path.call(print, "expression")]);
        }

      case "NGMicrosyntaxLet":
        return concat$d(["let ", path.call(print, "key"), n.value === null ? "" : concat$d([" = ", path.call(print, "value")])]);

      case "NGMicrosyntaxAs":
        return concat$d([path.call(print, "key"), " as ", path.call(print, "alias")]);

      case "ArgumentPlaceholder":
        return "?";

      default:
        /* istanbul ignore next */
        throw new Error("unknown type: " + JSON.stringify(n.type));
    }
  }

  function printStatementSequence(path, options, print) {
    var printed = [];
    var bodyNode = path.getNode();
    var isClass = bodyNode.type === "ClassBody";
    path.map(function (stmtPath, i) {
      var stmt = stmtPath.getValue(); // Just in case the AST has been modified to contain falsy
      // "statements," it's safer simply to skip them.

      /* istanbul ignore if */

      if (!stmt) {
        return;
      } // Skip printing EmptyStatement nodes to avoid leaving stray
      // semicolons lying around.


      if (stmt.type === "EmptyStatement") {
        return;
      }

      var stmtPrinted = print(stmtPath);
      var text = options.originalText;
      var parts = []; // in no-semi mode, prepend statement with semicolon if it might break ASI
      // don't prepend the only JSX element in a program with semicolon

      if (!options.semi && !isClass && !isTheOnlyJSXElementInMarkdown$1(options, stmtPath) && stmtNeedsASIProtection(stmtPath, options)) {
        if (stmt.comments && stmt.comments.some(function (comment) {
          return comment.leading;
        })) {
          parts.push(print(stmtPath, {
            needsSemi: true
          }));
        } else {
          parts.push(";", stmtPrinted);
        }
      } else {
        parts.push(stmtPrinted);
      }

      if (!options.semi && isClass) {
        if (classPropMayCauseASIProblems$1(stmtPath)) {
          parts.push(";");
        } else if (stmt.type === "ClassProperty") {
          var nextChild = bodyNode.body[i + 1];

          if (classChildNeedsASIProtection$1(nextChild)) {
            parts.push(";");
          }
        }
      }

      if (isNextLineEmpty$4(text, stmt, options) && !isLastStatement$1(stmtPath)) {
        parts.push(hardline$9);
      }

      printed.push(concat$d(parts));
    });
    return join$9(hardline$9, printed);
  }

  function printPropertyKey(path, options, print) {
    var node = path.getNode();

    if (node.computed) {
      return concat$d(["[", path.call(print, "key"), "]"]);
    }

    var parent = path.getParentNode();
    var key = node.key;

    if (options.quoteProps === "consistent" && !needsQuoteProps.has(parent)) {
      var objectHasStringProp = (parent.properties || parent.body || parent.members).some(function (prop) {
        return !prop.computed && prop.key && isStringLiteral$1(prop.key) && !isStringPropSafeToCoerceToIdentifier$1(prop, options);
      });
      needsQuoteProps.set(parent, objectHasStringProp);
    }

    if (key.type === "Identifier" && (options.parser === "json" || options.quoteProps === "consistent" && needsQuoteProps.get(parent))) {
      // a -> "a"
      var prop = printString$2(JSON.stringify(key.name), options);
      return path.call(function (keyPath) {
        return comments.printComments(keyPath, function () {
          return prop;
        }, options);
      }, "key");
    }

    if (isStringPropSafeToCoerceToIdentifier$1(node, options) && (options.quoteProps === "as-needed" || options.quoteProps === "consistent" && !needsQuoteProps.get(parent))) {
      // 'a' -> a
      return path.call(function (keyPath) {
        return comments.printComments(keyPath, function () {
          return key.value;
        }, options);
      }, "key");
    }

    return path.call(print, "key");
  }

  function printMethod(path, options, print) {
    var node = path.getNode();
    var kind = node.kind;
    var value = node.value || node;
    var parts = [];

    if (!kind || kind === "init" || kind === "method" || kind === "constructor") {
      if (value.async) {
        parts.push("async ");
      }

      if (value.generator) {
        parts.push("*");
      }
    } else {
      assert.ok(kind === "get" || kind === "set");
      parts.push(kind, " ");
    }

    parts.push(printPropertyKey(path, options, print), node.optional || node.key.optional ? "?" : "", node === value ? printMethodInternal(path, options, print) : path.call(function (path) {
      return printMethodInternal(path, options, print);
    }, "value"));
    return concat$d(parts);
  }

  function printMethodInternal(path, options, print) {
    var parts = [printFunctionTypeParameters(path, options, print), group$b(concat$d([printFunctionParams(path, print, options), printReturnType(path, print, options)]))];

    if (path.getNode().body) {
      parts.push(" ", path.call(print, "body"));
    } else {
      parts.push(options.semi ? ";" : "");
    }

    return concat$d(parts);
  }

  function couldGroupArg(arg) {
    return arg.type === "ObjectExpression" && (arg.properties.length > 0 || arg.comments) || arg.type === "ArrayExpression" && (arg.elements.length > 0 || arg.comments) || arg.type === "TSTypeAssertion" && couldGroupArg(arg.expression) || arg.type === "TSAsExpression" && couldGroupArg(arg.expression) || arg.type === "FunctionExpression" || arg.type === "ArrowFunctionExpression" && ( // we want to avoid breaking inside composite return types but not simple keywords
    // https://github.com/prettier/prettier/issues/4070
    // export class Thing implements OtherThing {
    //   do: (type: Type) => Provider<Prop> = memoize(
    //     (type: ObjectType): Provider<Opts> => {}
    //   );
    // }
    // https://github.com/prettier/prettier/issues/6099
    // app.get("/", (req, res): void => {
    //   res.send("Hello World!");
    // });
    !arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== "TSTypeReference") && (arg.body.type === "BlockStatement" || arg.body.type === "ArrowFunctionExpression" || arg.body.type === "ObjectExpression" || arg.body.type === "ArrayExpression" || arg.body.type === "CallExpression" || arg.body.type === "OptionalCallExpression" || arg.body.type === "ConditionalExpression" || isJSXNode$1(arg.body));
  }

  function shouldGroupLastArg(args) {
    var lastArg = getLast$2(args);
    var penultimateArg = getPenultimate$1(args);
    return !hasLeadingComment$3(lastArg) && !hasTrailingComment$1(lastArg) && couldGroupArg(lastArg) && ( // If the last two arguments are of the same type,
    // disable last element expansion.
    !penultimateArg || penultimateArg.type !== lastArg.type);
  }

  function shouldGroupFirstArg(args) {
    if (args.length !== 2) {
      return false;
    }

    var firstArg = args[0];
    var secondArg = args[1];
    return (!firstArg.comments || !firstArg.comments.length) && (firstArg.type === "FunctionExpression" || firstArg.type === "ArrowFunctionExpression" && firstArg.body.type === "BlockStatement") && secondArg.type !== "FunctionExpression" && secondArg.type !== "ArrowFunctionExpression" && secondArg.type !== "ConditionalExpression" && !couldGroupArg(secondArg);
  }

  function printJestEachTemplateLiteral(node, expressions, options) {
    /**
     * a    | b    | expected
     * ${1} | ${1} | ${2}
     * ${1} | ${2} | ${3}
     * ${2} | ${1} | ${3}
     */
    var headerNames = node.quasis[0].value.raw.trim().split(/\s*\|\s*/);

    if (headerNames.length > 1 || headerNames.some(function (headerName) {
      return headerName.length !== 0;
    })) {
      var parts = [];
      var stringifiedExpressions = expressions.map(function (doc) {
        return "${" + printDocToString$1(doc, Object.assign({}, options, {
          printWidth: Infinity,
          endOfLine: "lf"
        })).formatted + "}";
      });
      var tableBody = [{
        hasLineBreak: false,
        cells: []
      }];

      for (var i = 1; i < node.quasis.length; i++) {
        var row = tableBody[tableBody.length - 1];
        var correspondingExpression = stringifiedExpressions[i - 1];
        row.cells.push(correspondingExpression);

        if (correspondingExpression.indexOf("\n") !== -1) {
          row.hasLineBreak = true;
        }

        if (node.quasis[i].value.raw.indexOf("\n") !== -1) {
          tableBody.push({
            hasLineBreak: false,
            cells: []
          });
        }
      }

      var maxColumnCount = tableBody.reduce(function (maxColumnCount, row) {
        return Math.max(maxColumnCount, row.cells.length);
      }, headerNames.length);
      var maxColumnWidths = Array.from(new Array(maxColumnCount), function () {
        return 0;
      });
      var table = [{
        cells: headerNames
      }].concat(tableBody.filter(function (row) {
        return row.cells.length !== 0;
      }));
      table.filter(function (row) {
        return !row.hasLineBreak;
      }).forEach(function (row) {
        row.cells.forEach(function (cell, index) {
          maxColumnWidths[index] = Math.max(maxColumnWidths[index], getStringWidth$2(cell));
        });
      });
      parts.push(lineSuffixBoundary$1, "`", indent$7(concat$d([hardline$9, join$9(hardline$9, table.map(function (row) {
        return join$9(" | ", row.cells.map(function (cell, index) {
          return row.hasLineBreak ? cell : cell + " ".repeat(maxColumnWidths[index] - getStringWidth$2(cell));
        }));
      }))])), hardline$9, "`");
      return concat$d(parts);
    }
  }

  function printArgumentsList(path, options, print) {
    var node = path.getValue();
    var args = node.arguments;

    if (args.length === 0) {
      return concat$d(["(", comments.printDanglingComments(path, options,
      /* sameIndent */
      true), ")"]);
    } // useEffect(() => { ... }, [foo, bar, baz])


    if (args.length === 2 && args[0].type === "ArrowFunctionExpression" && args[0].params.length === 0 && args[0].body.type === "BlockStatement" && args[1].type === "ArrayExpression" && !args.find(function (arg) {
      return arg.comments;
    })) {
      return concat$d(["(", path.call(print, "arguments", 0), ", ", path.call(print, "arguments", 1), ")"]);
    } // func(
    //   ({
    //     a,
    //     b
    //   }) => {}
    // );


    function shouldBreakForArrowFunctionInArguments(arg, argPath) {
      if (!arg || arg.type !== "ArrowFunctionExpression" || !arg.body || arg.body.type !== "BlockStatement" || !arg.params || arg.params.length < 1) {
        return false;
      }

      var shouldBreak = false;
      argPath.each(function (paramPath) {
        var printed = concat$d([print(paramPath)]);
        shouldBreak = shouldBreak || willBreak$1(printed);
      }, "params");
      return shouldBreak;
    }

    var anyArgEmptyLine = false;
    var shouldBreakForArrowFunction = false;
    var hasEmptyLineFollowingFirstArg = false;
    var lastArgIndex = args.length - 1;
    var printedArguments = path.map(function (argPath, index) {
      var arg = argPath.getNode();
      var parts = [print(argPath)];

      if (index === lastArgIndex) ; else if (isNextLineEmpty$4(options.originalText, arg, options)) {
        if (index === 0) {
          hasEmptyLineFollowingFirstArg = true;
        }

        anyArgEmptyLine = true;
        parts.push(",", hardline$9, hardline$9);
      } else {
        parts.push(",", line$7);
      }

      shouldBreakForArrowFunction = shouldBreakForArrowFunctionInArguments(arg, argPath);
      return concat$d(parts);
    }, "arguments");
    var maybeTrailingComma = // Dynamic imports cannot have trailing commas
    !(node.callee && node.callee.type === "Import") && shouldPrintComma$1(options, "all") ? "," : "";

    function allArgsBrokenOut() {
      return group$b(concat$d(["(", indent$7(concat$d([line$7, concat$d(printedArguments)])), maybeTrailingComma, line$7, ")"]), {
        shouldBreak: true
      });
    }

    if (isFunctionCompositionArgs$1(args)) {
      return allArgsBrokenOut();
    }

    var shouldGroupFirst = shouldGroupFirstArg(args);
    var shouldGroupLast = shouldGroupLastArg(args);

    if (shouldGroupFirst || shouldGroupLast) {
      var shouldBreak = (shouldGroupFirst ? printedArguments.slice(1).some(willBreak$1) : printedArguments.slice(0, -1).some(willBreak$1)) || anyArgEmptyLine || shouldBreakForArrowFunction; // We want to print the last argument with a special flag

      var printedExpanded;
      var i = 0;
      path.each(function (argPath) {
        if (shouldGroupFirst && i === 0) {
          printedExpanded = [concat$d([argPath.call(function (p) {
            return print(p, {
              expandFirstArg: true
            });
          }), printedArguments.length > 1 ? "," : "", hasEmptyLineFollowingFirstArg ? hardline$9 : line$7, hasEmptyLineFollowingFirstArg ? hardline$9 : ""])].concat(printedArguments.slice(1));
        }

        if (shouldGroupLast && i === args.length - 1) {
          printedExpanded = printedArguments.slice(0, -1).concat(argPath.call(function (p) {
            return print(p, {
              expandLastArg: true
            });
          }));
        }

        i++;
      }, "arguments");
      var somePrintedArgumentsWillBreak = printedArguments.some(willBreak$1);
      var simpleConcat = concat$d(["(", concat$d(printedExpanded), ")"]);
      return concat$d([somePrintedArgumentsWillBreak ? breakParent$3 : "", conditionalGroup$1([!somePrintedArgumentsWillBreak && !node.typeArguments && !node.typeParameters ? simpleConcat : ifBreak$6(allArgsBrokenOut(), simpleConcat), shouldGroupFirst ? concat$d(["(", group$b(printedExpanded[0], {
        shouldBreak: true
      }), concat$d(printedExpanded.slice(1)), ")"]) : concat$d(["(", concat$d(printedArguments.slice(0, -1)), group$b(getLast$2(printedExpanded), {
        shouldBreak: true
      }), ")"]), allArgsBrokenOut()], {
        shouldBreak: shouldBreak
      })]);
    }

    var contents = concat$d(["(", indent$7(concat$d([softline$6, concat$d(printedArguments)])), ifBreak$6(maybeTrailingComma), softline$6, ")"]);

    if (isLongCurriedCallExpression$1(path)) {
      // By not wrapping the arguments in a group, the printer prioritizes
      // breaking up these arguments rather than the args of the parent call.
      return contents;
    }

    return group$b(contents, {
      shouldBreak: printedArguments.some(willBreak$1) || anyArgEmptyLine
    });
  }

  function printTypeAnnotation(path, options, print) {
    var node = path.getValue();

    if (!node.typeAnnotation) {
      return "";
    }

    var parentNode = path.getParentNode();
    var isDefinite = node.definite || parentNode && parentNode.type === "VariableDeclarator" && parentNode.definite;
    var isFunctionDeclarationIdentifier = parentNode.type === "DeclareFunction" && parentNode.id === node;

    if (isFlowAnnotationComment$1(options.originalText, node.typeAnnotation, options)) {
      return concat$d([" /*: ", path.call(print, "typeAnnotation"), " */"]);
    }

    return concat$d([isFunctionDeclarationIdentifier ? "" : isDefinite ? "!: " : ": ", path.call(print, "typeAnnotation")]);
  }

  function printFunctionTypeParameters(path, options, print) {
    var fun = path.getValue();

    if (fun.typeArguments) {
      return path.call(print, "typeArguments");
    }

    if (fun.typeParameters) {
      return path.call(print, "typeParameters");
    }

    return "";
  }

  function printFunctionParams(path, print, options, expandArg, printTypeParams) {
    var fun = path.getValue();
    var parent = path.getParentNode();
    var paramsField = fun.parameters ? "parameters" : "params";
    var isParametersInTestCall = isTestCall$1(parent);
    var shouldHugParameters = shouldHugArguments(fun);
    var shouldExpandParameters = expandArg && !(fun[paramsField] && fun[paramsField].some(function (n) {
      return n.comments;
    }));
    var typeParams = printTypeParams ? printFunctionTypeParameters(path, options, print) : "";
    var printed = [];

    if (fun[paramsField]) {
      var lastArgIndex = fun[paramsField].length - 1;
      printed = path.map(function (childPath, index) {
        var parts = [];
        var param = childPath.getValue();
        parts.push(print(childPath));

        if (index === lastArgIndex) {
          if (fun.rest) {
            parts.push(",", line$7);
          }
        } else if (isParametersInTestCall || shouldHugParameters || shouldExpandParameters) {
          parts.push(", ");
        } else if (isNextLineEmpty$4(options.originalText, param, options)) {
          parts.push(",", hardline$9, hardline$9);
        } else {
          parts.push(",", line$7);
        }

        return concat$d(parts);
      }, paramsField);
    }

    if (fun.rest) {
      printed.push(concat$d(["...", path.call(print, "rest")]));
    }

    if (printed.length === 0) {
      return concat$d([typeParams, "(", comments.printDanglingComments(path, options,
      /* sameIndent */
      true, function (comment) {
        return getNextNonSpaceNonCommentCharacter$1(options.originalText, comment, options.locEnd) === ")";
      }), ")"]);
    }

    var lastParam = getLast$2(fun[paramsField]); // If the parent is a call with the first/last argument expansion and this is the
    // params of the first/last argument, we don't want the arguments to break and instead
    // want the whole expression to be on a new line.
    //
    // Good:                 Bad:
    //   verylongcall(         verylongcall((
    //     (a, b) => {           a,
    //     }                     b,
    //   })                    ) => {
    //                         })

    if (shouldExpandParameters) {
      return group$b(concat$d([removeLines$2(typeParams), "(", concat$d(printed.map(removeLines$2)), ")"]));
    } // Single object destructuring should hug
    //
    // function({
    //   a,
    //   b,
    //   c
    // }) {}


    var hasNotParameterDecorator = fun[paramsField].every(function (param) {
      return !param.decorators;
    });

    if (shouldHugParameters && hasNotParameterDecorator) {
      return concat$d([typeParams, "(", concat$d(printed), ")"]);
    } // don't break in specs, eg; `it("should maintain parens around done even when long", (done) => {})`


    if (isParametersInTestCall) {
      return concat$d([typeParams, "(", concat$d(printed), ")"]);
    }

    var isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction$1(parent, options) || isTypeAnnotationAFunction$1(parent, options) || parent.type === "TypeAlias" || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType" || parent.type === "IntersectionTypeAnnotation" || parent.type === "FunctionTypeAnnotation" && parent.returnType === fun) && fun[paramsField].length === 1 && fun[paramsField][0].name === null && fun[paramsField][0].typeAnnotation && fun.typeParameters === null && isSimpleFlowType$1(fun[paramsField][0].typeAnnotation) && !fun.rest;

    if (isFlowShorthandWithOneArg) {
      if (options.arrowParens === "always") {
        return concat$d(["(", concat$d(printed), ")"]);
      }

      return concat$d(printed);
    }

    var canHaveTrailingComma = !(lastParam && lastParam.type === "RestElement") && !fun.rest;
    return concat$d([typeParams, "(", indent$7(concat$d([softline$6, concat$d(printed)])), ifBreak$6(canHaveTrailingComma && shouldPrintComma$1(options, "all") ? "," : ""), softline$6, ")"]);
  }

  function shouldPrintParamsWithoutParens(path, options) {
    if (options.arrowParens === "always") {
      return false;
    }

    if (options.arrowParens === "avoid") {
      var node = path.getValue();
      return canPrintParamsWithoutParens(node);
    } // Fallback default; should be unreachable


    return false;
  }

  function canPrintParamsWithoutParens(node) {
    return node.params.length === 1 && !node.rest && !node.typeParameters && !hasDanglingComments$1(node) && node.params[0].type === "Identifier" && !node.params[0].typeAnnotation && !node.params[0].comments && !node.params[0].optional && !node.predicate && !node.returnType;
  }

  function printFunctionDeclaration(path, print, options) {
    var n = path.getValue();
    var parts = [];

    if (n.async) {
      parts.push("async ");
    }

    parts.push("function");

    if (n.generator) {
      parts.push("*");
    }

    if (n.id) {
      parts.push(" ", path.call(print, "id"));
    }

    parts.push(printFunctionTypeParameters(path, options, print), group$b(concat$d([printFunctionParams(path, print, options), printReturnType(path, print, options)])), n.body ? " " : "", path.call(print, "body"));
    return concat$d(parts);
  }

  function printReturnType(path, print, options) {
    var n = path.getValue();
    var returnType = path.call(print, "returnType");

    if (n.returnType && isFlowAnnotationComment$1(options.originalText, n.returnType, options)) {
      return concat$d([" /*: ", returnType, " */"]);
    }

    var parts = [returnType]; // prepend colon to TypeScript type annotation

    if (n.returnType && n.returnType.typeAnnotation) {
      parts.unshift(": ");
    }

    if (n.predicate) {
      // The return type will already add the colon, but otherwise we
      // need to do it ourselves
      parts.push(n.returnType ? " " : ": ", path.call(print, "predicate"));
    }

    return concat$d(parts);
  }

  function printExportDeclaration(path, options, print) {
    var decl = path.getValue();
    var semi = options.semi ? ";" : "";
    var parts = ["export "];
    var isDefault = decl["default"] || decl.type === "ExportDefaultDeclaration";

    if (isDefault) {
      parts.push("default ");
    }

    parts.push(comments.printDanglingComments(path, options,
    /* sameIndent */
    true));

    if (needsHardlineAfterDanglingComment$1(decl)) {
      parts.push(hardline$9);
    }

    if (decl.declaration) {
      parts.push(path.call(print, "declaration"));

      if (isDefault && decl.declaration.type !== "ClassDeclaration" && decl.declaration.type !== "FunctionDeclaration" && decl.declaration.type !== "TSInterfaceDeclaration" && decl.declaration.type !== "DeclareClass" && decl.declaration.type !== "DeclareFunction" && decl.declaration.type !== "TSDeclareFunction") {
        parts.push(semi);
      }
    } else {
      if (decl.specifiers && decl.specifiers.length > 0) {
        var specifiers = [];
        var defaultSpecifiers = [];
        var namespaceSpecifiers = [];
        path.each(function (specifierPath) {
          var specifierType = path.getValue().type;

          if (specifierType === "ExportSpecifier") {
            specifiers.push(print(specifierPath));
          } else if (specifierType === "ExportDefaultSpecifier") {
            defaultSpecifiers.push(print(specifierPath));
          } else if (specifierType === "ExportNamespaceSpecifier") {
            namespaceSpecifiers.push(concat$d(["* as ", print(specifierPath)]));
          }
        }, "specifiers");
        var isNamespaceFollowed = namespaceSpecifiers.length !== 0 && specifiers.length !== 0;
        var isDefaultFollowed = defaultSpecifiers.length !== 0 && (namespaceSpecifiers.length !== 0 || specifiers.length !== 0);
        var canBreak = specifiers.length > 1 || defaultSpecifiers.length > 0 || decl.specifiers && decl.specifiers.some(function (node) {
          return node.comments;
        });
        var printed = "";

        if (specifiers.length !== 0) {
          if (canBreak) {
            printed = group$b(concat$d(["{", indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, join$9(concat$d([",", line$7]), specifiers)])), ifBreak$6(shouldPrintComma$1(options) ? "," : ""), options.bracketSpacing ? line$7 : softline$6, "}"]));
          } else {
            printed = concat$d(["{", options.bracketSpacing ? " " : "", concat$d(specifiers), options.bracketSpacing ? " " : "", "}"]);
          }
        }

        parts.push(decl.exportKind === "type" ? "type " : "", concat$d(defaultSpecifiers), concat$d([isDefaultFollowed ? ", " : ""]), concat$d(namespaceSpecifiers), concat$d([isNamespaceFollowed ? ", " : ""]), printed);
      } else {
        parts.push("{}");
      }

      if (decl.source) {
        parts.push(" from ", path.call(print, "source"));
      }

      parts.push(semi);
    }

    return concat$d(parts);
  }

  function printFlowDeclaration(path, parts) {
    var parentExportDecl = getParentExportDeclaration$1(path);

    if (parentExportDecl) {
      assert.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
    } else {
      // If the parent node has type DeclareExportDeclaration, then it
      // will be responsible for printing the "declare" token. Otherwise
      // it needs to be printed with this non-exported declaration node.
      parts.unshift("declare ");
    }

    return concat$d(parts);
  }

  function printTypeScriptModifiers(path, options, print) {
    var n = path.getValue();

    if (!n.modifiers || !n.modifiers.length) {
      return "";
    }

    return concat$d([join$9(" ", path.map(print, "modifiers")), " "]);
  }

  function printTypeParameters(path, options, print, paramsKey) {
    var n = path.getValue();

    if (!n[paramsKey]) {
      return "";
    } // for TypeParameterDeclaration typeParameters is a single node


    if (!Array.isArray(n[paramsKey])) {
      return path.call(print, paramsKey);
    }

    var grandparent = path.getNode(2);
    var greatGreatGrandParent = path.getNode(4);
    var isParameterInTestCall = grandparent != null && isTestCall$1(grandparent);
    var shouldInline = isParameterInTestCall || n[paramsKey].length === 0 || n[paramsKey].length === 1 && (shouldHugType(n[paramsKey][0]) || n[paramsKey][0].type === "GenericTypeAnnotation" && shouldHugType(n[paramsKey][0].id) || n[paramsKey][0].type === "TSTypeReference" && shouldHugType(n[paramsKey][0].typeName) || n[paramsKey][0].type === "NullableTypeAnnotation" || // See https://github.com/prettier/prettier/pull/6467 for the context.
    greatGreatGrandParent && greatGreatGrandParent.type === "VariableDeclarator" && grandparent && grandparent.type === "TSTypeAnnotation" && n[paramsKey][0].type !== "TSUnionType" && n[paramsKey][0].type !== "UnionTypeAnnotation" && n[paramsKey][0].type !== "TSConditionalType" && n[paramsKey][0].type !== "TSMappedType");

    if (shouldInline) {
      return concat$d(["<", join$9(", ", path.map(print, paramsKey)), ">"]);
    }

    return group$b(concat$d(["<", indent$7(concat$d([softline$6, join$9(concat$d([",", line$7]), path.map(print, paramsKey))])), ifBreak$6(options.parser !== "typescript" && shouldPrintComma$1(options, "all") ? "," : ""), softline$6, ">"]));
  }

  function printClass(path, options, print) {
    var n = path.getValue();
    var parts = [];

    if (n.abstract) {
      parts.push("abstract ");
    }

    parts.push("class");

    if (n.id) {
      parts.push(" ", path.call(print, "id"));
    }

    parts.push(path.call(print, "typeParameters"));
    var partsGroup = [];

    if (n.superClass) {
      var printed = concat$d(["extends ", path.call(print, "superClass"), path.call(print, "superTypeParameters")]); // Keep old behaviour of extends in same line
      // If there is only on extends and there are not comments

      if ((!n.implements || n.implements.length === 0) && (!n.superClass.comments || n.superClass.comments.length === 0)) {
        parts.push(concat$d([" ", path.call(function (superClass) {
          return comments.printComments(superClass, function () {
            return printed;
          }, options);
        }, "superClass")]));
      } else {
        partsGroup.push(group$b(concat$d([line$7, path.call(function (superClass) {
          return comments.printComments(superClass, function () {
            return printed;
          }, options);
        }, "superClass")])));
      }
    } else if (n.extends && n.extends.length > 0) {
      parts.push(" extends ", join$9(", ", path.map(print, "extends")));
    }

    if (n["mixins"] && n["mixins"].length > 0) {
      partsGroup.push(line$7, "mixins ", group$b(indent$7(join$9(concat$d([",", line$7]), path.map(print, "mixins")))));
    }

    if (n["implements"] && n["implements"].length > 0) {
      partsGroup.push(line$7, "implements", group$b(indent$7(concat$d([line$7, join$9(concat$d([",", line$7]), path.map(print, "implements"))]))));
    }

    if (partsGroup.length > 0) {
      parts.push(group$b(indent$7(concat$d(partsGroup))));
    }

    if (n.body && n.body.comments && hasLeadingOwnLineComment$1(options.originalText, n.body, options)) {
      parts.push(hardline$9);
    } else {
      parts.push(" ");
    }

    parts.push(path.call(print, "body"));
    return parts;
  }

  function printOptionalToken(path) {
    var node = path.getValue();

    if (!node.optional || // It's an optional computed method parsed by typescript-estree.
    // "?" is printed in `printMethod`.
    node.type === "Identifier" && node === path.getParentNode().key) {
      return "";
    }

    if (node.type === "OptionalCallExpression" || node.type === "OptionalMemberExpression" && node.computed) {
      return "?.";
    }

    return "?";
  }

  function printMemberLookup(path, options, print) {
    var property = path.call(print, "property");
    var n = path.getValue();
    var optional = printOptionalToken(path);

    if (!n.computed) {
      return concat$d([optional, ".", property]);
    }

    if (!n.property || isNumericLiteral$1(n.property)) {
      return concat$d([optional, "[", property, "]"]);
    }

    return group$b(concat$d([optional, "[", indent$7(concat$d([softline$6, property])), softline$6, "]"]));
  }

  function printBindExpressionCallee(path, options, print) {
    return concat$d(["::", path.call(print, "callee")]);
  } // We detect calls on member expressions specially to format a
  // common pattern better. The pattern we are looking for is this:
  //
  // arr
  //   .map(x => x + 1)
  //   .filter(x => x > 10)
  //   .some(x => x % 2)
  //
  // The way it is structured in the AST is via a nested sequence of
  // MemberExpression and CallExpression. We need to traverse the AST
  // and make groups out of it to print it in the desired way.


  function printMemberChain(path, options, print) {
    // The first phase is to linearize the AST by traversing it down.
    //
    //   a().b()
    // has the following AST structure:
    //   CallExpression(MemberExpression(CallExpression(Identifier)))
    // and we transform it into
    //   [Identifier, CallExpression, MemberExpression, CallExpression]
    var printedNodes = []; // Here we try to retain one typed empty line after each call expression or
    // the first group whether it is in parentheses or not

    function shouldInsertEmptyLineAfter(node) {
      var originalText = options.originalText;
      var nextCharIndex = getNextNonSpaceNonCommentCharacterIndex$2(originalText, node, options);
      var nextChar = originalText.charAt(nextCharIndex); // if it is cut off by a parenthesis, we only account for one typed empty
      // line after that parenthesis

      if (nextChar == ")") {
        return isNextLineEmptyAfterIndex$1(originalText, nextCharIndex + 1, options);
      }

      return isNextLineEmpty$4(originalText, node, options);
    }

    function rec(path) {
      var node = path.getValue();

      if ((node.type === "CallExpression" || node.type === "OptionalCallExpression") && (isMemberish$1(node.callee) || node.callee.type === "CallExpression" || node.callee.type === "OptionalCallExpression")) {
        printedNodes.unshift({
          node: node,
          printed: concat$d([comments.printComments(path, function () {
            return concat$d([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);
          }, options), shouldInsertEmptyLineAfter(node) ? hardline$9 : ""])
        });
        path.call(function (callee) {
          return rec(callee);
        }, "callee");
      } else if (isMemberish$1(node)) {
        printedNodes.unshift({
          node: node,
          needsParens: needsParens_1(path, options),
          printed: comments.printComments(path, function () {
            return node.type === "OptionalMemberExpression" || node.type === "MemberExpression" ? printMemberLookup(path, options, print) : printBindExpressionCallee(path, options, print);
          }, options)
        });
        path.call(function (object) {
          return rec(object);
        }, "object");
      } else if (node.type === "TSNonNullExpression") {
        printedNodes.unshift({
          node: node,
          printed: comments.printComments(path, function () {
            return "!";
          }, options)
        });
        path.call(function (expression) {
          return rec(expression);
        }, "expression");
      } else {
        printedNodes.unshift({
          node: node,
          printed: path.call(print)
        });
      }
    } // Note: the comments of the root node have already been printed, so we
    // need to extract this first call without printing them as they would
    // if handled inside of the recursive call.


    var node = path.getValue();
    printedNodes.unshift({
      node: node,
      printed: concat$d([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)])
    });
    path.call(function (callee) {
      return rec(callee);
    }, "callee"); // Once we have a linear list of printed nodes, we want to create groups out
    // of it.
    //
    //   a().b.c().d().e
    // will be grouped as
    //   [
    //     [Identifier, CallExpression],
    //     [MemberExpression, MemberExpression, CallExpression],
    //     [MemberExpression, CallExpression],
    //     [MemberExpression],
    //   ]
    // so that we can print it as
    //   a()
    //     .b.c()
    //     .d()
    //     .e
    // The first group is the first node followed by
    //   - as many CallExpression as possible
    //       < fn()()() >.something()
    //   - as many array accessors as possible
    //       < fn()[0][1][2] >.something()
    //   - then, as many MemberExpression as possible but the last one
    //       < this.items >.something()

    var groups = [];
    var currentGroup = [printedNodes[0]];
    var i = 1;

    for (; i < printedNodes.length; ++i) {
      if (printedNodes[i].node.type === "TSNonNullExpression" || printedNodes[i].node.type === "OptionalCallExpression" || printedNodes[i].node.type === "CallExpression" || (printedNodes[i].node.type === "MemberExpression" || printedNodes[i].node.type === "OptionalMemberExpression") && printedNodes[i].node.computed && isNumericLiteral$1(printedNodes[i].node.property)) {
        currentGroup.push(printedNodes[i]);
      } else {
        break;
      }
    }

    if (printedNodes[0].node.type !== "CallExpression" && printedNodes[0].node.type !== "OptionalCallExpression") {
      for (; i + 1 < printedNodes.length; ++i) {
        if (isMemberish$1(printedNodes[i].node) && isMemberish$1(printedNodes[i + 1].node)) {
          currentGroup.push(printedNodes[i]);
        } else {
          break;
        }
      }
    }

    groups.push(currentGroup);
    currentGroup = []; // Then, each following group is a sequence of MemberExpression followed by
    // a sequence of CallExpression. To compute it, we keep adding things to the
    // group until we has seen a CallExpression in the past and reach a
    // MemberExpression

    var hasSeenCallExpression = false;

    for (; i < printedNodes.length; ++i) {
      if (hasSeenCallExpression && isMemberish$1(printedNodes[i].node)) {
        // [0] should be appended at the end of the group instead of the
        // beginning of the next one
        if (printedNodes[i].node.computed && isNumericLiteral$1(printedNodes[i].node.property)) {
          currentGroup.push(printedNodes[i]);
          continue;
        }

        groups.push(currentGroup);
        currentGroup = [];
        hasSeenCallExpression = false;
      }

      if (printedNodes[i].node.type === "CallExpression" || printedNodes[i].node.type === "OptionalCallExpression") {
        hasSeenCallExpression = true;
      }

      currentGroup.push(printedNodes[i]);

      if (printedNodes[i].node.comments && printedNodes[i].node.comments.some(function (comment) {
        return comment.trailing;
      })) {
        groups.push(currentGroup);
        currentGroup = [];
        hasSeenCallExpression = false;
      }
    }

    if (currentGroup.length > 0) {
      groups.push(currentGroup);
    } // There are cases like Object.keys(), Observable.of(), _.values() where
    // they are the subject of all the chained calls and therefore should
    // be kept on the same line:
    //
    //   Object.keys(items)
    //     .filter(x => x)
    //     .map(x => x)
    //
    // In order to detect those cases, we use an heuristic: if the first
    // node is an identifier with the name starting with a capital
    // letter or just a sequence of _$. The rationale is that they are
    // likely to be factories.


    function isFactory(name) {
      return /^[A-Z]|^[_$]+$/.test(name);
    } // In case the Identifier is shorter than tab width, we can keep the
    // first call in a single line, if it's an ExpressionStatement.
    //
    //   d3.scaleLinear()
    //     .domain([0, 100])
    //     .range([0, width]);
    //


    function isShort(name) {
      return name.length <= options.tabWidth;
    }

    function shouldNotWrap(groups) {
      var parent = path.getParentNode();
      var isExpression = parent && parent.type === "ExpressionStatement";
      var hasComputed = groups[1].length && groups[1][0].node.computed;

      if (groups[0].length === 1) {
        var firstNode = groups[0][0].node;
        return firstNode.type === "ThisExpression" || firstNode.type === "Identifier" && (isFactory(firstNode.name) || isExpression && isShort(firstNode.name) || hasComputed);
      }

      var lastNode = getLast$2(groups[0]).node;
      return (lastNode.type === "MemberExpression" || lastNode.type === "OptionalMemberExpression") && lastNode.property.type === "Identifier" && (isFactory(lastNode.property.name) || hasComputed);
    }

    var shouldMerge = groups.length >= 2 && !groups[1][0].node.comments && shouldNotWrap(groups);

    function printGroup(printedGroup) {
      var printed = printedGroup.map(function (tuple) {
        return tuple.printed;
      }); // Checks if the last node (i.e. the parent node) needs parens and print
      // accordingly

      if (printedGroup.length > 0 && printedGroup[printedGroup.length - 1].needsParens) {
        return concat$d(["("].concat(_toConsumableArray(printed), [")"]));
      }

      return concat$d(printed);
    }

    function printIndentedGroup(groups) {
      if (groups.length === 0) {
        return "";
      }

      return indent$7(group$b(concat$d([hardline$9, join$9(hardline$9, groups.map(printGroup))])));
    }

    var printedGroups = groups.map(printGroup);
    var oneLine = concat$d(printedGroups);
    var cutoff = shouldMerge ? 3 : 2;
    var flatGroups = groups.slice(0, cutoff).reduce(function (res, group) {
      return res.concat(group);
    }, []);
    var hasComment = flatGroups.slice(1, -1).some(function (node) {
      return hasLeadingComment$3(node.node);
    }) || flatGroups.slice(0, -1).some(function (node) {
      return hasTrailingComment$1(node.node);
    }) || groups[cutoff] && hasLeadingComment$3(groups[cutoff][0].node); // If we only have a single `.`, we shouldn't do anything fancy and just
    // render everything concatenated together.

    if (groups.length <= cutoff && !hasComment) {
      if (isLongCurriedCallExpression$1(path)) {
        return oneLine;
      }

      return group$b(oneLine);
    } // Find out the last node in the first group and check if it has an
    // empty line after


    var lastNodeBeforeIndent = getLast$2(shouldMerge ? groups.slice(1, 2)[0] : groups[0]).node;
    var shouldHaveEmptyLineBeforeIndent = lastNodeBeforeIndent.type !== "CallExpression" && lastNodeBeforeIndent.type !== "OptionalCallExpression" && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);
    var expanded = concat$d([printGroup(groups[0]), shouldMerge ? concat$d(groups.slice(1, 2).map(printGroup)) : "", shouldHaveEmptyLineBeforeIndent ? hardline$9 : "", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))]);
    var callExpressions = printedNodes.map(function (_ref) {
      var node = _ref.node;
      return node;
    }).filter(isCallOrOptionalCallExpression$1); // We don't want to print in one line if there's:
    //  * A comment.
    //  * 3 or more chained calls.
    //  * Any group but the last one has a hard line.
    // If the last group is a function it's okay to inline if it fits.

    if (hasComment || callExpressions.length >= 3 || printedGroups.slice(0, -1).some(willBreak$1) ||
    /**
     *     scopes.filter(scope => scope.value !== '').map((scope, i) => {
     *       // multi line content
     *     })
     */
    function (lastGroupDoc, lastGroupNode) {
      return isCallOrOptionalCallExpression$1(lastGroupNode) && willBreak$1(lastGroupDoc);
    }(getLast$2(printedGroups), getLast$2(getLast$2(groups)).node) && callExpressions.slice(0, -1).some(function (n) {
      return n.arguments.some(isFunctionOrArrowExpression$1);
    })) {
      return group$b(expanded);
    }

    return concat$d([// We only need to check `oneLine` because if `expanded` is chosen
    // that means that the parent group has already been broken
    // naturally
    willBreak$1(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent$3 : "", conditionalGroup$1([oneLine, expanded])]);
  }

  function separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {
    if (isFacebookTranslationTag) {
      return "";
    }

    if (childNode.type === "JSXElement" && !childNode.closingElement || nextNode && nextNode.type === "JSXElement" && !nextNode.closingElement) {
      return child.length === 1 ? softline$6 : hardline$9;
    }

    return softline$6;
  }

  function separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {
    if (isFacebookTranslationTag) {
      return hardline$9;
    }

    if (child.length === 1) {
      return childNode.type === "JSXElement" && !childNode.closingElement || nextNode && nextNode.type === "JSXElement" && !nextNode.closingElement ? hardline$9 : softline$6;
    }

    return hardline$9;
  } // JSX Children are strange, mostly for two reasons:
  // 1. JSX reads newlines into string values, instead of skipping them like JS
  // 2. up to one whitespace between elements within a line is significant,
  //    but not between lines.
  //
  // Leading, trailing, and lone whitespace all need to
  // turn themselves into the rather ugly `{' '}` when breaking.
  //
  // We print JSX using the `fill` doc primitive.
  // This requires that we give it an array of alternating
  // content and whitespace elements.
  // To ensure this we add dummy `""` content elements as needed.


  function printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag) {
    var n = path.getValue();
    var children = []; // using `map` instead of `each` because it provides `i`

    path.map(function (childPath, i) {
      var child = childPath.getValue();

      if (isLiteral$1(child)) {
        var text = rawText$1(child); // Contains a non-whitespace character

        if (isMeaningfulJSXText$1(child)) {
          var words = text.split(matchJsxWhitespaceRegex$1); // Starts with whitespace

          if (words[0] === "") {
            children.push("");
            words.shift();

            if (/\n/.test(words[0])) {
              var next = n.children[i + 1];
              children.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], child, next));
            } else {
              children.push(jsxWhitespace);
            }

            words.shift();
          }

          var endWhitespace; // Ends with whitespace

          if (getLast$2(words) === "") {
            words.pop();
            endWhitespace = words.pop();
          } // This was whitespace only without a new line.


          if (words.length === 0) {
            return;
          }

          words.forEach(function (word, i) {
            if (i % 2 === 1) {
              children.push(line$7);
            } else {
              children.push(word);
            }
          });

          if (endWhitespace !== undefined) {
            if (/\n/.test(endWhitespace)) {
              var _next = n.children[i + 1];
              children.push(separatorWithWhitespace(isFacebookTranslationTag, getLast$2(children), child, _next));
            } else {
              children.push(jsxWhitespace);
            }
          } else {
            var _next2 = n.children[i + 1];
            children.push(separatorNoWhitespace(isFacebookTranslationTag, getLast$2(children), child, _next2));
          }
        } else if (/\n/.test(text)) {
          // Keep (up to one) blank line between tags/expressions/text.
          // Note: We don't keep blank lines between text elements.
          if (text.match(/\n/g).length > 1) {
            children.push("");
            children.push(hardline$9);
          }
        } else {
          children.push("");
          children.push(jsxWhitespace);
        }
      } else {
        var printedChild = print(childPath);
        children.push(printedChild);
        var _next3 = n.children[i + 1];

        var directlyFollowedByMeaningfulText = _next3 && isMeaningfulJSXText$1(_next3);

        if (directlyFollowedByMeaningfulText) {
          var firstWord = rawText$1(_next3).trim().split(matchJsxWhitespaceRegex$1)[0];
          children.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, child, _next3));
        } else {
          children.push(hardline$9);
        }
      }
    }, "children");
    return children;
  } // JSX expands children from the inside-out, instead of the outside-in.
  // This is both to break children before attributes,
  // and to ensure that when children break, their parents do as well.
  //
  // Any element that is written without any newlines and fits on a single line
  // is left that way.
  // Not only that, any user-written-line containing multiple JSX siblings
  // should also be kept on one line if possible,
  // so each user-written-line is wrapped in its own group.
  //
  // Elements that contain newlines or don't fit on a single line (recursively)
  // are fully-split, using hardline and shouldBreak: true.
  //
  // To support that case properly, all leading and trailing spaces
  // are stripped from the list of children, and replaced with a single hardline.


  function printJSXElement(path, options, print) {
    var n = path.getValue();

    if (n.type === "JSXElement" && isEmptyJSXElement$1(n)) {
      return concat$d([path.call(print, "openingElement"), path.call(print, "closingElement")]);
    }

    var openingLines = n.type === "JSXElement" ? path.call(print, "openingElement") : path.call(print, "openingFragment");
    var closingLines = n.type === "JSXElement" ? path.call(print, "closingElement") : path.call(print, "closingFragment");

    if (n.children.length === 1 && n.children[0].type === "JSXExpressionContainer" && (n.children[0].expression.type === "TemplateLiteral" || n.children[0].expression.type === "TaggedTemplateExpression")) {
      return concat$d([openingLines, concat$d(path.map(print, "children")), closingLines]);
    } // Convert `{" "}` to text nodes containing a space.
    // This makes it easy to turn them into `jsxWhitespace` which
    // can then print as either a space or `{" "}` when breaking.


    n.children = n.children.map(function (child) {
      if (isJSXWhitespaceExpression$1(child)) {
        return {
          type: "JSXText",
          value: " ",
          raw: " "
        };
      }

      return child;
    });
    var containsTag = n.children.filter(isJSXNode$1).length > 0;
    var containsMultipleExpressions = n.children.filter(function (child) {
      return child.type === "JSXExpressionContainer";
    }).length > 1;
    var containsMultipleAttributes = n.type === "JSXElement" && n.openingElement.attributes.length > 1; // Record any breaks. Should never go from true to false, only false to true.

    var forcedBreak = willBreak$1(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;
    var rawJsxWhitespace = options.singleQuote ? "{' '}" : '{" "}';
    var jsxWhitespace = ifBreak$6(concat$d([rawJsxWhitespace, softline$6]), " ");
    var isFacebookTranslationTag = n.openingElement && n.openingElement.name && n.openingElement.name.name === "fbt";
    var children = printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag);
    var containsText = n.children.filter(function (child) {
      return isMeaningfulJSXText$1(child);
    }).length > 0; // We can end up we multiple whitespace elements with empty string
    // content between them.
    // We need to remove empty whitespace and softlines before JSX whitespace
    // to get the correct output.

    for (var i = children.length - 2; i >= 0; i--) {
      var isPairOfEmptyStrings = children[i] === "" && children[i + 1] === "";
      var isPairOfHardlines = children[i] === hardline$9 && children[i + 1] === "" && children[i + 2] === hardline$9;
      var isLineFollowedByJSXWhitespace = (children[i] === softline$6 || children[i] === hardline$9) && children[i + 1] === "" && children[i + 2] === jsxWhitespace;
      var isJSXWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === "" && (children[i + 2] === softline$6 || children[i + 2] === hardline$9);
      var isDoubleJSXWhitespace = children[i] === jsxWhitespace && children[i + 1] === "" && children[i + 2] === jsxWhitespace;
      var isPairOfHardOrSoftLines = children[i] === softline$6 && children[i + 1] === "" && children[i + 2] === hardline$9 || children[i] === hardline$9 && children[i + 1] === "" && children[i + 2] === softline$6;

      if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJSXWhitespace || isDoubleJSXWhitespace || isPairOfHardOrSoftLines) {
        children.splice(i, 2);
      } else if (isJSXWhitespaceFollowedByLine) {
        children.splice(i + 1, 2);
      }
    } // Trim trailing lines (or empty strings)


    while (children.length && (isLineNext$1(getLast$2(children)) || isEmpty$1(getLast$2(children)))) {
      children.pop();
    } // Trim leading lines (or empty strings)


    while (children.length && (isLineNext$1(children[0]) || isEmpty$1(children[0])) && (isLineNext$1(children[1]) || isEmpty$1(children[1]))) {
      children.shift();
      children.shift();
    } // Tweak how we format children if outputting this element over multiple lines.
    // Also detect whether we will force this element to output over multiple lines.


    var multilineChildren = [];
    children.forEach(function (child, i) {
      // There are a number of situations where we need to ensure we display
      // whitespace as `{" "}` when outputting this element over multiple lines.
      if (child === jsxWhitespace) {
        if (i === 1 && children[i - 1] === "") {
          if (children.length === 2) {
            // Solitary whitespace
            multilineChildren.push(rawJsxWhitespace);
            return;
          } // Leading whitespace


          multilineChildren.push(concat$d([rawJsxWhitespace, hardline$9]));
          return;
        } else if (i === children.length - 1) {
          // Trailing whitespace
          multilineChildren.push(rawJsxWhitespace);
          return;
        } else if (children[i - 1] === "" && children[i - 2] === hardline$9) {
          // Whitespace after line break
          multilineChildren.push(rawJsxWhitespace);
          return;
        }
      }

      multilineChildren.push(child);

      if (willBreak$1(child)) {
        forcedBreak = true;
      }
    }); // If there is text we use `fill` to fit as much onto each line as possible.
    // When there is no text (just tags and expressions) we use `group`
    // to output each on a separate line.

    var content = containsText ? fill$4(multilineChildren) : group$b(concat$d(multilineChildren), {
      shouldBreak: true
    });
    var multiLineElem = group$b(concat$d([openingLines, indent$7(concat$d([hardline$9, content])), hardline$9, closingLines]));

    if (forcedBreak) {
      return multiLineElem;
    }

    return conditionalGroup$1([group$b(concat$d([openingLines, concat$d(children), closingLines])), multiLineElem]);
  }

  function maybeWrapJSXElementInParens(path, elem, options) {
    var parent = path.getParentNode();

    if (!parent) {
      return elem;
    }

    var NO_WRAP_PARENTS = {
      ArrayExpression: true,
      JSXAttribute: true,
      JSXElement: true,
      JSXExpressionContainer: true,
      JSXFragment: true,
      ExpressionStatement: true,
      CallExpression: true,
      OptionalCallExpression: true,
      ConditionalExpression: true,
      JsExpressionRoot: true
    };

    if (NO_WRAP_PARENTS[parent.type]) {
      return elem;
    }

    var shouldBreak = matchAncestorTypes$1(path, ["ArrowFunctionExpression", "CallExpression", "JSXExpressionContainer"]) || matchAncestorTypes$1(path, ["ArrowFunctionExpression", "OptionalCallExpression", "JSXExpressionContainer"]);
    var needsParens = needsParens_1(path, options);
    return group$b(concat$d([needsParens ? "" : ifBreak$6("("), indent$7(concat$d([softline$6, elem])), softline$6, needsParens ? "" : ifBreak$6(")")]), {
      shouldBreak: shouldBreak
    });
  }

  function shouldInlineLogicalExpression(node) {
    if (node.type !== "LogicalExpression") {
      return false;
    }

    if (node.right.type === "ObjectExpression" && node.right.properties.length !== 0) {
      return true;
    }

    if (node.right.type === "ArrayExpression" && node.right.elements.length !== 0) {
      return true;
    }

    if (isJSXNode$1(node.right)) {
      return true;
    }

    return false;
  } // For binary expressions to be consistent, we need to group
  // subsequent operators with the same precedence level under a single
  // group. Otherwise they will be nested such that some of them break
  // onto new lines but not all. Operators with the same precedence
  // level should either all break or not. Because we group them by
  // precedence level and the AST is structured based on precedence
  // level, things are naturally broken up correctly, i.e. `&&` is
  // broken before `+`.


  function printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {
    var parts = [];
    var node = path.getValue(); // We treat BinaryExpression and LogicalExpression nodes the same.

    if (isBinaryish$1(node)) {
      // Put all operators with the same precedence level in the same
      // group. The reason we only need to do this with the `left`
      // expression is because given an expression like `1 + 2 - 3`, it
      // is always parsed like `((1 + 2) - 3)`, meaning the `left` side
      // is where the rest of the expression will exist. Binary
      // expressions on the right side mean they have a difference
      // precedence level and should be treated as a separate group, so
      // print them normally. (This doesn't hold for the `**` operator,
      // which is unique in that it is right-associative.)
      if (shouldFlatten$1(node.operator, node.left.operator)) {
        // Flatten them out by recursively calling this function.
        parts = parts.concat(path.call(function (left) {
          return printBinaryishExpressions(left, print, options,
          /* isNested */
          true, isInsideParenthesis);
        }, "left"));
      } else {
        parts.push(path.call(print, "left"));
      }

      var shouldInline = shouldInlineLogicalExpression(node);
      var lineBeforeOperator = (node.operator === "|>" || node.type === "NGPipeExpression" || node.operator === "|" && options.parser === "__vue_expression") && !hasLeadingOwnLineComment$1(options.originalText, node.right, options);
      var operator = node.type === "NGPipeExpression" ? "|" : node.operator;
      var rightSuffix = node.type === "NGPipeExpression" && node.arguments.length !== 0 ? group$b(indent$7(concat$d([softline$6, ": ", join$9(concat$d([softline$6, ":", ifBreak$6(" ")]), path.map(print, "arguments").map(function (arg) {
        return align$1(2, group$b(arg));
      }))]))) : "";
      var right = shouldInline ? concat$d([operator, " ", path.call(print, "right"), rightSuffix]) : concat$d([lineBeforeOperator ? softline$6 : "", operator, lineBeforeOperator ? " " : line$7, path.call(print, "right"), rightSuffix]); // If there's only a single binary expression, we want to create a group
      // in order to avoid having a small right part like -1 be on its own line.

      var parent = path.getParentNode();
      var shouldGroup = !(isInsideParenthesis && node.type === "LogicalExpression") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;
      parts.push(" ", shouldGroup ? group$b(right) : right); // The root comments are already printed, but we need to manually print
      // the other ones since we don't call the normal print on BinaryExpression,
      // only for the left and right parts

      if (isNested && node.comments) {
        parts = comments.printComments(path, function () {
          return concat$d(parts);
        }, options);
      }
    } else {
      // Our stopping case. Simply print the node normally.
      parts.push(path.call(print));
    }

    return parts;
  }

  function printAssignmentRight(leftNode, rightNode, printedRight, options) {
    if (hasLeadingOwnLineComment$1(options.originalText, rightNode, options)) {
      return indent$7(concat$d([hardline$9, printedRight]));
    }

    var canBreak = isBinaryish$1(rightNode) && !shouldInlineLogicalExpression(rightNode) || rightNode.type === "ConditionalExpression" && isBinaryish$1(rightNode.test) && !shouldInlineLogicalExpression(rightNode.test) || rightNode.type === "StringLiteralTypeAnnotation" || rightNode.type === "ClassExpression" && rightNode.decorators && rightNode.decorators.length || (leftNode.type === "Identifier" || isStringLiteral$1(leftNode) || leftNode.type === "MemberExpression") && (isStringLiteral$1(rightNode) || isMemberExpressionChain$1(rightNode)) && // do not put values on a separate line from the key in json
    options.parser !== "json" && options.parser !== "json5" || rightNode.type === "SequenceExpression";

    if (canBreak) {
      return group$b(indent$7(concat$d([line$7, printedRight])));
    }

    return concat$d([" ", printedRight]);
  }

  function printAssignment(leftNode, printedLeft, operator, rightNode, printedRight, options) {
    if (!rightNode) {
      return printedLeft;
    }

    var printed = printAssignmentRight(leftNode, rightNode, printedRight, options);
    return group$b(concat$d([printedLeft, operator, printed]));
  }

  function adjustClause(node, clause, forceSpace) {
    if (node.type === "EmptyStatement") {
      return ";";
    }

    if (node.type === "BlockStatement" || forceSpace) {
      return concat$d([" ", clause]);
    }

    return indent$7(concat$d([line$7, clause]));
  }

  function nodeStr(node, options, isFlowOrTypeScriptDirectiveLiteral) {
    var raw = rawText$1(node);
    var isDirectiveLiteral = isFlowOrTypeScriptDirectiveLiteral || node.type === "DirectiveLiteral";
    return printString$2(raw, options, isDirectiveLiteral);
  }

  function printRegex(node) {
    var flags = node.flags.split("").sort().join("");
    return "/".concat(node.pattern, "/").concat(flags);
  }

  function exprNeedsASIProtection(path, options) {
    var node = path.getValue();
    var maybeASIProblem = needsParens_1(path, options) || node.type === "ParenthesizedExpression" || node.type === "TypeCastExpression" || node.type === "ArrowFunctionExpression" && !shouldPrintParamsWithoutParens(path, options) || node.type === "ArrayExpression" || node.type === "ArrayPattern" || node.type === "UnaryExpression" && node.prefix && (node.operator === "+" || node.operator === "-") || node.type === "TemplateLiteral" || node.type === "TemplateElement" || isJSXNode$1(node) || node.type === "BindExpression" && !node.object || node.type === "RegExpLiteral" || node.type === "Literal" && node.pattern || node.type === "Literal" && node.regex;

    if (maybeASIProblem) {
      return true;
    }

    if (!hasNakedLeftSide$2(node)) {
      return false;
    }

    return path.call.apply(path, [function (childPath) {
      return exprNeedsASIProtection(childPath, options);
    }].concat(getLeftSidePathName$2(path, node)));
  }

  function stmtNeedsASIProtection(path, options) {
    var node = path.getNode();

    if (node.type !== "ExpressionStatement") {
      return false;
    }

    return path.call(function (childPath) {
      return exprNeedsASIProtection(childPath, options);
    }, "expression");
  }

  function shouldHugType(node) {
    if (isSimpleFlowType$1(node) || isObjectType$1(node)) {
      return true;
    }

    if (node.type === "UnionTypeAnnotation" || node.type === "TSUnionType") {
      var voidCount = node.types.filter(function (n) {
        return n.type === "VoidTypeAnnotation" || n.type === "TSVoidKeyword" || n.type === "NullLiteralTypeAnnotation" || n.type === "TSNullKeyword";
      }).length;
      var objectCount = node.types.filter(function (n) {
        return n.type === "ObjectTypeAnnotation" || n.type === "TSTypeLiteral" || // This is a bit aggressive but captures Array<{x}>
        n.type === "GenericTypeAnnotation" || n.type === "TSTypeReference";
      }).length;

      if (node.types.length - 1 === voidCount && objectCount > 0) {
        return true;
      }
    }

    return false;
  }

  function shouldHugArguments(fun) {
    return fun && fun.params && fun.params.length === 1 && !fun.params[0].comments && (fun.params[0].type === "ObjectPattern" || fun.params[0].type === "ArrayPattern" || fun.params[0].type === "Identifier" && fun.params[0].typeAnnotation && (fun.params[0].typeAnnotation.type === "TypeAnnotation" || fun.params[0].typeAnnotation.type === "TSTypeAnnotation") && isObjectType$1(fun.params[0].typeAnnotation.typeAnnotation) || fun.params[0].type === "FunctionTypeParam" && isObjectType$1(fun.params[0].typeAnnotation) || fun.params[0].type === "AssignmentPattern" && (fun.params[0].left.type === "ObjectPattern" || fun.params[0].left.type === "ArrayPattern") && (fun.params[0].right.type === "Identifier" || fun.params[0].right.type === "ObjectExpression" && fun.params[0].right.properties.length === 0 || fun.params[0].right.type === "ArrayExpression" && fun.params[0].right.elements.length === 0)) && !fun.rest;
  }

  function printArrayItems(path, options, printPath, print) {
    var printedElements = [];
    var separatorParts = [];
    path.each(function (childPath) {
      printedElements.push(concat$d(separatorParts));
      printedElements.push(group$b(print(childPath)));
      separatorParts = [",", line$7];

      if (childPath.getValue() && isNextLineEmpty$4(options.originalText, childPath.getValue(), options)) {
        separatorParts.push(softline$6);
      }
    }, printPath);
    return concat$d(printedElements);
  }

  function willPrintOwnComments(path
  /*, options */
  ) {
    var node = path.getValue();
    var parent = path.getParentNode();
    return (node && (isJSXNode$1(node) || hasFlowShorthandAnnotationComment$2(node) || parent && (parent.type === "CallExpression" || parent.type === "OptionalCallExpression") && (hasFlowAnnotationComment$1(node.leadingComments) || hasFlowAnnotationComment$1(node.trailingComments))) || parent && (parent.type === "JSXSpreadAttribute" || parent.type === "JSXSpreadChild" || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType" || (parent.type === "ClassDeclaration" || parent.type === "ClassExpression") && parent.superClass === node)) && !hasIgnoreComment$4(path);
  }

  function canAttachComment$1(node) {
    return node.type && node.type !== "CommentBlock" && node.type !== "CommentLine" && node.type !== "Line" && node.type !== "Block" && node.type !== "EmptyStatement" && node.type !== "TemplateElement" && node.type !== "Import";
  }

  function printComment$2(commentPath, options) {
    var comment = commentPath.getValue();

    switch (comment.type) {
      case "CommentBlock":
      case "Block":
        {
          if (isIndentableBlockComment(comment)) {
            var printed = printIndentableBlockComment(comment); // We need to prevent an edge case of a previous trailing comment
            // printed as a `lineSuffix` which causes the comments to be
            // interleaved. See https://github.com/prettier/prettier/issues/4412

            if (comment.trailing && !hasNewline$4(options.originalText, options.locStart(comment), {
              backwards: true
            })) {
              return concat$d([hardline$9, printed]);
            }

            return printed;
          }

          var isInsideFlowComment = options.originalText.substr(options.locEnd(comment) - 3, 3) === "*-/";
          return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
        }

      case "CommentLine":
      case "Line":
        // Print shebangs with the proper comment characters
        if (options.originalText.slice(options.locStart(comment)).startsWith("#!")) {
          return "#!" + comment.value.trimRight();
        }

        return "//" + comment.value.trimRight();

      default:
        throw new Error("Not a comment: " + JSON.stringify(comment));
    }
  }

  function isIndentableBlockComment(comment) {
    // If the comment has multiple lines and every line starts with a star
    // we can fix the indentation of each line. The stars in the `/*` and
    // `*/` delimiters are not included in the comment value, so add them
    // back first.
    var lines = "*".concat(comment.value, "*").split("\n");
    return lines.length > 1 && lines.every(function (line) {
      return line.trim()[0] === "*";
    });
  }

  function printIndentableBlockComment(comment) {
    var lines = comment.value.split("\n");
    return concat$d(["/*", join$9(hardline$9, lines.map(function (line, index) {
      return index === 0 ? line.trimRight() : " " + (index < lines.length - 1 ? line.trim() : line.trimLeft());
    })), "*/"]);
  }

  var printerEstree = {
    preprocess: preprocess_1$1,
    print: genericPrint$3,
    embed: embed_1$1,
    insertPragma: insertPragma$7,
    massageAstNode: clean_1$1,
    hasPrettierIgnore: hasPrettierIgnore$3,
    willPrintOwnComments: willPrintOwnComments,
    canAttachComment: canAttachComment$1,
    printComment: printComment$2,
    isBlockComment: comments$1.isBlockComment,
    handleComments: {
      ownLine: comments$1.handleOwnLineComment,
      endOfLine: comments$1.handleEndOfLineComment,
      remaining: comments$1.handleRemainingComment
    }
  };

  var _require$$0$builders$7 = doc.builders,
      concat$e = _require$$0$builders$7.concat,
      hardline$a = _require$$0$builders$7.hardline,
      indent$8 = _require$$0$builders$7.indent,
      join$a = _require$$0$builders$7.join;

  function genericPrint$4(path, options, print) {
    var node = path.getValue();

    switch (node.type) {
      case "JsonRoot":
        return concat$e([path.call(print, "node"), hardline$a]);

      case "ArrayExpression":
        return node.elements.length === 0 ? "[]" : concat$e(["[", indent$8(concat$e([hardline$a, join$a(concat$e([",", hardline$a]), path.map(print, "elements"))])), hardline$a, "]"]);

      case "ObjectExpression":
        return node.properties.length === 0 ? "{}" : concat$e(["{", indent$8(concat$e([hardline$a, join$a(concat$e([",", hardline$a]), path.map(print, "properties"))])), hardline$a, "}"]);

      case "ObjectProperty":
        return concat$e([path.call(print, "key"), ": ", path.call(print, "value")]);

      case "UnaryExpression":
        return concat$e([node.operator === "+" ? "" : node.operator, path.call(print, "argument")]);

      case "NullLiteral":
        return "null";

      case "BooleanLiteral":
        return node.value ? "true" : "false";

      case "StringLiteral":
      case "NumericLiteral":
        return JSON.stringify(node.value);

      case "Identifier":
        return JSON.stringify(node.name);

      default:
        /* istanbul ignore next */
        throw new Error("unknown type: " + JSON.stringify(node.type));
    }
  }

  function clean$5(node, newNode
  /*, parent*/
  ) {
    delete newNode.start;
    delete newNode.end;
    delete newNode.extra;
    delete newNode.loc;
    delete newNode.comments;
    delete newNode.errors;

    if (node.type === "Identifier") {
      return {
        type: "StringLiteral",
        value: node.name
      };
    }

    if (node.type === "UnaryExpression" && node.operator === "+") {
      return newNode.argument;
    }
  }

  var printerEstreeJson = {
    preprocess: preprocess_1$1,
    print: genericPrint$4,
    massageAstNode: clean$5
  };

  var CATEGORY_JAVASCRIPT = "JavaScript"; // format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js

  var options$5 = {
    arrowParens: {
      since: "1.9.0",
      category: CATEGORY_JAVASCRIPT,
      type: "choice",
      default: "avoid",
      description: "Include parentheses around a sole arrow function parameter.",
      choices: [{
        value: "avoid",
        description: "Omit parens when possible. Example: `x => x`"
      }, {
        value: "always",
        description: "Always include parens. Example: `(x) => x`"
      }]
    },
    bracketSpacing: commonOptions.bracketSpacing,
    jsxBracketSameLine: {
      since: "0.17.0",
      category: CATEGORY_JAVASCRIPT,
      type: "boolean",
      default: false,
      description: "Put > on the last line instead of at a new line."
    },
    semi: {
      since: "1.0.0",
      category: CATEGORY_JAVASCRIPT,
      type: "boolean",
      default: true,
      description: "Print semicolons.",
      oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
    },
    singleQuote: commonOptions.singleQuote,
    jsxSingleQuote: {
      since: "1.15.0",
      category: CATEGORY_JAVASCRIPT,
      type: "boolean",
      default: false,
      description: "Use single quotes in JSX."
    },
    quoteProps: {
      since: "1.17.0",
      category: CATEGORY_JAVASCRIPT,
      type: "choice",
      default: "as-needed",
      description: "Change when properties in objects are quoted.",
      choices: [{
        value: "as-needed",
        description: "Only add quotes around object properties where required."
      }, {
        value: "consistent",
        description: "If at least one property in an object requires quotes, quote all properties."
      }, {
        value: "preserve",
        description: "Respect the input use of quotes in object properties."
      }]
    },
    trailingComma: {
      since: "0.0.0",
      category: CATEGORY_JAVASCRIPT,
      type: "choice",
      default: [{
        since: "0.0.0",
        value: false
      }, {
        since: "0.19.0",
        value: "none"
      }],
      description: "Print trailing commas wherever possible when multi-line.",
      choices: [{
        value: "none",
        description: "No trailing commas."
      }, {
        value: "es5",
        description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
      }, {
        value: "all",
        description: "Trailing commas wherever possible (including function arguments)."
      }, {
        value: true,
        deprecated: "0.19.0",
        redirect: "es5"
      }, {
        value: false,
        deprecated: "0.19.0",
        redirect: "none"
      }]
    }
  };

  var name$9 = "JavaScript";
  var type$8 = "programming";
  var tmScope$8 = "source.js";
  var aceMode$8 = "javascript";
  var codemirrorMode$4 = "javascript";
  var codemirrorMimeType$4 = "text/javascript";
  var color$3 = "#f1e05a";
  var aliases$2 = [
  	"js",
  	"node"
  ];
  var extensions$8 = [
  	".js",
  	"._js",
  	".bones",
  	".es",
  	".es6",
  	".frag",
  	".gs",
  	".jake",
  	".jsb",
  	".jscad",
  	".jsfl",
  	".jsm",
  	".jss",
  	".mjs",
  	".njs",
  	".pac",
  	".sjs",
  	".ssjs",
  	".xsjs",
  	".xsjslib"
  ];
  var filenames = [
  	"Jakefile"
  ];
  var interpreters = [
  	"chakra",
  	"d8",
  	"js",
  	"node",
  	"rhino",
  	"v8",
  	"v8-shell"
  ];
  var languageId$8 = 183;
  var JavaScript = {
  	name: name$9,
  	type: type$8,
  	tmScope: tmScope$8,
  	aceMode: aceMode$8,
  	codemirrorMode: codemirrorMode$4,
  	codemirrorMimeType: codemirrorMimeType$4,
  	color: color$3,
  	aliases: aliases$2,
  	extensions: extensions$8,
  	filenames: filenames,
  	interpreters: interpreters,
  	languageId: languageId$8
  };

  var JavaScript$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$9,
    type: type$8,
    tmScope: tmScope$8,
    aceMode: aceMode$8,
    codemirrorMode: codemirrorMode$4,
    codemirrorMimeType: codemirrorMimeType$4,
    color: color$3,
    aliases: aliases$2,
    extensions: extensions$8,
    filenames: filenames,
    interpreters: interpreters,
    languageId: languageId$8,
    'default': JavaScript
  });

  var name$a = "JSX";
  var type$9 = "programming";
  var group$c = "JavaScript";
  var extensions$9 = [
  	".jsx"
  ];
  var tmScope$9 = "source.js.jsx";
  var aceMode$9 = "javascript";
  var codemirrorMode$5 = "jsx";
  var codemirrorMimeType$5 = "text/jsx";
  var languageId$9 = 178;
  var JSX = {
  	name: name$a,
  	type: type$9,
  	group: group$c,
  	extensions: extensions$9,
  	tmScope: tmScope$9,
  	aceMode: aceMode$9,
  	codemirrorMode: codemirrorMode$5,
  	codemirrorMimeType: codemirrorMimeType$5,
  	languageId: languageId$9
  };

  var JSX$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$a,
    type: type$9,
    group: group$c,
    extensions: extensions$9,
    tmScope: tmScope$9,
    aceMode: aceMode$9,
    codemirrorMode: codemirrorMode$5,
    codemirrorMimeType: codemirrorMimeType$5,
    languageId: languageId$9,
    'default': JSX
  });

  var name$b = "TypeScript";
  var type$a = "programming";
  var color$4 = "#2b7489";
  var aliases$3 = [
  	"ts"
  ];
  var interpreters$1 = [
  	"deno",
  	"ts-node"
  ];
  var extensions$a = [
  	".ts"
  ];
  var tmScope$a = "source.ts";
  var aceMode$a = "typescript";
  var codemirrorMode$6 = "javascript";
  var codemirrorMimeType$6 = "application/typescript";
  var languageId$a = 378;
  var TypeScript = {
  	name: name$b,
  	type: type$a,
  	color: color$4,
  	aliases: aliases$3,
  	interpreters: interpreters$1,
  	extensions: extensions$a,
  	tmScope: tmScope$a,
  	aceMode: aceMode$a,
  	codemirrorMode: codemirrorMode$6,
  	codemirrorMimeType: codemirrorMimeType$6,
  	languageId: languageId$a
  };

  var TypeScript$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$b,
    type: type$a,
    color: color$4,
    aliases: aliases$3,
    interpreters: interpreters$1,
    extensions: extensions$a,
    tmScope: tmScope$a,
    aceMode: aceMode$a,
    codemirrorMode: codemirrorMode$6,
    codemirrorMimeType: codemirrorMimeType$6,
    languageId: languageId$a,
    'default': TypeScript
  });

  var name$c = "TSX";
  var type$b = "programming";
  var group$d = "TypeScript";
  var extensions$b = [
  	".tsx"
  ];
  var tmScope$b = "source.tsx";
  var aceMode$b = "javascript";
  var codemirrorMode$7 = "jsx";
  var codemirrorMimeType$7 = "text/jsx";
  var languageId$b = 94901924;
  var TSX = {
  	name: name$c,
  	type: type$b,
  	group: group$d,
  	extensions: extensions$b,
  	tmScope: tmScope$b,
  	aceMode: aceMode$b,
  	codemirrorMode: codemirrorMode$7,
  	codemirrorMimeType: codemirrorMimeType$7,
  	languageId: languageId$b
  };

  var TSX$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$c,
    type: type$b,
    group: group$d,
    extensions: extensions$b,
    tmScope: tmScope$b,
    aceMode: aceMode$b,
    codemirrorMode: codemirrorMode$7,
    codemirrorMimeType: codemirrorMimeType$7,
    languageId: languageId$b,
    'default': TSX
  });

  var name$d = "JSON";
  var type$c = "data";
  var tmScope$c = "source.json";
  var aceMode$c = "json";
  var codemirrorMode$8 = "javascript";
  var codemirrorMimeType$8 = "application/json";
  var searchable = false;
  var extensions$c = [
  	".json",
  	".avsc",
  	".geojson",
  	".gltf",
  	".har",
  	".ice",
  	".JSON-tmLanguage",
  	".jsonl",
  	".mcmeta",
  	".tfstate",
  	".tfstate.backup",
  	".topojson",
  	".webapp",
  	".webmanifest",
  	".yy",
  	".yyp"
  ];
  var filenames$1 = [
  	".arcconfig",
  	".htmlhintrc",
  	".tern-config",
  	".tern-project",
  	".watchmanconfig",
  	"composer.lock",
  	"mcmod.info"
  ];
  var languageId$c = 174;
  var _JSON = {
  	name: name$d,
  	type: type$c,
  	tmScope: tmScope$c,
  	aceMode: aceMode$c,
  	codemirrorMode: codemirrorMode$8,
  	codemirrorMimeType: codemirrorMimeType$8,
  	searchable: searchable,
  	extensions: extensions$c,
  	filenames: filenames$1,
  	languageId: languageId$c
  };

  var _JSON$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$d,
    type: type$c,
    tmScope: tmScope$c,
    aceMode: aceMode$c,
    codemirrorMode: codemirrorMode$8,
    codemirrorMimeType: codemirrorMimeType$8,
    searchable: searchable,
    extensions: extensions$c,
    filenames: filenames$1,
    languageId: languageId$c,
    'default': _JSON
  });

  var name$e = "JSON with Comments";
  var type$d = "data";
  var group$e = "JSON";
  var tmScope$d = "source.js";
  var aceMode$d = "javascript";
  var codemirrorMode$9 = "javascript";
  var codemirrorMimeType$9 = "text/javascript";
  var aliases$4 = [
  	"jsonc"
  ];
  var extensions$d = [
  	".sublime-build",
  	".sublime-commands",
  	".sublime-completions",
  	".sublime-keymap",
  	".sublime-macro",
  	".sublime-menu",
  	".sublime-mousemap",
  	".sublime-project",
  	".sublime-settings",
  	".sublime-theme",
  	".sublime-workspace",
  	".sublime_metrics",
  	".sublime_session"
  ];
  var filenames$2 = [
  	".babelrc",
  	".eslintrc.json",
  	".jscsrc",
  	".jshintrc",
  	".jslintrc",
  	"jsconfig.json",
  	"language-configuration.json",
  	"tsconfig.json"
  ];
  var languageId$d = 423;
  var JSON_with_Comments = {
  	name: name$e,
  	type: type$d,
  	group: group$e,
  	tmScope: tmScope$d,
  	aceMode: aceMode$d,
  	codemirrorMode: codemirrorMode$9,
  	codemirrorMimeType: codemirrorMimeType$9,
  	aliases: aliases$4,
  	extensions: extensions$d,
  	filenames: filenames$2,
  	languageId: languageId$d
  };

  var JSON_with_Comments$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$e,
    type: type$d,
    group: group$e,
    tmScope: tmScope$d,
    aceMode: aceMode$d,
    codemirrorMode: codemirrorMode$9,
    codemirrorMimeType: codemirrorMimeType$9,
    aliases: aliases$4,
    extensions: extensions$d,
    filenames: filenames$2,
    languageId: languageId$d,
    'default': JSON_with_Comments
  });

  var name$f = "JSON5";
  var type$e = "data";
  var extensions$e = [
  	".json5"
  ];
  var tmScope$e = "source.js";
  var aceMode$e = "javascript";
  var codemirrorMode$a = "javascript";
  var codemirrorMimeType$a = "application/json";
  var languageId$e = 175;
  var JSON5 = {
  	name: name$f,
  	type: type$e,
  	extensions: extensions$e,
  	tmScope: tmScope$e,
  	aceMode: aceMode$e,
  	codemirrorMode: codemirrorMode$a,
  	codemirrorMimeType: codemirrorMimeType$a,
  	languageId: languageId$e
  };

  var JSON5$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$f,
    type: type$e,
    extensions: extensions$e,
    tmScope: tmScope$e,
    aceMode: aceMode$e,
    codemirrorMode: codemirrorMode$a,
    codemirrorMimeType: codemirrorMimeType$a,
    languageId: languageId$e,
    'default': JSON5
  });

  var require$$0$6 = getCjsExportFromNamespace(JavaScript$1);

  var require$$1$2 = getCjsExportFromNamespace(JSX$1);

  var require$$2$1 = getCjsExportFromNamespace(TypeScript$1);

  var require$$3$1 = getCjsExportFromNamespace(TSX$1);

  var require$$4 = getCjsExportFromNamespace(_JSON$1);

  var require$$5 = getCjsExportFromNamespace(JSON_with_Comments$1);

  var require$$6 = getCjsExportFromNamespace(JSON5$1);

  var languages$4 = [createLanguage(require$$0$6, function (data) {
    return Object.assign(data, {
      since: "0.0.0",
      parsers: ["babel", "flow"],
      vscodeLanguageIds: ["javascript", "mongo"],
      interpreters: data.interpreters.concat(["nodejs"])
    });
  }), createLanguage(require$$0$6, function (data) {
    return Object.assign(data, {
      name: "Flow",
      since: "0.0.0",
      parsers: ["babel", "flow"],
      vscodeLanguageIds: ["javascript"],
      aliases: [],
      filenames: [],
      extensions: [".js.flow"]
    });
  }), createLanguage(require$$1$2, function (data) {
    return Object.assign(data, {
      since: "0.0.0",
      parsers: ["babel", "flow"],
      vscodeLanguageIds: ["javascriptreact"]
    });
  }), createLanguage(require$$2$1, function (data) {
    return Object.assign(data, {
      since: "1.4.0",
      parsers: ["typescript"],
      vscodeLanguageIds: ["typescript"]
    });
  }), createLanguage(require$$3$1, function (data) {
    return Object.assign(data, {
      since: "1.4.0",
      parsers: ["typescript"],
      vscodeLanguageIds: ["typescriptreact"]
    });
  }), createLanguage(require$$4, function (data) {
    return Object.assign(data, {
      name: "JSON.stringify",
      since: "1.13.0",
      parsers: ["json-stringify"],
      vscodeLanguageIds: ["json"],
      extensions: [],
      // .json file defaults to json instead of json-stringify
      filenames: ["package.json", "package-lock.json", "composer.json"]
    });
  }), createLanguage(require$$4, function (data) {
    return Object.assign(data, {
      since: "1.5.0",
      parsers: ["json"],
      vscodeLanguageIds: ["json"],
      filenames: data.filenames.concat([".prettierrc"])
    });
  }), createLanguage(require$$5, function (data) {
    return Object.assign(data, {
      since: "1.5.0",
      parsers: ["json"],
      vscodeLanguageIds: ["jsonc"],
      filenames: data.filenames.concat([".eslintrc"])
    });
  }), createLanguage(require$$6, function (data) {
    return Object.assign(data, {
      since: "1.13.0",
      parsers: ["json5"],
      vscodeLanguageIds: ["json5"]
    });
  })];
  var printers$4 = {
    estree: printerEstree,
    "estree-json": printerEstreeJson
  };
  var languageJs = {
    languages: languages$4,
    options: options$5,
    printers: printers$4
  };

  var json$1 = {
    "cjkPattern": "[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u3000-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d]",
    "kPattern": "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",
    "punctuationPattern": "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"
  };

  var cjkPattern = json$1.cjkPattern,
      kPattern = json$1.kPattern,
      punctuationPattern = json$1.punctuationPattern;
  var getLast$3 = util.getLast;
  var INLINE_NODE_TYPES = ["liquidNode", "inlineCode", "emphasis", "strong", "delete", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"];
  var INLINE_NODE_WRAPPER_TYPES = INLINE_NODE_TYPES.concat(["tableCell", "paragraph", "heading"]);
  var kRegex = new RegExp(kPattern);
  var punctuationRegex = new RegExp(punctuationPattern);
  /**
   * split text into whitespaces and words
   * @param {string} text
   * @return {Array<{ type: "whitespace", value: " " | "\n" | "" } | { type: "word", value: string }>}
   */

  function splitText(text, options) {
    var KIND_NON_CJK = "non-cjk";
    var KIND_CJ_LETTER = "cj-letter";
    var KIND_K_LETTER = "k-letter";
    var KIND_CJK_PUNCTUATION = "cjk-punctuation";
    var nodes = [];
    (options.proseWrap === "preserve" ? text : text.replace(new RegExp("(".concat(cjkPattern, ")\n(").concat(cjkPattern, ")"), "g"), "$1$2")).split(/([ \t\n]+)/).forEach(function (token, index, tokens) {
      // whitespace
      if (index % 2 === 1) {
        nodes.push({
          type: "whitespace",
          value: /\n/.test(token) ? "\n" : " "
        });
        return;
      } // word separated by whitespace


      if ((index === 0 || index === tokens.length - 1) && token === "") {
        return;
      }

      token.split(new RegExp("(".concat(cjkPattern, ")"))).forEach(function (innerToken, innerIndex, innerTokens) {
        if ((innerIndex === 0 || innerIndex === innerTokens.length - 1) && innerToken === "") {
          return;
        } // non-CJK word


        if (innerIndex % 2 === 0) {
          if (innerToken !== "") {
            appendNode({
              type: "word",
              value: innerToken,
              kind: KIND_NON_CJK,
              hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),
              hasTrailingPunctuation: punctuationRegex.test(getLast$3(innerToken))
            });
          }

          return;
        } // CJK character


        appendNode(punctuationRegex.test(innerToken) ? {
          type: "word",
          value: innerToken,
          kind: KIND_CJK_PUNCTUATION,
          hasLeadingPunctuation: true,
          hasTrailingPunctuation: true
        } : {
          type: "word",
          value: innerToken,
          kind: kRegex.test(innerToken) ? KIND_K_LETTER : KIND_CJ_LETTER,
          hasLeadingPunctuation: false,
          hasTrailingPunctuation: false
        });
      });
    });
    return nodes;

    function appendNode(node) {
      var lastNode = getLast$3(nodes);

      if (lastNode && lastNode.type === "word") {
        if (lastNode.kind === KIND_NON_CJK && node.kind === KIND_CJ_LETTER && !lastNode.hasTrailingPunctuation || lastNode.kind === KIND_CJ_LETTER && node.kind === KIND_NON_CJK && !node.hasLeadingPunctuation) {
          nodes.push({
            type: "whitespace",
            value: " "
          });
        } else if (!isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) && // disallow leading/trailing full-width whitespace
        ![lastNode.value, node.value].some(function (value) {
          return /\u3000/.test(value);
        })) {
          nodes.push({
            type: "whitespace",
            value: ""
          });
        }
      }

      nodes.push(node);

      function isBetween(kind1, kind2) {
        return lastNode.kind === kind1 && node.kind === kind2 || lastNode.kind === kind2 && node.kind === kind1;
      }
    }
  }

  function getOrderedListItemInfo(orderListItem, originalText) {
    var _originalText$slice$m = originalText.slice(orderListItem.position.start.offset, orderListItem.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/),
        _originalText$slice$m2 = _slicedToArray(_originalText$slice$m, 4),
        numberText = _originalText$slice$m2[1],
        marker = _originalText$slice$m2[2],
        leadingSpaces = _originalText$slice$m2[3];

    return {
      numberText: numberText,
      marker: marker,
      leadingSpaces: leadingSpaces
    };
  } // workaround for https://github.com/remarkjs/remark/issues/351
  // leading and trailing newlines are stripped by remark


  function getFencedCodeBlockValue(node, originalText) {
    var text = originalText.slice(node.position.start.offset, node.position.end.offset);
    var leadingSpaceCount = text.match(/^\s*/)[0].length;
    var replaceRegex = new RegExp("^\\s{0,".concat(leadingSpaceCount, "}"));
    var lineContents = text.split("\n");
    var markerStyle = text[leadingSpaceCount]; // ` or ~

    var marker = text.slice(leadingSpaceCount).match(new RegExp("^[".concat(markerStyle, "]+")))[0]; // https://spec.commonmark.org/0.28/#example-104: Closing fences may be indented by 0-3 spaces
    // https://spec.commonmark.org/0.28/#example-93: The closing code fence must be at least as long as the opening fence

    var hasEndMarker = new RegExp("^\\s{0,3}".concat(marker)).test(lineContents[lineContents.length - 1].slice(getIndent(lineContents.length - 1)));
    return lineContents.slice(1, hasEndMarker ? -1 : undefined).map(function (x, i) {
      return x.slice(getIndent(i + 1)).replace(replaceRegex, "");
    }).join("\n");

    function getIndent(lineIndex) {
      return node.position.indent[lineIndex - 1] - 1;
    }
  }

  function mapAst(ast, handler) {
    return function preorder(node, index, parentStack) {
      parentStack = parentStack || [];
      var newNode = handler(node, index, parentStack);

      if (Array.isArray(newNode)) {
        return newNode;
      }

      newNode = Object.assign({}, newNode);

      if (newNode.children) {
        newNode.children = newNode.children.reduce(function (nodes, child, index) {
          var newNodes = preorder(child, index, [newNode].concat(parentStack));

          if (!Array.isArray(newNodes)) {
            newNodes = [newNodes];
          }

          nodes.push.apply(nodes, newNodes);
          return nodes;
        }, []);
      }

      return newNode;
    }(ast, null, null);
  }

  var utils$5 = {
    mapAst: mapAst,
    splitText: splitText,
    punctuationPattern: punctuationPattern,
    getFencedCodeBlockValue: getFencedCodeBlockValue,
    getOrderedListItemInfo: getOrderedListItemInfo,
    INLINE_NODE_TYPES: INLINE_NODE_TYPES,
    INLINE_NODE_WRAPPER_TYPES: INLINE_NODE_WRAPPER_TYPES
  };

  var _require$$0$builders$8 = doc.builders,
      hardline$b = _require$$0$builders$8.hardline,
      literalline$5 = _require$$0$builders$8.literalline,
      concat$f = _require$$0$builders$8.concat,
      markAsRoot$3 = _require$$0$builders$8.markAsRoot,
      mapDoc$6 = doc.utils.mapDoc;
  var getFencedCodeBlockValue$1 = utils$5.getFencedCodeBlockValue;

  function embed$4(path, print, textToDoc, options) {
    var node = path.getValue();

    if (node.type === "code" && node.lang !== null) {
      // only look for the first string so as to support [markdown-preview-enhanced](https://shd101wyy.github.io/markdown-preview-enhanced/#/code-chunk)
      var langMatch = node.lang.match(/^[A-Za-z0-9_-]+/);
      var lang = langMatch ? langMatch[0] : "";
      var parser = getParserName(lang);

      if (parser) {
        var styleUnit = options.__inJsTemplate ? "~" : "`";
        var style = styleUnit.repeat(Math.max(3, util.getMaxContinuousCount(node.value, styleUnit) + 1));
        var doc = textToDoc(getFencedCodeBlockValue$1(node, options.originalText), {
          parser: parser
        });
        return markAsRoot$3(concat$f([style, node.lang, hardline$b, replaceNewlinesWithLiterallines(doc), style]));
      }
    }

    if (node.type === "yaml") {
      return markAsRoot$3(concat$f(["---", hardline$b, node.value && node.value.trim() ? replaceNewlinesWithLiterallines(textToDoc(node.value, {
        parser: "yaml"
      })) : "", "---"]));
    } // MDX


    switch (node.type) {
      case "importExport":
        return textToDoc(node.value, {
          parser: "babel"
        });

      case "jsx":
        return textToDoc(node.value, {
          parser: "__js_expression"
        });
    }

    return null;

    function getParserName(lang) {
      var supportInfo = support.getSupportInfo(null, {
        plugins: options.plugins
      });
      var language = supportInfo.languages.find(function (language) {
        return language.name.toLowerCase() === lang || language.aliases && language.aliases.indexOf(lang) !== -1 || language.extensions && language.extensions.find(function (ext) {
          return ext.substring(1) === lang;
        });
      });

      if (language) {
        return language.parsers[0];
      }

      return null;
    }

    function replaceNewlinesWithLiterallines(doc) {
      return mapDoc$6(doc, function (currentDoc) {
        return typeof currentDoc === "string" && currentDoc.includes("\n") ? concat$f(currentDoc.split(/(\n)/g).map(function (v, i) {
          return i % 2 === 0 ? v : literalline$5;
        })) : currentDoc;
      });
    }
  }

  var embed_1$2 = embed$4;

  var pragmas = ["format", "prettier"];

  function startWithPragma(text) {
    var pragma = "@(".concat(pragmas.join("|"), ")");
    var regex = new RegExp(["<!--\\s*".concat(pragma, "\\s*-->"), "<!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*".concat(pragma, "[^\\S\n]*($|\n)[\\s\\S]*\n.*-->")].join("|"), "m");
    var matched = text.match(regex);
    return matched && matched.index === 0;
  }

  var pragma$4 = {
    startWithPragma: startWithPragma,
    hasPragma: function hasPragma(text) {
      return startWithPragma(frontMatter(text).content.trimLeft());
    },
    insertPragma: function insertPragma(text) {
      var extracted = frontMatter(text);
      var pragma = "<!-- @".concat(pragmas[0], " -->");
      return extracted.frontMatter ? "".concat(extracted.frontMatter.raw, "\n\n").concat(pragma, "\n\n").concat(extracted.content) : "".concat(pragma, "\n\n").concat(extracted.content);
    }
  };

  var getOrderedListItemInfo$1 = utils$5.getOrderedListItemInfo,
      mapAst$1 = utils$5.mapAst,
      splitText$1 = utils$5.splitText; // 0x0 ~ 0x10ffff
  // eslint-disable-next-line no-control-regex

  var isSingleCharRegex = /^([\u0000-\uffff]|[\ud800-\udbff][\udc00-\udfff])$/;

  function preprocess$2(ast, options) {
    ast = restoreUnescapedCharacter(ast, options);
    ast = mergeContinuousTexts(ast);
    ast = transformInlineCode(ast);
    ast = transformIndentedCodeblockAndMarkItsParentList(ast, options);
    ast = markAlignedList(ast, options);
    ast = splitTextIntoSentences(ast, options);
    ast = transformImportExport(ast);
    ast = mergeContinuousImportExport(ast);
    return ast;
  }

  function transformImportExport(ast) {
    return mapAst$1(ast, function (node) {
      if (node.type !== "import" && node.type !== "export") {
        return node;
      }

      return Object.assign({}, node, {
        type: "importExport"
      });
    });
  }

  function transformInlineCode(ast) {
    return mapAst$1(ast, function (node) {
      if (node.type !== "inlineCode") {
        return node;
      }

      return Object.assign({}, node, {
        value: node.value.replace(/\s+/g, " ")
      });
    });
  }

  function restoreUnescapedCharacter(ast, options) {
    return mapAst$1(ast, function (node) {
      return node.type !== "text" ? node : Object.assign({}, node, {
        value: node.value !== "*" && node.value !== "_" && node.value !== "$" && // handle these cases in printer
        isSingleCharRegex.test(node.value) && node.position.end.offset - node.position.start.offset !== node.value.length ? options.originalText.slice(node.position.start.offset, node.position.end.offset) : node.value
      });
    });
  }

  function mergeContinuousImportExport(ast) {
    return mergeChildren(ast, function (prevNode, node) {
      return prevNode.type === "importExport" && node.type === "importExport";
    }, function (prevNode, node) {
      return {
        type: "importExport",
        value: prevNode.value + "\n\n" + node.value,
        position: {
          start: prevNode.position.start,
          end: node.position.end
        }
      };
    });
  }

  function mergeChildren(ast, shouldMerge, mergeNode) {
    return mapAst$1(ast, function (node) {
      if (!node.children) {
        return node;
      }

      var children = node.children.reduce(function (current, child) {
        var lastChild = current[current.length - 1];

        if (lastChild && shouldMerge(lastChild, child)) {
          current.splice(-1, 1, mergeNode(lastChild, child));
        } else {
          current.push(child);
        }

        return current;
      }, []);
      return Object.assign({}, node, {
        children: children
      });
    });
  }

  function mergeContinuousTexts(ast) {
    return mergeChildren(ast, function (prevNode, node) {
      return prevNode.type === "text" && node.type === "text";
    }, function (prevNode, node) {
      return {
        type: "text",
        value: prevNode.value + node.value,
        position: {
          start: prevNode.position.start,
          end: node.position.end
        }
      };
    });
  }

  function splitTextIntoSentences(ast, options) {
    return mapAst$1(ast, function (node, index, _ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          parentNode = _ref2[0];

      if (node.type !== "text") {
        return node;
      }

      var value = node.value;

      if (parentNode.type === "paragraph") {
        if (index === 0) {
          value = value.trimLeft();
        }

        if (index === parentNode.children.length - 1) {
          value = value.trimRight();
        }
      }

      return {
        type: "sentence",
        position: node.position,
        children: splitText$1(value, options)
      };
    });
  }

  function transformIndentedCodeblockAndMarkItsParentList(ast, options) {
    return mapAst$1(ast, function (node, index, parentStack) {
      if (node.type === "code") {
        // the first char may point to `\n`, e.g. `\n\t\tbar`, just ignore it
        var isIndented = /^\n?( {4,}|\t)/.test(options.originalText.slice(node.position.start.offset, node.position.end.offset));
        node.isIndented = isIndented;

        if (isIndented) {
          for (var i = 0; i < parentStack.length; i++) {
            var parent = parentStack[i]; // no need to check checked items

            if (parent.hasIndentedCodeblock) {
              break;
            }

            if (parent.type === "list") {
              parent.hasIndentedCodeblock = true;
            }
          }
        }
      }

      return node;
    });
  }

  function markAlignedList(ast, options) {
    return mapAst$1(ast, function (node, index, parentStack) {
      if (node.type === "list" && node.children.length !== 0) {
        // if one of its parents is not aligned, it's not possible to be aligned in sub-lists
        for (var i = 0; i < parentStack.length; i++) {
          var parent = parentStack[i];

          if (parent.type === "list" && !parent.isAligned) {
            node.isAligned = false;
            return node;
          }
        }

        node.isAligned = isAligned(node);
      }

      return node;
    });

    function getListItemStart(listItem) {
      return listItem.children.length === 0 ? -1 : listItem.children[0].position.start.column - 1;
    }

    function isAligned(list) {
      if (!list.ordered) {
        /**
         * - 123
         * - 123
         */
        return true;
      }

      var _list$children = _slicedToArray(list.children, 2),
          firstItem = _list$children[0],
          secondItem = _list$children[1];

      var firstInfo = getOrderedListItemInfo$1(firstItem, options.originalText);

      if (firstInfo.leadingSpaces.length > 1) {
        /**
         * 1.   123
         *
         * 1.   123
         * 1. 123
         */
        return true;
      }

      var firstStart = getListItemStart(firstItem);

      if (firstStart === -1) {
        /**
         * 1.
         *
         * 1.
         * 1.
         */
        return false;
      }

      if (list.children.length === 1) {
        /**
         * aligned:
         *
         * 11. 123
         *
         * not aligned:
         *
         * 1. 123
         */
        return firstStart % options.tabWidth === 0;
      }

      var secondStart = getListItemStart(secondItem);

      if (firstStart !== secondStart) {
        /**
         * 11. 123
         * 1. 123
         *
         * 1. 123
         * 11. 123
         */
        return false;
      }

      if (firstStart % options.tabWidth === 0) {
        /**
         * 11. 123
         * 12. 123
         */
        return true;
      }
      /**
       * aligned:
       *
       * 11. 123
       * 1.  123
       *
       * not aligned:
       *
       * 1. 123
       * 2. 123
       */


      var secondInfo = getOrderedListItemInfo$1(secondItem, options.originalText);
      return secondInfo.leadingSpaces.length > 1;
    }
  }

  var preprocess_1$2 = preprocess$2;

  var _require$$0$builders$9 = doc.builders,
      breakParent$4 = _require$$0$builders$9.breakParent,
      concat$g = _require$$0$builders$9.concat,
      join$b = _require$$0$builders$9.join,
      line$8 = _require$$0$builders$9.line,
      literalline$6 = _require$$0$builders$9.literalline,
      markAsRoot$4 = _require$$0$builders$9.markAsRoot,
      hardline$c = _require$$0$builders$9.hardline,
      softline$7 = _require$$0$builders$9.softline,
      ifBreak$7 = _require$$0$builders$9.ifBreak,
      fill$5 = _require$$0$builders$9.fill,
      align$2 = _require$$0$builders$9.align,
      indent$9 = _require$$0$builders$9.indent,
      group$f = _require$$0$builders$9.group,
      mapDoc$7 = doc.utils.mapDoc,
      printDocToString$2 = doc.printer.printDocToString;
  var getFencedCodeBlockValue$2 = utils$5.getFencedCodeBlockValue,
      getOrderedListItemInfo$2 = utils$5.getOrderedListItemInfo,
      splitText$2 = utils$5.splitText,
      punctuationPattern$1 = utils$5.punctuationPattern,
      INLINE_NODE_TYPES$1 = utils$5.INLINE_NODE_TYPES,
      INLINE_NODE_WRAPPER_TYPES$1 = utils$5.INLINE_NODE_WRAPPER_TYPES;
  var replaceEndOfLineWith$2 = util.replaceEndOfLineWith;
  var TRAILING_HARDLINE_NODES = ["importExport"];
  var SINGLE_LINE_NODE_TYPES = ["heading", "tableCell", "link"];
  var SIBLING_NODE_TYPES = ["listItem", "definition", "footnoteDefinition", "jsx"];

  function genericPrint$5(path, options, print) {
    var node = path.getValue();

    if (shouldRemainTheSameContent(path)) {
      return concat$g(splitText$2(options.originalText.slice(node.position.start.offset, node.position.end.offset), options).map(function (node) {
        return node.type === "word" ? node.value : node.value === "" ? "" : printLine(path, node.value, options);
      }));
    }

    switch (node.type) {
      case "root":
        if (node.children.length === 0) {
          return "";
        }

        return concat$g([normalizeDoc(printRoot(path, options, print)), TRAILING_HARDLINE_NODES.indexOf(getLastDescendantNode(node).type) === -1 ? hardline$c : ""]);

      case "paragraph":
        return printChildren$2(path, options, print, {
          postprocessor: fill$5
        });

      case "sentence":
        return printChildren$2(path, options, print);

      case "word":
        return node.value.replace(/[*$]/g, "\\$&") // escape all `*` and `$` (math)
        .replace(new RegExp(["(^|".concat(punctuationPattern$1, ")(_+)"), "(_+)(".concat(punctuationPattern$1, "|$)")].join("|"), "g"), function (_, text1, underscore1, underscore2, text2) {
          return (underscore1 ? "".concat(text1).concat(underscore1) : "".concat(underscore2).concat(text2)).replace(/_/g, "\\_");
        });
      // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis

      case "whitespace":
        {
          var parentNode = path.getParentNode();
          var index = parentNode.children.indexOf(node);
          var nextNode = parentNode.children[index + 1];
          var proseWrap = // leading char that may cause different syntax
          nextNode && /^>|^([-+*]|#{1,6}|[0-9]+[.)])$/.test(nextNode.value) ? "never" : options.proseWrap;
          return printLine(path, node.value, {
            proseWrap: proseWrap
          });
        }

      case "emphasis":
        {
          var _parentNode = path.getParentNode();

          var _index = _parentNode.children.indexOf(node);

          var prevNode = _parentNode.children[_index - 1];
          var _nextNode = _parentNode.children[_index + 1];
          var hasPrevOrNextWord = // `1*2*3` is considered emphasis but `1_2_3` is not
          prevNode && prevNode.type === "sentence" && prevNode.children.length > 0 && util.getLast(prevNode.children).type === "word" && !util.getLast(prevNode.children).hasTrailingPunctuation || _nextNode && _nextNode.type === "sentence" && _nextNode.children.length > 0 && _nextNode.children[0].type === "word" && !_nextNode.children[0].hasLeadingPunctuation;
          var style = hasPrevOrNextWord || getAncestorNode$2(path, "emphasis") ? "*" : "_";
          return concat$g([style, printChildren$2(path, options, print), style]);
        }

      case "strong":
        return concat$g(["**", printChildren$2(path, options, print), "**"]);

      case "delete":
        return concat$g(["~~", printChildren$2(path, options, print), "~~"]);

      case "inlineCode":
        {
          var backtickCount = util.getMinNotPresentContinuousCount(node.value, "`");

          var _style = "`".repeat(backtickCount || 1);

          var gap = backtickCount ? " " : "";
          return concat$g([_style, gap, node.value, gap, _style]);
        }

      case "link":
        switch (options.originalText[node.position.start.offset]) {
          case "<":
            {
              var mailto = "mailto:";
              var url = // <hello@example.com> is parsed as { url: "mailto:hello@example.com" }
              node.url.startsWith(mailto) && options.originalText.slice(node.position.start.offset + 1, node.position.start.offset + 1 + mailto.length) !== mailto ? node.url.slice(mailto.length) : node.url;
              return concat$g(["<", url, ">"]);
            }

          case "[":
            return concat$g(["[", printChildren$2(path, options, print), "](", printUrl(node.url, ")"), printTitle(node.title, options), ")"]);

          default:
            return options.originalText.slice(node.position.start.offset, node.position.end.offset);
        }

      case "image":
        return concat$g(["![", node.alt || "", "](", printUrl(node.url, ")"), printTitle(node.title, options), ")"]);

      case "blockquote":
        return concat$g(["> ", align$2("> ", printChildren$2(path, options, print))]);

      case "heading":
        return concat$g(["#".repeat(node.depth) + " ", printChildren$2(path, options, print)]);

      case "code":
        {
          if (node.isIndented) {
            // indented code block
            var alignment = " ".repeat(4);
            return align$2(alignment, concat$g([alignment, concat$g(replaceEndOfLineWith$2(node.value, hardline$c))]));
          } // fenced code block


          var styleUnit = options.__inJsTemplate ? "~" : "`";

          var _style2 = styleUnit.repeat(Math.max(3, util.getMaxContinuousCount(node.value, styleUnit) + 1));

          return concat$g([_style2, node.lang || "", hardline$c, concat$g(replaceEndOfLineWith$2(getFencedCodeBlockValue$2(node, options.originalText), hardline$c)), hardline$c, _style2]);
        }

      case "yaml":
      case "toml":
        return options.originalText.slice(node.position.start.offset, node.position.end.offset);

      case "html":
        {
          var _parentNode2 = path.getParentNode();

          var value = _parentNode2.type === "root" && util.getLast(_parentNode2.children) === node ? node.value.trimRight() : node.value;
          var isHtmlComment = /^<!--[\s\S]*-->$/.test(value);
          return concat$g(replaceEndOfLineWith$2(value, isHtmlComment ? hardline$c : markAsRoot$4(literalline$6)));
        }

      case "list":
        {
          var nthSiblingIndex = getNthListSiblingIndex(node, path.getParentNode());
          var isGitDiffFriendlyOrderedList = node.ordered && node.children.length > 1 && +getOrderedListItemInfo$2(node.children[1], options.originalText).numberText === 1;
          return printChildren$2(path, options, print, {
            processor: function processor(childPath, index) {
              var prefix = getPrefix();
              return concat$g([prefix, align$2(" ".repeat(prefix.length), printListItem(childPath, options, print, prefix))]);

              function getPrefix() {
                var rawPrefix = node.ordered ? (index === 0 ? node.start : isGitDiffFriendlyOrderedList ? 1 : node.start + index) + (nthSiblingIndex % 2 === 0 ? ". " : ") ") : nthSiblingIndex % 2 === 0 ? "- " : "* ";
                return node.isAligned ||
                /* workaround for https://github.com/remarkjs/remark/issues/315 */
                node.hasIndentedCodeblock ? alignListPrefix(rawPrefix, options) : rawPrefix;
              }
            }
          });
        }

      case "thematicBreak":
        {
          var counter = getAncestorCounter$1(path, "list");

          if (counter === -1) {
            return "---";
          }

          var _nthSiblingIndex = getNthListSiblingIndex(path.getParentNode(counter), path.getParentNode(counter + 1));

          return _nthSiblingIndex % 2 === 0 ? "***" : "---";
        }

      case "linkReference":
        return concat$g(["[", printChildren$2(path, options, print), "]", node.referenceType === "full" ? concat$g(["[", node.identifier, "]"]) : node.referenceType === "collapsed" ? "[]" : ""]);

      case "imageReference":
        switch (node.referenceType) {
          case "full":
            return concat$g(["![", node.alt || "", "][", node.identifier, "]"]);

          default:
            return concat$g(["![", node.alt, "]", node.referenceType === "collapsed" ? "[]" : ""]);
        }

      case "definition":
        {
          var lineOrSpace = options.proseWrap === "always" ? line$8 : " ";
          return group$f(concat$g([concat$g(["[", node.identifier, "]:"]), indent$9(concat$g([lineOrSpace, printUrl(node.url), node.title === null ? "" : concat$g([lineOrSpace, printTitle(node.title, options, false)])]))]));
        }

      case "footnote":
        return concat$g(["[^", printChildren$2(path, options, print), "]"]);

      case "footnoteReference":
        return concat$g(["[^", node.identifier, "]"]);

      case "footnoteDefinition":
        {
          var _nextNode2 = path.getParentNode().children[path.getName() + 1];
          var shouldInlineFootnote = node.children.length === 1 && node.children[0].type === "paragraph" && (options.proseWrap === "never" || options.proseWrap === "preserve" && node.children[0].position.start.line === node.children[0].position.end.line);
          return concat$g(["[^", node.identifier, "]: ", shouldInlineFootnote ? printChildren$2(path, options, print) : group$f(concat$g([align$2(" ".repeat(options.tabWidth), printChildren$2(path, options, print, {
            processor: function processor(childPath, index) {
              return index === 0 ? group$f(concat$g([softline$7, softline$7, childPath.call(print)])) : childPath.call(print);
            }
          })), _nextNode2 && _nextNode2.type === "footnoteDefinition" ? softline$7 : ""]))]);
        }

      case "table":
        return printTable(path, options, print);

      case "tableCell":
        return printChildren$2(path, options, print);

      case "break":
        return /\s/.test(options.originalText[node.position.start.offset]) ? concat$g(["  ", markAsRoot$4(literalline$6)]) : concat$g(["\\", hardline$c]);

      case "liquidNode":
        return concat$g(replaceEndOfLineWith$2(node.value, hardline$c));
      // MDX

      case "importExport":
      case "jsx":
        return node.value;
      // fallback to the original text if multiparser failed

      case "math":
        return concat$g(["$$", hardline$c, node.value ? concat$g([concat$g(replaceEndOfLineWith$2(node.value, hardline$c)), hardline$c]) : "", "$$"]);

      case "inlineMath":
        {
          // remark-math trims content but we don't want to remove whitespaces
          // since it's very possible that it's recognized as math accidentally
          return options.originalText.slice(options.locStart(node), options.locEnd(node));
        }

      case "tableRow": // handled in "table"

      case "listItem": // handled in "list"

      default:
        throw new Error("Unknown markdown type ".concat(JSON.stringify(node.type)));
    }
  }

  function printListItem(path, options, print, listPrefix) {
    var node = path.getValue();
    var prefix = node.checked === null ? "" : node.checked ? "[x] " : "[ ] ";
    return concat$g([prefix, printChildren$2(path, options, print, {
      processor: function processor(childPath, index) {
        if (index === 0 && childPath.getValue().type !== "list") {
          return align$2(" ".repeat(prefix.length), childPath.call(print));
        }

        var alignment = " ".repeat(clamp(options.tabWidth - listPrefix.length, 0, 3) // 4+ will cause indented code block
        );
        return concat$g([alignment, align$2(alignment, childPath.call(print))]);
      }
    })]);
  }

  function alignListPrefix(prefix, options) {
    var additionalSpaces = getAdditionalSpaces();
    return prefix + " ".repeat(additionalSpaces >= 4 ? 0 : additionalSpaces // 4+ will cause indented code block
    );

    function getAdditionalSpaces() {
      var restSpaces = prefix.length % options.tabWidth;
      return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;
    }
  }

  function getNthListSiblingIndex(node, parentNode) {
    return getNthSiblingIndex(node, parentNode, function (siblingNode) {
      return siblingNode.ordered === node.ordered;
    });
  }

  function getNthSiblingIndex(node, parentNode, condition) {
    condition = condition || function () {
      return true;
    };

    var index = -1;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = parentNode.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var childNode = _step.value;

        if (childNode.type === node.type && condition(childNode)) {
          index++;
        } else {
          index = -1;
        }

        if (childNode === node) {
          return index;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  function getAncestorCounter$1(path, typeOrTypes) {
    var types = [].concat(typeOrTypes);
    var counter = -1;
    var ancestorNode;

    while (ancestorNode = path.getParentNode(++counter)) {
      if (types.indexOf(ancestorNode.type) !== -1) {
        return counter;
      }
    }

    return -1;
  }

  function getAncestorNode$2(path, typeOrTypes) {
    var counter = getAncestorCounter$1(path, typeOrTypes);
    return counter === -1 ? null : path.getParentNode(counter);
  }

  function printLine(path, value, options) {
    if (options.proseWrap === "preserve" && value === "\n") {
      return hardline$c;
    }

    var isBreakable = options.proseWrap === "always" && !getAncestorNode$2(path, SINGLE_LINE_NODE_TYPES);
    return value !== "" ? isBreakable ? line$8 : " " : isBreakable ? softline$7 : "";
  }

  function printTable(path, options, print) {
    var hardlineWithoutBreakParent = hardline$c.parts[0];
    var node = path.getValue();
    var contents = []; // { [rowIndex: number]: { [columnIndex: number]: string } }

    path.map(function (rowPath) {
      var rowContents = [];
      rowPath.map(function (cellPath) {
        rowContents.push(printDocToString$2(cellPath.call(print), options).formatted);
      }, "children");
      contents.push(rowContents);
    }, "children"); // Get the width of each column

    var columnMaxWidths = contents.reduce(function (currentWidths, rowContents) {
      return currentWidths.map(function (width, columnIndex) {
        return Math.max(width, util.getStringWidth(rowContents[columnIndex]));
      });
    }, contents[0].map(function () {
      return 3;
    }) // minimum width = 3 (---, :--, :-:, --:)
    );
    var alignedTable = join$b(hardlineWithoutBreakParent, [printRow(contents[0]), printSeparator(), join$b(hardlineWithoutBreakParent, contents.slice(1).map(function (rowContents) {
      return printRow(rowContents);
    }))]);

    if (options.proseWrap !== "never") {
      return concat$g([breakParent$4, alignedTable]);
    } // Only if the --prose-wrap never is set and it exceeds the print width.


    var compactTable = join$b(hardlineWithoutBreakParent, [printRow(contents[0],
    /* isCompact */
    true), printSeparator(
    /* isCompact */
    true), join$b(hardlineWithoutBreakParent, contents.slice(1).map(function (rowContents) {
      return printRow(rowContents,
      /* isCompact */
      true);
    }))]);
    return concat$g([breakParent$4, group$f(ifBreak$7(compactTable, alignedTable))]);

    function printSeparator(isCompact) {
      return concat$g(["| ", join$b(" | ", columnMaxWidths.map(function (width, index) {
        var spaces = isCompact ? 3 : width;

        switch (node.align[index]) {
          case "left":
            return ":" + "-".repeat(spaces - 1);

          case "right":
            return "-".repeat(spaces - 1) + ":";

          case "center":
            return ":" + "-".repeat(spaces - 2) + ":";

          default:
            return "-".repeat(spaces);
        }
      })), " |"]);
    }

    function printRow(rowContents, isCompact) {
      return concat$g(["| ", join$b(" | ", isCompact ? rowContents : rowContents.map(function (rowContent, columnIndex) {
        switch (node.align[columnIndex]) {
          case "right":
            return alignRight(rowContent, columnMaxWidths[columnIndex]);

          case "center":
            return alignCenter(rowContent, columnMaxWidths[columnIndex]);

          default:
            return alignLeft(rowContent, columnMaxWidths[columnIndex]);
        }
      })), " |"]);
    }

    function alignLeft(text, width) {
      var spaces = width - util.getStringWidth(text);
      return concat$g([text, " ".repeat(spaces)]);
    }

    function alignRight(text, width) {
      var spaces = width - util.getStringWidth(text);
      return concat$g([" ".repeat(spaces), text]);
    }

    function alignCenter(text, width) {
      var spaces = width - util.getStringWidth(text);
      var left = Math.floor(spaces / 2);
      var right = spaces - left;
      return concat$g([" ".repeat(left), text, " ".repeat(right)]);
    }
  }

  function printRoot(path, options, print) {
    /** @typedef {{ index: number, offset: number }} IgnorePosition */

    /** @type {Array<{start: IgnorePosition, end: IgnorePosition}>} */
    var ignoreRanges = [];
    /** @type {IgnorePosition | null} */

    var ignoreStart = null;
    var children = path.getValue().children;
    children.forEach(function (childNode, index) {
      switch (isPrettierIgnore$1(childNode)) {
        case "start":
          if (ignoreStart === null) {
            ignoreStart = {
              index: index,
              offset: childNode.position.end.offset
            };
          }

          break;

        case "end":
          if (ignoreStart !== null) {
            ignoreRanges.push({
              start: ignoreStart,
              end: {
                index: index,
                offset: childNode.position.start.offset
              }
            });
            ignoreStart = null;
          }

          break;
      }
    });
    return printChildren$2(path, options, print, {
      processor: function processor(childPath, index) {
        if (ignoreRanges.length !== 0) {
          var ignoreRange = ignoreRanges[0];

          if (index === ignoreRange.start.index) {
            return concat$g([children[ignoreRange.start.index].value, options.originalText.slice(ignoreRange.start.offset, ignoreRange.end.offset), children[ignoreRange.end.index].value]);
          }

          if (ignoreRange.start.index < index && index < ignoreRange.end.index) {
            return false;
          }

          if (index === ignoreRange.end.index) {
            ignoreRanges.shift();
            return false;
          }
        }

        return childPath.call(print);
      }
    });
  }

  function printChildren$2(path, options, print, events) {
    events = events || {};
    var postprocessor = events.postprocessor || concat$g;

    var processor = events.processor || function (childPath) {
      return childPath.call(print);
    };

    var node = path.getValue();
    var parts = [];
    var lastChildNode;
    path.map(function (childPath, index) {
      var childNode = childPath.getValue();
      var result = processor(childPath, index);

      if (result !== false) {
        var data = {
          parts: parts,
          prevNode: lastChildNode,
          parentNode: node,
          options: options
        };

        if (!shouldNotPrePrintHardline(childNode, data)) {
          parts.push(hardline$c);

          if (lastChildNode && TRAILING_HARDLINE_NODES.indexOf(lastChildNode.type) !== -1) {
            if (shouldPrePrintTripleHardline(childNode, data)) {
              parts.push(hardline$c);
            }
          } else {
            if (shouldPrePrintDoubleHardline(childNode, data) || shouldPrePrintTripleHardline(childNode, data)) {
              parts.push(hardline$c);
            }

            if (shouldPrePrintTripleHardline(childNode, data)) {
              parts.push(hardline$c);
            }
          }
        }

        parts.push(result);
        lastChildNode = childNode;
      }
    }, "children");
    return postprocessor(parts);
  }

  function getLastDescendantNode(node) {
    var current = node;

    while (current.children && current.children.length !== 0) {
      current = current.children[current.children.length - 1];
    }

    return current;
  }
  /** @return {false | 'next' | 'start' | 'end'} */


  function isPrettierIgnore$1(node) {
    if (node.type !== "html") {
      return false;
    }

    var match = node.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
    return match === null ? false : match[1] ? match[1] : "next";
  }

  function isInlineNode(node) {
    return node && INLINE_NODE_TYPES$1.indexOf(node.type) !== -1;
  }

  function isEndsWithHardLine(node) {
    return node && /\n+$/.test(node.value);
  }

  function last(nodes) {
    return nodes && nodes[nodes.length - 1];
  }

  function shouldNotPrePrintHardline(node, _ref) {
    var parentNode = _ref.parentNode,
        parts = _ref.parts,
        prevNode = _ref.prevNode;
    var isFirstNode = parts.length === 0;
    var isInlineHTML = node.type === "html" && INLINE_NODE_WRAPPER_TYPES$1.indexOf(parentNode.type) !== -1;
    var isAfterHardlineNode = prevNode && (isEndsWithHardLine(prevNode) || isEndsWithHardLine(last(prevNode.children)));
    return isFirstNode || isInlineNode(node) || isInlineHTML || isAfterHardlineNode;
  }

  function shouldPrePrintDoubleHardline(node, _ref2) {
    var parentNode = _ref2.parentNode,
        prevNode = _ref2.prevNode;
    var prevNodeType = prevNode && prevNode.type;
    var nodeType = node.type;
    var isSequence = prevNodeType === nodeType;
    var isSiblingNode = isSequence && SIBLING_NODE_TYPES.indexOf(nodeType) !== -1;
    var isInTightListItem = parentNode.type === "listItem" && !parentNode.loose;
    var isPrevNodeLooseListItem = prevNodeType === "listItem" && prevNode.loose;
    var isPrevNodePrettierIgnore = isPrettierIgnore$1(prevNode) === "next";
    var isBlockHtmlWithoutBlankLineBetweenPrevHtml = nodeType === "html" && prevNodeType === "html" && prevNode.position.end.line + 1 === node.position.start.line;
    var isJsxInlineSibling = prevNodeType === "jsx" && isInlineNode(node) || nodeType === "jsx" && isInlineNode(prevNode);
    return isPrevNodeLooseListItem || !(isSiblingNode || isInTightListItem || isPrevNodePrettierIgnore || isBlockHtmlWithoutBlankLineBetweenPrevHtml || isJsxInlineSibling);
  }

  function shouldPrePrintTripleHardline(node, data) {
    var isPrevNodeList = data.prevNode && data.prevNode.type === "list";
    var isIndentedCode = node.type === "code" && node.isIndented;
    return isPrevNodeList && isIndentedCode;
  }

  function shouldRemainTheSameContent(path) {
    var ancestorNode = getAncestorNode$2(path, ["linkReference", "imageReference"]);
    return ancestorNode && (ancestorNode.type !== "linkReference" || ancestorNode.referenceType !== "full");
  }

  function normalizeDoc(doc) {
    return mapDoc$7(doc, function (currentDoc) {
      if (!currentDoc.parts) {
        return currentDoc;
      }

      if (currentDoc.type === "concat" && currentDoc.parts.length === 1) {
        return currentDoc.parts[0];
      }

      var parts = [];
      currentDoc.parts.forEach(function (part) {
        if (part.type === "concat") {
          parts.push.apply(parts, part.parts);
        } else if (part !== "") {
          parts.push(part);
        }
      });
      return Object.assign({}, currentDoc, {
        parts: normalizeParts$2(parts)
      });
    });
  }

  function printUrl(url, dangerousCharOrChars) {
    var dangerousChars = [" "].concat(dangerousCharOrChars || []);
    return new RegExp(dangerousChars.map(function (x) {
      return "\\".concat(x);
    }).join("|")).test(url) ? "<".concat(url, ">") : url;
  }

  function printTitle(title, options, printSpace) {
    if (printSpace == null) {
      printSpace = true;
    }

    if (!title) {
      return "";
    }

    if (printSpace) {
      return " " + printTitle(title, options, false);
    }

    if (title.includes('"') && title.includes("'") && !title.includes(")")) {
      return "(".concat(title, ")"); // avoid escaped quotes
    } // faster than using RegExps: https://jsperf.com/performance-of-match-vs-split


    var singleCount = title.split("'").length - 1;
    var doubleCount = title.split('"').length - 1;
    var quote = singleCount > doubleCount ? '"' : doubleCount > singleCount ? "'" : options.singleQuote ? "'" : '"';
    title = title.replace(new RegExp("(".concat(quote, ")"), "g"), "\\$1");
    return "".concat(quote).concat(title).concat(quote);
  }

  function normalizeParts$2(parts) {
    return parts.reduce(function (current, part) {
      var lastPart = util.getLast(current);

      if (typeof lastPart === "string" && typeof part === "string") {
        current.splice(-1, 1, lastPart + part);
      } else {
        current.push(part);
      }

      return current;
    }, []);
  }

  function clamp(value, min, max) {
    return value < min ? min : value > max ? max : value;
  }

  function clean$6(ast, newObj, parent) {
    delete newObj.position;
    delete newObj.raw; // front-matter
    // for codeblock

    if (ast.type === "code" || ast.type === "yaml" || ast.type === "import" || ast.type === "export" || ast.type === "jsx") {
      delete newObj.value;
    }

    if (ast.type === "list") {
      delete newObj.isAligned;
    } // texts can be splitted or merged


    if (ast.type === "text") {
      return null;
    }

    if (ast.type === "inlineCode") {
      newObj.value = ast.value.replace(/[ \t\n]+/g, " ");
    } // for insert pragma


    if (parent && parent.type === "root" && parent.children.length > 0 && (parent.children[0] === ast || (parent.children[0].type === "yaml" || parent.children[0].type === "toml") && parent.children[1] === ast) && ast.type === "html" && pragma$4.startWithPragma(ast.value)) {
      return null;
    }
  }

  function hasPrettierIgnore$4(path) {
    var index = +path.getName();

    if (index === 0) {
      return false;
    }

    var prevNode = path.getParentNode().children[index - 1];
    return isPrettierIgnore$1(prevNode) === "next";
  }

  var printerMarkdown = {
    preprocess: preprocess_1$2,
    print: genericPrint$5,
    embed: embed_1$2,
    massageAstNode: clean$6,
    hasPrettierIgnore: hasPrettierIgnore$4,
    insertPragma: pragma$4.insertPragma
  };

  var options$6 = {
    proseWrap: commonOptions.proseWrap,
    singleQuote: commonOptions.singleQuote
  };

  var name$g = "Markdown";
  var type$f = "prose";
  var aliases$5 = [
  	"pandoc"
  ];
  var aceMode$f = "markdown";
  var codemirrorMode$b = "gfm";
  var codemirrorMimeType$b = "text/x-gfm";
  var wrap = true;
  var extensions$f = [
  	".md",
  	".markdown",
  	".mdown",
  	".mdwn",
  	".mdx",
  	".mkd",
  	".mkdn",
  	".mkdown",
  	".ronn",
  	".workbook"
  ];
  var filenames$3 = [
  	"contents.lr"
  ];
  var tmScope$f = "source.gfm";
  var languageId$f = 222;
  var Markdown = {
  	name: name$g,
  	type: type$f,
  	aliases: aliases$5,
  	aceMode: aceMode$f,
  	codemirrorMode: codemirrorMode$b,
  	codemirrorMimeType: codemirrorMimeType$b,
  	wrap: wrap,
  	extensions: extensions$f,
  	filenames: filenames$3,
  	tmScope: tmScope$f,
  	languageId: languageId$f
  };

  var Markdown$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$g,
    type: type$f,
    aliases: aliases$5,
    aceMode: aceMode$f,
    codemirrorMode: codemirrorMode$b,
    codemirrorMimeType: codemirrorMimeType$b,
    wrap: wrap,
    extensions: extensions$f,
    filenames: filenames$3,
    tmScope: tmScope$f,
    languageId: languageId$f,
    'default': Markdown
  });

  var require$$0$7 = getCjsExportFromNamespace(Markdown$1);

  var languages$5 = [createLanguage(require$$0$7, function (data) {
    return Object.assign(data, {
      since: "1.8.0",
      parsers: ["remark"],
      vscodeLanguageIds: ["markdown"],
      filenames: data.filenames.concat(["README"]),
      extensions: data.extensions.filter(function (extension) {
        return extension !== ".mdx";
      })
    });
  }), createLanguage(require$$0$7, function (data) {
    return Object.assign(data, {
      name: "MDX",
      since: "1.15.0",
      parsers: ["mdx"],
      vscodeLanguageIds: ["mdx"],
      filenames: [],
      extensions: [".mdx"]
    });
  })];
  var printers$5 = {
    mdast: printerMarkdown
  };
  var languageMarkdown = {
    languages: languages$5,
    options: options$6,
    printers: printers$5
  };

  function isPragma(text) {
    return /^\s*@(prettier|format)\s*$/.test(text);
  }

  function hasPragma$4(text) {
    return /^\s*#[^\n\S]*@(prettier|format)\s*?(\n|$)/.test(text);
  }

  function insertPragma$8(text) {
    return "# @format\n\n".concat(text);
  }

  var pragma$5 = {
    isPragma: isPragma,
    hasPragma: hasPragma$4,
    insertPragma: insertPragma$8
  };

  var getLast$4 = util.getLast;

  function getAncestorCount(path, filter) {
    var counter = 0;
    var pathStackLength = path.stack.length - 1;

    for (var i = 0; i < pathStackLength; i++) {
      var value = path.stack[i];

      if (isNode(value) && filter(value)) {
        counter++;
      }
    }

    return counter;
  }
  /**
   * @param {any} value
   * @param {string[]=} types
   */


  function isNode(value, types) {
    return value && typeof value.type === "string" && (!types || types.indexOf(value.type) !== -1);
  }

  function mapNode(node, callback, parent) {
    return callback("children" in node ? Object.assign({}, node, {
      children: node.children.map(function (childNode) {
        return mapNode(childNode, callback, node);
      })
    }) : node, parent);
  }

  function defineShortcut(x, key, getter) {
    Object.defineProperty(x, key, {
      get: getter,
      enumerable: false
    });
  }

  function isNextLineEmpty$5(node, text) {
    var newlineCount = 0;
    var textLength = text.length;

    for (var i = node.position.end.offset - 1; i < textLength; i++) {
      var char = text[i];

      if (char === "\n") {
        newlineCount++;
      }

      if (newlineCount === 1 && /\S/.test(char)) {
        return false;
      }

      if (newlineCount === 2) {
        return true;
      }
    }

    return false;
  }

  function isLastDescendantNode(path) {
    var node = path.getValue();

    switch (node.type) {
      case "tag":
      case "anchor":
      case "comment":
        return false;
    }

    var pathStackLength = path.stack.length;

    for (var i = 1; i < pathStackLength; i++) {
      var item = path.stack[i];
      var parentItem = path.stack[i - 1];

      if (Array.isArray(parentItem) && typeof item === "number" && item !== parentItem.length - 1) {
        return false;
      }
    }

    return true;
  }

  function getLastDescendantNode$1(node) {
    return "children" in node && node.children.length !== 0 ? getLastDescendantNode$1(getLast$4(node.children)) : node;
  }

  function isPrettierIgnore$2(comment) {
    return comment.value.trim() === "prettier-ignore";
  }

  function hasPrettierIgnore$5(path) {
    var node = path.getValue();

    if (node.type === "documentBody") {
      var document = path.getParentNode();
      return hasEndComments(document.head) && isPrettierIgnore$2(getLast$4(document.head.endComments));
    }

    return hasLeadingComments(node) && isPrettierIgnore$2(getLast$4(node.leadingComments));
  }

  function isEmptyNode(node) {
    return (!node.children || node.children.length === 0) && !hasComments(node);
  }

  function hasComments(node) {
    return hasLeadingComments(node) || hasMiddleComments(node) || hasIndicatorComment(node) || hasTrailingComment$2(node) || hasEndComments(node);
  }

  function hasLeadingComments(node) {
    return node && node.leadingComments && node.leadingComments.length !== 0;
  }

  function hasMiddleComments(node) {
    return node && node.middleComments && node.middleComments.length !== 0;
  }

  function hasIndicatorComment(node) {
    return node && node.indicatorComment;
  }

  function hasTrailingComment$2(node) {
    return node && node.trailingComment;
  }

  function hasEndComments(node) {
    return node && node.endComments && node.endComments.length !== 0;
  }
  /**
   * " a   b c   d e   f " -> [" a   b", "c   d", "e   f "]
   */


  function splitWithSingleSpace(text) {
    var parts = [];
    var lastPart = undefined;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = text.split(/( +)/g)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var part = _step.value;

        if (part !== " ") {
          if (lastPart === " ") {
            parts.push(part);
          } else {
            parts.push((parts.pop() || "") + part);
          }
        } else if (lastPart === undefined) {
          parts.unshift("");
        }

        lastPart = part;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (lastPart === " ") {
      parts.push((parts.pop() || "") + " ");
    }

    if (parts[0] === "") {
      parts.shift();
      parts.unshift(" " + (parts.shift() || ""));
    }

    return parts;
  }

  function getFlowScalarLineContents(nodeType, content, options) {
    var rawLineContents = content.split("\n").map(function (lineContent, index, lineContents) {
      return index === 0 && index === lineContents.length - 1 ? lineContent : index !== 0 && index !== lineContents.length - 1 ? lineContent.trim() : index === 0 ? lineContent.trimRight() : lineContent.trimLeft();
    });

    if (options.proseWrap === "preserve") {
      return rawLineContents.map(function (lineContent) {
        return lineContent.length === 0 ? [] : [lineContent];
      });
    }

    return rawLineContents.map(function (lineContent) {
      return lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent);
    }).reduce(function (reduced, lineContentWords, index) {
      return index !== 0 && rawLineContents[index - 1].length !== 0 && lineContentWords.length !== 0 && !( // trailing backslash in quoteDouble should be preserved
      nodeType === "quoteDouble" && getLast$4(getLast$4(reduced)).endsWith("\\")) ? reduced.concat([reduced.pop().concat(lineContentWords)]) : reduced.concat([lineContentWords]);
    }, []).map(function (lineContentWords) {
      return options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords;
    });
  }

  function getBlockValueLineContents(node, _ref) {
    var parentIndent = _ref.parentIndent,
        isLastDescendant = _ref.isLastDescendant,
        options = _ref.options;
    var content = node.position.start.line === node.position.end.line ? "" : options.originalText.slice(node.position.start.offset, node.position.end.offset) // exclude open line `>` or `|`
    .match(/^[^\n]*?\n([\s\S]*)$/)[1];
    var leadingSpaceCount = node.indent === null ? function (match) {
      return match ? match[1].length : Infinity;
    }(content.match(/^( *)\S/m)) : node.indent - 1 + parentIndent;
    var rawLineContents = content.split("\n").map(function (lineContent) {
      return lineContent.slice(leadingSpaceCount);
    });

    if (options.proseWrap === "preserve" || node.type === "blockLiteral") {
      return removeUnnecessaryTrailingNewlines(rawLineContents.map(function (lineContent) {
        return lineContent.length === 0 ? [] : [lineContent];
      }));
    }

    return removeUnnecessaryTrailingNewlines(rawLineContents.map(function (lineContent) {
      return lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent);
    }).reduce(function (reduced, lineContentWords, index) {
      return index !== 0 && rawLineContents[index - 1].length !== 0 && lineContentWords.length !== 0 && !/^\s/.test(lineContentWords[0]) && !/^\s|\s$/.test(getLast$4(reduced)) ? reduced.concat([reduced.pop().concat(lineContentWords)]) : reduced.concat([lineContentWords]);
    }, []).map(function (lineContentWords) {
      return lineContentWords.reduce(function (reduced, word) {
        return (// disallow trailing spaces
          reduced.length !== 0 && /\s$/.test(getLast$4(reduced)) ? reduced.concat(reduced.pop() + " " + word) : reduced.concat(word)
        );
      }, []);
    }).map(function (lineContentWords) {
      return options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords;
    }));

    function removeUnnecessaryTrailingNewlines(lineContents) {
      if (node.chomping === "keep") {
        return getLast$4(lineContents).length === 0 ? lineContents.slice(0, -1) : lineContents;
      }

      var trailingNewlineCount = 0;

      for (var i = lineContents.length - 1; i >= 0; i--) {
        if (lineContents[i].length === 0) {
          trailingNewlineCount++;
        } else {
          break;
        }
      }

      return trailingNewlineCount === 0 ? lineContents : trailingNewlineCount >= 2 && !isLastDescendant ? // next empty line
      lineContents.slice(0, -(trailingNewlineCount - 1)) : lineContents.slice(0, -trailingNewlineCount);
    }
  }

  var utils$6 = {
    getLast: getLast$4,
    getAncestorCount: getAncestorCount,
    isNode: isNode,
    isEmptyNode: isEmptyNode,
    mapNode: mapNode,
    defineShortcut: defineShortcut,
    isNextLineEmpty: isNextLineEmpty$5,
    isLastDescendantNode: isLastDescendantNode,
    getBlockValueLineContents: getBlockValueLineContents,
    getFlowScalarLineContents: getFlowScalarLineContents,
    getLastDescendantNode: getLastDescendantNode$1,
    hasPrettierIgnore: hasPrettierIgnore$5,
    hasLeadingComments: hasLeadingComments,
    hasMiddleComments: hasMiddleComments,
    hasIndicatorComment: hasIndicatorComment,
    hasTrailingComment: hasTrailingComment$2,
    hasEndComments: hasEndComments
  };

  var insertPragma$9 = pragma$5.insertPragma,
      isPragma$1 = pragma$5.isPragma;
  var getAncestorCount$1 = utils$6.getAncestorCount,
      getBlockValueLineContents$1 = utils$6.getBlockValueLineContents,
      getFlowScalarLineContents$1 = utils$6.getFlowScalarLineContents,
      getLast$5 = utils$6.getLast,
      getLastDescendantNode$2 = utils$6.getLastDescendantNode,
      hasLeadingComments$1 = utils$6.hasLeadingComments,
      hasMiddleComments$1 = utils$6.hasMiddleComments,
      hasIndicatorComment$1 = utils$6.hasIndicatorComment,
      hasTrailingComment$3 = utils$6.hasTrailingComment,
      hasEndComments$1 = utils$6.hasEndComments,
      hasPrettierIgnore$6 = utils$6.hasPrettierIgnore,
      isLastDescendantNode$1 = utils$6.isLastDescendantNode,
      isNextLineEmpty$6 = utils$6.isNextLineEmpty,
      isNode$1 = utils$6.isNode,
      isEmptyNode$1 = utils$6.isEmptyNode,
      defineShortcut$1 = utils$6.defineShortcut,
      mapNode$1 = utils$6.mapNode;
  var docBuilders$2 = doc.builders;
  var conditionalGroup$2 = docBuilders$2.conditionalGroup,
      breakParent$5 = docBuilders$2.breakParent,
      concat$h = docBuilders$2.concat,
      dedent$3 = docBuilders$2.dedent,
      dedentToRoot$3 = docBuilders$2.dedentToRoot,
      fill$6 = docBuilders$2.fill,
      group$g = docBuilders$2.group,
      hardline$d = docBuilders$2.hardline,
      ifBreak$8 = docBuilders$2.ifBreak,
      join$c = docBuilders$2.join,
      line$9 = docBuilders$2.line,
      lineSuffix$2 = docBuilders$2.lineSuffix,
      literalline$7 = docBuilders$2.literalline,
      markAsRoot$5 = docBuilders$2.markAsRoot,
      softline$8 = docBuilders$2.softline;
  var replaceEndOfLineWith$3 = util.replaceEndOfLineWith;

  function preprocess$3(ast) {
    return mapNode$1(ast, defineShortcuts);
  }

  function defineShortcuts(node) {
    switch (node.type) {
      case "document":
        defineShortcut$1(node, "head", function () {
          return node.children[0];
        });
        defineShortcut$1(node, "body", function () {
          return node.children[1];
        });
        break;

      case "documentBody":
      case "sequenceItem":
      case "flowSequenceItem":
      case "mappingKey":
      case "mappingValue":
        defineShortcut$1(node, "content", function () {
          return node.children[0];
        });
        break;

      case "mappingItem":
      case "flowMappingItem":
        defineShortcut$1(node, "key", function () {
          return node.children[0];
        });
        defineShortcut$1(node, "value", function () {
          return node.children[1];
        });
        break;
    }

    return node;
  }

  function genericPrint$6(path, options, print) {
    var node = path.getValue();
    var parentNode = path.getParentNode();
    var tag = !node.tag ? "" : path.call(print, "tag");
    var anchor = !node.anchor ? "" : path.call(print, "anchor");
    var nextEmptyLine = isNode$1(node, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !isLastDescendantNode$1(path) ? printNextEmptyLine(path, options.originalText) : "";
    return concat$h([node.type !== "mappingValue" && hasLeadingComments$1(node) ? concat$h([join$c(hardline$d, path.map(print, "leadingComments")), hardline$d]) : "", tag, tag && anchor ? " " : "", anchor, tag || anchor ? isNode$1(node, ["sequence", "mapping"]) && !hasMiddleComments$1(node) ? hardline$d : " " : "", hasMiddleComments$1(node) ? concat$h([node.middleComments.length === 1 ? "" : hardline$d, join$c(hardline$d, path.map(print, "middleComments")), hardline$d]) : "", hasPrettierIgnore$6(path) ? concat$h(replaceEndOfLineWith$3(options.originalText.slice(node.position.start.offset, node.position.end.offset), literalline$7)) : group$g(_print(node, parentNode, path, options, print)), hasTrailingComment$3(node) && !isNode$1(node, ["document", "documentHead"]) ? lineSuffix$2(concat$h([node.type === "mappingValue" && !node.content ? "" : " ", parentNode.type === "mappingKey" && path.getParentNode(2).type === "mapping" && isInlineNode$1(node) ? "" : breakParent$5, path.call(print, "trailingComment")])) : "", nextEmptyLine, hasEndComments$1(node) && !isNode$1(node, ["documentHead", "documentBody"]) ? align$3(node.type === "sequenceItem" ? 2 : 0, concat$h([hardline$d, join$c(hardline$d, path.map(print, "endComments"))])) : ""]);
  }

  function _print(node, parentNode, path, options, print) {
    switch (node.type) {
      case "root":
        return concat$h([join$c(hardline$d, path.map(function (childPath, index) {
          var document = node.children[index];
          var nextDocument = node.children[index + 1];
          return concat$h([print(childPath), shouldPrintDocumentEndMarker(document, nextDocument) ? concat$h([hardline$d, "...", hasTrailingComment$3(document) ? concat$h([" ", path.call(print, "trailingComment")]) : ""]) : !nextDocument || hasTrailingComment$3(nextDocument.head) ? "" : concat$h([hardline$d, "---"])]);
        }, "children")), node.children.length === 0 || function (lastDescendantNode) {
          return isNode$1(lastDescendantNode, ["blockLiteral", "blockFolded"]) && lastDescendantNode.chomping === "keep";
        }(getLastDescendantNode$2(node)) ? "" : hardline$d]);

      case "document":
        {
          var nextDocument = parentNode.children[path.getName() + 1];
          return join$c(hardline$d, [shouldPrintDocumentHeadEndMarker(node, nextDocument, parentNode, options) === "head" ? join$c(hardline$d, [node.head.children.length === 0 && node.head.endComments.length === 0 ? "" : path.call(print, "head"), concat$h(["---", hasTrailingComment$3(node.head) ? concat$h([" ", path.call(print, "head", "trailingComment")]) : ""])].filter(Boolean)) : "", shouldPrintDocumentBody(node) ? path.call(print, "body") : ""].filter(Boolean));
        }

      case "documentHead":
        return join$c(hardline$d, [].concat(path.map(print, "children"), path.map(print, "endComments")));

      case "documentBody":
        {
          var children = join$c(hardline$d, path.map(print, "children")).parts;
          var endComments = join$c(hardline$d, path.map(print, "endComments")).parts;
          var separator = children.length === 0 || endComments.length === 0 ? "" : function (lastDescendantNode) {
            return isNode$1(lastDescendantNode, ["blockFolded", "blockLiteral"]) ? lastDescendantNode.chomping === "keep" ? // there's already a newline printed at the end of blockValue (chomping=keep, lastDescendant=true)
            "" : // an extra newline for better readability
            concat$h([hardline$d, hardline$d]) : hardline$d;
          }(getLastDescendantNode$2(node));
          return concat$h([].concat(children, separator, endComments));
        }

      case "directive":
        return concat$h(["%", join$c(" ", [node.name].concat(node.parameters))]);

      case "comment":
        return concat$h(["#", node.value]);

      case "alias":
        return concat$h(["*", node.value]);

      case "tag":
        return options.originalText.slice(node.position.start.offset, node.position.end.offset);

      case "anchor":
        return concat$h(["&", node.value]);

      case "plain":
        return printFlowScalarContent(node.type, options.originalText.slice(node.position.start.offset, node.position.end.offset), options);

      case "quoteDouble":
      case "quoteSingle":
        {
          var singleQuote = "'";
          var doubleQuote = '"';
          var raw = options.originalText.slice(node.position.start.offset + 1, node.position.end.offset - 1);

          if (node.type === "quoteSingle" && raw.includes("\\") || node.type === "quoteDouble" && /\\[^"]/.test(raw)) {
            // only quoteDouble can use escape chars
            // and quoteSingle do not need to escape backslashes
            var originalQuote = node.type === "quoteDouble" ? doubleQuote : singleQuote;
            return concat$h([originalQuote, printFlowScalarContent(node.type, raw, options), originalQuote]);
          } else if (raw.includes(doubleQuote)) {
            return concat$h([singleQuote, printFlowScalarContent(node.type, node.type === "quoteDouble" ? raw // double quote needs to be escaped by backslash in quoteDouble
            .replace(/\\"/g, doubleQuote).replace(/'/g, singleQuote.repeat(2)) : raw, options), singleQuote]);
          }

          if (raw.includes(singleQuote)) {
            return concat$h([doubleQuote, printFlowScalarContent(node.type, node.type === "quoteSingle" ? // single quote needs to be escaped by 2 single quotes in quoteSingle
            raw.replace(/''/g, singleQuote) : raw, options), doubleQuote]);
          }

          var quote = options.singleQuote ? singleQuote : doubleQuote;
          return concat$h([quote, printFlowScalarContent(node.type, raw, options), quote]);
        }

      case "blockFolded":
      case "blockLiteral":
        {
          var parentIndent = getAncestorCount$1(path, function (ancestorNode) {
            return isNode$1(ancestorNode, ["sequence", "mapping"]);
          });
          var isLastDescendant = isLastDescendantNode$1(path);
          return concat$h([node.type === "blockFolded" ? ">" : "|", node.indent === null ? "" : node.indent.toString(), node.chomping === "clip" ? "" : node.chomping === "keep" ? "+" : "-", hasIndicatorComment$1(node) ? concat$h([" ", path.call(print, "indicatorComment")]) : "", (node.indent === null ? dedent$3 : dedentToRoot$3)(align$3(node.indent === null ? options.tabWidth : node.indent - 1 + parentIndent, concat$h(getBlockValueLineContents$1(node, {
            parentIndent: parentIndent,
            isLastDescendant: isLastDescendant,
            options: options
          }).reduce(function (reduced, lineWords, index, lineContents) {
            return reduced.concat(index === 0 ? hardline$d : "", fill$6(join$c(line$9, lineWords).parts), index !== lineContents.length - 1 ? lineWords.length === 0 ? hardline$d : markAsRoot$5(literalline$7) : node.chomping === "keep" && isLastDescendant ? lineWords.length === 0 ? dedentToRoot$3(hardline$d) : dedentToRoot$3(literalline$7) : "");
          }, []))))]);
        }

      case "sequence":
        return join$c(hardline$d, path.map(print, "children"));

      case "sequenceItem":
        return concat$h(["- ", align$3(2, !node.content ? "" : path.call(print, "content"))]);

      case "mappingKey":
        return !node.content ? "" : path.call(print, "content");

      case "mappingValue":
        return !node.content ? "" : path.call(print, "content");

      case "mapping":
        return join$c(hardline$d, path.map(print, "children"));

      case "mappingItem":
      case "flowMappingItem":
        {
          var isEmptyMappingKey = isEmptyNode$1(node.key);
          var isEmptyMappingValue = isEmptyNode$1(node.value);

          if (isEmptyMappingKey && isEmptyMappingValue) {
            return concat$h([": "]);
          }

          var key = path.call(print, "key");
          var value = path.call(print, "value");

          if (isEmptyMappingValue) {
            return node.type === "flowMappingItem" && parentNode.type === "flowMapping" ? key : node.type === "mappingItem" && isAbsolutelyPrintedAsSingleLineNode(node.key.content, options) && !hasTrailingComment$3(node.key.content) && (!parentNode.tag || parentNode.tag.value !== "tag:yaml.org,2002:set") ? concat$h([key, needsSpaceInFrontOfMappingValue(node) ? " " : "", ":"]) : concat$h(["? ", align$3(2, key)]);
          }

          if (isEmptyMappingKey) {
            return concat$h([": ", align$3(2, value)]);
          }

          var groupId = Symbol("mappingKey");
          var forceExplicitKey = hasLeadingComments$1(node.value) || !isInlineNode$1(node.key.content);
          return forceExplicitKey ? concat$h(["? ", align$3(2, key), hardline$d, join$c("", path.map(print, "value", "leadingComments").map(function (comment) {
            return concat$h([comment, hardline$d]);
          })), ": ", align