ent.head) && isPrettierIgnore$2(getLast$4(document.head.endComments));
  }

  return hasLeadingComments(node) && isPrettierIgnore$2(getLast$4(node.leadingComments));
}

function isEmptyNode(node) {
  return (!node.children || node.children.length === 0) && !hasComments(node);
}

function hasComments(node) {
  return hasLeadingComments(node) || hasMiddleComments(node) || hasIndicatorComment(node) || hasTrailingComment$2(node) || hasEndComments(node);
}

function hasLeadingComments(node) {
  return node && node.leadingComments && node.leadingComments.length !== 0;
}

function hasMiddleComments(node) {
  return node && node.middleComments && node.middleComments.length !== 0;
}

function hasIndicatorComment(node) {
  return node && node.indicatorComment;
}

function hasTrailingComment$2(node) {
  return node && node.trailingComment;
}

function hasEndComments(node) {
  return node && node.endComments && node.endComments.length !== 0;
}
/**
 * " a   b c   d e   f " -> [" a   b", "c   d", "e   f "]
 */


function splitWithSingleSpace(text) {
  var parts = [];
  var lastPart = undefined;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = text.split(/( +)/g)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var part = _step.value;

      if (part !== " ") {
        if (lastPart === " ") {
          parts.push(part);
        } else {
          parts.push((parts.pop() || "") + part);
        }
      } else if (lastPart === undefined) {
        parts.unshift("");
      }

      lastPart = part;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (lastPart === " ") {
    parts.push((parts.pop() || "") + " ");
  }

  if (parts[0] === "") {
    parts.shift();
    parts.unshift(" " + (parts.shift() || ""));
  }

  return parts;
}

function getFlowScalarLineContents(nodeType, content, options) {
  var rawLineContents = content.split("\n").map(function (lineContent, index, lineContents) {
    return index === 0 && index === lineContents.length - 1 ? lineContent : index !== 0 && index !== lineContents.length - 1 ? lineContent.trim() : index === 0 ? lineContent.trimRight() : lineContent.trimLeft();
  });

  if (options.proseWrap === "preserve") {
    return rawLineContents.map(function (lineContent) {
      return lineContent.length === 0 ? [] : [lineContent];
    });
  }

  return rawLineContents.map(function (lineContent) {
    return lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent);
  }).reduce(function (reduced, lineContentWords, index) {
    return index !== 0 && rawLineContents[index - 1].length !== 0 && lineContentWords.length !== 0 && !( // trailing backslash in quoteDouble should be preserved
    nodeType === "quoteDouble" && getLast$4(getLast$4(reduced)).endsWith("\\")) ? reduced.concat([reduced.pop().concat(lineContentWords)]) : reduced.concat([lineContentWords]);
  }, []).map(function (lineContentWords) {
    return options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords;
  });
}

function getBlockValueLineContents(node, _ref) {
  var parentIndent = _ref.parentIndent,
      isLastDescendant = _ref.isLastDescendant,
      options = _ref.options;
  var content = node.position.start.line === node.position.end.line ? "" : options.originalText.slice(node.position.start.offset, node.position.end.offset) // exclude open line `>` or `|`
  .match(/^[^\n]*?\n([\s\S]*)$/)[1];
  var leadingSpaceCount = node.indent === null ? function (match) {
    return match ? match[1].length : Infinity;
  }(content.match(/^( *)\S/m)) : node.indent - 1 + parentIndent;
  var rawLineContents = content.split("\n").map(function (lineContent) {
    return lineContent.slice(leadingSpaceCount);
  });

  if (options.proseWrap === "preserve" || node.type === "blockLiteral") {
    return removeUnnecessaryTrailingNewlines(rawLineContents.map(function (lineContent) {
      return lineContent.length === 0 ? [] : [lineContent];
    }));
  }

  return removeUnnecessaryTrailingNewlines(rawLineContents.map(function (lineContent) {
    return lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent);
  }).reduce(function (reduced, lineContentWords, index) {
    return index !== 0 && rawLineContents[index - 1].length !== 0 && lineContentWords.length !== 0 && !/^\s/.test(lineContentWords[0]) && !/^\s|\s$/.test(getLast$4(reduced)) ? reduced.concat([reduced.pop().concat(lineContentWords)]) : reduced.concat([lineContentWords]);
  }, []).map(function (lineContentWords) {
    return lineContentWords.reduce(function (reduced, word) {
      return (// disallow trailing spaces
        reduced.length !== 0 && /\s$/.test(getLast$4(reduced)) ? reduced.concat(reduced.pop() + " " + word) : reduced.concat(word)
      );
    }, []);
  }).map(function (lineContentWords) {
    return options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords;
  }));

  function removeUnnecessaryTrailingNewlines(lineContents) {
    if (node.chomping === "keep") {
      return getLast$4(lineContents).length === 0 ? lineContents.slice(0, -1) : lineContents;
    }

    var trailingNewlineCount = 0;

    for (var i = lineContents.length - 1; i >= 0; i--) {
      if (lineContents[i].length === 0) {
        trailingNewlineCount++;
      } else {
        break;
      }
    }

    return trailingNewlineCount === 0 ? lineContents : trailingNewlineCount >= 2 && !isLastDescendant ? // next empty line
    lineContents.slice(0, -(trailingNewlineCount - 1)) : lineContents.slice(0, -trailingNewlineCount);
  }
}

var utils$6 = {
  getLast: getLast$4,
  getAncestorCount,
  isNode: isNode$1,
  isEmptyNode,
  mapNode,
  defineShortcut,
  isNextLineEmpty: isNextLineEmpty$5,
  isLastDescendantNode,
  getBlockValueLineContents,
  getFlowScalarLineContents,
  getLastDescendantNode: getLastDescendantNode$1,
  hasPrettierIgnore: hasPrettierIgnore$5,
  hasLeadingComments,
  hasMiddleComments,
  hasIndicatorComment,
  hasTrailingComment: hasTrailingComment$2,
  hasEndComments
};

var insertPragma$9 = pragma$5.insertPragma,
    isPragma$1 = pragma$5.isPragma;
var getAncestorCount$1 = utils$6.getAncestorCount,
    getBlockValueLineContents$1 = utils$6.getBlockValueLineContents,
    getFlowScalarLineContents$1 = utils$6.getFlowScalarLineContents,
    getLast$5 = utils$6.getLast,
    getLastDescendantNode$2 = utils$6.getLastDescendantNode,
    hasLeadingComments$1 = utils$6.hasLeadingComments,
    hasMiddleComments$1 = utils$6.hasMiddleComments,
    hasIndicatorComment$1 = utils$6.hasIndicatorComment,
    hasTrailingComment$3 = utils$6.hasTrailingComment,
    hasEndComments$1 = utils$6.hasEndComments,
    hasPrettierIgnore$6 = utils$6.hasPrettierIgnore,
    isLastDescendantNode$1 = utils$6.isLastDescendantNode,
    isNextLineEmpty$6 = utils$6.isNextLineEmpty,
    isNode$2 = utils$6.isNode,
    isEmptyNode$1 = utils$6.isEmptyNode,
    defineShortcut$1 = utils$6.defineShortcut,
    mapNode$1 = utils$6.mapNode;
var docBuilders$2 = doc.builders;
var conditionalGroup$2 = docBuilders$2.conditionalGroup,
    breakParent$5 = docBuilders$2.breakParent,
    concat$h = docBuilders$2.concat,
    dedent$3 = docBuilders$2.dedent,
    dedentToRoot$3 = docBuilders$2.dedentToRoot,
    fill$6 = docBuilders$2.fill,
    group$g = docBuilders$2.group,
    hardline$d = docBuilders$2.hardline,
    ifBreak$8 = docBuilders$2.ifBreak,
    join$c = docBuilders$2.join,
    line$9 = docBuilders$2.line,
    lineSuffix$2 = docBuilders$2.lineSuffix,
    literalline$7 = docBuilders$2.literalline,
    markAsRoot$5 = docBuilders$2.markAsRoot,
    softline$8 = docBuilders$2.softline;
var replaceEndOfLineWith$3 = util.replaceEndOfLineWith;

function preprocess$3(ast) {
  return mapNode$1(ast, defineShortcuts);
}

function defineShortcuts(node) {
  switch (node.type) {
    case "document":
      defineShortcut$1(node, "head", function () {
        return node.children[0];
      });
      defineShortcut$1(node, "body", function () {
        return node.children[1];
      });
      break;

    case "documentBody":
    case "sequenceItem":
    case "flowSequenceItem":
    case "mappingKey":
    case "mappingValue":
      defineShortcut$1(node, "content", function () {
        return node.children[0];
      });
      break;

    case "mappingItem":
    case "flowMappingItem":
      defineShortcut$1(node, "key", function () {
        return node.children[0];
      });
      defineShortcut$1(node, "value", function () {
        return node.children[1];
      });
      break;
  }

  return node;
}

function genericPrint$6(path, options, print) {
  var node = path.getValue();
  var parentNode = path.getParentNode();
  var tag = !node.tag ? "" : path.call(print, "tag");
  var anchor = !node.anchor ? "" : path.call(print, "anchor");
  var nextEmptyLine = isNode$2(node, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !isLastDescendantNode$1(path) ? printNextEmptyLine(path, options.originalText) : "";
  return concat$h([node.type !== "mappingValue" && hasLeadingComments$1(node) ? concat$h([join$c(hardline$d, path.map(print, "leadingComments")), hardline$d]) : "", tag, tag && anchor ? " " : "", anchor, tag || anchor ? isNode$2(node, ["sequence", "mapping"]) && !hasMiddleComments$1(node) ? hardline$d : " " : "", hasMiddleComments$1(node) ? concat$h([node.middleComments.length === 1 ? "" : hardline$d, join$c(hardline$d, path.map(print, "middleComments")), hardline$d]) : "", hasPrettierIgnore$6(path) ? concat$h(replaceEndOfLineWith$3(options.originalText.slice(node.position.start.offset, node.position.end.offset), literalline$7)) : group$g(_print(node, parentNode, path, options, print)), hasTrailingComment$3(node) && !isNode$2(node, ["document", "documentHead"]) ? lineSuffix$2(concat$h([node.type === "mappingValue" && !node.content ? "" : " ", parentNode.type === "mappingKey" && path.getParentNode(2).type === "mapping" && isInlineNode$1(node) ? "" : breakParent$5, path.call(print, "trailingComment")])) : "", nextEmptyLine, hasEndComments$1(node) && !isNode$2(node, ["documentHead", "documentBody"]) ? align$3(node.type === "sequenceItem" ? 2 : 0, concat$h([hardline$d, join$c(hardline$d, path.map(print, "endComments"))])) : ""]);
}

function _print(node, parentNode, path, options, print) {
  switch (node.type) {
    case "root":
      return concat$h([join$c(hardline$d, path.map(function (childPath, index) {
        var document = node.children[index];
        var nextDocument = node.children[index + 1];
        return concat$h([print(childPath), shouldPrintDocumentEndMarker(document, nextDocument) ? concat$h([hardline$d, "...", hasTrailingComment$3(document) ? concat$h([" ", path.call(print, "trailingComment")]) : ""]) : !nextDocument || hasTrailingComment$3(nextDocument.head) ? "" : concat$h([hardline$d, "---"])]);
      }, "children")), node.children.length === 0 || function (lastDescendantNode) {
        return isNode$2(lastDescendantNode, ["blockLiteral", "blockFolded"]) && lastDescendantNode.chomping === "keep";
      }(getLastDescendantNode$2(node)) ? "" : hardline$d]);

    case "document":
      {
        var nextDocument = parentNode.children[path.getName() + 1];
        return join$c(hardline$d, [shouldPrintDocumentHeadEndMarker(node, nextDocument, parentNode, options) === "head" ? join$c(hardline$d, [node.head.children.length === 0 && node.head.endComments.length === 0 ? "" : path.call(print, "head"), concat$h(["---", hasTrailingComment$3(node.head) ? concat$h([" ", path.call(print, "head", "trailingComment")]) : ""])].filter(Boolean)) : "", shouldPrintDocumentBody(node) ? path.call(print, "body") : ""].filter(Boolean));
      }

    case "documentHead":
      return join$c(hardline$d, [].concat(path.map(print, "children"), path.map(print, "endComments")));

    case "documentBody":
      {
        var children = join$c(hardline$d, path.map(print, "children")).parts;
        var endComments = join$c(hardline$d, path.map(print, "endComments")).parts;
        var separator = children.length === 0 || endComments.length === 0 ? "" : function (lastDescendantNode) {
          return isNode$2(lastDescendantNode, ["blockFolded", "blockLiteral"]) ? lastDescendantNode.chomping === "keep" ? // there's already a newline printed at the end of blockValue (chomping=keep, lastDescendant=true)
          "" : // an extra newline for better readability
          concat$h([hardline$d, hardline$d]) : hardline$d;
        }(getLastDescendantNode$2(node));
        return concat$h([].concat(children, separator, endComments));
      }

    case "directive":
      return concat$h(["%", join$c(" ", [node.name].concat(node.parameters))]);

    case "comment":
      return concat$h(["#", node.value]);

    case "alias":
      return concat$h(["*", node.value]);

    case "tag":
      return options.originalText.slice(node.position.start.offset, node.position.end.offset);

    case "anchor":
      return concat$h(["&", node.value]);

    case "plain":
      return printFlowScalarContent(node.type, options.originalText.slice(node.position.start.offset, node.position.end.offset), options);

    case "quoteDouble":
    case "quoteSingle":
      {
        var singleQuote = "'";
        var doubleQuote = '"';
        var raw = options.originalText.slice(node.position.start.offset + 1, node.position.end.offset - 1);

        if (node.type === "quoteSingle" && raw.includes("\\") || node.type === "quoteDouble" && /\\[^"]/.test(raw)) {
          // only quoteDouble can use escape chars
          // and quoteSingle do not need to escape backslashes
          var originalQuote = node.type === "quoteDouble" ? doubleQuote : singleQuote;
          return concat$h([originalQuote, printFlowScalarContent(node.type, raw, options), originalQuote]);
        } else if (raw.includes(doubleQuote)) {
          return concat$h([singleQuote, printFlowScalarContent(node.type, node.type === "quoteDouble" ? raw // double quote needs to be escaped by backslash in quoteDouble
          .replace(/\\"/g, doubleQuote).replace(/'/g, singleQuote.repeat(2)) : raw, options), singleQuote]);
        }

        if (raw.includes(singleQuote)) {
          return concat$h([doubleQuote, printFlowScalarContent(node.type, node.type === "quoteSingle" ? // single quote needs to be escaped by 2 single quotes in quoteSingle
          raw.replace(/''/g, singleQuote) : raw, options), doubleQuote]);
        }

        var quote = options.singleQuote ? singleQuote : doubleQuote;
        return concat$h([quote, printFlowScalarContent(node.type, raw, options), quote]);
      }

    case "blockFolded":
    case "blockLiteral":
      {
        var parentIndent = getAncestorCount$1(path, function (ancestorNode) {
          return isNode$2(ancestorNode, ["sequence", "mapping"]);
        });
        var isLastDescendant = isLastDescendantNode$1(path);
        return concat$h([node.type === "blockFolded" ? ">" : "|", node.indent === null ? "" : node.indent.toString(), node.chomping === "clip" ? "" : node.chomping === "keep" ? "+" : "-", hasIndicatorComment$1(node) ? concat$h([" ", path.call(print, "indicatorComment")]) : "", (node.indent === null ? dedent$3 : dedentToRoot$3)(align$3(node.indent === null ? options.tabWidth : node.indent - 1 + parentIndent, concat$h(getBlockValueLineContents$1(node, {
          parentIndent,
          isLastDescendant,
          options
        }).reduce(function (reduced, lineWords, index, lineContents) {
          return reduced.concat(index === 0 ? hardline$d : "", fill$6(join$c(line$9, lineWords).parts), index !== lineContents.length - 1 ? lineWords.length === 0 ? hardline$d : markAsRoot$5(literalline$7) : node.chomping === "keep" && isLastDescendant ? lineWords.length === 0 ? dedentToRoot$3(hardline$d) : dedentToRoot$3(literalline$7) : "");
        }, []))))]);
      }

    case "sequence":
      return join$c(hardline$d, path.map(print, "children"));

    case "sequenceItem":
      return concat$h(["- ", align$3(2, !node.content ? "" : path.call(print, "content"))]);

    case "mappingKey":
      return !node.content ? "" : path.call(print, "content");

    case "mappingValue":
      return !node.content ? "" : path.call(print, "content");

    case "mapping":
      return join$c(hardline$d, path.map(print, "children"));

    case "mappingItem":
    case "flowMappingItem":
      {
        var isEmptyMappingKey = isEmptyNode$1(node.key);
        var isEmptyMappingValue = isEmptyNode$1(node.value);

        if (isEmptyMappingKey && isEmptyMappingValue) {
          return concat$h([": "]);
        }

        var key = path.call(print, "key");
        var value = path.call(print, "value");

        if (isEmptyMappingValue) {
          return node.type === "flowMappingItem" && parentNode.type === "flowMapping" ? key : node.type === "mappingItem" && isAbsolutelyPrintedAsSingleLineNode(node.key.content, options) && !hasTrailingComment$3(node.key.content) && (!parentNode.tag || parentNode.tag.value !== "tag:yaml.org,2002:set") ? concat$h([key, needsSpaceInFrontOfMappingValue(node) ? " " : "", ":"]) : concat$h(["? ", align$3(2, key)]);
        }

        if (isEmptyMappingKey) {
          return concat$h([": ", align$3(2, value)]);
        }

        var groupId = Symbol("mappingKey");
        var forceExplicitKey = hasLeadingComments$1(node.value) || !isInlineNode$1(node.key.content);
        return forceExplicitKey ? concat$h(["? ", align$3(2, key), hardline$d, join$c("", path.map(print, "value", "leadingComments").map(function (comment) {
          return concat$h([comment, hardline$d]);
        })), ": ", align$3(2, value)]) : // force singleline
        isSingleLineNode(node.key.content) && !hasLeadingComments$1(node.key.content) && !hasMiddleComments$1(node.key.content) && !hasTrailingComment$3(node.key.content) && !hasEndComments$1(node.key) && !hasLeadingComments$1(node.value.content) && !hasMiddleComments$1(node.value.content) && !hasEndComments$1(node.value) && isAbsolutelyPrintedAsSingleLineNode(node.value.content, options) ? concat$h([key, needsSpaceInFrontOfMappingValue(node) ? " " : "", ": ", value]) : conditionalGroup$2([concat$h([group$g(concat$h([ifBreak$8("? "), group$g(align$3(2, key), {
          id: groupId
        })])), ifBreak$8(concat$h([hardline$d, ": ", align$3(2, value)]), indent(concat$h([needsSpaceInFrontOfMappingValue(node) ? " " : "", ":", hasLeadingComments$1(node.value.content) || hasEndComments$1(node.value) && node.value.content && !isNode$2(node.value.content, ["mapping", "sequence"]) || parentNode.type === "mapping" && hasTrailingComment$3(node.key.content) && isInlineNode$1(node.value.content) || isNode$2(node.value.content, ["mapping", "sequence"]) && node.value.content.tag === null && node.value.content.anchor === null ? hardline$d : !node.value.content ? "" : line$9, value])), {
          groupId
        })])]);
      }

    case "flowMapping":
    case "flowSequence":
      {
        var openMarker = node.type === "flowMapping" ? "{" : "[";
        var closeMarker = node.type === "flowMapping" ? "}" : "]";
        var bracketSpacing = node.type === "flowMapping" && node.children.length !== 0 && options.bracketSpacing ? line$9 : softline$8;

        var isLastItemEmptyMappingItem = node.children.length !== 0 && function (lastItem) {
          return lastItem.type === "flowMappingItem" && isEmptyNode$1(lastItem.key) && isEmptyNode$1(lastItem.value);
        }(getLast$5(node.children));

        return concat$h([openMarker, indent(concat$h([bracketSpacing, concat$h(path.map(function (childPath, index) {
          return concat$h([print(childPath), index === node.children.length - 1 ? "" : concat$h([",", line$9, node.children[index].position.start.line !== node.children[index + 1].position.start.line ? printNextEmptyLine(childPath, options.originalText) : ""])]);
        }, "children")), ifBreak$8(",", "")])), isLastItemEmptyMappingItem ? "" : bracketSpacing, closeMarker]);
      }

    case "flowSequenceItem":
      return path.call(print, "content");
    // istanbul ignore next

    default:
      throw new Error(`Unexpected node type ${node.type}`);
  }

  function indent(doc) {
    return docBuilders$2.align(" ".repeat(options.tabWidth), doc);
  }
}

function align$3(n, doc) {
  return typeof n === "number" && n > 0 ? docBuilders$2.align(" ".repeat(n), doc) : docBuilders$2.align(n, doc);
}

function isInlineNode$1(node) {
  if (!node) {
    return true;
  }

  switch (node.type) {
    case "plain":
    case "quoteDouble":
    case "quoteSingle":
    case "alias":
    case "flowMapping":
    case "flowSequence":
      return true;

    default:
      return false;
  }
}

function isSingleLineNode(node) {
  if (!node) {
    return true;
  }

  switch (node.type) {
    case "plain":
    case "quoteDouble":
    case "quoteSingle":
      return node.position.start.line === node.position.end.line;

    case "alias":
      return true;

    default:
      return false;
  }
}

function shouldPrintDocumentBody(document) {
  return document.body.children.length !== 0 || hasEndComments$1(document.body);
}

function shouldPrintDocumentEndMarker(document, nextDocument) {
  return (
    /**
     *... # trailingComment
     */
    hasTrailingComment$3(document) || nextDocument && (
    /**
     * ...
     * %DIRECTIVE
     * ---
     */
    nextDocument.head.children.length !== 0 ||
    /**
     * ...
     * # endComment
     * ---
     */
    hasEndComments$1(nextDocument.head))
  );
}

function shouldPrintDocumentHeadEndMarker(document, nextDocument, root, options) {
  if (
  /**
   * ---
   * preserve the first document head end marker
   */
  root.children[0] === document && /---(\s|$)/.test(options.originalText.slice(options.locStart(document), options.locStart(document) + 4)) ||
  /**
   * %DIRECTIVE
   * ---
   */
  document.head.children.length !== 0 ||
  /**
   * # end comment
   * ---
   */
  hasEndComments$1(document.head) ||
  /**
   * --- # trailing comment
   */
  hasTrailingComment$3(document.head)) {
    return "head";
  }

  if (shouldPrintDocumentEndMarker(document, nextDocument)) {
    return false;
  }

  return nextDocument ? "root" : false;
}

function isAbsolutelyPrintedAsSingleLineNode(node, options) {
  if (!node) {
    return true;
  }

  switch (node.type) {
    case "plain":
    case "quoteSingle":
    case "quoteDouble":
      break;

    case "alias":
      return true;

    default:
      return false;
  }

  if (options.proseWrap === "preserve") {
    return node.position.start.line === node.position.end.line;
  }

  if ( // backslash-newline
  /\\$/m.test(options.originalText.slice(node.position.start.offset, node.position.end.offset))) {
    return false;
  }

  switch (options.proseWrap) {
    case "never":
      return node.value.indexOf("\n") === -1;

    case "always":
      return !/[\n ]/.test(node.value);
    // istanbul ignore next

    default:
      return false;
  }
}

function needsSpaceInFrontOfMappingValue(node) {
  return node.key.content && node.key.content.type === "alias";
}

function printNextEmptyLine(path, originalText) {
  var node = path.getValue();
  var root = path.stack[0];
  root.isNextEmptyLinePrintedChecklist = root.isNextEmptyLinePrintedChecklist || [];

  if (!root.isNextEmptyLinePrintedChecklist[node.position.end.line]) {
    if (isNextLineEmpty$6(node, originalText)) {
      root.isNextEmptyLinePrintedChecklist[node.position.end.line] = true;
      return softline$8;
    }
  }

  return "";
}

function printFlowScalarContent(nodeType, content, options) {
  var lineContents = getFlowScalarLineContents$1(nodeType, content, options);
  return join$c(hardline$d, lineContents.map(function (lineContentWords) {
    return fill$6(join$c(line$9, lineContentWords).parts);
  }));
}

function clean$7(node, newNode
/*, parent */
) {
  if (isNode$2(newNode)) {
    delete newNode.position;

    switch (newNode.type) {
      case "comment":
        // insert pragma
        if (isPragma$1(newNode.value)) {
          return null;
        }

        break;

      case "quoteDouble":
      case "quoteSingle":
        newNode.type = "quote";
        break;
    }
  }
}

var printerYaml = {
  preprocess: preprocess$3,
  print: genericPrint$6,
  massageAstNode: clean$7,
  insertPragma: insertPragma$9
};

var options$7 = {
  bracketSpacing: commonOptions.bracketSpacing,
  singleQuote: commonOptions.singleQuote,
  proseWrap: commonOptions.proseWrap
};

var name$i = "YAML";
var type$g = "data";
var tmScope$g = "source.yaml";
var aliases$6 = [
	"yml"
];
var extensions$g = [
	".yml",
	".mir",
	".reek",
	".rviz",
	".sublime-syntax",
	".syntax",
	".yaml",
	".yaml-tmlanguage",
	".yml.mysql"
];
var filenames$4 = [
	".clang-format",
	".clang-tidy",
	".gemrc",
	"glide.lock"
];
var aceMode$g = "yaml";
var codemirrorMode$c = "yaml";
var codemirrorMimeType$c = "text/x-yaml";
var languageId$g = 407;
var YAML = {
	name: name$i,
	type: type$g,
	tmScope: tmScope$g,
	aliases: aliases$6,
	extensions: extensions$g,
	filenames: filenames$4,
	aceMode: aceMode$g,
	codemirrorMode: codemirrorMode$c,
	codemirrorMimeType: codemirrorMimeType$c,
	languageId: languageId$g
};

var YAML$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$i,
  type: type$g,
  tmScope: tmScope$g,
  aliases: aliases$6,
  extensions: extensions$g,
  filenames: filenames$4,
  aceMode: aceMode$g,
  codemirrorMode: codemirrorMode$c,
  codemirrorMimeType: codemirrorMimeType$c,
  languageId: languageId$g,
  'default': YAML
});

var require$$0$8 = getCjsExportFromNamespace(YAML$1);

var languages$6 = [createLanguage(require$$0$8, function (data) {
  return Object.assign(data, {
    since: "1.14.0",
    parsers: ["yaml"],
    vscodeLanguageIds: ["yaml"]
  });
})];
var languageYaml = {
  languages: languages$6,
  printers: {
    yaml: printerYaml
  },
  options: options$7
};

// plugin will look for `eval("require")()` and transform to `require()` in the bundle,
// and rewrite the paths to require from the top-level.
// We need to list the parsers and getters so we can load them only when necessary.


var internalPlugins = [// JS
languageJs, {
  parsers: {
    // JS - Babel
    get babel() {
      return require("./parser-babylon").parsers.babel;
    },

    get "babel-flow"() {
      return require("./parser-babylon").parsers["babel-flow"];
    },

    get babylon() {
      return require("./parser-babylon").parsers.babel;
    },

    get json() {
      return require("./parser-babylon").parsers.json;
    },

    get json5() {
      return require("./parser-babylon").parsers.json5;
    },

    get "json-stringify"() {
      return require("./parser-babylon").parsers["json-stringify"];
    },

    get __js_expression() {
      return require("./parser-babylon").parsers.__js_expression;
    },

    get __vue_expression() {
      return require("./parser-babylon").parsers.__vue_expression;
    },

    get __vue_event_binding() {
      return require("./parser-babylon").parsers.__vue_event_binding;
    },

    // JS - Flow
    get flow() {
      return require("./parser-flow").parsers.flow;
    },

    // JS - TypeScript
    get typescript() {
      return require("./parser-typescript").parsers.typescript;
    },

    /**
     * TODO: Remove this old alias in a major version
     */
    get "typescript-eslint"() {
      return require("./parser-typescript").parsers.typescript;
    },

    // JS - Angular Action
    get __ng_action() {
      return require("./parser-angular").parsers.__ng_action;
    },

    // JS - Angular Binding
    get __ng_binding() {
      return require("./parser-angular").parsers.__ng_binding;
    },

    // JS - Angular Interpolation
    get __ng_interpolation() {
      return require("./parser-angular").parsers.__ng_interpolation;
    },

    // JS - Angular Directive
    get __ng_directive() {
      return require("./parser-angular").parsers.__ng_directive;
    }

  }
}, // CSS
languageCss, {
  parsers: {
    // TODO: switch these to just `postcss` and use `language` instead.
    get css() {
      return require("./parser-postcss").parsers.css;
    },

    get less() {
      return require("./parser-postcss").parsers.css;
    },

    get scss() {
      return require("./parser-postcss").parsers.css;
    }

  }
}, // Handlebars
languageHandlebars, {
  parsers: {
    get glimmer() {
      return require("./parser-glimmer").parsers.glimmer;
    }

  }
}, // GraphQL
languageGraphql, {
  parsers: {
    get graphql() {
      return require("./parser-graphql").parsers.graphql;
    }

  }
}, // Markdown
languageMarkdown, {
  parsers: {
    get remark() {
      return require("./parser-markdown").parsers.remark;
    },

    // TODO: Delete this in 2.0
    get markdown() {
      return require("./parser-markdown").parsers.remark;
    },

    get mdx() {
      return require("./parser-markdown").parsers.mdx;
    }

  }
}, languageHtml, {
  parsers: {
    // HTML
    get html() {
      return require("./parser-html").parsers.html;
    },

    // Vue
    get vue() {
      return require("./parser-html").parsers.vue;
    },

    // Angular
    get angular() {
      return require("./parser-html").parsers.angular;
    },

    // Lightning Web Components
    get lwc() {
      return require("./parser-html").parsers.lwc;
    }

  }
}, // YAML
languageYaml, {
  parsers: {
    get yaml() {
      return require("./parser-yaml").parsers.yaml;
    }

  }
}];

var partition = function partition(array, fn) {
  var a = [];
  var b = [];
  array.forEach(function (item) {
    if (fn(item)) {
      a.push(item);
    } else {
      b.push(item);
    }
  });
  return [a, b];
};

function loadPlugins(plugins, pluginSearchDirs) {
  if (!plugins) {
    plugins = [];
  }

  if (!pluginSearchDirs) {
    pluginSearchDirs = [];
  } // unless pluginSearchDirs are provided, auto-load plugins from node_modules that are parent to Prettier


  if (!pluginSearchDirs.length) {
    var autoLoadDir = thirdParty.findParentDir(__dirname, "node_modules");

    if (autoLoadDir) {
      pluginSearchDirs = [autoLoadDir];
    }
  }

  var _partition = partition(plugins, function (plugin) {
    return typeof plugin === "string";
  }),
      _partition2 = _slicedToArray(_partition, 2),
      externalPluginNames = _partition2[0],
      externalPluginInstances = _partition2[1];

  var externalManualLoadPluginInfos = externalPluginNames.map(function (pluginName) {
    var requirePath;

    try {
      // try local files
      requirePath = resolve.sync(path$2.resolve(process.cwd(), pluginName));
    } catch (e) {
      // try node modules
      requirePath = resolve.sync(pluginName, {
        basedir: process.cwd()
      });
    }

    return {
      name: pluginName,
      requirePath
    };
  });
  var externalAutoLoadPluginInfos = pluginSearchDirs.map(function (pluginSearchDir) {
    var resolvedPluginSearchDir = path$2.resolve(process.cwd(), pluginSearchDir);
    var nodeModulesDir = path$2.resolve(resolvedPluginSearchDir, "node_modules"); // In some fringe cases (ex: files "mounted" as virtual directories), the
    // isDirectory(resolvedPluginSearchDir) check might be false even though
    // the node_modules actually exists.

    if (!isDirectory(nodeModulesDir) && !isDirectory(resolvedPluginSearchDir)) {
      throw new Error(`${pluginSearchDir} does not exist or is not a directory`);
    }

    return findPluginsInNodeModules(nodeModulesDir).map(function (pluginName) {
      return {
        name: pluginName,
        requirePath: resolve.sync(pluginName, {
          basedir: resolvedPluginSearchDir
        })
      };
    });
  }).reduce(function (a, b) {
    return a.concat(b);
  }, []);
  var externalPlugins = lodash_uniqby(externalManualLoadPluginInfos.concat(externalAutoLoadPluginInfos), "requirePath").map(function (externalPluginInfo) {
    return Object.assign({
      name: externalPluginInfo.name
    }, require(externalPluginInfo.requirePath));
  }).concat(externalPluginInstances);
  return internalPlugins.concat(externalPlugins);
}

function findPluginsInNodeModules(nodeModulesDir) {
  var pluginPackageJsonPaths = globby.sync(["prettier-plugin-*/package.json", "@*/prettier-plugin-*/package.json", "@prettier/plugin-*/package.json"], {
    cwd: nodeModulesDir
  });
  return pluginPackageJsonPaths.map(path$2.dirname);
}

function isDirectory(dir) {
  try {
    return fs$1.statSync(dir).isDirectory();
  } catch (e) {
    return false;
  }
}

var loadPlugins_1 = loadPlugins;

var version$3 = require$$0.version;
var getSupportInfo$2 = support.getSupportInfo; // Luckily `opts` is always the 2nd argument

function _withPlugins(fn) {
  return function () {
    var args = Array.from(arguments);
    var opts = args[1] || {};
    args[1] = Object.assign({}, opts, {
      plugins: loadPlugins_1(opts.plugins, opts.pluginSearchDirs)
    });
    return fn.apply(null, args);
  };
}

function withPlugins(fn) {
  var resultingFn = _withPlugins(fn);

  if (fn.sync) {
    resultingFn.sync = _withPlugins(fn.sync);
  }

  return resultingFn;
}

var formatWithCursor = withPlugins(core.formatWithCursor);
var src$1 = {
  formatWithCursor,

  format(text, opts) {
    return formatWithCursor(text, opts).formatted;
  },

  check: function check(text, opts) {
    var formatted = formatWithCursor(text, opts).formatted;
    return formatted === text;
  },
  doc,
  resolveConfig: resolveConfig_1.resolveConfig,
  resolveConfigFile: resolveConfig_1.resolveConfigFile,
  clearConfigCache: resolveConfig_1.clearCache,
  getFileInfo: withPlugins(getFileInfo_1),
  getSupportInfo: withPlugins(getSupportInfo$2),
  version: version$3,
  util: utilShared,

  /* istanbul ignore next */
  __debug: {
    parse: withPlugins(core.parse),
    formatAST: withPlugins(core.formatAST),
    formatDoc: withPlugins(core.formatDoc),
    printToDoc: withPlugins(core.printToDoc),
    printDocToString: withPlugins(core.printDocToString)
  }
};

var prettier = src$1;

var at,
    // The index of the current character
ch,
    // The current character
escapee = {
  '"': '"',
  '\\': '\\',
  '/': '/',
  b: '\b',
  f: '\f',
  n: '\n',
  r: '\r',
  t: '\t'
},
    text,
    error = function error(m) {
  // Call error when something is wrong.
  throw {
    name: 'SyntaxError',
    message: m,
    at: at,
    text: text
  };
},
    next = function next(c) {
  // If a c parameter is provided, verify that it matches the current character.
  if (c && c !== ch) {
    error("Expected '" + c + "' instead of '" + ch + "'");
  } // Get the next character. When there are no more characters,
  // return the empty string.


  ch = text.charAt(at);
  at += 1;
  return ch;
},
    number$1 = function number() {
  // Parse a number value.
  var number,
      string = '';

  if (ch === '-') {
    string = '-';
    next('-');
  }

  while (ch >= '0' && ch <= '9') {
    string += ch;
    next();
  }

  if (ch === '.') {
    string += '.';

    while (next() && ch >= '0' && ch <= '9') {
      string += ch;
    }
  }

  if (ch === 'e' || ch === 'E') {
    string += ch;
    next();

    if (ch === '-' || ch === '+') {
      string += ch;
      next();
    }

    while (ch >= '0' && ch <= '9') {
      string += ch;
      next();
    }
  }

  number = +string;

  if (!isFinite(number)) {
    error("Bad number");
  } else {
    return number;
  }
},
    string$1 = function string() {
  // Parse a string value.
  var hex,
      i,
      string = '',
      uffff; // When parsing for string values, we must look for " and \ characters.

  if (ch === '"') {
    while (next()) {
      if (ch === '"') {
        next();
        return string;
      } else if (ch === '\\') {
        next();

        if (ch === 'u') {
          uffff = 0;

          for (i = 0; i < 4; i += 1) {
            hex = parseInt(next(), 16);

            if (!isFinite(hex)) {
              break;
            }

            uffff = uffff * 16 + hex;
          }

          string += String.fromCharCode(uffff);
        } else if (typeof escapee[ch] === 'string') {
          string += escapee[ch];
        } else {
          break;
        }
      } else {
        string += ch;
      }
    }
  }

  error("Bad string");
},
    white = function white() {
  // Skip whitespace.
  while (ch && ch <= ' ') {
    next();
  }
},
    word = function word() {
  // true, false, or null.
  switch (ch) {
    case 't':
      next('t');
      next('r');
      next('u');
      next('e');
      return true;

    case 'f':
      next('f');
      next('a');
      next('l');
      next('s');
      next('e');
      return false;

    case 'n':
      next('n');
      next('u');
      next('l');
      next('l');
      return null;
  }

  error("Unexpected '" + ch + "'");
},
    value,
    // Place holder for the value function.
array$2 = function array() {
  // Parse an array value.
  var array = [];

  if (ch === '[') {
    next('[');
    white();

    if (ch === ']') {
      next(']');
      return array; // empty array
    }

    while (ch) {
      array.push(value());
      white();

      if (ch === ']') {
        next(']');
        return array;
      }

      next(',');
      white();
    }
  }

  error("Bad array");
},
    object$1 = function object() {
  // Parse an object value.
  var key,
      object = {};

  if (ch === '{') {
    next('{');
    white();

    if (ch === '}') {
      next('}');
      return object; // empty object
    }

    while (ch) {
      key = string$1();
      white();
      next(':');

      if (Object.hasOwnProperty.call(object, key)) {
        error('Duplicate key "' + key + '"');
      }

      object[key] = value();
      white();

      if (ch === '}') {
        next('}');
        return object;
      }

      next(',');
      white();
    }
  }

  error("Bad object");
};

value = function value() {
  // Parse a JSON value. It could be an object, an array, a string, a number,
  // or a word.
  white();

  switch (ch) {
    case '{':
      return object$1();

    case '[':
      return array$2();

    case '"':
      return string$1();

    case '-':
      return number$1();

    default:
      return ch >= '0' && ch <= '9' ? number$1() : word();
  }
}; // Return the json_parse function. It will have access to all of the above
// functions and variables.


var parse$4 = function parse(source, reviver) {
  var result;
  text = source;
  at = 0;
  ch = ' ';
  result = value();
  white();

  if (ch) {
    error("Syntax error");
  } // If there is a reviver function, we recursively walk the new structure,
  // passing each name/value pair to the reviver function for possible
  // transformation, starting with a temporary root object that holds the result
  // in an empty key. If there is not a reviver function, we simply return the
  // result.


  return typeof reviver === 'function' ? function walk(holder, key) {
    var k,
        v,
        value = holder[key];

    if (value && typeof value === 'object') {
      for (k in value) {
        if (Object.prototype.hasOwnProperty.call(value, k)) {
          v = walk(value, k);

          if (v !== undefined) {
            value[k] = v;
          } else {
            delete value[k];
          }
        }
      }
    }

    return reviver.call(holder, key, value);
  }({
    '': result
  }, '') : result;
};

var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent$a,
    meta$1 = {
  // table of character substitutions
  '\b': '\\b',
  '\t': '\\t',
  '\n': '\\n',
  '\f': '\\f',
  '\r': '\\r',
  '"': '\\"',
  '\\': '\\\\'
},
    rep;

function quote(string) {
  // If the string contains no control characters, no quote characters, and no
  // backslash characters, then we can safely slap some quotes around it.
  // Otherwise we must also replace the offending characters with safe escape
  // sequences.
  escapable.lastIndex = 0;
  return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
    var c = meta$1[a];
    return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
  }) + '"' : '"' + string + '"';
}

function str(key, holder) {
  // Produce a string from holder[key].
  var i,
      // The loop counter.
  k,
      // The member key.
  v,
      // The member value.
  length,
      mind = gap,
      partial,
      value = holder[key]; // If the value has a toJSON method, call it to obtain a replacement value.

  if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
    value = value.toJSON(key);
  } // If we were called with a replacer function, then call the replacer to
  // obtain a replacement value.


  if (typeof rep === 'function') {
    value = rep.call(holder, key, value);
  } // What happens next depends on the value's type.


  switch (typeof value) {
    case 'string':
      return quote(value);

    case 'number':
      // JSON numbers must be finite. Encode non-finite numbers as null.
      return isFinite(value) ? String(value) : 'null';

    case 'boolean':
    case 'null':
      // If the value is a boolean or null, convert it to a string. Note:
      // typeof null does not produce 'null'. The case is included here in
      // the remote chance that this gets fixed someday.
      return String(value);

    case 'object':
      if (!value) return 'null';
      gap += indent$a;
      partial = []; // Array.isArray

      if (Object.prototype.toString.apply(value) === '[object Array]') {
        length = value.length;

        for (i = 0; i < length; i += 1) {
          partial[i] = str(i, value) || 'null';
        } // Join all of the elements together, separated with commas, and
        // wrap them in brackets.


        v = partial.length === 0 ? '[]' : gap ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' : '[' + partial.join(',') + ']';
        gap = mind;
        return v;
      } // If the replacer is an array, use it to select the members to be
      // stringified.


      if (rep && typeof rep === 'object') {
        length = rep.length;

        for (i = 0; i < length; i += 1) {
          k = rep[i];

          if (typeof k === 'string') {
            v = str(k, value);

            if (v) {
              partial.push(quote(k) + (gap ? ': ' : ':') + v);
            }
          }
        }
      } else {
        // Otherwise, iterate through all of the keys in the object.
        for (k in value) {
          if (Object.prototype.hasOwnProperty.call(value, k)) {
            v = str(k, value);

            if (v) {
              partial.push(quote(k) + (gap ? ': ' : ':') + v);
            }
          }
        }
      } // Join all of the member texts together, separated with commas,
      // and wrap them in braces.


      v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' : '{' + partial.join(',') + '}';
      gap = mind;
      return v;
  }
}

var stringify = function stringify(value, replacer, space) {
  var i;
  gap = '';
  indent$a = ''; // If the space parameter is a number, make an indent string containing that
  // many spaces.

  if (typeof space === 'number') {
    for (i = 0; i < space; i += 1) {
      indent$a += ' ';
    }
  } // If the space parameter is a string, it will be used as the indent string.
  else if (typeof space === 'string') {
      indent$a = space;
    } // If there is a replacer, it must be a function or an array.
  // Otherwise, throw an error.


  rep = replacer;

  if (replacer && typeof replacer !== 'function' && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
    throw new Error('JSON.stringify');
  } // Make a fake root object containing our value under the key of ''.
  // Return the result of stringifying the value.


  return str('', {
    '': value
  });
};

var parse$5 = parse$4;
var stringify$1 = stringify;
var jsonify = {
  parse: parse$5,
  stringify: stringify$1
};

var json$2 = typeof JSON !== 'undefined' ? JSON : jsonify;

var jsonStableStringify = function jsonStableStringify(obj, opts) {
  if (!opts) opts = {};
  if (typeof opts === 'function') opts = {
    cmp: opts
  };
  var space = opts.space || '';
  if (typeof space === 'number') space = Array(space + 1).join(' ');
  var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;

  var replacer = opts.replacer || function (key, value) {
    return value;
  };

  var cmp = opts.cmp && function (f) {
    return function (node) {
      return function (a, b) {
        var aobj = {
          key: a,
          value: node[a]
        };
        var bobj = {
          key: b,
          value: node[b]
        };
        return f(aobj, bobj);
      };
    };
  }(opts.cmp);

  var seen = [];
  return function stringify(parent, key, node, level) {
    var indent = space ? '\n' + new Array(level + 1).join(space) : '';
    var colonSeparator = space ? ': ' : ':';

    if (node && node.toJSON && typeof node.toJSON === 'function') {
      node = node.toJSON();
    }

    node = replacer.call(parent, key, node);

    if (node === undefined) {
      return;
    }

    if (typeof node !== 'object' || node === null) {
      return json$2.stringify(node);
    }

    if (isArray$1(node)) {
      var out = [];

      for (var i = 0; i < node.length; i++) {
        var item = stringify(node, i, node[i], level + 1) || json$2.stringify(null);
        out.push(indent + space + item);
      }

      return '[' + out.join(',') + indent + ']';
    } else {
      if (seen.indexOf(node) !== -1) {
        if (cycles) return json$2.stringify('__cycle__');
        throw new TypeError('Converting circular structure to JSON');
      } else seen.push(node);

      var keys = objectKeys(node).sort(cmp && cmp(node));
      var out = [];

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = stringify(node, key, node[key], level + 1);
        if (!value) continue;
        var keyValue = json$2.stringify(key) + colonSeparator + value;
        out.push(indent + space + keyValue);
      }

      seen.splice(seen.indexOf(node), 1);
      return '{' + out.join(',') + indent + '}';
    }
  }({
    '': obj
  }, '', obj, 0);
};

var isArray$1 = Array.isArray || function (x) {
  return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
  var has = Object.prototype.hasOwnProperty || function () {
    return true;
  };

  var keys = [];

  for (var key in obj) {
    if (has.call(obj, key)) keys.push(key);
  }

  return keys;
};

var preserveCamelCase = function preserveCamelCase(string) {
  var isLastCharLower = false;
  var isLastCharUpper = false;
  var isLastLastCharUpper = false;

  for (var i = 0; i < string.length; i++) {
    var character = string[i];

    if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
      string = string.slice(0, i) + '-' + string.slice(i);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      i++;
    } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
      string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
    }
  }

  return string;
};

var camelCase = function camelCase(input, options) {
  if (!(typeof input === 'string' || Array.isArray(input))) {
    throw new TypeError('Expected the input to be `string | string[]`');
  }

  options = Object.assign({
    pascalCase: false
  }, options);

  var postProcess = function postProcess(x) {
    return options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
  };

  if (Array.isArray(input)) {
    input = input.map(function (x) {
      return x.trim();
    }).filter(function (x) {
      return x.length;
    }).join('-');
  } else {
    input = input.trim();
  }

  if (input.length === 0) {
    return '';
  }

  if (input.length === 1) {
    return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
  }

  var hasUpperCase = input !== input.toLowerCase();

  if (hasUpperCase) {
    input = preserveCamelCase(input);
  }

  input = input.replace(/^[_.\- ]+/, '').toLowerCase().replace(/[_.\- ]+(\w|$)/g, function (_, p1) {
    return p1.toUpperCase();
  }).replace(/\d+(\w|$)/g, function (m) {
    return m.toUpperCase();
  });
  return postProcess(input);
};

var camelcase = camelCase; // TODO: Remove this for the next major release

var default_1$6 = camelCase;
camelcase.default = default_1$6;

/*!
 * dashify <https://github.com/jonschlinkert/dashify>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var dashify = function dashify(str, options) {
  if (typeof str !== 'string') throw new TypeError('expected a string');
  return str.trim().replace(/([a-z])([A-Z])/g, '$1-$2').replace(/\W/g, function (m) {
    return /[À-ž]/.test(m) ? m : '-';
  }).replace(/^-+|-+$/g, '').replace(/-{2,}/g, function (m) {
    return options && options.condense ? '-' : m;
  }).toLowerCase();
};

var minimist = function minimist(args, opts) {
  if (!opts) opts = {};
  var flags = {
    bools: {},
    strings: {},
    unknownFn: null
  };

  if (typeof opts['unknown'] === 'function') {
    flags.unknownFn = opts['unknown'];
  }

  if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
    flags.allBools = true;
  } else {
    [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
      flags.bools[key] = true;
    });
  }

  var aliases = {};
  Object.keys(opts.alias || {}).forEach(function (key) {
    aliases[key] = [].concat(opts.alias[key]);
    aliases[key].forEach(function (x) {
      aliases[x] = [key].concat(aliases[key].filter(function (y) {
        return x !== y;
      }));
    });
  });
  [].concat(opts.string).filter(Boolean).forEach(function (key) {
    flags.strings[key] = true;

    if (aliases[key]) {
      flags.strings[aliases[key]] = true;
    }
  });
  var defaults = opts['default'] || {};
  var argv = {
    _: []
  };
  Object.keys(flags.bools).forEach(function (key) {
    setArg(key, defaults[key] === undefined ? false : defaults[key]);
  });
  var notFlags = [];

  if (args.indexOf('--') !== -1) {
    notFlags = args.slice(args.indexOf('--') + 1);
    args = args.slice(0, args.indexOf('--'));
  }

  function argDefined(key, arg) {
    return flags.allBools && /^--[^=]+$/.test(arg) || flags.strings[key] || flags.bools[key] || aliases[key];
  }

  function setArg(key, val, arg) {
    if (arg && flags.unknownFn && !argDefined(key, arg)) {
      if (flags.unknownFn(arg) === false) return;
    }

    var value = !flags.strings[key] && isNumber(val) ? Number(val) : val;
    setKey(argv, key.split('.'), value);
    (aliases[key] || []).forEach(function (x) {
      setKey(argv, x.split('.'), value);
    });
  }

  function setKey(obj, keys, value) {
    var o = obj;
    keys.slice(0, -1).forEach(function (key) {
      if (o[key] === undefined) o[key] = {};
      o = o[key];
    });
    var key = keys[keys.length - 1];

    if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
      o[key] = value;
    } else if (Array.isArray(o[key])) {
      o[key].push(value);
    } else {
      o[key] = [o[key], value];
    }
  }

  function aliasIsBoolean(key) {
    return aliases[key].some(function (x) {
      return flags.bools[x];
    });
  }

  for (var i = 0; i < args.length; i++) {
    var arg = args[i];

    if (/^--.+=/.test(arg)) {
      // Using [\s\S] instead of . because js doesn't support the
      // 'dotall' regex modifier. See:
      // http://stackoverflow.com/a/1068308/13216
      var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
      var key = m[1];
      var value = m[2];

      if (flags.bools[key]) {
        value = value !== 'false';
      }

      setArg(key, value, arg);
    } else if (/^--no-.+/.test(arg)) {
      var key = arg.match(/^--no-(.+)/)[1];
      setArg(key, false, arg);
    } else if (/^--.+/.test(arg)) {
      var key = arg.match(/^--(.+)/)[1];
      var next = args[i + 1];

      if (next !== undefined && !/^-/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
        setArg(key, next, arg);
        i++;
      } else if (/^(true|false)$/.test(next)) {
        setArg(key, next === 'true', arg);
        i++;
      } else {
        setArg(key, flags.strings[key] ? '' : true, arg);
      }
    } else if (/^-[^-]+/.test(arg)) {
      var letters = arg.slice(1, -1).split('');
      var broken = false;

      for (var j = 0; j < letters.length; j++) {
        var next = arg.slice(j + 2);

        if (next === '-') {
          setArg(letters[j], next, arg);
          continue;
        }

        if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
          setArg(letters[j], next.split('=')[1], arg);
          broken = true;
          break;
        }

        if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
          setArg(letters[j], next, arg);
          broken = true;
          break;
        }

        if (letters[j + 1] && letters[j + 1].match(/\W/)) {
          setArg(letters[j], arg.slice(j + 2), arg);
          broken = true;
          break;
        } else {
          setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
        }
      }

      var key = arg.slice(-1)[0];

      if (!broken && key !== '-') {
        if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
          setArg(key, args[i + 1], arg);
          i++;
        } else if (args[i + 1] && /true|false/.test(args[i + 1])) {
          setArg(key, args[i + 1] === 'true', arg);
          i++;
        } else {
          setArg(key, flags.strings[key] ? '' : true, arg);
        }
      }
    } else {
      if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
        argv._.push(flags.strings['_'] || !isNumber(arg) ? arg : Number(arg));
      }

      if (opts.stopEarly) {
        argv._.push.apply(argv._, args.slice(i + 1));

        break;
      }
    }
  }

  Object.keys(defaults).forEach(function (key) {
    if (!hasKey$1(argv, key.split('.'))) {
      setKey(argv, key.split('.'), defaults[key]);
      (aliases[key] || []).forEach(function (x) {
        setKey(argv, x.split('.'), defaults[key]);
      });
    }
  });

  if (opts['--']) {
    argv['--'] = new Array();
    notFlags.forEach(function (key) {
      argv['--'].push(key);
    });
  } else {
    notFlags.forEach(function (key) {
      argv._.push(key);
    });
  }

  return argv;
};

function hasKey$1(obj, keys) {
  var o = obj;
  keys.slice(0, -1).forEach(function (key) {
    o = o[key] || {};
  });
  var key = keys[keys.length - 1];
  return key in o;
}

function isNumber(x) {
  if (typeof x === 'number') return true;
  if (/^0x[0-9a-f]+$/i.test(x)) return true;
  return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

var PLACEHOLDER = null;
/**
 * unspecified boolean flag without default value is parsed as `undefined` instead of `false`
 */

var minimist_1 = function minimist_1(args, options) {
  var boolean = options.boolean || [];
  var defaults = options.default || {};
  var booleanWithoutDefault = boolean.filter(function (key) {
    return !(key in defaults);
  });
  var newDefaults = Object.assign({}, defaults, booleanWithoutDefault.reduce(function (reduced, key) {
    return Object.assign(reduced, {
      [key]: PLACEHOLDER
    });
  }, {}));
  var parsed = minimist(args, Object.assign({}, options, {
    default: newDefaults
  }));
  return Object.keys(parsed).reduce(function (reduced, key) {
    if (parsed[key] !== PLACEHOLDER) {
      reduced[key] = parsed[key];
    }

    return reduced;
  }, {});
};

var categoryOrder = [coreOptions.CATEGORY_OUTPUT, coreOptions.CATEGORY_FORMAT, coreOptions.CATEGORY_CONFIG, coreOptions.CATEGORY_EDITOR, coreOptions.CATEGORY_OTHER];
/**
 * {
 *   [optionName]: {
 *     // The type of the option. For 'choice', see also `choices` below.
 *     // When passing a type other than the ones listed below, the option is
 *     // treated as taking any string as argument, and `--option <${type}>` will
 *     // be displayed in --help.
 *     type: "boolean" | "choice" | "int" | string;
 *
 *     // Default value to be passed to the minimist option `default`.
 *     default?: any;
 *
 *     // Alias name to be passed to the minimist option `alias`.
 *     alias?: string;
 *
 *     // For grouping options by category in --help.
 *     category?: string;
 *
 *     // Description to be displayed in --help. If omitted, the option won't be
 *     // shown at all in --help (but see also `oppositeDescription` below).
 *     description?: string;
 *
 *     // Description for `--no-${name}` to be displayed in --help. If omitted,
 *     // `--no-${name}` won't be shown.
 *     oppositeDescription?: string;
 *
 *     // Indicate if this option is simply passed to the API.
 *     // true: use camelified name as the API option name.
 *     // string: use this value as the API option name.
 *     forwardToApi?: boolean | string;
 *
 *     // Indicate that a CLI flag should be an array when forwarded to the API.
 *     array?: boolean;
 *
 *     // Specify available choices for validation. They will also be displayed
 *     // in --help as <a|b|c>.
 *     // Use an object instead of a string if a choice is deprecated and should
 *     // be treated as `redirect` instead, or if you'd like to add description for
 *     // the choice.
 *     choices?: Array<
 *       | string
 *       | { value: string, description?: string, deprecated?: boolean, redirect?: string }
 *     >;
 *
 *     // If the option has a value that is an exception to the regular value
 *     // constraints, indicate that value here (or use a function for more
 *     // flexibility).
 *     exception?: ((value: any) => boolean);
 *
 *     // Indicate that the option is deprecated. Use a string to add an extra
 *     // message to --help for the option, for example to suggest a replacement
 *     // option.
 *     deprecated?: true | string;
 *   }
 * }
 *
 * Note: The options below are sorted alphabetically.
 */

var options$8 = {
  check: {
    type: "boolean",
    category: coreOptions.CATEGORY_OUTPUT,
    alias: "c",
    description: dedent_1`
      Check if the given files are formatted, print a human-friendly summary
      message and paths to unformatted files (see also --list-different).
    `
  },
  color: {
    // The supports-color package (a sub sub dependency) looks directly at
    // `process.argv` for `--no-color` and such-like options. The reason it is
    // listed here is to avoid "Ignored unknown option: --no-color" warnings.
    // See https://github.com/chalk/supports-color/#info for more information.
    type: "boolean",
    default: true,
    description: "Colorize error messages.",
    oppositeDescription: "Do not colorize error messages."
  },
  config: {
    type: "path",
    category: coreOptions.CATEGORY_CONFIG,
    description: "Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).",
    oppositeDescription: "Do not look for a configuration file.",
    exception: function exception(value) {
      return value === false;
    }
  },
  "config-precedence": {
    type: "choice",
    category: coreOptions.CATEGORY_CONFIG,
    default: "cli-override",
    choices: [{
      value: "cli-override",
      description: "CLI options take precedence over config file"
    }, {
      value: "file-override",
      description: "Config file take precedence over CLI options"
    }, {
      value: "prefer-file",
      description: dedent_1`
          If a config file is found will evaluate it and ignore other CLI options.
          If no config file is found CLI options will evaluate as normal.
        `
    }],
    description: "Define in which order config files and CLI options should be evaluated."
  },
  "debug-benchmark": {
    // Run the formatting benchmarks. Requires 'benchmark' module to be installed.
    type: "boolean"
  },
  "debug-check": {
    // Run the formatting once again on the formatted output, throw if different.
    type: "boolean"
  },
  "debug-print-doc": {
    type: "boolean"
  },
  "debug-repeat": {
    // Repeat the formatting a few times and measure the average duration.
    type: "int",
    default: 0
  },
  editorconfig: {
    type: "boolean",
    category: coreOptions.CATEGORY_CONFIG,
    description: "Take .editorconfig into account when parsing configuration.",
    oppositeDescription: "Don't take .editorconfig into account when parsing configuration.",
    default: true
  },
  "find-config-path": {
    type: "path",
    category: coreOptions.CATEGORY_CONFIG,
    description: "Find and print the path to a configuration file for the given input file."
  },
  "file-info": {
    type: "path",
    description: dedent_1`
      Extract the following info (as JSON) for a given file path. Reported fields:
      * ignored (boolean) - true if file path is filtered by --ignore-path
      * inferredParser (string | null) - name of parser inferred from file path
    `
  },
  help: {
    type: "flag",
    alias: "h",
    description: dedent_1`
      Show CLI usage, or details about the given flag.
      Example: --help write
    `,
    exception: function exception(value) {
      return value === "";
    }
  },
  "ignore-path": {
    type: "path",
    category: coreOptions.CATEGORY_CONFIG,
    default: ".prettierignore",
    description: "Path to a file with patterns describing files to ignore."
  },
  "list-different": {
    type: "boolean",
    category: coreOptions.CATEGORY_OUTPUT,
    alias: "l",
    description: "Print the names of files that are different from Prettier's formatting (see also --check)."
  },
  loglevel: {
    type: "choice",
    description: "What level of logs to report.",
    default: "log",
    choices: ["silent", "error", "warn", "log", "debug"]
  },
  stdin: {
    type: "boolean",
    description: "Force reading input from stdin."
  },
  "support-info": {
    type: "boolean",
    description: "Print support information as JSON."
  },
  version: {
    type: "boolean",
    alias: "v",
    description: "Print Prettier version."
  },
  "with-node-modules": {
    type: "boolean",
    category: coreOptions.CATEGORY_CONFIG,
    description: "Process files inside 'node_modules' directory."
  },
  write: {
    type: "boolean",
    category: coreOptions.CATEGORY_OUTPUT,
    description: "Edit files in-place. (Beware!)"
  }
};
var usageSummary = dedent_1`
  Usage: prettier [options] [file/glob ...]

  By default, output is written to stdout.
  Stdin is read if it is piped to Prettier and no files are given.
`;
var constant = {
  categoryOrder,
  options: options$8,
  usageSummary
};

// which causes unwanted lines in the output. An additional check for isCI() helps.
// See https://github.com/prettier/prettier/issues/5801


var isTty = function isTTY() {
  return process.stdout.isTTY && !thirdParty.isCI();
};

var OPTION_USAGE_THRESHOLD = 25;
var CHOICE_USAGE_MARGIN = 3;
var CHOICE_USAGE_INDENTATION = 2;

function getOptions(argv, detailedOptions) {
  return detailedOptions.filter(function (option) {
    return option.forwardToApi;
  }).reduce(function (current, option) {
    return Object.assign(current, {
      [option.forwardToApi]: argv[option.name]
    });
  }, {});
}

function cliifyOptions(object, apiDetailedOptionMap) {
  return Object.keys(object || {}).reduce(function (output, key) {
    var apiOption = apiDetailedOptionMap[key];
    var cliKey = apiOption ? apiOption.name : key;
    output[dashify(cliKey)] = object[key];
    return output;
  }, {});
}

function diff(a, b) {
  return require$$0$1.createTwoFilesPatch("", "", a, b, "", "", {
    context: 2
  });
}

function handleError(context, filename, error) {
  if (error instanceof errors.UndefinedParserError) {
    if (context.argv["write"] && isTty()) {
      readline$1.clearLine(process.stdout, 0);
      readline$1.cursorTo(process.stdout, 0, null);
    }

    if (!context.argv["check"] && !context.argv["list-different"]) {
      process.exitCode = 2;
    }

    context.logger.error(error.message);
    return;
  }

  if (context.argv["write"]) {
    // Add newline to split errors from filename line.
    process.stdout.write("\n");
  }

  var isParseError = Boolean(error && error.loc);
  var isValidationError = /^Invalid \S+ value\./.test(error && error.message);

  if (isParseError) {
    // `invalid.js: SyntaxError: Unexpected token (1:1)`.
    context.logger.error(`${filename}: ${String(error)}`);
  } else if (isValidationError || error instanceof errors.ConfigError) {
    // `Invalid printWidth value. Expected an integer, but received 0.5.`
    context.logger.error(error.message); // If validation fails for one file, it will fail for all of them.

    process.exit(1);
  } else if (error instanceof errors.DebugError) {
    // `invalid.js: Some debug error message`
    context.logger.error(`${filename}: ${error.message}`);
  } else {
    // `invalid.js: Error: Some unexpected error\n[stack trace]`
    context.logger.error(filename + ": " + (error.stack || error));
  } // Don't exit the process if one file failed


  process.exitCode = 2;
}

function logResolvedConfigPathOrDie(context) {
  var configFile = prettier.resolveConfigFile.sync(context.argv["find-config-path"]);

  if (configFile) {
    context.logger.log(path$2.relative(process.cwd(), configFile));
  } else {
    process.exit(1);
  }
}

function logFileInfoOrDie(context) {
  var options = {
    ignorePath: context.argv["ignore-path"],
    withNodeModules: context.argv["with-node-modules"],
    plugins: context.argv["plugin"],
    pluginSearchDirs: context.argv["plugin-search-dir"]
  };
  context.logger.log(prettier.format(jsonStableStringify(prettier.getFileInfo.sync(context.argv["file-info"], options)), {
    parser: "json"
  }));
}

function writeOutput(context, result, options) {
  // Don't use `console.log` here since it adds an extra newline at the end.
  process.stdout.write(context.argv["debug-check"] ? result.filepath : result.formatted);

  if (options && options.cursorOffset >= 0) {
    process.stderr.write(result.cursorOffset + "\n");
  }
}

function listDifferent(context, input, options, filename) {
  if (!context.argv["check"] && !context.argv["list-different"]) {
    return;
  }

  try {
    if (!options.filepath && !options.parser) {
      throw new errors.UndefinedParserError("No parser and no file path given, couldn't infer a parser.");
    }

    if (!prettier.check(input, options)) {
      if (!context.argv["write"]) {
        context.logger.log(filename);
        process.exitCode = 1;
      }
    }
  } catch (error) {
    context.logger.error(error.message);
  }

  return true;
}

function format$1(context, input, opt) {
  if (!opt.parser && !opt.filepath) {
    throw new errors.UndefinedParserError("No parser and no file path given, couldn't infer a parser.");
  }

  if (context.argv["debug-print-doc"]) {
    var doc = prettier.__debug.printToDoc(input, opt);

    return {
      formatted: prettier.__debug.formatDoc(doc)
    };
  }

  if (context.argv["debug-check"]) {
    var pp = prettier.format(input, opt);
    var pppp = prettier.format(pp, opt);

    if (pp !== pppp) {
      throw new errors.DebugError("prettier(input) !== prettier(prettier(input))\n" + diff(pp, pppp));
    } else {
      var _stringify = function _stringify(obj) {
        return JSON.stringify(obj, null, 2);
      };

      var ast = _stringify(prettier.__debug.parse(input, opt,
      /* massage */
      true).ast);

      var past = _stringify(prettier.__debug.parse(pp, opt,
      /* massage */
      true).ast);

      if (ast !== past) {
        var MAX_AST_SIZE = 2097152; // 2MB

        var astDiff = ast.length > MAX_AST_SIZE || past.length > MAX_AST_SIZE ? "AST diff too large to render" : diff(ast, past);
        throw new errors.DebugError("ast(input) !== ast(prettier(input))\n" + astDiff + "\n" + diff(input, pp));
      }
    }

    return {
      formatted: pp,
      filepath: opt.filepath || "(stdin)\n"
    };
  }
  /* istanbul ignore if */


  if (context.argv["debug-benchmark"]) {
    var benchmark;

    try {
      benchmark = require("benchmark");
    } catch (err) {
      context.logger.debug("'--debug-benchmark' requires the 'benchmark' package to be installed.");
      process.exit(2);
    }

    context.logger.debug("'--debug-benchmark' option found, measuring formatWithCursor with 'benchmark' module.");
    var suite = new benchmark.Suite();
    suite.add("format", function () {
      prettier.formatWithCursor(input, opt);
    }).on("cycle", function (event) {
      var results = {
        benchmark: String(event.target),
        hz: event.target.hz,
        ms: event.target.times.cycle * 1000
      };
      context.logger.debug("'--debug-benchmark' measurements for formatWithCursor: " + JSON.stringify(results, null, 2));
    }).run({
      async: false
    });
  } else if (context.argv["debug-repeat"] > 0) {
    var repeat = context.argv["debug-repeat"];
    context.logger.debug("'--debug-repeat' option found, running formatWithCursor " + repeat + " times."); // should be using `performance.now()`, but only `Date` is cross-platform enough

    var now = Date.now ? function () {
      return Date.now();
    } : function () {
      return +new Date();
    };
    var totalMs = 0;

    for (var i = 0; i < repeat; ++i) {
      var startMs = now();
      prettier.formatWithCursor(input, opt);
      totalMs += now() - startMs;
    }

    var averageMs = totalMs / repeat;
    var results = {
      repeat,
      hz: 1000 / averageMs,
      ms: averageMs
    };
    context.logger.debug("'--debug-repeat' measurements for formatWithCursor: " + JSON.stringify(results, null, 2));
  }

  return prettier.formatWithCursor(input, opt);
}

function getOptionsOrDie(context, filePath) {
  try {
    if (context.argv["config"] === false) {
      context.logger.debug("'--no-config' option found, skip loading config file.");
      return null;
    }

    context.logger.debug(context.argv["config"] ? `load config file from '${context.argv["config"]}'` : `resolve config from '${filePath}'`);
    var options = prettier.resolveConfig.sync(filePath, {
      editorconfig: context.argv["editorconfig"],
      config: context.argv["config"]
    });
    context.logger.debug("loaded options `" + JSON.stringify(options) + "`");
    return options;
  } catch (error) {
    context.logger.error(`Invalid configuration file \`${filePath}\`: ` + error.message);
    process.exit(2);
  }
}

function getOptionsForFile(context, filepath) {
  var options = getOptionsOrDie(context, filepath);
  var hasPlugins = options && options.plugins;

  if (hasPlugins) {
    pushContextPlugins(context, options.plugins);
  }

  var appliedOptions = Object.assign({
    filepath
  }, applyConfigPrecedence(context, options && optionsNormalizer.normalizeApiOptions(options, context.supportOptions, {
    logger: context.logger
  })));
  context.logger.debug(`applied config-precedence (${context.argv["config-precedence"]}): ` + `${JSON.stringify(appliedOptions)}`);

  if (hasPlugins) {
    popContextPlugins(context);
  }

  return appliedOptions;
}

function parseArgsToOptions(context, overrideDefaults) {
  var minimistOptions = createMinimistOptions(context.detailedOptions);
  var apiDetailedOptionMap = createApiDetailedOptionMap(context.detailedOptions);
  return getOptions(optionsNormalizer.normalizeCliOptions(minimist_1(context.args, Object.assign({
    string: minimistOptions.string,
    boolean: minimistOptions.boolean,
    default: cliifyOptions(overrideDefaults, apiDetailedOptionMap)
  })), context.detailedOptions, {
    logger: false
  }), context.detailedOptions);
}

function applyConfigPrecedence(context, options) {
  try {
    switch (context.argv["config-precedence"]) {
      case "cli-override":
        return parseArgsToOptions(context, options);

      case "file-override":
        return Object.assign({}, parseArgsToOptions(context), options);

      case "prefer-file":
        return options || parseArgsToOptions(context);
    }
  } catch (error) {
    context.logger.error(error.toString());
    process.exit(2);
  }
}

function formatStdin(context) {
  var filepath = context.argv["stdin-filepath"] ? path$2.resolve(process.cwd(), context.argv["stdin-filepath"]) : process.cwd();
  var ignorer = createIgnorerFromContextOrDie(context);
  var relativeFilepath = path$2.relative(process.cwd(), filepath);
  thirdParty.getStream(process.stdin).then(function (input) {
    if (relativeFilepath && ignorer.filter([relativeFilepath]).length === 0) {
      writeOutput(context, {
        formatted: input
      });
      return;
    }

    var options = getOptionsForFile(context, filepath);

    if (listDifferent(context, input, options, "(stdin)")) {
      return;
    }

    writeOutput(context, format$1(context, input, options), options);
  }).catch(function (error) {
    handleError(context, relativeFilepath || "stdin", error);
  });
}

function createIgnorerFromContextOrDie(context) {
  try {
    return createIgnorer_1.sync(context.argv["ignore-path"], context.argv["with-node-modules"]);
  } catch (e) {
    context.logger.error(e.message);
    process.exit(2);
  }
}

function eachFilename(context, patterns, callback) {
  // The '!./' globs are due to https://github.com/prettier/prettier/issues/2110
  var ignoreNodeModules = context.argv["with-node-modules"] !== true;

  if (ignoreNodeModules) {
    patterns = patterns.concat(["!**/node_modules/**", "!./node_modules/**"]);
  }

  patterns = patterns.concat(["!**/.{git,svn,hg}/**", "!./.{git,svn,hg}/**"]);

  try {
    var filePaths = globby.sync(patterns, {
      dot: true,
      nodir: true
    }).map(function (filePath) {
      return path$2.relative(process.cwd(), filePath);
    });

    if (filePaths.length === 0) {
      context.logger.error(`No matching files. Patterns tried: ${patterns.join(" ")}`);
      process.exitCode = 2;
      return;
    }

    filePaths.forEach(function (filePath) {
      return callback(filePath);
    });
  } catch (error) {
    context.logger.error(`Unable to expand glob patterns: ${patterns.join(" ")}\n${error.message}`); // Don't exit the process if one pattern failed

    process.exitCode = 2;
  }
}

function formatFiles(context) {
  // The ignorer will be used to filter file paths after the glob is checked,
  // before any files are actually written
  var ignorer = createIgnorerFromContextOrDie(context);
  var numberOfUnformattedFilesFound = 0;

  if (context.argv["check"]) {
    context.logger.log("Checking formatting...");
  }

  eachFilename(context, context.filePatterns, function (filename) {
    var fileIgnored = ignorer.filter([filename]).length === 0;

    if (fileIgnored && (context.argv["debug-check"] || context.argv["write"] || context.argv["check"] || context.argv["list-different"])) {
      return;
    }

    var options = Object.assign(getOptionsForFile(context, filename), {
      filepath: filename
    });

    if (isTty()) {
      context.logger.log(filename, {
        newline: false
      });
    }

    var input;

    try {
      input = fs$1.readFileSync(filename, "utf8");
    } catch (error) {
      // Add newline to split errors from filename line.
      context.logger.log("");
      context.logger.error(`Unable to read file: ${filename}\n${error.message}`); // Don't exit the process if one file failed

      process.exitCode = 2;
      return;
    }

    if (fileIgnored) {
      writeOutput(context, {
        formatted: input
      }, options);
      return;
    }

    var start = Date.now();
    var result;
    var output;

    try {
      result = format$1(context, input, Object.assign({}, options, {
        filepath: filename
      }));
      output = result.formatted;
    } catch (error) {
      handleError(context, filename, error);
      return;
    }

    var isDifferent = output !== input;

    if (isTty()) {
      // Remove previously printed filename to log it with duration.
      readline$1.clearLine(process.stdout, 0);
      readline$1.cursorTo(process.stdout, 0, null);
    }

    if (context.argv["write"]) {
      // Don't write the file if it won't change in order not to invalidate
      // mtime based caches.
      if (isDifferent) {
        if (!context.argv["check"] && !context.argv["list-different"]) {
          context.logger.log(`${filename} ${Date.now() - start}ms`);
        }

        try {
          fs$1.writeFileSync(filename, output, "utf8");
        } catch (error) {
          context.logger.error(`Unable to write file: ${filename}\n${error.message}`); // Don't exit the process if one file failed

          process.exitCode = 2;
        }
      } else if (!context.argv["check"] && !context.argv["list-different"]) {
        context.logger.log(`${chalk.grey(filename)} ${Date.now() - start}ms`);
      }
    } else if (context.argv["debug-check"]) {
      if (result.filepath) {
        context.logger.log(result.filepath);
      } else {
        process.exitCode = 2;
      }
    } else if (!context.argv["check"] && !context.argv["list-different"]) {
      writeOutput(context, result, options);
    }

    if ((context.argv["check"] || context.argv["list-different"]) && isDifferent) {
      context.logger.log(filename);
      numberOfUnformattedFilesFound += 1;
    }
  }); // Print check summary based on expected exit code

  if (context.argv["check"]) {
    context.logger.log(numberOfUnformattedFilesFound === 0 ? "All matched files use Prettier code style!" : context.argv["write"] ? "Code style issues fixed in the above file(s)." : "Code style issues found in the above file(s). Forgot to run Prettier?");
  } // Ensure non-zero exitCode when using --check/list-different is not combined with --write


  if ((context.argv["check"] || context.argv["list-different"]) && numberOfUnformattedFilesFound > 0 && !process.exitCode && !context.argv["write"]) {
    process.exitCode = 1;
  }
}

function getOptionsWithOpposites(options) {
  // Add --no-foo after --foo.
  var optionsWithOpposites = options.map(function (option) {
    return [option.description ? option : null, option.oppositeDescription ? Object.assign({}, option, {
      name: `no-${option.name}`,
      type: "boolean",
      description: option.oppositeDescription
    }) : null];
  });
  return flattenArray(optionsWithOpposites).filter(Boolean);
}

function createUsage(context) {
  var options = getOptionsWithOpposites(context.detailedOptions).filter( // remove unnecessary option (e.g. `semi`, `color`, etc.), which is only used for --help <flag>
  function (option) {
    return !(option.type === "boolean" && option.oppositeDescription && !option.name.startsWith("no-"));
  });
  var groupedOptions = groupBy(options, function (option) {
    return option.category;
  });
  var firstCategories = constant.categoryOrder.slice(0, -1);
  var lastCategories = constant.categoryOrder.slice(-1);
  var restCategories = Object.keys(groupedOptions).filter(function (category) {
    return firstCategories.indexOf(category) === -1 && lastCategories.indexOf(category) === -1;
  });
  var allCategories = firstCategories.concat(restCategories, lastCategories);
  var optionsUsage = allCategories.map(function (category) {
    var categoryOptions = groupedOptions[category].map(function (option) {
      return createOptionUsage(context, option, OPTION_USAGE_THRESHOLD);
    }).join("\n");
    return `${category} options:\n\n${indent$b(categoryOptions, 2)}`;
  });
  return [constant.usageSummary].concat(optionsUsage, [""]).join("\n\n");
}

function createOptionUsage(context, option, threshold) {
  var header = createOptionUsageHeader(option);
  var optionDefaultValue = getOptionDefaultValue(context, option.name);
  return createOptionUsageRow(header, `${option.description}${optionDefaultValue === undefined ? "" : `\nDefaults to ${createDefaultValueDisplay(optionDefaultValue)}.`}`, threshold);
}

function createDefaultValueDisplay(value) {
  return Array.isArray(value) ? `[${value.map(createDefaultValueDisplay).join(", ")}]` : value;
}

function createOptionUsageHeader(option) {
  var name = `--${option.name}`;
  var alias = option.alias ? `-${option.alias},` : null;
  var type = createOptionUsageType(option);
  return [alias, name, type].filter(Boolean).join(" ");
}

function createOptionUsageRow(header, content, threshold) {
  var separator = header.length >= threshold ? `\n${" ".repeat(threshold)}` : " ".repeat(threshold - header.length);
  var description = content.replace(/\n/g, `\n${" ".repeat(threshold)}`);
  return `${header}${separator}${description}`;
}

function createOptionUsageType(option) {
  switch (option.type) {
    case "boolean":
      return null;

    case "choice":
      return `<${option.choices.filter(function (choice) {
        return choice.since !== null;
      }).filter(function (choice) {
        return !choice.deprecated;
      }).map(function (choice) {
        return choice.value;
      }).join("|")}>`;

    default:
      return `<${option.type}>`;
  }
}

function flattenArray(array) {
  return [].concat.apply([], array);
}

function createChoiceUsages(choices, margin, indentation) {
  var activeChoices = choices.filter(function (choice) {
    return !choice.deprecated && choice.since !== null;
  });
  var threshold = activeChoices.map(function (choice) {
    return choice.value.length;
  }).reduce(function (current, length) {
    return Math.max(current, length);
  }, 0) + margin;
  return activeChoices.map(function (choice) {
    return indent$b(createOptionUsageRow(choice.value, choice.description, threshold), indentation);
  });
}

function createDetailedUsage(context, flag) {
  var option = getOptionsWithOpposites(context.detailedOptions).find(function (option) {
    return option.name === flag || option.alias === flag;
  });
  var header = createOptionUsageHeader(option);
  var description = `\n\n${indent$b(option.description, 2)}`;
  var choices = option.type !== "choice" ? "" : `\n\nValid options:\n\n${createChoiceUsages(option.choices, CHOICE_USAGE_MARGIN, CHOICE_USAGE_INDENTATION).join("\n")}`;
  var optionDefaultValue = getOptionDefaultValue(context, option.name);
  var defaults = optionDefaultValue !== undefined ? `\n\nDefault: ${createDefaultValueDisplay(optionDefaultValue)}` : "";
  var pluginDefaults = option.pluginDefaults && Object.keys(option.pluginDefaults).length ? `\nPlugin defaults:${Object.keys(option.pluginDefaults).map(function (key) {
    return `\n* ${key}: ${createDefaultValueDisplay(option.pluginDefaults[key])}`;
  })}` : "";
  return `${header}${description}${choices}${defaults}${pluginDefaults}`;
}

function getOptionDefaultValue(context, optionName) {
  // --no-option
  if (!(optionName in context.detailedOptionMap)) {
    return undefined;
  }

  var option = context.detailedOptionMap[optionName];

  if (option.default !== undefined) {
    return option.default;
  }

  var optionCamelName = camelcase(optionName);

  if (optionCamelName in context.apiDefaultOptions) {
    return context.apiDefaultOptions[optionCamelName];
  }

  return undefined;
}

function indent$b(str, spaces) {
  return str.replace(/^/gm, " ".repeat(spaces));
}

function groupBy(array, getKey) {
  return array.reduce(function (obj, item) {
    var key = getKey(item);
    var previousItems = key in obj ? obj[key] : [];
    return Object.assign({}, obj, {
      [key]: previousItems.concat(item)
    });
  }, Object.create(null));
}

function pick(object, keys) {
  return !keys ? object : keys.reduce(function (reduced, key) {
    return Object.assign(reduced, {
      [key]: object[key]
    });
  }, {});
}

function createLogger(logLevel) {
  return {
    warn: createLogFunc("warn", "yellow"),
    error: createLogFunc("error", "red"),
    debug: createLogFunc("debug", "blue"),
    log: createLogFunc("log")
  };

  function createLogFunc(loggerName, color) {
    if (!shouldLog(loggerName)) {
      return function () {};
    }

    var prefix = color ? `[${chalk[color](loggerName)}] ` : "";
    return function (message, opts) {
      opts = Object.assign({
        newline: true
      }, opts);
      var stream = process[loggerName === "log" ? "stdout" : "stderr"];
      stream.write(message.replace(/^/gm, prefix) + (opts.newline ? "\n" : ""));
    };
  }

  function shouldLog(loggerName) {
    switch (logLevel) {
      case "silent":
        return false;

      default:
        return true;

      case "debug":
        if (loggerName === "debug") {
          return true;
        }

      // fall through

      case "log":
        if (loggerName === "log") {
          return true;
        }

      // fall through

      case "warn":
        if (loggerName === "warn") {
          return true;
        }

      // fall through

      case "error":
        return loggerName === "error";
    }
  }
}

function normalizeDetailedOption(name, option) {
  return Object.assign({
    category: coreOptions.CATEGORY_OTHER
  }, option, {
    choices: option.choices && option.choices.map(function (choice) {
      var newChoice = Object.assign({
        description: "",
        deprecated: false
      }, typeof choice === "object" ? choice : {
        value: choice
      });

      if (newChoice.value === true) {
        newChoice.value = ""; // backward compatibility for original boolean option
      }

      return newChoice;
    })
  });
}

function normalizeDetailedOptionMap(detailedOptionMap) {
  return Object.keys(detailedOptionMap).sort().reduce(function (normalized, name) {
    var option = detailedOptionMap[name];
    return Object.assign(normalized, {
      [name]: normalizeDetailedOption(name, option)
    });
  }, {});
}

function createMinimistOptions(detailedOptions) {
  return {
    // we use vnopts' AliasSchema to handle aliases for better error messages
    alias: {},
    boolean: detailedOptions.filter(function (option) {
      return option.type === "boolean";
    }).map(function (option) {
      return [option.name].concat(option.alias || []);
    }).reduce(function (a, b) {
      return a.concat(b);
    }),
    string: detailedOptions.filter(function (option) {
      return option.type !== "boolean";
    }).map(function (option) {
      return [option.name].concat(option.alias || []);
    }).reduce(function (a, b) {
      return a.concat(b);
    }),
    default: detailedOptions.filter(function (option) {
      return !option.deprecated;
    }).filter(function (option) {
      return !option.forwardToApi || option.name === "plugin" || option.name === "plugin-search-dir";
    }).filter(function (option) {
      return option.default !== undefined;
    }).reduce(function (current, option) {
      return Object.assign({
        [option.name]: option.default
      }, current);
    }, {})
  };
}

function createApiDetailedOptionMap(detailedOptions) {
  return detailedOptions.reduce(function (current, option) {
    return option.forwardToApi && option.forwardToApi !== option.name ? Object.assign(current, {
      [option.forwardToApi]: option
    }) : current;
  }, {});
}

function createDetailedOptionMap(supportOptions) {
  return supportOptions.reduce(function (reduced, option) {
    var newOption = Object.assign({}, option, {
      name: option.cliName || dashify(option.name),
      description: option.cliDescription || option.description,
      category: option.cliCategory || coreOptions.CATEGORY_FORMAT,
      forwardToApi: option.name
    });

    if (option.deprecated) {
      delete newOption.forwardToApi;
      delete newOption.description;
      delete newOption.oppositeDescription;
      newOption.deprecated = true;
    }

    return Object.assign(reduced, {
      [newOption.name]: newOption
    });
  }, {});
} //-----------------------------context-util-start-------------------------------

/**
 * @typedef {Object} Context
 * @property logger
 * @property args
 * @property argv
 * @property filePatterns
 * @property supportOptions
 * @property detailedOptions
 * @property detailedOptionMap
 * @property apiDefaultOptions
 */


function createContext(args) {
  var context = {
    args
  };
  updateContextArgv(context);
  normalizeContextArgv(context, ["loglevel", "plugin", "plugin-search-dir"]);
  context.logger = createLogger(context.argv["loglevel"]);
  updateContextArgv(context, context.argv["plugin"], context.argv["plugin-search-dir"]);
  return context;
}

function initContext(context) {
  // split into 2 step so that we could wrap this in a `try..catch` in cli/index.js
  normalizeContextArgv(context);
}

function updateContextOptions(context, plugins, pluginSearchDirs) {
  var supportOptions = prettier.getSupportInfo(null, {
    showDeprecated: true,
    showUnreleased: true,
    showInternal: true,
    plugins,
    pluginSearchDirs
  }).options;
  var detailedOptionMap = normalizeDetailedOptionMap(Object.assign({}, createDetailedOptionMap(supportOptions), constant.options));
  var detailedOptions = arrayify(detailedOptionMap, "name");
  var apiDefaultOptions = supportOptions.filter(function (optionInfo) {
    return !optionInfo.deprecated;
  }).reduce(function (reduced, optionInfo) {
    return Object.assign(reduced, {
      [optionInfo.name]: optionInfo.default
    });
  }, Object.assign({}, options$1.hiddenDefaults));
  context.supportOptions = supportOptions;
  context.detailedOptions = detailedOptions;
  context.detailedOptionMap = detailedOptionMap;
  context.apiDefaultOptions = apiDefaultOptions;
}

function pushContextPlugins(context, plugins, pluginSearchDirs) {
  context._supportOptions = context.supportOptions;
  context._detailedOptions = context.detailedOptions;
  context._detailedOptionMap = context.detailedOptionMap;
  context._apiDefaultOptions = context.apiDefaultOptions;
  updateContextOptions(context, plugins, pluginSearchDirs);
}

function popContextPlugins(context) {
  context.supportOptions = context._supportOptions;
  context.detailedOptions = context._detailedOptions;
  context.detailedOptionMap = context._detailedOptionMap;
  context.apiDefaultOptions = context._apiDefaultOptions;
}

function updateContextArgv(context, plugins, pluginSearchDirs) {
  pushContextPlugins(context, plugins, pluginSearchDirs);
  var minimistOptions = createMinimistOptions(context.detailedOptions);
  var argv = minimist_1(context.args, minimistOptions);
  context.argv = argv;
  context.filePatterns = argv["_"];
}

function normalizeContextArgv(context, keys) {
  var detailedOptions = !keys ? context.detailedOptions : context.detailedOptions.filter(function (option) {
    return keys.indexOf(option.name) !== -1;
  });
  var argv = !keys ? context.argv : pick(context.argv, keys);
  context.argv = optionsNormalizer.normalizeCliOptions(argv, detailedOptions, {
    logger: context.logger
  });
} //------------------------------context-util-end--------------------------------


var util$2 = {
  createContext,
  createDetailedOptionMap,
  createDetailedUsage,
  createUsage,
  format: format$1,
  formatFiles,
  formatStdin,
  initContext,
  logResolvedConfigPathOrDie,
  logFileInfoOrDie,
  normalizeDetailedOptionMap
};

function run(args) {
  var context = util$2.createContext(args);

  try {
    util$2.initContext(context);
    context.logger.debug(`normalized argv: ${JSON.stringify(context.argv)}`);

    if (context.argv["check"] && context.argv["list-different"]) {
      context.logger.error("Cannot use --check and --list-different together.");
      process.exit(1);
    }

    if (context.argv["write"] && context.argv["debug-check"]) {
      context.logger.error("Cannot use --write and --debug-check together.");
      process.exit(1);
    }

    if (context.argv["find-config-path"] && context.filePatterns.length) {
      context.logger.error("Cannot use --find-config-path with multiple files");
      process.exit(1);
    }

    if (context.argv["file-info"] && context.filePatterns.length) {
      context.logger.error("Cannot use --file-info with multiple files");
      process.exit(1);
    }

    if (context.argv["version"]) {
      context.logger.log(prettier.version);
      process.exit(0);
    }

    if (context.argv["help"] !== undefined) {
      context.logger.log(typeof context.argv["help"] === "string" && context.argv["help"] !== "" ? util$2.createDetailedUsage(context, context.argv["help"]) : util$2.createUsage(context));
      process.exit(0);
    }

    if (context.argv["support-info"]) {
      context.logger.log(prettier.format(jsonStableStringify(prettier.getSupportInfo()), {
        parser: "json"
      }));
      process.exit(0);
    }

    var hasFilePatterns = context.filePatterns.length !== 0;
    var useStdin = context.argv["stdin"] || !hasFilePatterns && !process.stdin.isTTY;

    if (context.argv["find-config-path"]) {
      util$2.logResolvedConfigPathOrDie(context);
    } else if (context.argv["file-info"]) {
      util$2.logFileInfoOrDie(context);
    } else if (useStdin) {
      util$2.formatStdin(context);
    } else if (hasFilePatterns) {
      util$2.formatFiles(context);
    } else {
      context.logger.log(util$2.createUsage(context));
      process.exit(1);
    }
  } catch (error) {
    context.logger.error(error.message);
    process.exit(1);
  }
}

var cli = {
  run
};

cli.run(process.argv.slice(2));
var prettier$1 = {};

module.exports = prettier$1;
