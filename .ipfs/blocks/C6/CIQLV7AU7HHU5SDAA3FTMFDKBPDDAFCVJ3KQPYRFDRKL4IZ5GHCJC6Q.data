        if (node.kind === 258 /* EnumDeclaration */) {
                    ts.setSourceMapRange(statement.declarationList, node);
                }
                else {
                    ts.setSourceMapRange(statement, node);
                }
                // Trailing comments for module declaration should be emitted after the function closure
                // instead of the variable statement:
                //
                //     /** Module comment*/
                //     module m1 {
                //         function foo4Export() {
                //         }
                //     } // trailing comment module
                //
                // Should emit:
                //
                //     /** Module comment*/
                //     var m1;
                //     (function (m1) {
                //         function foo4Export() {
                //         }
                //     })(m1 || (m1 = {})); // trailing comment module
                //
                ts.setCommentRange(statement, node);
                ts.addEmitFlags(statement, 1024 /* NoTrailingComments */ | 4194304 /* HasEndOfDeclarationMarker */);
                statements.push(statement);
                return true;
            }
            else {
                // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding
                // declaration we do not emit a leading variable declaration. To preserve the
                // begin/end semantics of the declararation and to properly handle exports
                // we wrap the leading variable declaration in a `MergeDeclarationMarker`.
                var mergeMarker = factory.createMergeDeclarationMarker(statement);
                ts.setEmitFlags(mergeMarker, 1536 /* NoComments */ | 4194304 /* HasEndOfDeclarationMarker */);
                statements.push(mergeMarker);
                return false;
            }
        }
        /**
         * Visits a module declaration node.
         *
         * This function will be called any time a TypeScript namespace (ModuleDeclaration) is encountered.
         *
         * @param node The module declaration node.
         */
        function visitModuleDeclaration(node) {
            if (!shouldEmitModuleDeclaration(node)) {
                return factory.createNotEmittedStatement(node);
            }
            ts.Debug.assertNode(node.name, ts.isIdentifier, "A TypeScript namespace should have an Identifier name.");
            enableSubstitutionForNamespaceExports();
            var statements = [];
            // We request to be advised when the printer is about to print this node. This allows
            // us to set up the correct state for later substitutions.
            var emitFlags = 2 /* AdviseOnEmitNode */;
            // If needed, we should emit a variable declaration for the module. If we emit
            // a leading variable declaration, we should not emit leading comments for the
            // module body.
            var varAdded = addVarForEnumOrModuleDeclaration(statements, node);
            if (varAdded) {
                // We should still emit the comments if we are emitting a system module.
                if (moduleKind !== ts.ModuleKind.System || currentLexicalScope !== currentSourceFile) {
                    emitFlags |= 512 /* NoLeadingComments */;
                }
            }
            // `parameterName` is the declaration name used inside of the namespace.
            var parameterName = getNamespaceParameterName(node);
            // `containerName` is the expression used inside of the namespace for exports.
            var containerName = getNamespaceContainerName(node);
            // `exportName` is the expression used within this node's container for any exported references.
            var exportName = ts.hasSyntacticModifier(node, 1 /* Export */)
                ? factory.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, /*allowComments*/ false, /*allowSourceMaps*/ true)
                : factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
            //  x || (x = {})
            //  exports.x || (exports.x = {})
            var moduleArg = factory.createLogicalOr(exportName, factory.createAssignment(exportName, factory.createObjectLiteralExpression()));
            if (hasNamespaceQualifiedExportName(node)) {
                // `localName` is the expression used within this node's containing scope for any local references.
                var localName = factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
                //  x = (exports.x || (exports.x = {}))
                moduleArg = factory.createAssignment(localName, moduleArg);
            }
            //  (function (x_1) {
            //      x_1.y = ...;
            //  })(x || (x = {}));
            var moduleStatement = factory.createExpressionStatement(factory.createCallExpression(factory.createFunctionExpression(
            /*modifiers*/ undefined, 
            /*asteriskToken*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, [factory.createParameterDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)], 
            /*type*/ undefined, transformModuleBody(node, containerName)), 
            /*typeArguments*/ undefined, [moduleArg]));
            ts.setOriginalNode(moduleStatement, node);
            if (varAdded) {
                // If a variable was added, synthetic comments are emitted on it, not on the moduleStatement.
                ts.setSyntheticLeadingComments(moduleStatement, undefined);
                ts.setSyntheticTrailingComments(moduleStatement, undefined);
            }
            ts.setTextRange(moduleStatement, node);
            ts.addEmitFlags(moduleStatement, emitFlags);
            statements.push(moduleStatement);
            // Add a DeclarationMarker for the namespace to preserve trailing comments and mark
            // the end of the declaration.
            statements.push(factory.createEndOfDeclarationMarker(node));
            return statements;
        }
        /**
         * Transforms the body of a module declaration.
         *
         * @param node The module declaration node.
         */
        function transformModuleBody(node, namespaceLocalName) {
            var savedCurrentNamespaceContainerName = currentNamespaceContainerName;
            var savedCurrentNamespace = currentNamespace;
            var savedCurrentScopeFirstDeclarationsOfName = currentScopeFirstDeclarationsOfName;
            currentNamespaceContainerName = namespaceLocalName;
            currentNamespace = node;
            currentScopeFirstDeclarationsOfName = undefined;
            var statements = [];
            startLexicalEnvironment();
            var statementsLocation;
            var blockLocation;
            if (node.body) {
                if (node.body.kind === 260 /* ModuleBlock */) {
                    saveStateAndInvoke(node.body, function (body) { return ts.addRange(statements, ts.visitNodes(body.statements, namespaceElementVisitor, ts.isStatement)); });
                    statementsLocation = node.body.statements;
                    blockLocation = node.body;
                }
                else {
                    var result = visitModuleDeclaration(node.body);
                    if (result) {
                        if (ts.isArray(result)) {
                            ts.addRange(statements, result);
                        }
                        else {
                            statements.push(result);
                        }
                    }
                    var moduleBlock = getInnerMostModuleDeclarationFromDottedModule(node).body;
                    statementsLocation = ts.moveRangePos(moduleBlock.statements, -1);
                }
            }
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            currentNamespaceContainerName = savedCurrentNamespaceContainerName;
            currentNamespace = savedCurrentNamespace;
            currentScopeFirstDeclarationsOfName = savedCurrentScopeFirstDeclarationsOfName;
            var block = factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), 
            /*location*/ statementsLocation), 
            /*multiLine*/ true);
            ts.setTextRange(block, blockLocation);
            // namespace hello.hi.world {
            //      function foo() {}
            //
            //      // TODO, blah
            // }
            //
            // should be emitted as
            //
            // var hello;
            // (function (hello) {
            //     var hi;
            //     (function (hi) {
            //         var world;
            //         (function (world) {
            //             function foo() { }
            //             // TODO, blah
            //         })(world = hi.world || (hi.world = {}));
            //     })(hi = hello.hi || (hello.hi = {}));
            // })(hello || (hello = {}));
            // We only want to emit comment on the namespace which contains block body itself, not the containing namespaces.
            if (!node.body || node.body.kind !== 260 /* ModuleBlock */) {
                ts.setEmitFlags(block, ts.getEmitFlags(block) | 1536 /* NoComments */);
            }
            return block;
        }
        function getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration) {
            if (moduleDeclaration.body.kind === 259 /* ModuleDeclaration */) {
                var recursiveInnerModule = getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration.body);
                return recursiveInnerModule || moduleDeclaration.body;
            }
        }
        /**
         * Visits an import declaration, eliding it if it is not referenced and `importsNotUsedAsValues` is not 'preserve'.
         *
         * @param node The import declaration node.
         */
        function visitImportDeclaration(node) {
            if (!node.importClause) {
                // Do not elide a side-effect only import declaration.
                //  import "foo";
                return node;
            }
            if (node.importClause.isTypeOnly) {
                // Always elide type-only imports
                return undefined;
            }
            // Elide the declaration if the import clause was elided.
            var importClause = ts.visitNode(node.importClause, visitImportClause, ts.isImportClause);
            return importClause ||
                compilerOptions.importsNotUsedAsValues === 1 /* Preserve */ ||
                compilerOptions.importsNotUsedAsValues === 2 /* Error */
                ? factory.updateImportDeclaration(node, 
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, importClause, node.moduleSpecifier)
                : undefined;
        }
        /**
         * Visits an import clause, eliding it if it is not referenced.
         *
         * @param node The import clause node.
         */
        function visitImportClause(node) {
            if (node.isTypeOnly) {
                return undefined;
            }
            // Elide the import clause if we elide both its name and its named bindings.
            var name = resolver.isReferencedAliasDeclaration(node) ? node.name : undefined;
            var namedBindings = ts.visitNode(node.namedBindings, visitNamedImportBindings, ts.isNamedImportBindings);
            return (name || namedBindings) ? factory.updateImportClause(node, /*isTypeOnly*/ false, name, namedBindings) : undefined;
        }
        /**
         * Visits named import bindings, eliding it if it is not referenced.
         *
         * @param node The named import bindings node.
         */
        function visitNamedImportBindings(node) {
            if (node.kind === 266 /* NamespaceImport */) {
                // Elide a namespace import if it is not referenced.
                return resolver.isReferencedAliasDeclaration(node) ? node : undefined;
            }
            else {
                // Elide named imports if all of its import specifiers are elided.
                var elements = ts.visitNodes(node.elements, visitImportSpecifier, ts.isImportSpecifier);
                return ts.some(elements) ? factory.updateNamedImports(node, elements) : undefined;
            }
        }
        /**
         * Visits an import specifier, eliding it if it is not referenced.
         *
         * @param node The import specifier node.
         */
        function visitImportSpecifier(node) {
            // Elide an import specifier if it is not referenced.
            return resolver.isReferencedAliasDeclaration(node) ? node : undefined;
        }
        /**
         * Visits an export assignment, eliding it if it does not contain a clause that resolves
         * to a value.
         *
         * @param node The export assignment node.
         */
        function visitExportAssignment(node) {
            // Elide the export assignment if it does not reference a value.
            return resolver.isValueAliasDeclaration(node)
                ? ts.visitEachChild(node, visitor, context)
                : undefined;
        }
        /**
         * Visits an export declaration, eliding it if it does not contain a clause that resolves
         * to a value.
         *
         * @param node The export declaration node.
         */
        function visitExportDeclaration(node) {
            if (node.isTypeOnly) {
                return undefined;
            }
            if (!node.exportClause || ts.isNamespaceExport(node.exportClause)) {
                // never elide `export <whatever> from <whereever>` declarations -
                // they should be kept for sideffects/untyped exports, even when the
                // type checker doesn't know about any exports
                return node;
            }
            if (!resolver.isValueAliasDeclaration(node)) {
                // Elide the export declaration if it does not export a value.
                return undefined;
            }
            // Elide the export declaration if all of its named exports are elided.
            var exportClause = ts.visitNode(node.exportClause, visitNamedExportBindings, ts.isNamedExportBindings);
            return exportClause
                ? factory.updateExportDeclaration(node, 
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, node.isTypeOnly, exportClause, node.moduleSpecifier)
                : undefined;
        }
        /**
         * Visits named exports, eliding it if it does not contain an export specifier that
         * resolves to a value.
         *
         * @param node The named exports node.
         */
        function visitNamedExports(node) {
            // Elide the named exports if all of its export specifiers were elided.
            var elements = ts.visitNodes(node.elements, visitExportSpecifier, ts.isExportSpecifier);
            return ts.some(elements) ? factory.updateNamedExports(node, elements) : undefined;
        }
        function visitNamespaceExports(node) {
            return factory.updateNamespaceExport(node, ts.visitNode(node.name, visitor, ts.isIdentifier));
        }
        function visitNamedExportBindings(node) {
            return ts.isNamespaceExport(node) ? visitNamespaceExports(node) : visitNamedExports(node);
        }
        /**
         * Visits an export specifier, eliding it if it does not resolve to a value.
         *
         * @param node The export specifier node.
         */
        function visitExportSpecifier(node) {
            // Elide an export specifier if it does not reference a value.
            return resolver.isValueAliasDeclaration(node) ? node : undefined;
        }
        /**
         * Determines whether to emit an import equals declaration.
         *
         * @param node The import equals declaration node.
         */
        function shouldEmitImportEqualsDeclaration(node) {
            // preserve old compiler's behavior: emit 'var' for import declaration (even if we do not consider them referenced) when
            // - current file is not external module
            // - import declaration is top level and target is value imported by entity name
            return resolver.isReferencedAliasDeclaration(node)
                || (!ts.isExternalModule(currentSourceFile)
                    && resolver.isTopLevelValueImportEqualsWithEntityName(node));
        }
        /**
         * Visits an import equals declaration.
         *
         * @param node The import equals declaration node.
         */
        function visitImportEqualsDeclaration(node) {
            // Always elide type-only imports
            if (node.isTypeOnly) {
                return undefined;
            }
            if (ts.isExternalModuleImportEqualsDeclaration(node)) {
                var isReferenced = resolver.isReferencedAliasDeclaration(node);
                // If the alias is unreferenced but we want to keep the import, replace with 'import "mod"'.
                if (!isReferenced && compilerOptions.importsNotUsedAsValues === 1 /* Preserve */) {
                    return ts.setOriginalNode(ts.setTextRange(factory.createImportDeclaration(
                    /*decorators*/ undefined, 
                    /*modifiers*/ undefined, 
                    /*importClause*/ undefined, node.moduleReference.expression), node), node);
                }
                return isReferenced ? ts.visitEachChild(node, visitor, context) : undefined;
            }
            if (!shouldEmitImportEqualsDeclaration(node)) {
                return undefined;
            }
            var moduleReference = ts.createExpressionFromEntityName(factory, node.moduleReference);
            ts.setEmitFlags(moduleReference, 1536 /* NoComments */ | 2048 /* NoNestedComments */);
            if (isNamedExternalModuleExport(node) || !isExportOfNamespace(node)) {
                //  export var ${name} = ${moduleReference};
                //  var ${name} = ${moduleReference};
                return ts.setOriginalNode(ts.setTextRange(factory.createVariableStatement(ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), factory.createVariableDeclarationList([
                    ts.setOriginalNode(factory.createVariableDeclaration(node.name, 
                    /*exclamationToken*/ undefined, 
                    /*type*/ undefined, moduleReference), node)
                ])), node), node);
            }
            else {
                // exports.${name} = ${moduleReference};
                return ts.setOriginalNode(createNamespaceExport(node.name, moduleReference, node), node);
            }
        }
        /**
         * Gets a value indicating whether the node is exported from a namespace.
         *
         * @param node The node to test.
         */
        function isExportOfNamespace(node) {
            return currentNamespace !== undefined && ts.hasSyntacticModifier(node, 1 /* Export */);
        }
        /**
         * Gets a value indicating whether the node is exported from an external module.
         *
         * @param node The node to test.
         */
        function isExternalModuleExport(node) {
            return currentNamespace === undefined && ts.hasSyntacticModifier(node, 1 /* Export */);
        }
        /**
         * Gets a value indicating whether the node is a named export from an external module.
         *
         * @param node The node to test.
         */
        function isNamedExternalModuleExport(node) {
            return isExternalModuleExport(node)
                && !ts.hasSyntacticModifier(node, 512 /* Default */);
        }
        /**
         * Gets a value indicating whether the node is the default export of an external module.
         *
         * @param node The node to test.
         */
        function isDefaultExternalModuleExport(node) {
            return isExternalModuleExport(node)
                && ts.hasSyntacticModifier(node, 512 /* Default */);
        }
        /**
         * Creates a statement for the provided expression. This is used in calls to `map`.
         */
        function expressionToStatement(expression) {
            return factory.createExpressionStatement(expression);
        }
        function addExportMemberAssignment(statements, node) {
            var expression = factory.createAssignment(factory.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, /*allowComments*/ false, /*allowSourceMaps*/ true), factory.getLocalName(node));
            ts.setSourceMapRange(expression, ts.createRange(node.name ? node.name.pos : node.pos, node.end));
            var statement = factory.createExpressionStatement(expression);
            ts.setSourceMapRange(statement, ts.createRange(-1, node.end));
            statements.push(statement);
        }
        function createNamespaceExport(exportName, exportValue, location) {
            return ts.setTextRange(factory.createExpressionStatement(factory.createAssignment(factory.getNamespaceMemberName(currentNamespaceContainerName, exportName, /*allowComments*/ false, /*allowSourceMaps*/ true), exportValue)), location);
        }
        function createNamespaceExportExpression(exportName, exportValue, location) {
            return ts.setTextRange(factory.createAssignment(getNamespaceMemberNameWithSourceMapsAndWithoutComments(exportName), exportValue), location);
        }
        function getNamespaceMemberNameWithSourceMapsAndWithoutComments(name) {
            return factory.getNamespaceMemberName(currentNamespaceContainerName, name, /*allowComments*/ false, /*allowSourceMaps*/ true);
        }
        /**
         * Gets the declaration name used inside of a namespace or enum.
         */
        function getNamespaceParameterName(node) {
            var name = factory.getGeneratedNameForNode(node);
            ts.setSourceMapRange(name, node.name);
            return name;
        }
        /**
         * Gets the expression used to refer to a namespace or enum within the body
         * of its declaration.
         */
        function getNamespaceContainerName(node) {
            return factory.getGeneratedNameForNode(node);
        }
        /**
         * Gets a local alias for a class declaration if it is a decorated class with an internal
         * reference to the static side of the class. This is necessary to avoid issues with
         * double-binding semantics for the class name.
         */
        function getClassAliasIfNeeded(node) {
            if (resolver.getNodeCheckFlags(node) & 16777216 /* ClassWithConstructorReference */) {
                enableSubstitutionForClassAliases();
                var classAlias = factory.createUniqueName(node.name && !ts.isGeneratedIdentifier(node.name) ? ts.idText(node.name) : "default");
                classAliases[ts.getOriginalNodeId(node)] = classAlias;
                hoistVariableDeclaration(classAlias);
                return classAlias;
            }
        }
        function getClassPrototype(node) {
            return factory.createPropertyAccessExpression(factory.getDeclarationName(node), "prototype");
        }
        function getClassMemberPrefix(node, member) {
            return ts.isStatic(member)
                ? factory.getDeclarationName(node)
                : getClassPrototype(node);
        }
        function enableSubstitutionForNonQualifiedEnumMembers() {
            if ((enabledSubstitutions & 8 /* NonQualifiedEnumMembers */) === 0) {
                enabledSubstitutions |= 8 /* NonQualifiedEnumMembers */;
                context.enableSubstitution(79 /* Identifier */);
            }
        }
        function enableSubstitutionForClassAliases() {
            if ((enabledSubstitutions & 1 /* ClassAliases */) === 0) {
                enabledSubstitutions |= 1 /* ClassAliases */;
                // We need to enable substitutions for identifiers. This allows us to
                // substitute class names inside of a class declaration.
                context.enableSubstitution(79 /* Identifier */);
                // Keep track of class aliases.
                classAliases = [];
            }
        }
        function enableSubstitutionForNamespaceExports() {
            if ((enabledSubstitutions & 2 /* NamespaceExports */) === 0) {
                enabledSubstitutions |= 2 /* NamespaceExports */;
                // We need to enable substitutions for identifiers and shorthand property assignments. This allows us to
                // substitute the names of exported members of a namespace.
                context.enableSubstitution(79 /* Identifier */);
                context.enableSubstitution(292 /* ShorthandPropertyAssignment */);
                // We need to be notified when entering and exiting namespaces.
                context.enableEmitNotification(259 /* ModuleDeclaration */);
            }
        }
        function isTransformedModuleDeclaration(node) {
            return ts.getOriginalNode(node).kind === 259 /* ModuleDeclaration */;
        }
        function isTransformedEnumDeclaration(node) {
            return ts.getOriginalNode(node).kind === 258 /* EnumDeclaration */;
        }
        /**
         * Hook for node emit.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to emit.
         * @param emit A callback used to emit the node in the printer.
         */
        function onEmitNode(hint, node, emitCallback) {
            var savedApplicableSubstitutions = applicableSubstitutions;
            var savedCurrentSourceFile = currentSourceFile;
            if (ts.isSourceFile(node)) {
                currentSourceFile = node;
            }
            if (enabledSubstitutions & 2 /* NamespaceExports */ && isTransformedModuleDeclaration(node)) {
                applicableSubstitutions |= 2 /* NamespaceExports */;
            }
            if (enabledSubstitutions & 8 /* NonQualifiedEnumMembers */ && isTransformedEnumDeclaration(node)) {
                applicableSubstitutions |= 8 /* NonQualifiedEnumMembers */;
            }
            previousOnEmitNode(hint, node, emitCallback);
            applicableSubstitutions = savedApplicableSubstitutions;
            currentSourceFile = savedCurrentSourceFile;
        }
        /**
         * Hooks node substitutions.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to substitute.
         */
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 /* Expression */) {
                return substituteExpression(node);
            }
            else if (ts.isShorthandPropertyAssignment(node)) {
                return substituteShorthandPropertyAssignment(node);
            }
            return node;
        }
        function substituteShorthandPropertyAssignment(node) {
            if (enabledSubstitutions & 2 /* NamespaceExports */) {
                var name = node.name;
                var exportedName = trySubstituteNamespaceExportedName(name);
                if (exportedName) {
                    // A shorthand property with an assignment initializer is probably part of a
                    // destructuring assignment
                    if (node.objectAssignmentInitializer) {
                        var initializer = factory.createAssignment(exportedName, node.objectAssignmentInitializer);
                        return ts.setTextRange(factory.createPropertyAssignment(name, initializer), node);
                    }
                    return ts.setTextRange(factory.createPropertyAssignment(name, exportedName), node);
                }
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79 /* Identifier */:
                    return substituteExpressionIdentifier(node);
                case 204 /* PropertyAccessExpression */:
                    return substitutePropertyAccessExpression(node);
                case 205 /* ElementAccessExpression */:
                    return substituteElementAccessExpression(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            return trySubstituteClassAlias(node)
                || trySubstituteNamespaceExportedName(node)
                || node;
        }
        function trySubstituteClassAlias(node) {
            if (enabledSubstitutions & 1 /* ClassAliases */) {
                if (resolver.getNodeCheckFlags(node) & 33554432 /* ConstructorReferenceInClass */) {
                    // Due to the emit for class decorators, any reference to the class from inside of the class body
                    // must instead be rewritten to point to a temporary variable to avoid issues with the double-bind
                    // behavior of class names in ES6.
                    // Also, when emitting statics for class expressions, we must substitute a class alias for
                    // constructor references in static property initializers.
                    var declaration = resolver.getReferencedValueDeclaration(node);
                    if (declaration) {
                        var classAlias = classAliases[declaration.id]; // TODO: GH#18217
                        if (classAlias) {
                            var clone_2 = factory.cloneNode(classAlias);
                            ts.setSourceMapRange(clone_2, node);
                            ts.setCommentRange(clone_2, node);
                            return clone_2;
                        }
                    }
                }
            }
            return undefined;
        }
        function trySubstituteNamespaceExportedName(node) {
            // If this is explicitly a local name, do not substitute.
            if (enabledSubstitutions & applicableSubstitutions && !ts.isGeneratedIdentifier(node) && !ts.isLocalName(node)) {
                // If we are nested within a namespace declaration, we may need to qualifiy
                // an identifier that is exported from a merged namespace.
                var container = resolver.getReferencedExportContainer(node, /*prefixLocals*/ false);
                if (container && container.kind !== 300 /* SourceFile */) {
                    var substitute = (applicableSubstitutions & 2 /* NamespaceExports */ && container.kind === 259 /* ModuleDeclaration */) ||
                        (applicableSubstitutions & 8 /* NonQualifiedEnumMembers */ && container.kind === 258 /* EnumDeclaration */);
                    if (substitute) {
                        return ts.setTextRange(factory.createPropertyAccessExpression(factory.getGeneratedNameForNode(container), node), 
                        /*location*/ node);
                    }
                }
            }
            return undefined;
        }
        function substitutePropertyAccessExpression(node) {
            return substituteConstantValue(node);
        }
        function substituteElementAccessExpression(node) {
            return substituteConstantValue(node);
        }
        function substituteConstantValue(node) {
            var constantValue = tryGetConstEnumValue(node);
            if (constantValue !== undefined) {
                // track the constant value on the node for the printer in needsDotDotForPropertyAccess
                ts.setConstantValue(node, constantValue);
                var substitute = typeof constantValue === "string" ? factory.createStringLiteral(constantValue) : factory.createNumericLiteral(constantValue);
                if (!compilerOptions.removeComments) {
                    var originalNode = ts.getOriginalNode(node, ts.isAccessExpression);
                    var propertyName = ts.isPropertyAccessExpression(originalNode)
                        ? ts.declarationNameToString(originalNode.name)
                        : ts.getTextOfNode(originalNode.argumentExpression);
                    ts.addSyntheticTrailingComment(substitute, 3 /* MultiLineCommentTrivia */, " " + propertyName + " ");
                }
                return substitute;
            }
            return node;
        }
        function tryGetConstEnumValue(node) {
            if (compilerOptions.isolatedModules) {
                return undefined;
            }
            return ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node) ? resolver.getConstantValue(node) : undefined;
        }
    }
    ts.transformTypeScript = transformTypeScript;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ClassPropertySubstitutionFlags;
    (function (ClassPropertySubstitutionFlags) {
        /**
         * Enables substitutions for class expressions with static fields
         * which have initializers that reference the class name.
         */
        ClassPropertySubstitutionFlags[ClassPropertySubstitutionFlags["ClassAliases"] = 1] = "ClassAliases";
        /**
         * Enables substitutions for class expressions with static fields
         * which have initializers that reference the 'this' or 'super'.
         */
        ClassPropertySubstitutionFlags[ClassPropertySubstitutionFlags["ClassStaticThisOrSuperReference"] = 2] = "ClassStaticThisOrSuperReference";
    })(ClassPropertySubstitutionFlags || (ClassPropertySubstitutionFlags = {}));
    var PrivateIdentifierKind;
    (function (PrivateIdentifierKind) {
        PrivateIdentifierKind["Field"] = "f";
        PrivateIdentifierKind["Method"] = "m";
        PrivateIdentifierKind["Accessor"] = "a";
    })(PrivateIdentifierKind = ts.PrivateIdentifierKind || (ts.PrivateIdentifierKind = {}));
    var ClassFacts;
    (function (ClassFacts) {
        ClassFacts[ClassFacts["None"] = 0] = "None";
        ClassFacts[ClassFacts["ClassWasDecorated"] = 1] = "ClassWasDecorated";
        ClassFacts[ClassFacts["NeedsClassConstructorReference"] = 2] = "NeedsClassConstructorReference";
        ClassFacts[ClassFacts["NeedsClassSuperReference"] = 4] = "NeedsClassSuperReference";
        ClassFacts[ClassFacts["NeedsSubstitutionForThisInClassStaticField"] = 8] = "NeedsSubstitutionForThisInClassStaticField";
    })(ClassFacts || (ClassFacts = {}));
    /**
     * Transforms ECMAScript Class Syntax.
     * TypeScript parameter property syntax is transformed in the TypeScript transformer.
     * For now, this transforms public field declarations using TypeScript class semantics,
     * where declarations are elided and initializers are transformed as assignments in the constructor.
     * When --useDefineForClassFields is on, this transforms to ECMAScript semantics, with Object.defineProperty.
     */
    function transformClassFields(context) {
        var factory = context.factory, hoistVariableDeclaration = context.hoistVariableDeclaration, endLexicalEnvironment = context.endLexicalEnvironment, startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment, addBlockScopedVariable = context.addBlockScopedVariable;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var useDefineForClassFields = ts.getUseDefineForClassFields(compilerOptions);
        var shouldTransformPrivateElementsOrClassStaticBlocks = languageVersion < 99 /* ESNext */;
        // We don't need to transform `super` property access when targeting ES5, ES3 because
        // the es2015 transformation handles those.
        var shouldTransformSuperInStaticInitializers = (languageVersion <= 8 /* ES2021 */ || !useDefineForClassFields) && languageVersion >= 2 /* ES2015 */;
        var shouldTransformThisInStaticInitializers = languageVersion <= 8 /* ES2021 */ || !useDefineForClassFields;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        var enabledSubstitutions;
        var classAliases;
        /**
         * Tracks what computed name expressions originating from elided names must be inlined
         * at the next execution site, in document order
         */
        var pendingExpressions;
        /**
         * Tracks what computed name expression statements and static property initializers must be
         * emitted at the next execution site, in document order (for decorated classes).
         */
        var pendingStatements;
        var classLexicalEnvironmentStack = [];
        var classLexicalEnvironmentMap = new ts.Map();
        var currentClassLexicalEnvironment;
        var currentComputedPropertyNameClassLexicalEnvironment;
        var currentStaticPropertyDeclarationOrStaticBlock;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            var options = context.getCompilerOptions();
            if (node.isDeclarationFile
                || useDefineForClassFields && options.target === 99 /* ESNext */) {
                return node;
            }
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function visitorWorker(node, valueIsDiscarded) {
            if (node.transformFlags & 8388608 /* ContainsClassFields */) {
                switch (node.kind) {
                    case 224 /* ClassExpression */:
                    case 255 /* ClassDeclaration */:
                        return visitClassLike(node);
                    case 165 /* PropertyDeclaration */:
                        return visitPropertyDeclaration(node);
                    case 235 /* VariableStatement */:
                        return visitVariableStatement(node);
                    case 80 /* PrivateIdentifier */:
                        return visitPrivateIdentifier(node);
                    case 168 /* ClassStaticBlockDeclaration */:
                        return visitClassStaticBlockDeclaration(node);
                }
            }
            if (node.transformFlags & 8388608 /* ContainsClassFields */ ||
                node.transformFlags & 33554432 /* ContainsLexicalSuper */ &&
                    shouldTransformSuperInStaticInitializers &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                switch (node.kind) {
                    case 217 /* PrefixUnaryExpression */:
                    case 218 /* PostfixUnaryExpression */:
                        return visitPreOrPostfixUnaryExpression(node, valueIsDiscarded);
                    case 219 /* BinaryExpression */:
                        return visitBinaryExpression(node, valueIsDiscarded);
                    case 206 /* CallExpression */:
                        return visitCallExpression(node);
                    case 208 /* TaggedTemplateExpression */:
                        return visitTaggedTemplateExpression(node);
                    case 204 /* PropertyAccessExpression */:
                        return visitPropertyAccessExpression(node);
                    case 205 /* ElementAccessExpression */:
                        return visitElementAccessExpression(node);
                    case 236 /* ExpressionStatement */:
                        return visitExpressionStatement(node);
                    case 240 /* ForStatement */:
                        return visitForStatement(node);
                    case 254 /* FunctionDeclaration */:
                    case 211 /* FunctionExpression */:
                    case 169 /* Constructor */:
                    case 167 /* MethodDeclaration */:
                    case 170 /* GetAccessor */:
                    case 171 /* SetAccessor */: {
                        var savedCurrentStaticPropertyDeclarationOrStaticBlock = currentStaticPropertyDeclarationOrStaticBlock;
                        currentStaticPropertyDeclarationOrStaticBlock = undefined;
                        var result = ts.visitEachChild(node, visitor, context);
                        currentStaticPropertyDeclarationOrStaticBlock = savedCurrentStaticPropertyDeclarationOrStaticBlock;
                        return result;
                    }
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function discardedValueVisitor(node) {
            return visitorWorker(node, /*valueIsDiscarded*/ true);
        }
        function visitor(node) {
            return visitorWorker(node, /*valueIsDiscarded*/ false);
        }
        function heritageClauseVisitor(node) {
            switch (node.kind) {
                case 289 /* HeritageClause */:
                    return ts.visitEachChild(node, heritageClauseVisitor, context);
                case 226 /* ExpressionWithTypeArguments */:
                    return visitExpressionWithTypeArguments(node);
            }
            return visitor(node);
        }
        function visitorDestructuringTarget(node) {
            switch (node.kind) {
                case 203 /* ObjectLiteralExpression */:
                case 202 /* ArrayLiteralExpression */:
                    return visitAssignmentPattern(node);
                default:
                    return visitor(node);
            }
        }
        /**
         * If we visit a private name, this means it is an undeclared private name.
         * Replace it with an empty identifier to indicate a problem with the code.
         */
        function visitPrivateIdentifier(node) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                return node;
            }
            return ts.setOriginalNode(factory.createIdentifier(""), node);
        }
        /**
         * Visits the members of a class that has fields.
         *
         * @param node The node to visit.
         */
        function classElementVisitor(node) {
            switch (node.kind) {
                case 169 /* Constructor */:
                    // Constructors for classes using class fields are transformed in
                    // `visitClassDeclaration` or `visitClassExpression`.
                    return undefined;
                case 170 /* GetAccessor */:
                case 171 /* SetAccessor */:
                case 167 /* MethodDeclaration */:
                    return visitMethodOrAccessorDeclaration(node);
                case 165 /* PropertyDeclaration */:
                    return visitPropertyDeclaration(node);
                case 160 /* ComputedPropertyName */:
                    return visitComputedPropertyName(node);
                case 232 /* SemicolonClassElement */:
                    return node;
                default:
                    return visitor(node);
            }
        }
        function visitVariableStatement(node) {
            var savedPendingStatements = pendingStatements;
            pendingStatements = [];
            var visitedNode = ts.visitEachChild(node, visitor, context);
            var statement = ts.some(pendingStatements) ? __spreadArray([visitedNode], pendingStatements, true) :
                visitedNode;
            pendingStatements = savedPendingStatements;
            return statement;
        }
        function visitComputedPropertyName(name) {
            var node = ts.visitEachChild(name, visitor, context);
            if (ts.some(pendingExpressions)) {
                var expressions = pendingExpressions;
                expressions.push(node.expression);
                pendingExpressions = [];
                node = factory.updateComputedPropertyName(node, factory.inlineExpressions(expressions));
            }
            return node;
        }
        function visitMethodOrAccessorDeclaration(node) {
            ts.Debug.assert(!ts.some(node.decorators));
            if (!shouldTransformPrivateElementsOrClassStaticBlocks || !ts.isPrivateIdentifier(node.name)) {
                return ts.visitEachChild(node, classElementVisitor, context);
            }
            // leave invalid code untransformed
            var info = accessPrivateIdentifier(node.name);
            ts.Debug.assert(info, "Undeclared private name for property declaration.");
            if (!info.isValid) {
                return node;
            }
            var functionName = getHoistedFunctionName(node);
            if (functionName) {
                getPendingExpressions().push(factory.createAssignment(functionName, factory.createFunctionExpression(ts.filter(node.modifiers, function (m) { return !ts.isStaticModifier(m); }), node.asteriskToken, functionName, 
                /* typeParameters */ undefined, ts.visitParameterList(node.parameters, classElementVisitor, context), 
                /* type */ undefined, ts.visitFunctionBody(node.body, classElementVisitor, context))));
            }
            // remove method declaration from class
            return undefined;
        }
        function getHoistedFunctionName(node) {
            ts.Debug.assert(ts.isPrivateIdentifier(node.name));
            var info = accessPrivateIdentifier(node.name);
            ts.Debug.assert(info, "Undeclared private name for property declaration.");
            if (info.kind === "m" /* Method */) {
                return info.methodName;
            }
            if (info.kind === "a" /* Accessor */) {
                if (ts.isGetAccessor(node)) {
                    return info.getterName;
                }
                if (ts.isSetAccessor(node)) {
                    return info.setterName;
                }
            }
        }
        function visitPropertyDeclaration(node) {
            ts.Debug.assert(!ts.some(node.decorators));
            if (ts.isPrivateIdentifier(node.name)) {
                if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                    // Initializer is elided as the field is initialized in transformConstructor.
                    return factory.updatePropertyDeclaration(node, 
                    /*decorators*/ undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.name, 
                    /*questionOrExclamationToken*/ undefined, 
                    /*type*/ undefined, 
                    /*initializer*/ undefined);
                }
                // leave invalid code untransformed
                var info = accessPrivateIdentifier(node.name);
                ts.Debug.assert(info, "Undeclared private name for property declaration.");
                if (!info.isValid) {
                    return node;
                }
            }
            // Create a temporary variable to store a computed property name (if necessary).
            // If it's not inlineable, then we emit an expression after the class which assigns
            // the property name to the temporary variable.
            var expr = getPropertyNameExpressionIfNeeded(node.name, !!node.initializer || useDefineForClassFields);
            if (expr && !ts.isSimpleInlineableExpression(expr)) {
                getPendingExpressions().push(expr);
            }
            return undefined;
        }
        function createPrivateIdentifierAccess(info, receiver) {
            return createPrivateIdentifierAccessHelper(info, ts.visitNode(receiver, visitor, ts.isExpression));
        }
        function createPrivateIdentifierAccessHelper(info, receiver) {
            ts.setCommentRange(receiver, ts.moveRangePos(receiver, -1));
            switch (info.kind) {
                case "a" /* Accessor */:
                    return context.getEmitHelperFactory().createClassPrivateFieldGetHelper(receiver, info.brandCheckIdentifier, info.kind, info.getterName);
                case "m" /* Method */:
                    return context.getEmitHelperFactory().createClassPrivateFieldGetHelper(receiver, info.brandCheckIdentifier, info.kind, info.methodName);
                case "f" /* Field */:
                    return context.getEmitHelperFactory().createClassPrivateFieldGetHelper(receiver, info.brandCheckIdentifier, info.kind, info.variableName);
                default:
                    ts.Debug.assertNever(info, "Unknown private element type");
            }
        }
        function visitPropertyAccessExpression(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifier(node.name)) {
                var privateIdentifierInfo = accessPrivateIdentifier(node.name);
                if (privateIdentifierInfo) {
                    return ts.setTextRange(ts.setOriginalNode(createPrivateIdentifierAccess(privateIdentifierInfo, node.expression), node), node);
                }
            }
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node) &&
                ts.isIdentifier(node.name) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                currentClassLexicalEnvironment) {
                var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                if (facts & 1 /* ClassWasDecorated */) {
                    return visitInvalidSuperProperty(node);
                }
                if (classConstructor && superClassReference) {
                    // converts `super.x` into `Reflect.get(_baseTemp, "x", _classTemp)`
                    var superProperty = factory.createReflectGetCall(superClassReference, factory.createStringLiteralFromNode(node.name), classConstructor);
                    ts.setOriginalNode(superProperty, node.expression);
                    ts.setTextRange(superProperty, node.expression);
                    return superProperty;
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitElementAccessExpression(node) {
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                currentClassLexicalEnvironment) {
                var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                if (facts & 1 /* ClassWasDecorated */) {
                    return visitInvalidSuperProperty(node);
                }
                if (classConstructor && superClassReference) {
                    // converts `super[x]` into `Reflect.get(_baseTemp, x, _classTemp)`
                    var superProperty = factory.createReflectGetCall(superClassReference, ts.visitNode(node.argumentExpression, visitor, ts.isExpression), classConstructor);
                    ts.setOriginalNode(superProperty, node.expression);
                    ts.setTextRange(superProperty, node.expression);
                    return superProperty;
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitPreOrPostfixUnaryExpression(node, valueIsDiscarded) {
            if (node.operator === 45 /* PlusPlusToken */ || node.operator === 46 /* MinusMinusToken */) {
                if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierPropertyAccessExpression(node.operand)) {
                    var info = void 0;
                    if (info = accessPrivateIdentifier(node.operand.name)) {
                        var receiver = ts.visitNode(node.operand.expression, visitor, ts.isExpression);
                        var _a = createCopiableReceiverExpr(receiver), readExpression = _a.readExpression, initializeExpression = _a.initializeExpression;
                        var expression = createPrivateIdentifierAccess(info, readExpression);
                        var temp = ts.isPrefixUnaryExpression(node) || valueIsDiscarded ? undefined : factory.createTempVariable(hoistVariableDeclaration);
                        expression = ts.expandPreOrPostfixIncrementOrDecrementExpression(factory, node, expression, hoistVariableDeclaration, temp);
                        expression = createPrivateIdentifierAssignment(info, initializeExpression || readExpression, expression, 63 /* EqualsToken */);
                        ts.setOriginalNode(expression, node);
                        ts.setTextRange(expression, node);
                        if (temp) {
                            expression = factory.createComma(expression, temp);
                            ts.setTextRange(expression, node);
                        }
                        return expression;
                    }
                }
                else if (shouldTransformSuperInStaticInitializers &&
                    ts.isSuperProperty(node.operand) &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                    // converts `++super.a` into `(Reflect.set(_baseTemp, "a", (_a = Reflect.get(_baseTemp, "a", _classTemp), _b = ++_a), _classTemp), _b)`
                    // converts `++super[f()]` into `(Reflect.set(_baseTemp, _a = f(), (_b = Reflect.get(_baseTemp, _a, _classTemp), _c = ++_b), _classTemp), _c)`
                    // converts `--super.a` into `(Reflect.set(_baseTemp, "a", (_a = Reflect.get(_baseTemp, "a", _classTemp), _b = --_a), _classTemp), _b)`
                    // converts `--super[f()]` into `(Reflect.set(_baseTemp, _a = f(), (_b = Reflect.get(_baseTemp, _a, _classTemp), _c = --_b), _classTemp), _c)`
                    // converts `super.a++` into `(Reflect.set(_baseTemp, "a", (_a = Reflect.get(_baseTemp, "a", _classTemp), _b = _a++), _classTemp), _b)`
                    // converts `super[f()]++` into `(Reflect.set(_baseTemp, _a = f(), (_b = Reflect.get(_baseTemp, _a, _classTemp), _c = _b++), _classTemp), _c)`
                    // converts `super.a--` into `(Reflect.set(_baseTemp, "a", (_a = Reflect.get(_baseTemp, "a", _classTemp), _b = _a--), _classTemp), _b)`
                    // converts `super[f()]--` into `(Reflect.set(_baseTemp, _a = f(), (_b = Reflect.get(_baseTemp, _a, _classTemp), _c = _b--), _classTemp), _c)`
                    var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                    if (facts & 1 /* ClassWasDecorated */) {
                        var operand = visitInvalidSuperProperty(node.operand);
                        return ts.isPrefixUnaryExpression(node) ?
                            factory.updatePrefixUnaryExpression(node, operand) :
                            factory.updatePostfixUnaryExpression(node, operand);
                    }
                    if (classConstructor && superClassReference) {
                        var setterName = void 0;
                        var getterName = void 0;
                        if (ts.isPropertyAccessExpression(node.operand)) {
                            if (ts.isIdentifier(node.operand.name)) {
                                getterName = setterName = factory.createStringLiteralFromNode(node.operand.name);
                            }
                        }
                        else {
                            if (ts.isSimpleInlineableExpression(node.operand.argumentExpression)) {
                                getterName = setterName = node.operand.argumentExpression;
                            }
                            else {
                                getterName = factory.createTempVariable(hoistVariableDeclaration);
                                setterName = factory.createAssignment(getterName, ts.visitNode(node.operand.argumentExpression, visitor, ts.isExpression));
                            }
                        }
                        if (setterName && getterName) {
                            var expression = factory.createReflectGetCall(superClassReference, getterName, classConstructor);
                            ts.setTextRange(expression, node.operand);
                            var temp = valueIsDiscarded ? undefined : factory.createTempVariable(hoistVariableDeclaration);
                            expression = ts.expandPreOrPostfixIncrementOrDecrementExpression(factory, node, expression, hoistVariableDeclaration, temp);
                            expression = factory.createReflectSetCall(superClassReference, setterName, expression, classConstructor);
                            ts.setOriginalNode(expression, node);
                            ts.setTextRange(expression, node);
                            if (temp) {
                                expression = factory.createComma(expression, temp);
                                ts.setTextRange(expression, node);
                            }
                            return expression;
                        }
                    }
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForStatement(node) {
            return factory.updateForStatement(node, ts.visitNode(node.initializer, discardedValueVisitor, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, discardedValueVisitor, ts.isExpression), ts.visitIterationBody(node.statement, visitor, context));
        }
        function visitExpressionStatement(node) {
            return factory.updateExpressionStatement(node, ts.visitNode(node.expression, discardedValueVisitor, ts.isExpression));
        }
        function createCopiableReceiverExpr(receiver) {
            var clone = ts.nodeIsSynthesized(receiver) ? receiver : factory.cloneNode(receiver);
            if (ts.isSimpleInlineableExpression(receiver)) {
                return { readExpression: clone, initializeExpression: undefined };
            }
            var readExpression = factory.createTempVariable(hoistVariableDeclaration);
            var initializeExpression = factory.createAssignment(readExpression, clone);
            return { readExpression: readExpression, initializeExpression: initializeExpression };
        }
        function visitCallExpression(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierPropertyAccessExpression(node.expression)) {
                // Transform call expressions of private names to properly bind the `this` parameter.
                var _a = factory.createCallBinding(node.expression, hoistVariableDeclaration, languageVersion), thisArg = _a.thisArg, target = _a.target;
                if (ts.isCallChain(node)) {
                    return factory.updateCallChain(node, factory.createPropertyAccessChain(ts.visitNode(target, visitor), node.questionDotToken, "call"), 
                    /*questionDotToken*/ undefined, 
                    /*typeArguments*/ undefined, __spreadArray([ts.visitNode(thisArg, visitor, ts.isExpression)], ts.visitNodes(node.arguments, visitor, ts.isExpression), true));
                }
                return factory.updateCallExpression(node, factory.createPropertyAccessExpression(ts.visitNode(target, visitor), "call"), 
                /*typeArguments*/ undefined, __spreadArray([ts.visitNode(thisArg, visitor, ts.isExpression)], ts.visitNodes(node.arguments, visitor, ts.isExpression), true));
            }
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node.expression) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.classConstructor)) {
                // converts `super.f(...)` into `Reflect.get(_baseTemp, "f", _classTemp).call(_classTemp, ...)`
                var invocation = factory.createFunctionCallCall(ts.visitNode(node.expression, visitor, ts.isExpression), currentClassLexicalEnvironment.classConstructor, ts.visitNodes(node.arguments, visitor, ts.isExpression));
                ts.setOriginalNode(invocation, node);
                ts.setTextRange(invocation, node);
                return invocation;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitTaggedTemplateExpression(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierPropertyAccessExpression(node.tag)) {
                // Bind the `this` correctly for tagged template literals when the tag is a private identifier property access.
                var _a = factory.createCallBinding(node.tag, hoistVariableDeclaration, languageVersion), thisArg = _a.thisArg, target = _a.target;
                return factory.updateTaggedTemplateExpression(node, factory.createCallExpression(factory.createPropertyAccessExpression(ts.visitNode(target, visitor), "bind"), 
                /*typeArguments*/ undefined, [ts.visitNode(thisArg, visitor, ts.isExpression)]), 
                /*typeArguments*/ undefined, ts.visitNode(node.template, visitor, ts.isTemplateLiteral));
            }
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node.tag) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.classConstructor)) {
                // converts `` super.f`x` `` into `` Reflect.get(_baseTemp, "f", _classTemp).bind(_classTemp)`x` ``
                var invocation = factory.createFunctionBindCall(ts.visitNode(node.tag, visitor, ts.isExpression), currentClassLexicalEnvironment.classConstructor, []);
                ts.setOriginalNode(invocation, node);
                ts.setTextRange(invocation, node);
                return factory.updateTaggedTemplateExpression(node, invocation, 
                /*typeArguments*/ undefined, ts.visitNode(node.template, visitor, ts.isTemplateLiteral));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformClassStaticBlockDeclaration(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                if (currentClassLexicalEnvironment) {
                    classLexicalEnvironmentMap.set(ts.getOriginalNodeId(node), currentClassLexicalEnvironment);
                }
                startLexicalEnvironment();
                var savedCurrentStaticPropertyDeclarationOrStaticBlock = currentStaticPropertyDeclarationOrStaticBlock;
                currentStaticPropertyDeclarationOrStaticBlock = node;
                var statements = ts.visitNodes(node.body.statements, visitor, ts.isStatement);
                statements = factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
                currentStaticPropertyDeclarationOrStaticBlock = savedCurrentStaticPropertyDeclarationOrStaticBlock;
                var iife = factory.createImmediatelyInvokedArrowFunction(statements);
                ts.setOriginalNode(iife, node);
                ts.setTextRange(iife, node);
                ts.addEmitFlags(iife, 2 /* AdviseOnEmitNode */);
                return iife;
            }
        }
        function visitBinaryExpression(node, valueIsDiscarded) {
            if (ts.isDestructuringAssignment(node)) {
                var savedPendingExpressions = pendingExpressions;
                pendingExpressions = undefined;
                node = factory.updateBinaryExpression(node, ts.visitNode(node.left, visitorDestructuringTarget), node.operatorToken, ts.visitNode(node.right, visitor));
                var expr = ts.some(pendingExpressions) ?
                    factory.inlineExpressions(ts.compact(__spreadArray(__spreadArray([], pendingExpressions, true), [node], false))) :
                    node;
                pendingExpressions = savedPendingExpressions;
                return expr;
            }
            if (ts.isAssignmentExpression(node)) {
                if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierPropertyAccessExpression(node.left)) {
                    var info = accessPrivateIdentifier(node.left.name);
                    if (info) {
                        return ts.setTextRange(ts.setOriginalNode(createPrivateIdentifierAssignment(info, node.left.expression, node.right, node.operatorToken.kind), node), node);
                    }
                }
                else if (shouldTransformSuperInStaticInitializers &&
                    ts.isSuperProperty(node.left) &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                    var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                    if (facts & 1 /* ClassWasDecorated */) {
                        return factory.updateBinaryExpression(node, visitInvalidSuperProperty(node.left), node.operatorToken, ts.visitNode(node.right, visitor, ts.isExpression));
                    }
                    if (classConstructor && superClassReference) {
                        var setterName = ts.isElementAccessExpression(node.left) ? ts.visitNode(node.left.argumentExpression, visitor, ts.isExpression) :
                            ts.isIdentifier(node.left.name) ? factory.createStringLiteralFromNode(node.left.name) :
                                undefined;
                        if (setterName) {
                            // converts `super.x = 1` into `(Reflect.set(_baseTemp, "x", _a = 1, _classTemp), _a)`
                            // converts `super[f()] = 1` into `(Reflect.set(_baseTemp, f(), _a = 1, _classTemp), _a)`
                            // converts `super.x += 1` into `(Reflect.set(_baseTemp, "x", _a = Reflect.get(_baseTemp, "x", _classtemp) + 1, _classTemp), _a)`
                            // converts `super[f()] += 1` into `(Reflect.set(_baseTemp, _a = f(), _b = Reflect.get(_baseTemp, _a, _classtemp) + 1, _classTemp), _b)`
                            var expression = ts.visitNode(node.right, visitor, ts.isExpression);
                            if (ts.isCompoundAssignment(node.operatorToken.kind)) {
                                var getterName = setterName;
                                if (!ts.isSimpleInlineableExpression(setterName)) {
                                    getterName = factory.createTempVariable(hoistVariableDeclaration);
                                    setterName = factory.createAssignment(getterName, setterName);
                                }
                                var superPropertyGet = factory.createReflectGetCall(superClassReference, getterName, classConstructor);
                                ts.setOriginalNode(superPropertyGet, node.left);
                                ts.setTextRange(superPropertyGet, node.left);
                                expression = factory.createBinaryExpression(superPropertyGet, ts.getNonAssignmentOperatorForCompoundAssignment(node.operatorToken.kind), expression);
                                ts.setTextRange(expression, node);
                            }
                            var temp = valueIsDiscarded ? undefined : factory.createTempVariable(hoistVariableDeclaration);
                            if (temp) {
                                expression = factory.createAssignment(temp, expression);
                                ts.setTextRange(temp, node);
                            }
                            expression = factory.createReflectSetCall(superClassReference, setterName, expression, classConstructor);
                            ts.setOriginalNode(expression, node);
                            ts.setTextRange(expression, node);
                            if (temp) {
                                expression = factory.createComma(expression, temp);
                                ts.setTextRange(expression, node);
                            }
                            return expression;
                        }
                    }
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function createPrivateIdentifierAssignment(info, receiver, right, operator) {
            receiver = ts.visitNode(receiver, visitor, ts.isExpression);
            right = ts.visitNode(right, visitor, ts.isExpression);
            if (ts.isCompoundAssignment(operator)) {
                var _a = createCopiableReceiverExpr(receiver), readExpression = _a.readExpression, initializeExpression = _a.initializeExpression;
                receiver = initializeExpression || readExpression;
                right = factory.createBinaryExpression(createPrivateIdentifierAccessHelper(info, readExpression), ts.getNonAssignmentOperatorForCompoundAssignment(operator), right);
            }
            ts.setCommentRange(receiver, ts.moveRangePos(receiver, -1));
            switch (info.kind) {
                case "a" /* Accessor */:
                    return context.getEmitHelperFactory().createClassPrivateFieldSetHelper(receiver, info.brandCheckIdentifier, right, info.kind, info.setterName);
                case "m" /* Method */:
                    return context.getEmitHelperFactory().createClassPrivateFieldSetHelper(receiver, info.brandCheckIdentifier, right, info.kind, 
                    /* f */ undefined);
                case "f" /* Field */:
                    return context.getEmitHelperFactory().createClassPrivateFieldSetHelper(receiver, info.brandCheckIdentifier, right, info.kind, info.variableName);
                default:
                    ts.Debug.assertNever(info, "Unknown private element type");
            }
        }
        /**
         * Set up the environment for a class.
         */
        function visitClassLike(node) {
            if (!ts.forEach(node.members, doesClassElementNeedTransform)) {
                return ts.visitEachChild(node, visitor, context);
            }
            var savedPendingExpressions = pendingExpressions;
            pendingExpressions = undefined;
            startClassLexicalEnvironment();
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                var name = ts.getNameOfDeclaration(node);
                if (name && ts.isIdentifier(name)) {
                    getPrivateIdentifierEnvironment().className = ts.idText(name);
                }
                var privateInstanceMethodsAndAccessors = getPrivateInstanceMethodsAndAccessors(node);
                if (ts.some(privateInstanceMethodsAndAccessors)) {
                    getPrivateIdentifierEnvironment().weakSetName = createHoistedVariableForClass("instances", privateInstanceMethodsAndAccessors[0].name);
                }
            }
            var result = ts.isClassDeclaration(node) ?
                visitClassDeclaration(node) :
                visitClassExpression(node);
            endClassLexicalEnvironment();
            pendingExpressions = savedPendingExpressions;
            return result;
        }
        function doesClassElementNeedTransform(node) {
            return ts.isPropertyDeclaration(node) || ts.isClassStaticBlockDeclaration(node) || (shouldTransformPrivateElementsOrClassStaticBlocks && node.name && ts.isPrivateIdentifier(node.name));
        }
        function getPrivateInstanceMethodsAndAccessors(node) {
            return ts.filter(node.members, ts.isNonStaticMethodOrAccessorWithPrivateName);
        }
        function getClassFacts(node) {
            var facts = 0 /* None */;
            var original = ts.getOriginalNode(node);
            if (ts.isClassDeclaration(original) && ts.classOrConstructorParameterIsDecorated(original)) {
                facts |= 1 /* ClassWasDecorated */;
            }
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (!ts.isStatic(member))
                    continue;
                if (member.name && ts.isPrivateIdentifier(member.name) && shouldTransformPrivateElementsOrClassStaticBlocks) {
                    facts |= 2 /* NeedsClassConstructorReference */;
                }
                if (ts.isPropertyDeclaration(member) || ts.isClassStaticBlockDeclaration(member)) {
                    if (shouldTransformThisInStaticInitializers && member.transformFlags & 8192 /* ContainsLexicalThis */) {
                        facts |= 8 /* NeedsSubstitutionForThisInClassStaticField */;
                        if (!(facts & 1 /* ClassWasDecorated */)) {
                            facts |= 2 /* NeedsClassConstructorReference */;
                        }
                    }
                    if (shouldTransformSuperInStaticInitializers && member.transformFlags & 33554432 /* ContainsLexicalSuper */) {
                        if (!(facts & 1 /* ClassWasDecorated */)) {
                            facts |= 2 /* NeedsClassConstructorReference */ | 4 /* NeedsClassSuperReference */;
                        }
                    }
                }
            }
            return facts;
        }
        function visitExpressionWithTypeArguments(node) {
            var facts = (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.facts) || 0 /* None */;
            if (facts & 4 /* NeedsClassSuperReference */) {
                var temp = factory.createTempVariable(hoistVariableDeclaration, /*reserveInNestedScopes*/ true);
                getClassLexicalEnvironment().superClassReference = temp;
                return factory.updateExpressionWithTypeArguments(node, factory.createAssignment(temp, ts.visitNode(node.expression, visitor, ts.isExpression)), 
                /*typeArguments*/ undefined);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitClassDeclaration(node) {
            var facts = getClassFacts(node);
            if (facts) {
                getClassLexicalEnvironment().facts = facts;
            }
            if (facts & 8 /* NeedsSubstitutionForThisInClassStaticField */) {
                enableSubstitutionForClassStaticThisOrSuperReference();
            }
            var staticProperties = ts.getStaticPropertiesAndClassStaticBlock(node);
            // If a class has private static fields, or a static field has a `this` or `super` reference,
            // then we need to allocate a temp variable to hold on to that reference.
            var pendingClassReferenceAssignment;
            if (facts & 2 /* NeedsClassConstructorReference */) {
                var temp = factory.createTempVariable(hoistVariableDeclaration, /*reservedInNestedScopes*/ true);
                getClassLexicalEnvironment().classConstructor = factory.cloneNode(temp);
                pendingClassReferenceAssignment = factory.createAssignment(temp, factory.getInternalName(node));
            }
            var extendsClauseElement = ts.getEffectiveBaseTypeNode(node);
            var isDerivedClass = !!(extendsClauseElement && ts.skipOuterExpressions(extendsClauseElement.expression).kind !== 104 /* NullKeyword */);
            var statements = [
                factory.updateClassDeclaration(node, 
                /*decorators*/ undefined, node.modifiers, node.name, 
                /*typeParameters*/ undefined, ts.visitNodes(node.heritageClauses, heritageClauseVisitor, ts.isHeritageClause), transformClassMembers(node, isDerivedClass))
            ];
            if (pendingClassReferenceAssignment) {
                getPendingExpressions().unshift(pendingClassReferenceAssignment);
            }
            // Write any pending expressions from elided or moved computed property names
            if (ts.some(pendingExpressions)) {
                statements.push(factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions)));
            }
            // Emit static property assignment. Because classDeclaration is lexically evaluated,
            // it is safe to emit static property assignment after classDeclaration
            // From ES6 specification:
            //      HasLexicalDeclaration (N) : Determines if the argument identifier has a binding in this environment record that was created using
            //                                  a lexical declaration such as a LexicalDeclaration or a ClassDeclaration.
            if (ts.some(staticProperties)) {
                addPropertyOrClassStaticBlockStatements(statements, staticProperties, factory.getInternalName(node));
            }
            return statements;
        }
        function visitClassExpression(node) {
            var facts = getClassFacts(node);
            if (facts) {
                getClassLexicalEnvironment().facts = facts;
            }
            if (facts & 8 /* NeedsSubstitutionForThisInClassStaticField */) {
                enableSubstitutionForClassStaticThisOrSuperReference();
            }
            // If this class expression is a transformation of a decorated class declaration,
            // then we want to output the pendingExpressions as statements, not as inlined
            // expressions with the class statement.
            //
            // In this case, we use pendingStatements to produce the same output as the
            // class declaration transformation. The VariableStatement visitor will insert
            // these statements after the class expression variable statement.
            var isDecoratedClassDeclaration = !!(facts & 1 /* ClassWasDecorated */);
            var staticPropertiesOrClassStaticBlocks = ts.getStaticPropertiesAndClassStaticBlock(node);
            var extendsClauseElement = ts.getEffectiveBaseTypeNode(node);
            var isDerivedClass = !!(extendsClauseElement && ts.skipOuterExpressions(extendsClauseElement.expression).kind !== 104 /* NullKeyword */);
            var isClassWithConstructorReference = resolver.getNodeCheckFlags(node) & 16777216 /* ClassWithConstructorReference */;
            var temp;
            function createClassTempVar() {
                var classCheckFlags = resolver.getNodeCheckFlags(node);
                var isClassWithConstructorReference = classCheckFlags & 16777216 /* ClassWithConstructorReference */;
                var requiresBlockScopedVar = classCheckFlags & 524288 /* BlockScopedBindingInLoop */;
                return factory.createTempVariable(requiresBlockScopedVar ? addBlockScopedVariable : hoistVariableDeclaration, !!isClassWithConstructorReference);
            }
            if (facts & 2 /* NeedsClassConstructorReference */) {
                temp = createClassTempVar();
                getClassLexicalEnvironment().classConstructor = factory.cloneNode(temp);
            }
            var classExpression = factory.updateClassExpression(node, ts.visitNodes(node.decorators, visitor, ts.isDecorator), node.modifiers, node.name, 
            /*typeParameters*/ undefined, ts.visitNodes(node.heritageClauses, heritageClauseVisitor, ts.isHeritageClause), transformClassMembers(node, isDerivedClass));
            var hasTransformableStatics = ts.some(staticPropertiesOrClassStaticBlocks, function (p) { return ts.isClassStaticBlockDeclaration(p) || !!p.initializer || (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifier(p.name)); });
            if (hasTransformableStatics || ts.some(pendingExpressions)) {
                if (isDecoratedClassDeclaration) {
                    ts.Debug.assertIsDefined(pendingStatements, "Decorated classes transformed by TypeScript are expected to be within a variable declaration.");
                    // Write any pending expressions from elided or moved computed property names
                    if (pendingStatements && pendingExpressions && ts.some(pendingExpressions)) {
                        pendingStatements.push(factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions)));
                    }
                    if (pendingStatements && ts.some(staticPropertiesOrClassStaticBlocks)) {
                        addPropertyOrClassStaticBlockStatements(pendingStatements, staticPropertiesOrClassStaticBlocks, factory.getInternalName(node));
                    }
                    if (temp) {
                        return factory.inlineExpressions([factory.createAssignment(temp, classExpression), temp]);
                    }
                    return classExpression;
                }
                else {
                    var expressions = [];
                    temp || (temp = createClassTempVar());
                    if (isClassWithConstructorReference) {
                        // record an alias as the class name is not in scope for statics.
                        enableSubstitutionForClassAliases();
                        var alias = factory.cloneNode(temp);
                        alias.autoGenerateFlags &= ~8 /* ReservedInNestedScopes */;
                        classAliases[ts.getOriginalNodeId(node)] = alias;
                    }
                    // To preserve the behavior of the old emitter, we explicitly indent
                    // the body of a class with static initializers.
                    ts.setEmitFlags(classExpression, 65536 /* Indented */ | ts.getEmitFlags(classExpression));
                    expressions.push(ts.startOnNewLine(factory.createAssignment(temp, classExpression)));
                    // Add any pending expressions leftover from elided or relocated computed property names
                    ts.addRange(expressions, ts.map(pendingExpressions, ts.startOnNewLine));
                    ts.addRange(expressions, generateInitializedPropertyExpressionsOrClassStaticBlock(staticPropertiesOrClassStaticBlocks, temp));
                    expressions.push(ts.startOnNewLine(temp));
                    return factory.inlineExpressions(expressions);
                }
            }
            return classExpression;
        }
        function visitClassStaticBlockDeclaration(node) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                return ts.visitEachChild(node, classElementVisitor, context);
            }
            // ClassStaticBlockDeclaration for classes are transformed in `visitClassDeclaration` or `visitClassExpression`.
            return undefined;
        }
        function transformClassMembers(node, isDerivedClass) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                // Declare private names.
                for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                    var member = _a[_i];
                    if (ts.isPrivateIdentifierClassElementDeclaration(member)) {
                        addPrivateIdentifierToEnvironment(member);
                    }
                }
                if (ts.some(getPrivateInstanceMethodsAndAccessors(node))) {
                    createBrandCheckWeakSetForPrivateMethods();
                }
            }
            var members = [];
            var constructor = transformConstructor(node, isDerivedClass);
            if (constructor) {
                members.push(constructor);
            }
            ts.addRange(members, ts.visitNodes(node.members, classElementVisitor, ts.isClassElement));
            return ts.setTextRange(factory.createNodeArray(members), /*location*/ node.members);
        }
        function createBrandCheckWeakSetForPrivateMethods() {
            var weakSetName = getPrivateIdentifierEnvironment().weakSetName;
            ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
            getPendingExpressions().push(factory.createAssignment(weakSetName, factory.createNewExpression(factory.createIdentifier("WeakSet"), 
            /*typeArguments*/ undefined, [])));
        }
        function isClassElementThatRequiresConstructorStatement(member) {
            if (ts.isStatic(member) || ts.hasSyntacticModifier(ts.getOriginalNode(member), 128 /* Abstract */)) {
                return false;
            }
            if (useDefineForClassFields) {
                // If we are using define semantics and targeting ESNext or higher,
                // then we don't need to transform any class properties.
                return languageVersion < 99 /* ESNext */;
            }
            return ts.isInitializedProperty(member) || shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierClassElementDeclaration(member);
        }
        function transformConstructor(node, isDerivedClass) {
            var constructor = ts.visitNode(ts.getFirstConstructorWithBody(node), visitor, ts.isConstructorDeclaration);
            var elements = node.members.filter(isClassElementThatRequiresConstructorStatement);
            if (!ts.some(elements)) {
                return constructor;
            }
            var parameters = ts.visitParameterList(constructor ? constructor.parameters : undefined, visitor, context);
            var body = transformConstructorBody(node, constructor, isDerivedClass);
            if (!body) {
                return undefined;
            }
            return ts.startOnNewLine(ts.setOriginalNode(ts.setTextRange(factory.createConstructorDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, parameters !== null && parameters !== void 0 ? parameters : [], body), constructor || node), constructor));
        }
        function transformConstructorBody(node, constructor, isDerivedClass) {
            var properties = ts.getProperties(node, /*requireInitializer*/ false, /*isStatic*/ false);
            if (!useDefineForClassFields) {
                properties = ts.filter(properties, function (property) { return !!property.initializer || ts.isPrivateIdentifier(property.name); });
            }
            var privateMethodsAndAccessors = getPrivateInstanceMethodsAndAccessors(node);
            var needsConstructorBody = ts.some(properties) || ts.some(privateMethodsAndAccessors);
            // Only generate synthetic constructor when there are property initializers to move.
            if (!constructor && !needsConstructorBody) {
                return ts.visitFunctionBody(/*node*/ undefined, visitor, context);
            }
            resumeLexicalEnvironment();
            var indexOfFirstStatement = 0;
            var statements = [];
            if (!constructor && isDerivedClass) {
                // Add a synthetic `super` call:
                //
                //  super(...arguments);
                //
                statements.push(factory.createExpressionStatement(factory.createCallExpression(factory.createSuper(), 
                /*typeArguments*/ undefined, [factory.createSpreadElement(factory.createIdentifier("arguments"))])));
            }
            if (constructor) {
                indexOfFirstStatement = ts.addPrologueDirectivesAndInitialSuperCall(factory, constructor, statements, visitor);
            }
            // Add the property initializers. Transforms this:
            //
            //  public x = 1;
            //
            // Into this:
            //
            //  constructor() {
            //      this.x = 1;
            //  }
            //
            if (constructor === null || constructor === void 0 ? void 0 : constructor.body) {
                var afterParameterProperties = ts.findIndex(constructor.body.statements, function (s) { return !ts.isParameterPropertyDeclaration(ts.getOriginalNode(s), constructor); }, indexOfFirstStatement);
                if (afterParameterProperties === -1) {
                    afterParameterProperties = constructor.body.statements.length;
                }
                if (afterParameterProperties > indexOfFirstStatement) {
                    if (!useDefineForClassFields) {
                        ts.addRange(statements, ts.visitNodes(constructor.body.statements, visitor, ts.isStatement, indexOfFirstStatement, afterParameterProperties - indexOfFirstStatement));
                    }
                    indexOfFirstStatement = afterParameterProperties;
                }
            }
            var receiver = factory.createThis();
            // private methods can be called in property initializers, they should execute first.
            addMethodStatements(statements, privateMethodsAndAccessors, receiver);
            addPropertyOrClassStaticBlockStatements(statements, properties, receiver);
            // Add existing statements, skipping the initial super call.
            if (constructor) {
                ts.addRange(statements, ts.visitNodes(constructor.body.statements, visitor, ts.isStatement, indexOfFirstStatement));
            }
            statements = factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
            return ts.setTextRange(factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), 
            /*location*/ constructor ? constructor.body.statements : node.members), 
            /*multiLine*/ true), 
            /*location*/ constructor ? constructor.body : undefined);
        }
        /**
         * Generates assignment statements for property initializers.
         *
         * @param properties An array of property declarations to transform.
         * @param receiver The receiver on which each property should be assigned.
         */
        function addPropertyOrClassStaticBlockStatements(statements, properties, receiver) {
            for (var _i = 0, properties_7 = properties; _i < properties_7.length; _i++) {
                var property = properties_7[_i];
                var expression = ts.isClassStaticBlockDeclaration(property) ?
                    transformClassStaticBlockDeclaration(property) :
                    transformProperty(property, receiver);
                if (!expression) {
                    continue;
                }
                var statement = factory.createExpressionStatement(expression);
                ts.setSourceMapRange(statement, ts.moveRangePastModifiers(property));
                ts.setCommentRange(statement, property);
                ts.setOriginalNode(statement, property);
                statements.push(statement);
            }
        }
        /**
         * Generates assignment expressions for property initializers.
         *
         * @param propertiesOrClassStaticBlocks An array of property declarations to transform.
         * @param receiver The receiver on which each property should be assigned.
         */
        function generateInitializedPropertyExpressionsOrClassStaticBlock(propertiesOrClassStaticBlocks, receiver) {
            var expressions = [];
            for (var _i = 0, propertiesOrClassStaticBlocks_1 = propertiesOrClassStaticBlocks; _i < propertiesOrClassStaticBlocks_1.length; _i++) {
                var property = propertiesOrClassStaticBlocks_1[_i];
                var expression = ts.isClassStaticBlockDeclaration(property) ? transformClassStaticBlockDeclaration(property) : transformProperty(property, receiver);
                if (!expression) {
                    continue;
                }
                ts.startOnNewLine(expression);
                ts.setSourceMapRange(expression, ts.moveRangePastModifiers(property));
                ts.setCommentRange(expression, property);
                ts.setOriginalNode(expression, property);
                expressions.push(expression);
            }
            return expressions;
        }
        /**
         * Transforms a property initializer into an assignment statement.
         *
         * @param property The property declaration.
         * @param receiver The object receiving the property assignment.
         */
        function transformProperty(property, receiver) {
            var savedCurrentStaticPropertyDeclarationOrStaticBlock = currentStaticPropertyDeclarationOrStaticBlock;
            var transformed = transformPropertyWorker(property, receiver);
            if (transformed && ts.hasStaticModifier(property) && (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.facts)) {
                // capture the lexical environment for the member
                ts.setOriginalNode(transformed, property);
                ts.addEmitFlags(transformed, 2 /* AdviseOnEmitNode */);
                classLexicalEnvironmentMap.set(ts.getOriginalNodeId(transformed), currentClassLexicalEnvironment);
            }
            currentStaticPropertyDeclarationOrStaticBlock = savedCurrentStaticPropertyDeclarationOrStaticBlock;
            return transformed;
        }
        function transformPropertyWorker(property, receiver) {
            var _a;
            // We generate a name here in order to reuse the value cached by the relocated computed name expression (which uses the same generated name)
            var emitAssignment = !useDefineForClassFields;
            var propertyName = ts.isComputedPropertyName(property.name) && !ts.isSimpleInlineableExpression(property.name.expression)
                ? factory.updateComputedPropertyName(property.name, factory.getGeneratedNameForNode(property.name))
                : property.name;
            if (ts.hasStaticModifier(property)) {
                currentStaticPropertyDeclarationOrStaticBlock = property;
            }
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifier(propertyName)) {
                var privateIdentifierInfo = accessPrivateIdentifier(propertyName);
                if (privateIdentifierInfo) {
                    if (privateIdentifierInfo.kind === "f" /* Field */) {
                        if (!privateIdentifierInfo.isStatic) {
                            return createPrivateInstanceFieldInitializer(receiver, ts.visitNode(property.initializer, visitor, ts.isExpression), privateIdentifierInfo.brandCheckIdentifier);
                        }
                        else {
                            return createPrivateStaticFieldInitializer(privateIdentifierInfo.variableName, ts.visitNode(property.initializer, visitor, ts.isExpression));
                        }
                    }
                    else {
                        return undefined;
                    }
                }
                else {
                    ts.Debug.fail("Undeclared private name for property declaration.");
                }
            }
            if ((ts.isPrivateIdentifier(propertyName) || ts.hasStaticModifier(property)) && !property.initializer) {
                return undefined;
            }
            var propertyOriginalNode = ts.getOriginalNode(property);
            if (ts.hasSyntacticModifier(propertyOriginalNode, 128 /* Abstract */)) {
                return undefined;
            }
            var initializer = property.initializer || emitAssignment ? (_a = ts.visitNode(property.initializer, visitor, ts.isExpression)) !== null && _a !== void 0 ? _a : factory.createVoidZero()
                : ts.isParameterPropertyDeclaration(propertyOriginalNode, propertyOriginalNode.parent) && ts.isIdentifier(propertyName) ? propertyName
                    : factory.createVoidZero();
            if (emitAssignment || ts.isPrivateIdentifier(propertyName)) {
                var memberAccess = ts.createMemberAccessForPropertyName(factory, receiver, propertyName, /*location*/ propertyName);
                return factory.createAssignment(memberAccess, initializer);
            }
            else {
                var name = ts.isComputedPropertyName(propertyName) ? propertyName.expression
                    : ts.isIdentifier(propertyName) ? factory.createStringLiteral(ts.unescapeLeadingUnderscores(propertyName.escapedText))
                        : propertyName;
                var descriptor = factory.createPropertyDescriptor({ value: initializer, configurable: true, writable: true, enumerable: true });
                return factory.createObjectDefinePropertyCall(receiver, name, descriptor);
            }
        }
        function enableSubstitutionForClassAliases() {
            if ((enabledSubstitutions & 1 /* ClassAliases */) === 0) {
                enabledSubstitutions |= 1 /* ClassAliases */;
                // We need to enable substitutions for identifiers. This allows us to
                // substitute class names inside of a class declaration.
                context.enableSubstitution(79 /* Identifier */);
                // Keep track of class aliases.
                classAliases = [];
            }
        }
        function enableSubstitutionForClassStaticThisOrSuperReference() {
            if ((enabledSubstitutions & 2 /* ClassStaticThisOrSuperReference */) === 0) {
                enabledSubstitutions |= 2 /* ClassStaticThisOrSuperReference */;
                // substitute `this` in a static field initializer
                context.enableSubstitution(108 /* ThisKeyword */);
                // these push a new lexical environment that is not the class lexical environment
                context.enableEmitNotification(254 /* FunctionDeclaration */);
                context.enableEmitNotification(211 /* FunctionExpression */);
                context.enableEmitNotification(169 /* Constructor */);
                // these push a new lexical environment that is not the class lexical environment, except
                // when they have a computed property name
                context.enableEmitNotification(170 /* GetAccessor */);
                context.enableEmitNotification(171 /* SetAccessor */);
                context.enableEmitNotification(167 /* MethodDeclaration */);
                context.enableEmitNotification(165 /* PropertyDeclaration */);
                // class lexical environments are restored when entering a computed property name
                context.enableEmitNotification(160 /* ComputedPropertyName */);
            }
        }
        /**
         * Generates brand-check initializer for private methods.
         *
         * @param statements Statement list that should be used to append new statements.
         * @param methods An array of method declarations.
         * @param receiver The receiver on which each method should be assigned.
         */
        function addMethodStatements(statements, methods, receiver) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks || !ts.some(methods)) {
                return;
            }
            var weakSetName = getPrivateIdentifierEnvironment().weakSetName;
            ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
            statements.push(factory.createExpressionStatement(createPrivateInstanceMethodInitializer(receiver, weakSetName)));
        }
        function visitInvalidSuperProperty(node) {
            return ts.isPropertyAccessExpression(node) ?
                factory.updatePropertyAccessExpression(node, factory.createVoidZero(), node.name) :
                factory.updateElementAccessExpression(node, factory.createVoidZero(), ts.visitNode(node.argumentExpression, visitor, ts.isExpression));
        }
        function onEmitNode(hint, node, emitCallback) {
            var original = ts.getOriginalNode(node);
            if (original.id) {
                var classLexicalEnvironment = classLexicalEnvironmentMap.get(original.id);
                if (classLexicalEnvironment) {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentClassLexicalEnvironment = classLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = classLexicalEnvironment;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
            }
            switch (node.kind) {
                case 211 /* FunctionExpression */:
                    if (ts.isArrowFunction(original) || ts.getEmitFlags(node) & 262144 /* AsyncFunctionBody */) {
                        break;
                    }
                // falls through
                case 254 /* FunctionDeclaration */:
                case 169 /* Constructor */: {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentClassLexicalEnvironment = undefined;
                    currentComputedPropertyNameClassLexicalEnvironment = undefined;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
                case 170 /* GetAccessor */:
                case 171 /* SetAccessor */:
                case 167 /* MethodDeclaration */:
                case 165 /* PropertyDeclaration */: {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = currentClassLexicalEnvironment;
                    currentClassLexicalEnvironment = undefined;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
                case 160 /* ComputedPropertyName */: {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = undefined;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        /**
         * Hooks node substitutions.
         *
         * @param hint The context for the emitter.
         * @param node The node to substitute.
         */
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 /* Expression */) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79 /* Identifier */:
                    return substituteExpressionIdentifier(node);
                case 108 /* ThisKeyword */:
                    return substituteThisExpression(node);
            }
            return node;
        }
        function substituteThisExpression(node) {
            if (enabledSubstitutions & 2 /* ClassStaticThisOrSuperReference */ && currentClassLexicalEnvironment) {
                var facts = currentClassLexicalEnvironment.facts, classConstructor = currentClassLexicalEnvironment.classConstructor;
                if (facts & 1 /* ClassWasDecorated */) {
                    return factory.createParenthesizedExpression(factory.createVoidZero());
                }
                if (classConstructor) {
                    return ts.setTextRange(ts.setOriginalNode(factory.cloneNode(classConstructor), node), node);
                }
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            return trySubstituteClassAlias(node) || node;
        }
        function trySubstituteClassAlias(node) {
            if (enabledSubstitutions & 1 /* ClassAliases */) {
                if (resolver.getNodeCheckFlags(node) & 33554432 /* ConstructorReferenceInClass */) {
                    // Due to the emit for class decorators, any reference to the class from inside of the class body
                    // must instead be rewritten to point to a temporary variable to avoid issues with the double-bind
                    // behavior of class names in ES6.
                    // Also, when emitting statics for class expressions, we must substitute a class alias for
                    // constructor references in static property initializers.
                    var declaration = resolver.getReferencedValueDeclaration(node);
                    if (declaration) {
                        var classAlias = classAliases[declaration.id]; // TODO: GH#18217
                        if (classAlias) {
                            var clone_3 = factory.cloneNode(classAlias);
                            ts.setSourceMapRange(clone_3, node);
                            ts.setCommentRange(clone_3, node);
                            return clone_3;
                        }
                    }
                }
            }
            return undefined;
        }
        /**
         * If the name is a computed property, this function transforms it, then either returns an expression which caches the
         * value of the result or the expression itself if the value is either unused or safe to inline into multiple locations
         * @param shouldHoist Does the expression need to be reused? (ie, for an initializer or a decorator)
         */
        function getPropertyNameExpressionIfNeeded(name, shouldHoist) {
            if (ts.isComputedPropertyName(name)) {
                var expression = ts.visitNode(name.expression, visitor, ts.isExpression);
                var innerExpression = ts.skipPartiallyEmittedExpressions(expression);
                var inlinable = ts.isSimpleInlineableExpression(innerExpression);
                var alreadyTransformed = ts.isAssignmentExpression(innerExpression) && ts.isGeneratedIdentifier(innerExpression.left);
                if (!alreadyTransformed && !inlinable && shouldHoist) {
                    var generatedName = factory.getGeneratedNameForNode(name);
                    if (resolver.getNodeCheckFlags(name) & 524288 /* BlockScopedBindingInLoop */) {
                        addBlockScopedVariable(generatedName);
                    }
                    else {
                        hoistVariableDeclaration(generatedName);
                    }
                    return factory.createAssignment(generatedName, expression);
                }
                return (inlinable || ts.isIdentifier(innerExpression)) ? undefined : expression;
            }
        }
        function startClassLexicalEnvironment() {
            classLexicalEnvironmentStack.push(currentClassLexicalEnvironment);
            currentClassLexicalEnvironment = undefined;
        }
        function endClassLexicalEnvironment() {
            currentClassLexicalEnvironment = classLexicalEnvironmentStack.pop();
        }
        function getClassLexicalEnvironment() {
            return currentClassLexicalEnvironment || (currentClassLexicalEnvironment = {
                facts: 0 /* None */,
                classConstructor: undefined,
                superClassReference: undefined,
                privateIdentifierEnvironment: undefined,
            });
        }
        function getPrivateIdentifierEnvironment() {
            var lex = getClassLexicalEnvironment();
            lex.privateIdentifierEnvironment || (lex.privateIdentifierEnvironment = {
                className: "",
                identifiers: new ts.Map()
            });
            return lex.privateIdentifierEnvironment;
        }
        function getPendingExpressions() {
            return pendingExpressions || (pendingExpressions = []);
        }
        function addPrivateIdentifierToEnvironment(node) {
            var _a;
            var text = ts.getTextOfPropertyName(node.name);
            var lex = getClassLexicalEnvironment();
            var classConstructor = lex.classConstructor;
            var privateEnv = getPrivateIdentifierEnvironment();
            var weakSetName = privateEnv.weakSetName;
            var assignmentExpressions = [];
            var privateName = node.name.escapedText;
            var previousInfo = privateEnv.identifiers.get(privateName);
            var isValid = !isReservedPrivateName(node.name) && previousInfo === undefined;
            if (ts.hasStaticModifier(node)) {
                ts.Debug.assert(classConstructor, "weakSetName should be set in private identifier environment");
                if (ts.isPropertyDeclaration(node)) {
                    var variableName = createHoistedVariableForPrivateName(text, node);
                    privateEnv.identifiers.set(privateName, {
                        kind: "f" /* Field */,
                        variableName: variableName,
                        brandCheckIdentifier: classConstructor,
                        isStatic: true,
                        isValid: isValid,
                    });
                }
                else if (ts.isMethodDeclaration(node)) {
                    var functionName = createHoistedVariableForPrivateName(text, node);
                    privateEnv.identifiers.set(privateName, {
                        kind: "m" /* Method */,
                        methodName: functionName,
                        brandCheckIdentifier: classConstructor,
                        isStatic: true,
                        isValid: isValid,
                    });
                }
                else if (ts.isGetAccessorDeclaration(node)) {
                    var getterName = createHoistedVariableForPrivateName(text + "_get", node);
                    if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" /* Accessor */ && previousInfo.isStatic && !previousInfo.getterName) {
                        previousInfo.getterName = getterName;
                    }
                    else {
                        privateEnv.identifiers.set(privateName, {
                            kind: "a" /* Accessor */,
                            getterName: getterName,
                            setterName: undefined,
                            brandCheckIdentifier: classConstructor,
                            isStatic: true,
                            isValid: isValid,
                        });
                    }
                }
                else if (ts.isSetAccessorDeclaration(node)) {
                    var setterName = createHoistedVariableForPrivateName(text + "_set", node);
                    if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" /* Accessor */ && previousInfo.isStatic && !previousInfo.setterName) {
                        previousInfo.setterName = setterName;
                    }
                    else {
                        privateEnv.identifiers.set(privateName, {
                            kind: "a" /* Accessor */,
                            getterName: undefined,
                            setterName: setterName,
                            brandCheckIdentifier: classConstructor,
                            isStatic: true,
                            isValid: isValid,
                        });
                    }
                }
                else {
                    ts.Debug.assertNever(node, "Unknown class element type.");
                }
            }
            else if (ts.isPropertyDeclaration(node)) {
                var weakMapName = createHoistedVariableForPrivateName(text, node);
                privateEnv.identifiers.set(privateName, {
                    kind: "f" /* Field */,
                    brandCheckIdentifier: weakMapName,
                    isStatic: false,
                    variableName: undefined,
                    isValid: isValid,
                });
                assignmentExpressions.push(factory.createAssignment(weakMapName, factory.createNewExpression(factory.createIdentifier("WeakMap"), 
                /*typeArguments*/ undefined, [])));
            }
            else if (ts.isMethodDeclaration(node)) {
                ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
                privateEnv.identifiers.set(privateName, {
                    kind: "m" /* Method */,
                    methodName: createHoistedVariableForPrivateName(text, node),
                    brandCheckIdentifier: weakSetName,
                    isStatic: false,
                    isValid: isValid,
                });
            }
            else if (ts.isAccessor(node)) {
                ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
                if (ts.isGetAccessor(node)) {
                    var getterName = createHoistedVariableForPrivateName(text + "_get", node);
                    if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" /* Accessor */ && !previousInfo.isStatic && !previousInfo.getterName) {
                        previousInfo.getterName = getterName;
                    }
                    else {
                        privateEnv.identifiers.set(privateName, {
                            kind: "a" /* Accessor */,
                            getterName: getterName,
                            setterName: undefined,
                            brandCheckIdentifier: weakSetName,
                            isStatic: false,
                            isValid: isValid,
                        });
                    }
                }
                else {
                    var setterName = createHoistedVariableForPrivateName(text + "_set", node);
                    if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" /* Accessor */ && !previousInfo.isStatic && !previousInfo.setterName) {
                        previousInfo.setterName = setterName;
                    }
                    else {
                        privateEnv.identifiers.set(privateName, {
                            kind: "a" /* Accessor */,
                            getterName: undefined,
                            setterName: setterName,
                            brandCheckIdentifier: weakSetName,
                            isStatic: false,
                            isValid: isValid,
                        });
                    }
                }
            }
            else {
                ts.Debug.assertNever(node, "Unknown class element type.");
            }
            (_a = getPendingExpressions()).push.apply(_a, assignmentExpressions);
        }
        function createHoistedVariableForClass(name, node) {
            var className = getPrivateIdentifierEnvironment().className;
            var prefix = className ? "_" + className : "";
            var identifier = factory.createUniqueName(prefix + "_" + name, 16 /* Optimistic */);
            if (resolver.getNodeCheckFlags(node) & 524288 /* BlockScopedBindingInLoop */) {
                addBlockScopedVariable(identifier);
            }
            else {
                hoistVariableDeclaration(identifier);
            }
            return identifier;
        }
        function createHoistedVariableForPrivateName(privateName, node) {
            return createHoistedVariableForClass(privateName.substring(1), node.name);
        }
        function accessPrivateIdentifier(name) {
            var _a;
            if (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.privateIdentifierEnvironment) {
                var info = currentClassLexicalEnvironment.privateIdentifierEnvironment.identifiers.get(name.escapedText);
                if (info) {
                    return info;
                }
            }
            for (var i = classLexicalEnvironmentStack.length - 1; i >= 0; --i) {
                var env = classLexicalEnvironmentStack[i];
                if (!env) {
                    continue;
                }
                var info = (_a = env.privateIdentifierEnvironment) === null || _a === void 0 ? void 0 : _a.identifiers.get(name.escapedText);
                if (info) {
                    return info;
                }
            }
            return undefined;
        }
        function wrapPrivateIdentifierForDestructuringTarget(node) {
            var parameter = factory.getGeneratedNameForNode(node);
            var info = accessPrivateIdentifier(node.name);
            if (!info) {
                return ts.visitEachChild(node, visitor, context);
            }
            var receiver = node.expression;
            // We cannot copy `this` or `super` into the function because they will be bound
            // differently inside the function.
            if (ts.isThisProperty(node) || ts.isSuperProperty(node) || !ts.isSimpleCopiableExpression(node.expression)) {
                receiver = factory.createTempVariable(hoistVariableDeclaration, /*reservedInNestedScopes*/ true);
                getPendingExpressions().push(factory.createBinaryExpression(receiver, 63 /* EqualsToken */, ts.visitNode(node.expression, visitor, ts.isExpression)));
            }
            return factory.createAssignmentTargetWrapper(parameter, createPrivateIdentifierAssignment(info, receiver, parameter, 63 /* EqualsToken */));
        }
        function visitArrayAssignmentTarget(node) {
            var target = ts.getTargetOfBindingOrAssignmentElement(node);
            if (target) {
                var wrapped = void 0;
                if (ts.isPrivateIdentifierPropertyAccessExpression(target)) {
                    wrapped = wrapPrivateIdentifierForDestructuringTarget(target);
                }
                else if (shouldTransformSuperInStaticInitializers &&
                    ts.isSuperProperty(target) &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                    var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                    if (facts & 1 /* ClassWasDecorated */) {
                        wrapped = visitInvalidSuperProperty(target);
                    }
                    else if (classConstructor && superClassReference) {
                        var name = ts.isElementAccessExpression(target) ? ts.visitNode(target.argumentExpression, visitor, ts.isExpression) :
                            ts.isIdentifier(target.name) ? factory.createStringLiteralFromNode(target.name) :
                                undefined;
                        if (name) {
                            var temp = factory.createTempVariable(/*recordTempVariable*/ undefined);
                            wrapped = factory.createAssignmentTargetWrapper(temp, factory.createReflectSetCall(superClassReference, name, temp, classConstructor));
                        }
                    }
                }
                if (wrapped) {
                    if (ts.isAssignmentExpression(node)) {
                        return factory.updateBinaryExpression(node, wrapped, node.operatorToken, ts.visitNode(node.right, visitor, ts.isExpression));
                    }
                    else if (ts.isSpreadElement(node)) {
                        return factory.updateSpreadElement(node, wrapped);
                    }
                    else {
                        return wrapped;
                    }
                }
            }
            return ts.visitNode(node, visitorDestructuringTarget);
        }
        function visitObjectAssignmentTarget(node) {
            if (ts.isObjectBindingOrAssignmentElement(node) && !ts.isShorthandPropertyAssignment(node)) {
                var target = ts.getTargetOfBindingOrAssignmentElement(node);
                var wrapped = void 0;
                if (target) {
                    if (ts.isPrivateIdentifierPropertyAccessExpression(target)) {
                        wrapped = wrapPrivateIdentifierForDestructuringTarget(target);
                    }
                    else if (shouldTransformSuperInStaticInitializers &&
                        ts.isSuperProperty(target) &&
                        currentStaticPropertyDeclarationOrStaticBlock &&
                        currentClassLexicalEnvironment) {
                        var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                        if (facts & 1 /* ClassWasDecorated */) {
                            wrapped = visitInvalidSuperProperty(target);
                        }
                        else if (classConstructor && superClassReference) {
                            var name = ts.isElementAccessExpression(target) ? ts.visitNode(target.argumentExpression, visitor, ts.isExpression) :
                                ts.isIdentifier(target.name) ? factory.createStringLiteralFromNode(target.name) :
                                    undefined;
                            if (name) {
                                var temp = factory.createTempVariable(/*recordTempVariable*/ undefined);
                                wrapped = factory.createAssignmentTargetWrapper(temp, factory.createReflectSetCall(superClassReference, name, temp, classConstructor));
                            }
                        }
                    }
                }
                if (ts.isPropertyAssignment(node)) {
                    var initializer = ts.getInitializerOfBindingOrAssignmentElement(node);
                    return factory.updatePropertyAssignment(node, ts.visitNode(node.name, visitor, ts.isPropertyName), wrapped ?
                        initializer ? factory.createAssignment(wrapped, ts.visitNode(initializer, visitor)) : wrapped :
                        ts.visitNode(node.initializer, visitorDestructuringTarget, ts.isExpression));
                }
                if (ts.isSpreadAssignment(node)) {
                    return factory.updateSpreadAssignment(node, wrapped || ts.visitNode(node.expression, visitorDestructuringTarget, ts.isExpression));
                }
                ts.Debug.assert(wrapped === undefined, "Should not have generated a wrapped target");
            }
            return ts.visitNode(node, visitor);
        }
        function visitAssignmentPattern(node) {
            if (ts.isArrayLiteralExpression(node)) {
                // Transforms private names in destructuring assignment array bindings.
                // Transforms SuperProperty assignments in destructuring assignment array bindings in static initializers.
                //
                // Source:
                // ([ this.#myProp ] = [ "hello" ]);
                //
                // Transformation:
                // [ { set value(x) { this.#myProp = x; } }.value ] = [ "hello" ];
                return factory.updateArrayLiteralExpression(node, ts.visitNodes(node.elements, visitArrayAssignmentTarget, ts.isExpression));
            }
            else {
                // Transforms private names in destructuring assignment object bindings.
                // Transforms SuperProperty assignments in destructuring assignment object bindings in static initializers.
                //
                // Source:
                // ({ stringProperty: this.#myProp } = { stringProperty: "hello" });
                //
                // Transformation:
                // ({ stringProperty: { set value(x) { this.#myProp = x; } }.value }) = { stringProperty: "hello" };
                return factory.updateObjectLiteralExpression(node, ts.visitNodes(node.properties, visitObjectAssignmentTarget, ts.isObjectLiteralElementLike));
            }
        }
    }
    ts.transformClassFields = transformClassFields;
    function createPrivateStaticFieldInitializer(variableName, initializer) {
        return ts.factory.createAssignment(variableName, ts.factory.createObjectLiteralExpression([
            ts.factory.createPropertyAssignment("value", initializer || ts.factory.createVoidZero())
        ]));
    }
    function createPrivateInstanceFieldInitializer(receiver, initializer, weakMapName) {
        return ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(weakMapName, "set"), 
        /*typeArguments*/ undefined, [receiver, initializer || ts.factory.createVoidZero()]);
    }
    function createPrivateInstanceMethodInitializer(receiver, weakSetName) {
        return ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(weakSetName, "add"), 
        /*typeArguments*/ undefined, [receiver]);
    }
    function isReservedPrivateName(node) {
        return node.escapedText === "#constructor";
    }
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ES2017SubstitutionFlags;
    (function (ES2017SubstitutionFlags) {
        /** Enables substitutions for async methods with `super` calls. */
        ES2017SubstitutionFlags[ES2017SubstitutionFlags["AsyncMethodsWithSuper"] = 1] = "AsyncMethodsWithSuper";
    })(ES2017SubstitutionFlags || (ES2017SubstitutionFlags = {}));
    var ContextFlags;
    (function (ContextFlags) {
        ContextFlags[ContextFlags["NonTopLevel"] = 1] = "NonTopLevel";
        ContextFlags[ContextFlags["HasLexicalThis"] = 2] = "HasLexicalThis";
    })(ContextFlags || (ContextFlags = {}));
    function transformES2017(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        /**
         * Keeps track of whether expression substitution has been enabled for specific edge cases.
         * They are persisted between each SourceFile transformation and should not be reset.
         */
        var enabledSubstitutions;
        /**
         * This keeps track of containers where `super` is valid, for use with
         * just-in-time substitution for `super` expressions inside of async methods.
         */
        var enclosingSuperContainerFlags = 0;
        var enclosingFunctionParameterNames;
        /**
         * Keeps track of property names accessed on super (`super.x`) within async functions.
         */
        var capturedSuperProperties;
        /** Whether the async function contains an element access on super (`super[x]`). */
        var hasSuperElementAccess;
        /** A set of node IDs for generated super accessors (variable statements). */
        var substitutedSuperAccessors = [];
        var contextFlags = 0;
        // Save the previous transformation hooks.
        var previousOnEmitNode = context.onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        // Set new transformation hooks.
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            setContextFlag(1 /* NonTopLevel */, false);
            setContextFlag(2 /* HasLexicalThis */, !ts.isEffectiveStrictModeSourceFile(node, compilerOptions));
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function setContextFlag(flag, val) {
            contextFlags = val ? contextFlags | flag : contextFlags & ~flag;
        }
        function inContext(flags) {
            return (contextFlags & flags) !== 0;
        }
        function inTopLevelContext() {
            return !inContext(1 /* NonTopLevel */);
        }
        function inHasLexicalThisContext() {
            return inContext(2 /* HasLexicalThis */);
        }
        function doWithContext(flags, cb, value) {
            var contextFlagsToSet = flags & ~contextFlags;
            if (contextFlagsToSet) {
                setContextFlag(contextFlagsToSet, /*val*/ true);
                var result = cb(value);
                setContextFlag(contextFlagsToSet, /*val*/ false);
                return result;
            }
            return cb(value);
        }
        function visitDefault(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 128 /* ContainsES2017 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 130 /* AsyncKeyword */:
                    // ES2017 async modifier should be elided for targets < ES2017
                    return undefined;
                case 216 /* AwaitExpression */:
                    return visitAwaitExpression(node);
                case 167 /* MethodDeclaration */:
                    return doWithContext(1 /* NonTopLevel */ | 2 /* HasLexicalThis */, visitMethodDeclaration, node);
                case 254 /* FunctionDeclaration */:
                    return doWithContext(1 /* NonTopLevel */ | 2 /* HasLexicalThis */, visitFunctionDeclaration, node);
                case 211 /* FunctionExpression */:
                    return doWithContext(1 /* NonTopLevel */ | 2 /* HasLexicalThis */, visitFunctionExpression, node);
                case 212 /* ArrowFunction */:
                    return doWithContext(1 /* NonTopLevel */, visitArrowFunction, node);
                case 204 /* PropertyAccessExpression */:
                    if (capturedSuperProperties && ts.isPropertyAccessExpression(node) && node.expression.kind === 106 /* SuperKeyword */) {
                        capturedSuperProperties.add(node.name.escapedText);
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 205 /* ElementAccessExpression */:
                    if (capturedSuperProperties && node.expression.kind === 106 /* SuperKeyword */) {
                        hasSuperElementAccess = true;
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 170 /* GetAccessor */:
                case 171 /* SetAccessor */:
                case 169 /* Constructor */:
                case 255 /* ClassDeclaration */:
                case 224 /* ClassExpression */:
                    return doWithContext(1 /* NonTopLevel */ | 2 /* HasLexicalThis */, visitDefault, node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function asyncBodyVisitor(node) {
            if (ts.isNodeWithPossibleHoistedDeclaration(node)) {
                switch (node.kind) {
                    case 235 /* VariableStatement */:
                        return visitVariableStatementInAsyncBody(node);
                    case 240 /* ForStatement */:
                        return visitForStatementInAsyncBody(node);
                    case 241 /* ForInStatement */:
                        return visitForInStatementInAsyncBody(node);
                    case 242 /* ForOfStatement */:
                        return visitForOfStatementInAsyncBody(node);
                    case 290 /* CatchClause */:
                        return visitCatchClauseInAsyncBody(node);
                    case 233 /* Block */:
                    case 247 /* SwitchStatement */:
                    case 261 /* CaseBlock */:
                    case 287 /* CaseClause */:
                    case 288 /* DefaultClause */:
                    case 250 /* TryStatement */:
                    case 238 /* DoStatement */:
                    case 239 /* WhileStatement */:
                    case 237 /* IfStatement */:
                    case 246 /* WithStatement */:
                    case 248 /* LabeledStatement */:
                        return ts.visitEachChild(node, asyncBodyVisitor, context);
                    default:
                        return ts.Debug.assertNever(node, "Unhandled node.");
                }
            }
            return visitor(node);
        }
        function visitCatchClauseInAsyncBody(node) {
            var catchClauseNames = new ts.Set();
            recordDeclarationName(node.variableDeclaration, catchClauseNames); // TODO: GH#18217
            // names declared in a catch variable are block scoped
            var catchClauseUnshadowedNames;
            catchClauseNames.forEach(function (_, escapedName) {
                if (enclosingFunctionParameterNames.has(escapedName)) {
                    if (!catchClauseUnshadowedNames) {
                        catchClauseUnshadowedNames = new ts.Set(enclosingFunctionParameterNames);
                    }
                    catchClauseUnshadowedNames.delete(escapedName);
                }
            });
            if (catchClauseUnshadowedNames) {
                var savedEnclosingFunctionParameterNames = enclosingFunctionParameterNames;
                enclosingFunctionParameterNames = catchClauseUnshadowedNames;
                var result = ts.visitEachChild(node, asyncBodyVisitor, context);
                enclosingFunctionParameterNames = savedEnclosingFunctionParameterNames;
                return result;
            }
            else {
                return ts.visitEachChild(node, asyncBodyVisitor, context);
            }
        }
        function visitVariableStatementInAsyncBody(node) {
            if (isVariableDeclarationListWithCollidingName(node.declarationList)) {
                var expression = visitVariableDeclarationListWithCollidingNames(node.declarationList, /*hasReceiver*/ false);
                return expression ? factory.createExpressionStatement(expression) : undefined;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForInStatementInAsyncBody(node) {
            return factory.updateForInStatement(node, isVariableDeclarationListWithCollidingName(node.initializer)
                ? visitVariableDeclarationListWithCollidingNames(node.initializer, /*hasReceiver*/ true)
                : ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, asyncBodyVisitor, context));
        }
        function visitForOfStatementInAsyncBody(node) {
            return factory.updateForOfStatement(node, ts.visitNode(node.awaitModifier, visitor, ts.isToken), isVariableDeclarationListWithCollidingName(node.initializer)
                ? visitVariableDeclarationListWithCollidingNames(node.initializer, /*hasReceiver*/ true)
                : ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, asyncBodyVisitor, context));
        }
        function visitForStatementInAsyncBody(node) {
            var initializer = node.initializer; // TODO: GH#18217
            return factory.updateForStatement(node, isVariableDeclarationListWithCollidingName(initializer)
                ? visitVariableDeclarationListWithCollidingNames(initializer, /*hasReceiver*/ false)
                : ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitor, ts.isExpression), ts.visitIterationBody(node.statement, asyncBodyVisitor, context));
        }
        /**
         * Visits an AwaitExpression node.
         *
         * This function will be called any time a ES2017 await expression is encountered.
         *
         * @param node The node to visit.
         */
        function visitAwaitExpression(node) {
            // do not downlevel a top-level await as it is module syntax...
            if (inTopLevelContext()) {
                return ts.visitEachChild(node, visitor, context);
            }
            return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(
            /*asteriskToken*/ undefined, ts.visitNode(node.expression, visitor, ts.isExpression)), node), node);
        }
        /**
         * Visits a MethodDeclaration node.
         *
         * This function will be called when one of the following conditions are met:
         * - The node is marked as async
         *
         * @param node The node to visit.
         */
        function visitMethodDeclaration(node) {
            return factory.updateMethodDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, node.name, 
            /*questionToken*/ undefined, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.getFunctionFlags(node) & 2 /* Async */
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        /**
         * Visits a FunctionDeclaration node.
         *
         * This function will be called when one of the following conditions are met:
         * - The node is marked async
         *
         * @param node The node to visit.
         */
        function visitFunctionDeclaration(node) {
            return factory.updateFunctionDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.getFunctionFlags(node) & 2 /* Async */
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        /**
         * Visits a FunctionExpression node.
         *
         * This function will be called when one of the following conditions are met:
         * - The node is marked async
         *
         * @param node The node to visit.
         */
        function visitFunctionExpression(node) {
            return factory.updateFunctionExpression(node, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.getFunctionFlags(node) & 2 /* Async */
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        /**
         * Visits an ArrowFunction.
         *
         * This function will be called when one of the following conditions are met:
         * - The node is marked async
         *
         * @param node The node to visit.
         */
        function visitArrowFunction(node) {
            return factory.updateArrowFunction(node, ts.visitNodes(node.modifiers, visitor, ts.isModifier), 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, node.equalsGreaterThanToken, ts.getFunctionFlags(node) & 2 /* Async */
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        function recordDeclarationName(_a, names) {
            var name = _a.name;
            if (ts.isIdentifier(name)) {
                names.add(name.escapedText);
            }
            else {
                for (var _i = 0, _b = name.elements; _i < _b.length; _i++) {
                    var element = _b[_i];
                    if (!ts.isOmittedExpression(element)) {
                        recordDeclarationName(element, names);
                    }
                }
            }
        }
        function isVariableDeclarationListWithCollidingName(node) {
            return !!node
                && ts.isVariableDeclarationList(node)
                && !(node.flags & 3 /* BlockScoped */)
                && node.declarations.some(collidesWithParameterName);
        }
        function visitVariableDeclarationListWithCollidingNames(node, hasReceiver) {
            hoistVariableDeclarationList(node);
            var variables = ts.getInitializedVariables(node);
            if (variables.length === 0) {
                if (hasReceiver) {
                    return ts.visitNode(factory.converters.convertToAssignmentElementTarget(node.declarations[0].name), visitor, ts.isExpression);
                }
                return undefined;
            }
            return factory.inlineExpressions(ts.map(variables, transformInitializedVariable));
        }
        function hoistVariableDeclarationList(node) {
            ts.forEach(node.declarations, hoistVariable);
        }
        function hoistVariable(_a) {
            var name = _a.name;
            if (ts.isIdentifier(name)) {
                hoistVariableDeclaration(name);
            }
            else {
                for (var _i = 0, _b = name.elements; _i < _b.length; _i++) {
                    var element = _b[_i];
                    if (!ts.isOmittedExpression(element)) {
                        hoistVariable(element);
                    }
                }
            }
        }
        function transformInitializedVariable(node) {
            var converted = ts.setSourceMapRange(factory.createAssignment(factory.converters.convertToAssignmentElementTarget(node.name), node.initializer), node);
            return ts.visitNode(converted, visitor, ts.isExpression);
        }
        function collidesWithParameterName(_a) {
            var name = _a.name;
            if (ts.isIdentifier(name)) {
                return enclosingFunctionParameterNames.has(name.escapedText);
            }
            else {
                for (var _i = 0, _b = name.elements; _i < _b.length; _i++) {
                    var element = _b[_i];
                    if (!ts.isOmittedExpression(element) && collidesWithParameterName(element)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function transformAsyncFunctionBody(node) {
            resumeLexicalEnvironment();
            var original = ts.getOriginalNode(node, ts.isFunctionLike);
            var nodeType = original.type;
            var promiseConstructor = languageVersion < 2 /* ES2015 */ ? getPromiseConstructor(nodeType) : undefined;
            var isArrowFunction = node.kind === 212 /* ArrowFunction */;
            var hasLexicalArguments = (resolver.getNodeCheckFlags(node) & 8192 /* CaptureArguments */) !== 0;
            // An async function is emit as an outer function that calls an inner
            // generator function. To preserve lexical bindings, we pass the current
            // `this` and `arguments` objects to `__awaiter`. The generator function
            // passed to `__awaiter` is executed inside of the callback to the
            // promise constructor.
            var savedEnclosingFunctionParameterNames = enclosingFunctionParameterNames;
            enclosingFunctionParameterNames = new ts.Set();
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                recordDeclarationName(parameter, enclosingFunctionParameterNames);
            }
            var savedCapturedSuperProperties = capturedSuperProperties;
            var savedHasSuperElementAccess = hasSuperElementAccess;
            if (!isArrowFunction) {
                capturedSuperProperties = new ts.Set();
                hasSuperElementAccess = false;
            }
            var result;
            if (!isArrowFunction) {
                var statements = [];
                var statementOffset = factory.copyPrologue(node.body.statements, statements, /*ensureUseStrict*/ false, visitor);
                statements.push(factory.createReturnStatement(emitHelpers().createAwaiterHelper(inHasLexicalThisContext(), hasLexicalArguments, promiseConstructor, transformAsyncFunctionBodyWorker(node.body, statementOffset))));
                ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
                // Minor optimization, emit `_super` helper to capture `super` access in an arrow.
                // This step isn't needed if we eventually transform this to ES5.
                var emitSuperHelpers = languageVersion >= 2 /* ES2015 */ && resolver.getNodeCheckFlags(node) & (4096 /* AsyncMethodWithSuperBinding */ | 2048 /* AsyncMethodWithSuper */);
                if (emitSuperHelpers) {
                    enableSubstitutionForAsyncMethodsWithSuper();
                    if (capturedSuperProperties.size) {
                        var variableStatement = createSuperAccessVariableStatement(factory, resolver, node, capturedSuperProperties);
                        substitutedSuperAccessors[ts.getNodeId(variableStatement)] = true;
                        ts.insertStatementsAfterStandardPrologue(statements, [variableStatement]);
                    }
                }
                var block = factory.createBlock(statements, /*multiLine*/ true);
                ts.setTextRange(block, node.body);
                if (emitSuperHelpers && hasSuperElementAccess) {
                    // Emit helpers for super element access expressions (`super[x]`).
                    if (resolver.getNodeCheckFlags(node) & 4096 /* AsyncMethodWithSuperBinding */) {
                        ts.addEmitHelper(block, ts.advancedAsyncSuperHelper);
                    }
                    else if (resolver.getNodeCheckFlags(node) & 2048 /* AsyncMethodWithSuper */) {
                        ts.addEmitHelper(block, ts.asyncSuperHelper);
                    }
                }
                result = block;
            }
            else {
                var expression = emitHelpers().createAwaiterHelper(inHasLexicalThisContext(), hasLexicalArguments, promiseConstructor, transformAsyncFunctionBodyWorker(node.body));
                var declarations = endLexicalEnvironment();
                if (ts.some(declarations)) {
                    var block = factory.converters.convertToFunctionBlock(expression);
                    result = factory.updateBlock(block, ts.setTextRange(factory.createNodeArray(ts.concatenate(declarations, block.statements)), block.statements));
                }
                else {
                    result = expression;
                }
            }
            enclosingFunctionParameterNames = savedEnclosingFunctionParameterNames;
            if (!isArrowFunction) {
                capturedSuperProperties = savedCapturedSuperProperties;
                hasSuperElementAccess = savedHasSuperElementAccess;
            }
            return result;
        }
        function transformAsyncFunctionBodyWorker(body, start) {
            if (ts.isBlock(body)) {
                return factory.updateBlock(body, ts.visitNodes(body.statements, asyncBodyVisitor, ts.isStatement, start));
            }
            else {
                return factory.converters.convertToFunctionBlock(ts.visitNode(body, asyncBodyVisitor, ts.isConciseBody));
            }
        }
        function getPromiseConstructor(type) {
            var typeName = type && ts.getEntityNameFromTypeNode(type);
            if (typeName && ts.isEntityName(typeName)) {
                var serializationKind = resolver.getTypeReferenceSerializationKind(typeName);
                if (serializationKind === ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue
                    || serializationKind === ts.TypeReferenceSerializationKind.Unknown) {
                    return typeName;
                }
            }
            return undefined;
        }
        function enableSubstitutionForAsyncMethodsWithSuper() {
            if ((enabledSubstitutions & 1 /* AsyncMethodsWithSuper */) === 0) {
                enabledSubstitutions |= 1 /* AsyncMethodsWithSuper */;
                // We need to enable substitutions for call, property access, and element access
                // if we need to rewrite super calls.
                context.enableSubstitution(206 /* CallExpression */);
                context.enableSubstitution(204 /* PropertyAccessExpression */);
                context.enableSubstitution(205 /* ElementAccessExpression */);
                // We need to be notified when entering and exiting declarations that bind super.
                context.enableEmitNotification(255 /* ClassDeclaration */);
                context.enableEmitNotification(167 /* MethodDeclaration */);
                context.enableEmitNotification(170 /* GetAccessor */);
                context.enableEmitNotification(171 /* SetAccessor */);
                context.enableEmitNotification(169 /* Constructor */);
                // We need to be notified when entering the generated accessor arrow functions.
                context.enableEmitNotification(235 /* VariableStatement */);
            }
        }
        /**
         * Hook for node emit.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to emit.
         * @param emit A callback used to emit the node in the printer.
         */
        function onEmitNode(hint, node, emitCallback) {
            // If we need to support substitutions for `super` in an async method,
            // we should track it here.
            if (enabledSubstitutions & 1 /* AsyncMethodsWithSuper */ && isSuperContainer(node)) {
                var superContainerFlags = resolver.getNodeCheckFlags(node) & (2048 /* AsyncMethodWithSuper */ | 4096 /* AsyncMethodWithSuperBinding */);
                if (superContainerFlags !== enclosingSuperContainerFlags) {
                    var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                    enclosingSuperContainerFlags = superContainerFlags;
                    previousOnEmitNode(hint, node, emitCallback);
                    enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                    return;
                }
            }
            // Disable substitution in the generated super accessor itself.
            else if (enabledSubstitutions && substitutedSuperAccessors[ts.getNodeId(node)]) {
                var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                enclosingSuperContainerFlags = 0;
                previousOnEmitNode(hint, node, emitCallback);
                enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                return;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        /**
         * Hooks node substitutions.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to substitute.
         */
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 /* Expression */ && enclosingSuperContainerFlags) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 204 /* PropertyAccessExpression */:
                    return substitutePropertyAccessExpression(node);
                case 205 /* ElementAccessExpression */:
                    return substituteElementAccessExpression(node);
                case 206 /* CallExpression */:
                    return substituteCallExpression(node);
            }
            return node;
        }
        function substitutePropertyAccessExpression(node) {
            if (node.expression.kind === 106 /* SuperKeyword */) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createUniqueName("_super", 16 /* Optimistic */ | 32 /* FileLevel */), node.name), node);
            }
            return node;
        }
        function substituteElementAccessExpression(node) {
            if (node.expression.kind === 106 /* SuperKeyword */) {
                return createSuperElementAccessInAsyncMethod(node.argumentExpression, node);
            }
            return node;
        }
        function substituteCallExpression(node) {
            var expression = node.expression;
            if (ts.isSuperProperty(expression)) {
                var argumentExpression = ts.isPropertyAccessExpression(expression)
                    ? substitutePropertyAccessExpression(expression)
                    : substituteElementAccessExpression(expression);
                return factory.createCallExpression(factory.createPropertyAccessExpression(argumentExpression, "call"), 
                /*typeArguments*/ undefined, __spreadArray([
                    factory.createThis()
                ], node.arguments, true));
            }
            return node;
        }
        function isSuperContainer(node) {
            var kind = node.kind;
            return kind === 255 /* ClassDeclaration */
                || kind === 169 /* Constructor */
                || kind === 167 /* MethodDeclaration */
                || kind === 170 /* GetAccessor */
                || kind === 171 /* SetAccessor */;
        }
        function createSuperElementAccessInAsyncMethod(argumentExpression, location) {
            if (enclosingSuperContainerFlags & 4096 /* AsyncMethodWithSuperBinding */) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createCallExpression(factory.createUniqueName("_superIndex", 16 /* Optimistic */ | 32 /* FileLevel */), 
                /*typeArguments*/ undefined, [argumentExpression]), "value"), location);
            }
            else {
                return ts.setTextRange(factory.createCallExpression(factory.createUniqueName("_superIndex", 16 /* Optimistic */ | 32 /* FileLevel */), 
                /*typeArguments*/ undefined, [argumentExpression]), location);
            }
        }
    }
    ts.transformES2017 = transformES2017;
    /** Creates a variable named `_super` with accessor properties for the given property names. */
    function createSuperAccessVariableStatement(factory, resolver, node, names) {
        // Create a variable declaration with a getter/setter (if binding) definition for each name:
        //   const _super = Object.create(null, { x: { get: () => super.x, set: (v) => super.x = v }, ... });
        var hasBinding = (resolver.getNodeCheckFlags(node) & 4096 /* AsyncMethodWithSuperBinding */) !== 0;
        var accessors = [];
        names.forEach(function (_, key) {
            var name = ts.unescapeLeadingUnderscores(key);
            var getterAndSetter = [];
            getterAndSetter.push(factory.createPropertyAssignment("get", factory.createArrowFunction(
            /* modifiers */ undefined, 
            /* typeParameters */ undefined, 
            /* parameters */ [], 
            /* type */ undefined, 
            /* equalsGreaterThanToken */ undefined, ts.setEmitFlags(factory.createPropertyAccessExpression(ts.setEmitFlags(factory.createSuper(), 4 /* NoSubstitution */), name), 4 /* NoSubstitution */))));
            if (hasBinding) {
                getterAndSetter.push(factory.createPropertyAssignment("set", factory.createArrowFunction(
                /* modifiers */ undefined, 
                /* typeParameters */ undefined, 
                /* parameters */ [
                    factory.createParameterDeclaration(
                    /* decorators */ undefined, 
                    /* modifiers */ undefined, 
                    /* dotDotDotToken */ undefined, "v", 
                    /* questionToken */ undefined, 
                    /* type */ undefined, 
                    /* initializer */ undefined)
                ], 
                /* type */ undefined, 
                /* equalsGreaterThanToken */ undefined, factory.createAssignment(ts.setEmitFlags(factory.createPropertyAccessExpression(ts.setEmitFlags(factory.createSuper(), 4 /* NoSubstitution */), name), 4 /* NoSubstitution */), factory.createIdentifier("v")))));
            }
            accessors.push(factory.createPropertyAssignment(name, factory.createObjectLiteralExpression(getterAndSetter)));
        });
        return factory.createVariableStatement(
        /* modifiers */ undefined, factory.createVariableDeclarationList([
            factory.createVariableDeclaration(factory.createUniqueName("_super", 16 /* Optimistic */ | 32 /* FileLevel */), 
            /*exclamationToken*/ undefined, 
            /* type */ undefined, factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "create"), 
            /* typeArguments */ undefined, [
                factory.createNull(),
                factory.createObjectLiteralExpression(accessors, /* multiline */ true)
            ]))
        ], 2 /* Const */));
    }
    ts.createSuperAccessVariableStatement = createSuperAccessVariableStatement;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ESNextSubstitutionFlags;
    (function (ESNextSubstitutionFlags) {
        /** Enables substitutions for async methods with `super` calls. */
        ESNextSubstitutionFlags[ESNextSubstitutionFlags["AsyncMethodsWithSuper"] = 1] = "AsyncMethodsWithSuper";
    })(ESNextSubstitutionFlags || (ESNextSubstitutionFlags = {}));
    // Facts we track as we traverse the tree
    var HierarchyFacts;
    (function (HierarchyFacts) {
        HierarchyFacts[HierarchyFacts["None"] = 0] = "None";
        //
        // Ancestor facts
        //
        HierarchyFacts[HierarchyFacts["HasLexicalThis"] = 1] = "HasLexicalThis";
        HierarchyFacts[HierarchyFacts["IterationContainer"] = 2] = "IterationContainer";
        // NOTE: do not add more ancestor flags without also updating AncestorFactsMask below.
        //
        // Ancestor masks
        //
        HierarchyFacts[HierarchyFacts["AncestorFactsMask"] = 3] = "AncestorFactsMask";
        HierarchyFacts[HierarchyFacts["SourceFileIncludes"] = 1] = "SourceFileIncludes";
        HierarchyFacts[HierarchyFacts["SourceFileExcludes"] = 2] = "SourceFileExcludes";
        HierarchyFacts[HierarchyFacts["StrictModeSourceFileIncludes"] = 0] = "StrictModeSourceFileIncludes";
        HierarchyFacts[HierarchyFacts["ClassOrFunctionIncludes"] = 1] = "ClassOrFunctionIncludes";
        HierarchyFacts[HierarchyFacts["ClassOrFunctionExcludes"] = 2] = "ClassOrFunctionExcludes";
        HierarchyFacts[HierarchyFacts["ArrowFunctionIncludes"] = 0] = "ArrowFunctionIncludes";
        HierarchyFacts[HierarchyFacts["ArrowFunctionExcludes"] = 2] = "ArrowFunctionExcludes";
        HierarchyFacts[HierarchyFacts["IterationStatementIncludes"] = 2] = "IterationStatementIncludes";
        HierarchyFacts[HierarchyFacts["IterationStatementExcludes"] = 0] = "IterationStatementExcludes";
    })(HierarchyFacts || (HierarchyFacts = {}));
    function transformES2018(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var exportedVariableStatement = false;
        var enabledSubstitutions;
        var enclosingFunctionFlags;
        var enclosingSuperContainerFlags = 0;
        var hierarchyFacts = 0;
        var currentSourceFile;
        var taggedTemplateStringDeclarations;
        /** Keeps track of property names accessed on super (`super.x`) within async functions. */
        var capturedSuperProperties;
        /** Whether the async function contains an element access on super (`super[x]`). */
        var hasSuperElementAccess;
        /** A set of node IDs for generated super accessors. */
        var substitutedSuperAccessors = [];
        return ts.chainBundle(context, transformSourceFile);
        function affectsSubtree(excludeFacts, includeFacts) {
            return hierarchyFacts !== (hierarchyFacts & ~excludeFacts | includeFacts);
        }
        /**
         * Sets the `HierarchyFacts` for this node prior to visiting this node's subtree, returning the facts set prior to modification.
         * @param excludeFacts The existing `HierarchyFacts` to reset before visiting the subtree.
         * @param includeFacts The new `HierarchyFacts` to set before visiting the subtree.
         */
        function enterSubtree(excludeFacts, includeFacts) {
            var ancestorFacts = hierarchyFacts;
            hierarchyFacts = (hierarchyFacts & ~excludeFacts | includeFacts) & 3 /* AncestorFactsMask */;
            return ancestorFacts;
        }
        /**
         * Restores the `HierarchyFacts` for this node's ancestor after visiting this node's
         * subtree.
         * @param ancestorFacts The `HierarchyFacts` of the ancestor to restore after visiting the subtree.
         */
        function exitSubtree(ancestorFacts) {
            hierarchyFacts = ancestorFacts;
        }
        function recordTaggedTemplateString(temp) {
            taggedTemplateStringDeclarations = ts.append(taggedTemplateStringDeclarations, factory.createVariableDeclaration(temp));
        }
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            var visited = visitSourceFile(node);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            taggedTemplateStringDeclarations = undefined;
            return visited;
        }
        function visitor(node) {
            return visitorWorker(node, /*expressionResultIsUnused*/ false);
        }
        function visitorWithUnusedExpressionResult(node) {
            return visitorWorker(node, /*expressionResultIsUnused*/ true);
        }
        function visitorNoAsyncModifier(node) {
            if (node.kind === 130 /* AsyncKeyword */) {
                return undefined;
            }
            return node;
        }
        function doWithHierarchyFacts(cb, value, excludeFacts, includeFacts) {
            if (affectsSubtree(excludeFacts, includeFacts)) {
                var ancestorFacts = enterSubtree(excludeFacts, includeFacts);
                var result = cb(value);
                exitSubtree(ancestorFacts);
                return result;
            }
            return cb(value);
        }
        function visitDefault(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * @param expressionResultIsUnused Indicates the result of an expression is unused by the parent node (i.e., the left side of a comma or the
         * expression of an `ExpressionStatement`).
         */
        function visitorWorker(node, expressionResultIsUnused) {
            if ((node.transformFlags & 64 /* ContainsES2018 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 216 /* AwaitExpression */:
                    return visitAwaitExpression(node);
                case 222 /* YieldExpression */:
                    return visitYieldExpression(node);
                case 245 /* ReturnStatement */:
                    return visitReturnStatement(node);
                case 248 /* LabeledStatement */:
                    return visitLabeledStatement(node);
                case 203 /* ObjectLiteralExpression */:
                    return visitObjectLiteralExpression(node);
                case 219 /* BinaryExpression */:
                    return visitBinaryExpression(node, expressionResultIsUnused);
                case 346 /* CommaListExpression */:
                    return visitCommaListExpression(node, expressionResultIsUnused);
                case 290 /* CatchClause */:
                    return visitCatchClause(node);
                case 235 /* VariableStatement */:
                    return visitVariableStatement(node);
                case 252 /* VariableDeclaration */:
                    return visitVariableDeclaration(node);
                case 238 /* DoStatement */:
                case 239 /* WhileStatement */:
                case 241 /* ForInStatement */:
                    return doWithHierarchyFacts(visitDefault, node, 0 /* IterationStatementExcludes */, 2 /* IterationStatementIncludes */);
                case 242 /* ForOfStatement */:
                    return visitForOfStatement(node, /*outermostLabeledStatement*/ undefined);
                case 240 /* ForStatement */:
                    return doWithHierarchyFacts(visitForStatement, node, 0 /* IterationStatementExcludes */, 2 /* IterationStatementIncludes */);
                case 215 /* VoidExpression */:
                    return visitVoidExpression(node);
                case 169 /* Constructor */:
                    return doWithHierarchyFacts(visitConstructorDeclaration, node, 2 /* ClassOrFunctionExcludes */, 1 /* ClassOrFunctionIncludes */);
                case 167 /* MethodDeclaration */:
                    return doWithHierarchyFacts(visitMethodDeclaration, node, 2 /* ClassOrFunctionExcludes */, 1 /* ClassOrFunctionIncludes */);
                case 170 /* GetAccessor */:
                    return doWithHierarchyFacts(visitGetAccessorDeclaration, node, 2 /* ClassOrFunctionExcludes */, 1 /* ClassOrFunctionIncludes */);
                case 171 /* SetAccessor */:
                    return doWithHierarchyFacts(visitSetAccessorDeclaration, node, 2 /* ClassOrFunctionExcludes */, 1 /* ClassOrFunctionIncludes */);
                case 254 /* FunctionDeclaration */:
                    return doWithHierarchyFacts(visitFunctionDeclaration, node, 2 /* ClassOrFunctionExcludes */, 1 /* ClassOrFunctionIncludes */);
                case 211 /* FunctionExpression */:
                    return doWithHierarchyFacts(visitFunctionExpression, node, 2 /* ClassOrFunctionExcludes */, 1 /* ClassOrFunctionIncludes */);
                case 212 /* ArrowFunction */:
                    return doWithHierarchyFacts(visitArrowFunction, node, 2 /* ArrowFunctionExcludes */, 0 /* ArrowFunctionIncludes */);
                case 162 /* Parameter */:
                    return visitParameter(node);
                case 236 /* ExpressionStatement */:
                    return visitExpressionStatement(node);
                case 210 /* ParenthesizedExpression */:
                    return visitParenthesizedExpression(node, expressionResultIsUnused);
                case 208 /* TaggedTemplateExpression */:
                    return visitTaggedTemplateExpression(node);
                case 204 /* PropertyAccessExpression */:
                    if (capturedSuperProperties && ts.isPropertyAccessExpression(node) && node.expression.kind === 106 /* SuperKeyword */) {
                        capturedSuperProperties.add(node.name.escapedText);
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 205 /* ElementAccessExpression */:
                    if (capturedSuperProperties && node.expression.kind === 106 /* SuperKeyword */) {
                        hasSuperElementAccess = true;
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 255 /* ClassDeclaration */:
                case 224 /* ClassExpression */:
                    return doWithHierarchyFacts(visitDefault, node, 2 /* ClassOrFunctionExcludes */, 1 /* ClassOrFunctionIncludes */);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitAwaitExpression(node) {
            if (enclosingFunctionFlags & 2 /* Async */ && enclosingFunctionFlags & 1 /* Generator */) {
                return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(/*asteriskToken*/ undefined, emitHelpers().createAwaitHelper(ts.visitNode(node.expression, visitor, ts.isExpression))), 
                /*location*/ node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitYieldExpression(node) {
            if (enclosingFunctionFlags & 2 /* Async */ && enclosingFunctionFlags & 1 /* Generator */) {
                if (node.asteriskToken) {
                    var expression = ts.visitNode(ts.Debug.assertDefined(node.expression), visitor, ts.isExpression);
                    return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(
                    /*asteriskToken*/ undefined, emitHelpers().createAwaitHelper(factory.updateYieldExpression(node, node.asteriskToken, ts.setTextRange(emitHelpers().createAsyncDelegatorHelper(ts.setTextRange(emitHelpers().createAsyncValuesHelper(expression), expression)), expression)))), node), node);
                }
                return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(
                /*asteriskToken*/ undefined, createDownlevelAwait(node.expression
                    ? ts.visitNode(node.expression, visitor, ts.isExpression)
                    : factory.createVoidZero())), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitReturnStatement(node) {
            if (enclosingFunctionFlags & 2 /* Async */ && enclosingFunctionFlags & 1 /* Generator */) {
                return factory.updateReturnStatement(node, createDownlevelAwait(node.expression ? ts.visitNode(node.expression, visitor, ts.isExpression) : factory.createVoidZero()));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitLabeledStatement(node) {
            if (enclosingFunctionFlags & 2 /* Async */) {
                var statement = ts.unwrapInnermostStatementOfLabel(node);
                if (statement.kind === 242 /* ForOfStatement */ && statement.awaitModifier) {
                    return visitForOfStatement(statement, node);
                }
                return factory.restoreEnclosingLabel(ts.visitNode(statement, visitor, ts.isStatement, factory.liftToBlock), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function chunkObjectLiteralElements(elements) {
            var chunkObject;
            var objects = [];
            for (var _i = 0, elements_4 = elements; _i < elements_4.length; _i++) {
                var e = elements_4[_i];
                if (e.kind === 293 /* SpreadAssignment */) {
                    if (chunkObject) {
                        objects.push(factory.createObjectLiteralExpression(chunkObject));
                        chunkObject = undefined;
                    }
                    var target = e.expression;
                    objects.push(ts.visitNode(target, visitor, ts.isExpression));
                }
                else {
                    chunkObject = ts.append(chunkObject, e.kind === 291 /* PropertyAssignment */
                        ? factory.createPropertyAssignment(e.name, ts.visitNode(e.initializer, visitor, ts.isExpression))
                        : ts.visitNode(e, visitor, ts.isObjectLiteralElementLike));
                }
            }
            if (chunkObject) {
                objects.push(factory.createObjectLiteralExpression(chunkObject));
            }
            return objects;
        }
        function visitObjectLiteralExpression(node) {
            if (node.transformFlags & 32768 /* ContainsObjectRestOrSpread */) {
                // spread elements emit like so:
                // non-spread elements are chunked together into object literals, and then all are passed to __assign:
                //     { a, ...o, b } => __assign(__assign({a}, o), {b});
                // If the first element is a spread element, then the first argument to __assign is {}:
                //     { ...o, a, b, ...o2 } => __assign(__assign(__assign({}, o), {a, b}), o2)
                //
                // We cannot call __assign with more than two elements, since any element could cause side effects. For
                // example:
                //      var k = { a: 1, b: 2 };
                //      var o = { a: 3, ...k, b: k.a++ };
                //      // expected: { a: 1, b: 1 }
                // If we translate the above to `__assign({ a: 3 }, k, { b: k.a++ })`, the `k.a++` will evaluate before
                // `k` is spread and we end up with `{ a: 2, b: 1 }`.
                //
                // This also occurs for spread elements, not just property assignments:
                //      var k = { a: 1, get b() { l = { z: 9 }; return 2; } };
                //      var l = { c: 3 };
                //      var o = { ...k, ...l };
                //      // expected: { a: 1, b: 2, z: 9 }
                // If we translate the above to `__assign({}, k, l)`, the `l` will evaluate before `k` is spread and we
                // end up with `{ a: 1, b: 2, c: 3 }`
                var objects = chunkObjectLiteralElements(node.properties);
                if (objects.length && objects[0].kind !== 203 /* ObjectLiteralExpression */) {
                    objects.unshift(factory.createObjectLiteralExpression());
                }
                var expression = objects[0];
                if (objects.length > 1) {
                    for (var i = 1; i < objects.length; i++) {
                        expression = emitHelpers().createAssignHelper([expression, objects[i]]);
                    }
                    return expression;
                }
                else {
                    return emitHelpers().createAssignHelper(objects);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitExpressionStatement(node) {
            return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
        }
        /**
         * @param expressionResultIsUnused Indicates the result of an expression is unused by the parent node (i.e., the left side of a comma or the
         * expression of an `ExpressionStatement`).
         */
        function visitParenthesizedExpression(node, expressionResultIsUnused) {
            return ts.visitEachChild(node, expressionResultIsUnused ? visitorWithUnusedExpressionResult : visitor, context);
        }
        function visitSourceFile(node) {
            var ancestorFacts = enterSubtree(2 /* SourceFileExcludes */, ts.isEffectiveStrictModeSourceFile(node, compilerOptions) ?
                0 /* StrictModeSourceFileIncludes */ :
                1 /* SourceFileIncludes */);
            exportedVariableStatement = false;
            var visited = ts.visitEachChild(node, visitor, context);
            var statement = ts.concatenate(visited.statements, taggedTemplateStringDeclarations && [
                factory.createVariableStatement(/*modifiers*/ undefined, factory.createVariableDeclarationList(taggedTemplateStringDeclarations))
            ]);
            var result = factory.updateSourceFile(visited, ts.setTextRange(factory.createNodeArray(statement), node.statements));
            exitSubtree(ancestorFacts);
            return result;
        }
        function visitTaggedTemplateExpression(node) {
            return ts.processTaggedTemplateExpression(context, node, visitor, currentSourceFile, recordTaggedTemplateString, ts.ProcessLevel.LiftRestriction);
        }
        /**
         * Visits a BinaryExpression that contains a destructuring assignment.
         *
         * @param node A BinaryExpression node.
         * @param expressionResultIsUnused Indicates the result of an expression is unused by the parent node (i.e., the left side of a comma or the
         * expression of an `ExpressionStatement`).
         */
        function visitBinaryExpression(node, expressionResultIsUnused) {
            if (ts.isDestructuringAssignment(node) && node.left.transformFlags & 32768 /* ContainsObjectRestOrSpread */) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 1 /* ObjectRest */, !expressionResultIsUnused);
            }
            if (node.operatorToken.kind === 27 /* CommaToken */) {
                return factory.updateBinaryExpression(node, ts.visitNode(node.left, visitorWithUnusedExpressionResult, ts.isExpression), node.operatorToken, ts.visitNode(node.right, expressionResultIsUnused ? visitorWithUnusedExpressionResult : visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * @param expressionResultIsUnused Indicates the result of an expression is unused by the parent node (i.e., the left side of a comma or the
         * expression of an `ExpressionStatement`).
         */
        function visitCommaListExpression(node, expressionResultIsUnused) {
            if (expressionResultIsUnused) {
                return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
            }
            var result;
            for (var i = 0; i < node.elements.length; i++) {
                var element = node.elements[i];
                var visited = ts.visitNode(element, i < node.elements.length - 1 ? visitorWithUnusedExpressionResult : visitor, ts.isExpression);
                if (result || visited !== element) {
                    result || (result = node.elements.slice(0, i));
                    result.push(visited);
                }
            }
            var elements = result ? ts.setTextRange(factory.createNodeArray(result), node.elements) : node.elements;
            return factory.updateCommaListExpression(node, elements);
        }
        function visitCatchClause(node) {
            if (node.variableDeclaration &&
                ts.isBindingPattern(node.variableDeclaration.name) &&
                node.variableDeclaration.name.transformFlags & 32768 /* ContainsObjectRestOrSpread */) {
                var name = factory.getGeneratedNameForNode(node.variableDeclaration.name);
                var updatedDecl = factory.updateVariableDeclaration(node.variableDeclaration, node.variableDeclaration.name, /*exclamationToken*/ undefined, /*type*/ undefined, name);
                var visitedBindings = ts.flattenDestructuringBinding(updatedDecl, visitor, context, 1 /* ObjectRest */);
                var block = ts.visitNode(node.block, visitor, ts.isBlock);
                if (ts.some(visitedBindings)) {
                    block = factory.updateBlock(block, __spreadArray([
                        factory.createVariableStatement(/*modifiers*/ undefined, visitedBindings)
                    ], block.statements, true));
                }
                return factory.updateCatchClause(node, factory.updateVariableDeclaration(node.variableDeclaration, name, /*exclamationToken*/ undefined, /*type*/ undefined, /*initializer*/ undefined), block);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitVariableStatement(node) {
            if (ts.hasSyntacticModifier(node, 1 /* Export */)) {
                var savedExportedVariableStatement = exportedVariableStatement;
                exportedVariableStatement = true;
                var visited = ts.visitEachChild(node, visitor, context);
                exportedVariableStatement = savedExportedVariableStatement;
                return visited;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * Visits a VariableDeclaration node with a binding pattern.
         *
         * @param node A VariableDeclaration node.
         */
        function visitVariableDeclaration(node) {
            if (exportedVariableStatement) {
                var savedExportedVariableStatement = exportedVariableStatement;
                exportedVariableStatement = false;
                var visited = visitVariableDeclarationWorker(node, /*exportedVariableStatement*/ true);
                exportedVariableStatement = savedExportedVariableStatement;
                return visited;
            }
            return visitVariableDeclarationWorker(node, /*exportedVariableStatement*/ false);
        }
        function visitVariableDeclarationWorker(node, exportedVariableStatement) {
            // If we are here it is because the name contains a binding pattern with a rest somewhere in it.
            if (ts.isBindingPattern(node.name) && node.name.transformFlags & 32768 /* ContainsObjectRestOrSpread */) {
                return ts.flattenDestructuringBinding(node, visitor, context, 1 /* ObjectRest */, 
                /*rval*/ undefined, exportedVariableStatement);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForStatement(node) {
            return factory.updateForStatement(node, ts.visitNode(node.initializer, visitorWithUnusedExpressionResult, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitorWithUnusedExpressionResult, ts.isExpression), ts.visitIterationBody(node.statement, visitor, context));
        }
        function visitVoidExpression(node) {
            return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
        }
        /**
         * Visits a ForOfStatement and converts it into a ES2015-compatible ForOfStatement.
         *
         * @param node A ForOfStatement.
         */
        function visitForOfStatement(node, outermostLabeledStatement) {
            var ancestorFacts = enterSubtree(0 /* IterationStatementExcludes */, 2 /* IterationStatementIncludes */);
            if (node.initializer.transformFlags & 32768 /* ContainsObjectRestOrSpread */) {
                node = transformForOfStatementWithObjectRest(node);
            }
            var result = node.awaitModifier ?
                transformForAwaitOfStatement(node, outermostLabeledStatement, ancestorFacts) :
                factory.restoreEnclosingLabel(ts.visitEachChild(node, visitor, context), outermostLabeledStatement);
            exitSubtree(ancestorFacts);
            return result;
        }
        function transformForOfStatementWithObjectRest(node) {
            var initializerWithoutParens = ts.skipParentheses(node.initializer);
            if (ts.isVariableDeclarationList(initializerWithoutParens) || ts.isAssignmentPattern(initializerWithoutParens)) {
                var bodyLocation = void 0;
                var statementsLocation = void 0;
                var temp = factory.createTempVariable(/*recordTempVariable*/ undefined);
                var statements = [ts.createForOfBindingStatement(factory, initializerWithoutParens, temp)];
                if (ts.isBlock(node.statement)) {
                    ts.addRange(statements, node.statement.statements);
                    bodyLocation = node.statement;
                    statementsLocation = node.statement.statements;
                }
                else if (node.statement) {
                    ts.append(statements, node.statement);
                    bodyLocation = node.statement;
                    statementsLocation = node.statement;
                }
                return factory.updateForOfStatement(node, node.awaitModifier, ts.setTextRange(factory.createVariableDeclarationList([
                    ts.setTextRange(factory.createVariableDeclaration(temp), node.initializer)
                ], 1 /* Let */), node.initializer), node.expression, ts.setTextRange(factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), statementsLocation), 
                /*multiLine*/ true), bodyLocation));
            }
            return node;
        }
        function convertForOfStatementHead(node, boundValue) {
            var binding = ts.createForOfBindingStatement(factory, node.initializer, boundValue);
            var bodyLocation;
            var statementsLocation;
            var statements = [ts.visitNode(binding, visitor, ts.isStatement)];
            var statement = ts.visitIterationBody(node.statement, visitor, context);
            if (ts.isBlock(statement)) {
                ts.addRange(statements, statement.statements);
                bodyLocation = statement;
                statementsLocation = statement.statements;
            }
            else {
                statements.push(statement);
            }
            return ts.setEmitFlags(ts.setTextRange(factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), statementsLocation), 
            /*multiLine*/ true), bodyLocation), 48 /* NoSourceMap */ | 384 /* NoTokenSourceMaps */);
        }
        function createDownlevelAwait(expression) {
            return enclosingFunctionFlags & 1 /* Generator */
                ? factory.createYieldExpression(/*asteriskToken*/ undefined, emitHelpers().createAwaitHelper(expression))
                : factory.createAwaitExpression(expression);
        }
        function transformForAwaitOfStatement(node, outermostLabeledStatement, ancestorFacts) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var iterator = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(expression) : factory.createTempVariable(/*recordTempVariable*/ undefined);
            var result = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(iterator) : factory.createTempVariable(/*recordTempVariable*/ undefined);
            var errorRecord = factory.createUniqueName("e");
            var catchVariable = factory.getGeneratedNameForNode(errorRecord);
            var returnMethod = factory.createTempVariable(/*recordTempVariable*/ undefined);
            var callValues = ts.setTextRange(emitHelpers().createAsyncValuesHelper(expression), node.expression);
            var callNext = factory.createCallExpression(factory.createPropertyAccessExpression(iterator, "next"), /*typeArguments*/ undefined, []);
            var getDone = factory.createPropertyAccessExpression(result, "done");
            var getValue = factory.createPropertyAccessExpression(result, "value");
            var callReturn = factory.createFunctionCallCall(returnMethod, iterator, []);
            hoistVariableDeclaration(errorRecord);
            hoistVariableDeclaration(returnMethod);
            // if we are enclosed in an outer loop ensure we reset 'errorRecord' per each iteration
            var initializer = ancestorFacts & 2 /* IterationContainer */ ?
                factory.inlineExpressions([factory.createAssignment(errorRecord, factory.createVoidZero()), callValues]) :
                callValues;
            var forStatement = ts.setEmitFlags(ts.setTextRange(factory.createForStatement(
            /*initializer*/ ts.setEmitFlags(ts.setTextRange(factory.createVariableDeclarationList([
                ts.setTextRange(factory.createVariableDeclaration(iterator, /*exclamationToken*/ undefined, /*type*/ undefined, initializer), node.expression),
                factory.createVariableDeclaration(result)
            ]), node.expression), 2097152 /* NoHoisting */), 
            /*condition*/ factory.createComma(factory.createAssignment(result, createDownlevelAwait(callNext)), factory.createLogicalNot(getDone)), 
            /*incrementor*/ undefined, 
            /*statement*/ convertForOfStatementHead(node, getValue)), 
            /*location*/ node), 256 /* NoTokenTrailingSourceMaps */);
            return factory.createTryStatement(factory.createBlock([
                factory.restoreEnclosingLabel(forStatement, outermostLabeledStatement)
            ]), factory.createCatchClause(factory.createVariableDeclaration(catchVariable), ts.setEmitFlags(factory.createBlock([
                factory.createExpressionStatement(factory.createAssignment(errorRecord, factory.createObjectLiteralExpression([
                    factory.createPropertyAssignment("error", catchVariable)
                ])))
            ]), 1 /* SingleLine */)), factory.createBlock([
                factory.createTryStatement(
                /*tryBlock*/ factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(factory.createLogicalAnd(factory.createLogicalAnd(result, factory.createLogicalNot(getDone)), factory.createAssignment(returnMethod, factory.createPropertyAccessExpression(iterator, "return"))), factory.createExpressionStatement(createDownlevelAwait(callReturn))), 1 /* SingleLine */)
                ]), 
                /*catchClause*/ undefined, 
                /*finallyBlock*/ ts.setEmitFlags(factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(errorRecord, factory.createThrowStatement(factory.createPropertyAccessExpression(errorRecord, "error"))), 1 /* SingleLine */)
                ]), 1 /* SingleLine */))
            ]));
        }
        function visitParameter(node) {
            if (node.transformFlags & 32768 /* ContainsObjectRestOrSpread */) {
                // Binding patterns are converted into a generated name and are
                // evaluated inside the function body.
                return factory.updateParameterDeclaration(node, 
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, node.dotDotDotToken, factory.getGeneratedNameForNode(node), 
                /*questionToken*/ undefined, 
                /*type*/ undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitConstructorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = 0 /* Normal */;
            var updated = factory.updateConstructorDeclaration(node, 
            /*decorators*/ undefined, node.modifiers, ts.visitParameterList(node.parameters, visitor, context), transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function visitGetAccessorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = 0 /* Normal */;
            var updated = factory.updateGetAccessorDeclaration(node, 
            /*decorators*/ undefined, node.modifiers, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function visitSetAccessorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = 0 /* Normal */;
            var updated = factory.updateSetAccessorDeclaration(node, 
            /*decorators*/ undefined, node.modifiers, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitParameterList(node.parameters, visitor, context), transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function visitMethodDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            var updated = factory.updateMethodDeclaration(node, 
            /*decorators*/ undefined, enclosingFunctionFlags & 1 /* Generator */
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2 /* Async */
                ? undefined
                : node.asteriskToken, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitNode(/*questionToken*/ undefined, visitor, ts.isToken), 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, enclosingFunctionFlags & 2 /* Async */ && enclosingFunctionFlags & 1 /* Generator */
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function visitFunctionDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            var updated = factory.updateFunctionDeclaration(node, 
            /*decorators*/ undefined, enclosingFunctionFlags & 1 /* Generator */
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2 /* Async */
                ? undefined
                : node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, enclosingFunctionFlags & 2 /* Async */ && enclosingFunctionFlags & 1 /* Generator */
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function visitArrowFunction(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            var updated = factory.updateArrowFunction(node, node.modifiers, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, node.equalsGreaterThanToken, transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function visitFunctionExpression(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            var updated = factory.updateFunctionExpression(node, enclosingFunctionFlags & 1 /* Generator */
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2 /* Async */
                ? undefined
                : node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, enclosingFunctionFlags & 2 /* Async */ && enclosingFunctionFlags & 1 /* Generator */
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function transformAsyncGeneratorFunctionBody(node) {
            resumeLexicalEnvironment();
            var statements = [];
            var statementOffset = factory.copyPrologue(node.body.statements, statements, /*ensureUseStrict*/ false, visitor);
            appendObjectRestAssignmentsIfNeeded(statements, node);
            var savedCapturedSuperProperties = capturedSuperProperties;
            var savedHasSuperElementAccess = hasSuperElementAccess;
            capturedSuperProperties = new ts.Set();
            hasSuperElementAccess = false;
            var returnStatement = factory.createReturnStatement(emitHelpers().createAsyncGeneratorHelper(factory.createFunctionExpression(
            /*modifiers*/ undefined, factory.createToken(41 /* AsteriskToken */), node.name && factory.getGeneratedNameForNode(node.name), 
            /*typeParameters*/ undefined, 
            /*parameters*/ [], 
            /*type*/ undefined, factory.updateBlock(node.body, ts.visitLexicalEnvironment(node.body.statements, visitor, context, statementOffset))), !!(hierarchyFacts & 1 /* HasLexicalThis */)));
            // Minor optimization, emit `_super` helper to capture `super` access in an arrow.
            // This step isn't needed if we eventually transform this to ES5.
            var emitSuperHelpers = languageVersion >= 2 /* ES2015 */ && resolver.getNodeCheckFlags(node) & (4096 /* AsyncMethodWithSuperBinding */ | 2048 /* AsyncMethodWithSuper */);
            if (emitSuperHelpers) {
                enableSubstitutionForAsyncMethodsWithSuper();
                var variableStatement = ts.createSuperAccessVariableStatement(factory, resolver, node, capturedSuperProperties);
                substitutedSuperAccessors[ts.getNodeId(variableStatement)] = true;
                ts.insertStatementsAfterStandardPrologue(statements, [variableStatement]);
            }
            statements.push(returnStatement);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            var block = factory.updateBlock(node.body, statements);
            if (emitSuperHelpers && hasSuperElementAccess) {
                if (resolver.getNodeCheckFlags(node) & 4096 /* AsyncMethodWithSuperBinding */) {
                    ts.addEmitHelper(block, ts.advancedAsyncSuperHelper);
                }
                else if (resolver.getNodeCheckFlags(node) & 2048 /* AsyncMethodWithSuper */) {
                    ts.addEmitHelper(block, ts.asyncSuperHelper);
                }
            }
            capturedSuperProperties = savedCapturedSuperProperties;
            hasSuperElementAccess = savedHasSuperElementAccess;
            return block;
        }
        function transformFunctionBody(node) {
            var _a;
            resumeLexicalEnvironment();
            var statementOffset = 0;
            var statements = [];
            var body = (_a = ts.visitNode(node.body, visitor, ts.isConciseBody)) !== null && _a !== void 0 ? _a : factory.createBlock([]);
            if (ts.isBlock(body)) {
                statementOffset = factory.copyPrologue(body.statements, statements, /*ensureUseStrict*/ false, visitor);
            }
            ts.addRange(statements, appendObjectRestAssignmentsIfNeeded(/*statements*/ undefined, node));
            var leadingStatements = endLexicalEnvironment();
            if (statementOffset > 0 || ts.some(statements) || ts.some(leadingStatements)) {
                var block = factory.converters.convertToFunctionBlock(body, /*multiLine*/ true);
                ts.insertStatementsAfterStandardPrologue(statements, leadingStatements);
                ts.addRange(statements, block.statements.slice(statementOffset));
                return factory.updateBlock(block, ts.setTextRange(factory.createNodeArray(statements), block.statements));
            }
            return body;
        }
        function appendObjectRestAssignmentsIfNeeded(statements, node) {
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                if (parameter.transformFlags & 32768 /* ContainsObjectRestOrSpread */) {
                    var temp = factory.getGeneratedNameForNode(parameter);
                    var declarations = ts.flattenDestructuringBinding(parameter, visitor, context, 1 /* ObjectRest */, temp, 
                    /*doNotRecordTempVariablesInLine*/ false, 
                    /*skipInitializer*/ true);
                    if (ts.some(declarations)) {
                        var statement = factory.createVariableStatement(
                        /*modifiers*/ undefined, factory.createVariableDeclarationList(declarations));
                        ts.setEmitFlags(statement, 1048576 /* CustomPrologue */);
                        statements = ts.append(statements, statement);
                    }
                }
            }
            return statements;
        }
        function enableSubstitutionForAsyncMethodsWithSuper() {
            if ((enabledSubstitutions & 1 /* AsyncMethodsWithSuper */) === 0) {
                enabledSubstitutions |= 1 /* AsyncMethodsWithSuper */;
                // We need to enable substitutions for call, property access, and element access
                // if we need to rewrite super calls.
                context.enableSubstitution(206 /* CallExpression */);
                context.enableSubstitution(204 /* PropertyAccessExpression */);
                context.enableSubstitution(205 /* ElementAccessExpression */);
                // We need to be notified when entering and exiting declarations that bind super.
                context.enableEmitNotification(255 /* ClassDeclaration */);
                context.enableEmitNotification(167 /* MethodDeclaration */);
                context.enableEmitNotification(170 /* GetAccessor */);
                context.enableEmitNotification(171 /* SetAccessor */);
                context.enableEmitNotification(169 /* Constructor */);
                // We need to be notified when entering the generated accessor arrow functions.
                context.enableEmitNotification(235 /* VariableStatement */);
            }
        }
        /**
         * Called by the printer just before a node is printed.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to be printed.
         * @param emitCallback The callback used to emit the node.
         */
        function onEmitNode(hint, node, emitCallback) {
            // If we need to support substitutions for `super` in an async method,
            // we should track it here.
            if (enabledSubstitutions & 1 /* AsyncMethodsWithSuper */ && isSuperContainer(node)) {
                var superContainerFlags = resolver.getNodeCheckFlags(node) & (2048 /* AsyncMethodWithSuper */ | 4096 /* AsyncMethodWithSuperBinding */);
                if (superContainerFlags !== enclosingSuperContainerFlags) {
                    var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                    enclosingSuperContainerFlags = superContainerFlags;
                    previousOnEmitNode(hint, node, emitCallback);
                    enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                    return;
                }
            }
            // Disable substitution in the generated super accessor itself.
            else if (enabledSubstitutions && substitutedSuperAccessors[ts.getNodeId(node)]) {
                var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                enclosingSuperContainerFlags = 0;
                previousOnEmitNode(hint, node, emitCallback);
                enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                return;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        /**
         * Hooks node substitutions.
         *
         * @param hint The context for the emitter.
         * @param node The node to substitute.
         */
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 /* Expression */ && enclosingSuperContainerFlags) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 204 /* PropertyAccessExpression */:
                    return substitutePropertyAccessExpression(node);
                case 205 /* ElementAccessExpression */:
                    return substituteElementAccessExpression(node);
                case 206 /* CallExpression */:
                    return substituteCallExpression(node);
            }
            return node;
        }
        function substitutePropertyAccessExpression(node) {
            if (node.expression.kind === 106 /* SuperKeyword */) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createUniqueName("_super", 16 /* Optimistic */ | 32 /* FileLevel */), node.name), node);
            }
            return node;
        }
        function substituteElementAccessExpression(node) {
            if (node.expression.kind === 106 /* SuperKeyword */) {
                return createSuperElementAccessInAsyncMethod(node.argumentExpression, node);
            }
            return node;
        }
        function substituteCallExpression(node) {
            var expression = node.expression;
            if (ts.isSuperProperty(expression)) {
                var argumentExpression = ts.isPropertyAccessExpression(expression)
                    ? substitutePropertyAccessExpression(expression)
                    : substituteElementAccessExpression(expression);
                return factory.createCallExpression(factory.createPropertyAccessExpression(argumentExpression, "call"), 
                /*typeArguments*/ undefined, __spreadArray([
                    factory.createThis()
                ], node.arguments, true));
            }
            return node;
        }
        function isSuperContainer(node) {
            var kind = node.kind;
            return kind === 255 /* ClassDeclaration */
                || kind === 169 /* Constructor */
                || kind === 167 /* MethodDeclaration */
                || kind === 170 /* GetAccessor */
                || kind === 171 /* SetAccessor */;
        }
        function createSuperElementAccessInAsyncMethod(argumentExpression, location) {
            if (enclosingSuperContainerFlags & 4096 /* AsyncMethodWithSuperBinding */) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createCallExpression(factory.createIdentifier("_superIndex"), 
                /*typeArguments*/ undefined, [argumentExpression]), "value"), location);
            }
            else {
                return ts.setTextRange(factory.createCallExpression(factory.createIdentifier("_superIndex"), 
                /*typeArguments*/ undefined, [argumentExpression]), location);
            }
        }
    }
    ts.transformES2018 = transformES2018;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformES2019(context) {
        var factory = context.factory;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 32 /* ContainsES2019 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 290 /* CatchClause */:
                    return visitCatchClause(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitCatchClause(node) {
            if (!node.variableDeclaration) {
                return factory.updateCatchClause(node, factory.createVariableDeclaration(factory.createTempVariable(/*recordTempVariable*/ undefined)), ts.visitNode(node.block, visitor, ts.isBlock));
            }
            return ts.visitEachChild(node, visitor, context);
        }
    }
    ts.transformES2019 = transformES2019;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformES2020(context) {
        var factory = context.factory, hoistVariableDeclaration = context.hoistVariableDeclaration;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 16 /* ContainsES2020 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 206 /* CallExpression */: {
                    var updated = visitNonOptionalCallExpression(node, /*captureThisArg*/ false);
                    ts.Debug.assertNotNode(updated, ts.isSyntheticReference);
                    return updated;
                }
                case 204 /* PropertyAccessExpression */:
                case 205 /* ElementAccessExpression */:
                    if (ts.isOptionalChain(node)) {
                        var updated = visitOptionalExpression(node, /*captureThisArg*/ false, /*isDelete*/ false);
                        ts.Debug.assertNotNode(updated, ts.isSyntheticReference);
                        return updated;
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 219 /* BinaryExpression */:
                    if (node.operatorToken.kind === 60 /* QuestionQuestionToken */) {
                        return transformNullishCoalescingExpression(node);
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 213 /* DeleteExpression */:
                    return visitDeleteExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function flattenChain(chain) {
            ts.Debug.assertNotNode(chain, ts.isNonNullChain);
            var links = [chain];
            while (!chain.questionDotToken && !ts.isTaggedTemplateExpression(chain)) {
                chain = ts.cast(ts.skipPartiallyEmittedExpressions(chain.expression), ts.isOptionalChain);
                ts.Debug.assertNotNode(chain, ts.isNonNullChain);
                links.unshift(chain);
            }
            return { expression: chain.expression, chain: links };
        }
        function visitNonOptionalParenthesizedExpression(node, captureThisArg, isDelete) {
            var expression = visitNonOptionalExpression(node.expression, captureThisArg, isDelete);
            if (ts.isSyntheticReference(expression)) {
                // `(a.b)` -> { expression `((_a = a).b)`, thisArg: `_a` }
                // `(a[b])` -> { expression `((_a = a)[b])`, thisArg: `_a` }
                return factory.createSyntheticReferenceExpression(factory.updateParenthesizedExpression(node, expression.expression), expression.thisArg);
            }
            return factory.updateParenthesizedExpression(node, expression);
        }
        function visitNonOptionalPropertyOrElementAccessExpression(node, captureThisArg, isDelete) {
            if (ts.isOptionalChain(node)) {
                // If `node` is an optional chain, then it is the outermost chain of an optional expression.
                return visitOptionalExpression(node, captureThisArg, isDelete);
            }
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            ts.Debug.assertNotNode(expression, ts.isSyntheticReference);
            var thisArg;
            if (captureThisArg) {
                if (!ts.isSimpleCopiableExpression(expression)) {
                    thisArg = factory.createTempVariable(hoistVariableDeclaration);
                    expression = factory.createAssignment(thisArg, expression);
                }
                else {
                    thisArg = expression;
                }
            }
            expression = node.kind === 204 /* PropertyAccessExpression */
                ? factory.updatePropertyAccessExpression(node, expression, ts.visitNode(node.name, visitor, ts.isIdentifier))
                : factory.updateElementAccessExpression(node, expression, ts.visitNode(node.argumentExpression, visitor, ts.isExpression));
            return thisArg ? factory.createSyntheticReferenceExpression(expression, thisArg) : expression;
        }
        function visitNonOptionalCallExpression(node, captureThisArg) {
            if (ts.isOptionalChain(node)) {
                // If `node` is an optional chain, then it is the outermost chain of an optional expression.
                return visitOptionalExpression(node, captureThisArg, /*isDelete*/ false);
            }
            if (ts.isParenthesizedExpression(node.expression) && ts.isOptionalChain(ts.skipParentheses(node.expression))) {
                // capture thisArg for calls of parenthesized optional chains like `(foo?.bar)()`
                var expression = visitNonOptionalParenthesizedExpression(node.expression, /*captureThisArg*/ true, /*isDelete*/ false);
                var args = ts.visitNodes(node.arguments, visitor, ts.isExpression);
                if (ts.isSyntheticReference(expression)) {
                    return ts.setTextRange(factory.createFunctionCallCall(expression.expression, expression.thisArg, args), node);
                }
                return factory.updateCallExpression(node, expression, /*typeArguments*/ undefined, args);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitNonOptionalExpression(node, captureThisArg, isDelete) {
            switch (node.kind) {
                case 210 /* ParenthesizedExpression */: return visitNonOptionalParenthesizedExpression(node, captureThisArg, isDelete);
                case 204 /* PropertyAccessExpression */:
                case 205 /* ElementAccessExpression */: return visitNonOptionalPropertyOrElementAccessExpression(node, captureThisArg, isDelete);
                case 206 /* CallExpression */: return visitNonOptionalCallExpression(node, captureThisArg);
                default: return ts.visitNode(node, visitor, ts.isExpression);
            }
        }
        function visitOptionalExpression(node, captureThisArg, isDelete) {
            var _a = flattenChain(node), expression = _a.expression, chain = _a.chain;
            var left = visitNonOptionalExpression(expression, ts.isCallChain(chain[0]), /*isDelete*/ false);
            var leftThisArg = ts.isSyntheticReference(left) ? left.thisArg : undefined;
            var leftExpression = ts.isSyntheticReference(left) ? left.expression : left;
            var capturedLeft = leftExpression;
            if (!ts.isSimpleCopiableExpression(leftExpression)) {
                capturedLeft = factory.createTempVariable(hoistVariableDeclaration);
                leftExpression = factory.createAssignment(capturedLeft, leftExpression);
            }
            var rightExpression = capturedLeft;
            var thisArg;
            for (var i = 0; i < chain.length; i++) {
                var segment = chain[i];
                switch (segment.kind) {
                    case 204 /* PropertyAccessExpression */:
                    case 205 /* ElementAccessExpression */:
                        if (i === chain.length - 1 && captureThisArg) {
                            if (!ts.isSimpleCopiableExpression(rightExpression)) {
                                thisArg = factory.createTempVariable(hoistVariableDeclaration);
                                rightExpression = factory.createAssignment(thisArg, rightExpression);
                            }
                            else {
                                thisArg = rightExpression;
                            }
                        }
                        rightExpression = segment.kind === 204 /* PropertyAccessExpression */
                            ? factory.createPropertyAccessExpression(rightExpression, ts.visitNode(segment.name, visitor, ts.isIdentifier))
                            : factory.createElementAccessExpression(rightExpression, ts.visitNode(segment.argumentExpression, visitor, ts.isExpression));
                        break;
                    case 206 /* CallExpression */:
                        if (i === 0 && leftThisArg) {
                            rightExpression = factory.createFunctionCallCall(rightExpression, leftThisArg.kind === 106 /* SuperKeyword */ ? factory.createThis() : leftThisArg, ts.visitNodes(segment.arguments, visitor, ts.isExpression));
                        }
                        else {
                            rightExpression = factory.createCallExpression(rightExpression, 
                            /*typeArguments*/ undefined, ts.visitNodes(segment.arguments, visitor, ts.isExpression));
                        }
                        break;
                }
                ts.setOriginalNode(rightExpression, segment);
            }
            var target = isDelete
                ? factory.createConditionalExpression(createNotNullCondition(leftExpression, capturedLeft, /*invert*/ true), /*questionToken*/ undefined, factory.createTrue(), /*colonToken*/ undefined, factory.createDeleteExpression(rightExpression))
                : factory.createConditionalExpression(createNotNullCondition(leftExpression, capturedLeft, /*invert*/ true), /*questionToken*/ undefined, factory.createVoidZero(), /*colonToken*/ undefined, rightExpression);
            ts.setTextRange(target, node);
            return thisArg ? factory.createSyntheticReferenceExpression(target, thisArg) : target;
        }
        function createNotNullCondition(left, right, invert) {
            return factory.createBinaryExpression(factory.createBinaryExpression(left, factory.createToken(invert ? 36 /* EqualsEqualsEqualsToken */ : 37 /* ExclamationEqualsEqualsToken */), factory.createNull()), factory.createToken(invert ? 56 /* BarBarToken */ : 55 /* AmpersandAmpersandToken */), factory.createBinaryExpression(right, factory.createToken(invert ? 36 /* EqualsEqualsEqualsToken */ : 37 /* ExclamationEqualsEqualsToken */), factory.createVoidZero()));
        }
        function transformNullishCoalescingExpression(node) {
            var left = ts.visitNode(node.left, visitor, ts.isExpression);
            var right = left;
            if (!ts.isSimpleCopiableExpression(left)) {
                right = factory.createTempVariable(hoistVariableDeclaration);
                left = factory.createAssignment(right, left);
            }
            return ts.setTextRange(factory.createConditionalExpression(createNotNullCondition(left, right), 
            /*questionToken*/ undefined, right, 
            /*colonToken*/ undefined, ts.visitNode(node.right, visitor, ts.isExpression)), node);
        }
        function visitDeleteExpression(node) {
            return ts.isOptionalChain(ts.skipParentheses(node.expression))
                ? ts.setOriginalNode(visitNonOptionalExpression(node.expression, /*captureThisArg*/ false, /*isDelete*/ true), node)
                : factory.updateDeleteExpression(node, ts.visitNode(node.expression, visitor, ts.isExpression));
        }
    }
    ts.transformES2020 = transformES2020;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformES2021(context) {
        var hoistVariableDeclaration = context.hoistVariableDeclaration, factory = context.factory;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 8 /* ContainsES2021 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 219 /* BinaryExpression */:
                    var binaryExpression = node;
                    if (ts.isLogicalOrCoalescingAssignmentExpression(binaryExpression)) {
                        return transformLogicalAssignment(binaryExpression);
                    }
                // falls through
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformLogicalAssignment(binaryExpression) {
            var operator = binaryExpression.operatorToken;
            var nonAssignmentOperator = ts.getNonAssignmentOperatorForCompoundAssignment(operator.kind);
            var left = ts.skipParentheses(ts.visitNode(binaryExpression.left, visitor, ts.isLeftHandSideExpression));
            var assignmentTarget = left;
            var right = ts.skipParentheses(ts.visitNode(binaryExpression.right, visitor, ts.isExpression));
            if (ts.isAccessExpression(left)) {
                var propertyAccessTargetSimpleCopiable = ts.isSimpleCopiableExpression(left.expression);
                var propertyAccessTarget = propertyAccessTargetSimpleCopiable ? left.expression :
                    factory.createTempVariable(hoistVariableDeclaration);
                var propertyAccessTargetAssignment = propertyAccessTargetSimpleCopiable ? left.expression : factory.createAssignment(propertyAccessTarget, left.expression);
                if (ts.isPropertyAccessExpression(left)) {
                    assignmentTarget = factory.createPropertyAccessExpression(propertyAccessTarget, left.name);
                    left = factory.createPropertyAccessExpression(propertyAccessTargetAssignment, left.name);
                }
                else {
                    var elementAccessArgumentSimpleCopiable = ts.isSimpleCopiableExpression(left.argumentExpression);
                    var elementAccessArgument = elementAccessArgumentSimpleCopiable ? left.argumentExpression :
                        factory.createTempVariable(hoistVariableDeclaration);
                    assignmentTarget = factory.createElementAccessExpression(propertyAccessTarget, elementAccessArgument);
                    left = factory.createElementAccessExpression(propertyAccessTargetAssignment, elementAccessArgumentSimpleCopiable ? left.argumentExpression : factory.createAssignment(elementAccessArgument, left.argumentExpression));
                }
            }
            return factory.createBinaryExpression(left, nonAssignmentOperator, factory.createParenthesizedExpression(factory.createAssignment(assignmentTarget, right)));
        }
    }
    ts.transformES2021 = transformES2021;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformESNext(context) {
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 4 /* ContainsESNext */) === 0) {
                return node;
            }
            switch (node.kind) {
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
    }
    ts.transformESNext = transformESNext;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformJsx(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory;
        var compilerOptions = context.getCompilerOptions();
        var currentSourceFile;
        var currentFileState;
        return ts.chainBundle(context, transformSourceFile);
        function getCurrentFileNameExpression() {
            if (currentFileState.filenameDeclaration) {
                return currentFileState.filenameDeclaration.name;
            }
            var declaration = factory.createVariableDeclaration(factory.createUniqueName("_jsxFileName", 16 /* Optimistic */ | 32 /* FileLevel */), /*exclaimationToken*/ undefined, /*type*/ undefined, factory.createStringLiteral(currentSourceFile.fileName));
            currentFileState.filenameDeclaration = declaration;
            return currentFileState.filenameDeclaration.name;
        }
        function getJsxFactoryCalleePrimitive(childrenLength) {
            return compilerOptions.jsx === 5 /* ReactJSXDev */ ? "jsxDEV" : childrenLength > 1 ? "jsxs" : "jsx";
        }
        function getJsxFactoryCallee(childrenLength) {
            var type = getJsxFactoryCalleePrimitive(childrenLength);
            return getImplicitImportForName(type);
        }
        function getImplicitJsxFragmentReference() {
            return getImplicitImportForName("Fragment");
        }
        function getImplicitImportForName(name) {
            var _a, _b;
            var importSource = name === "createElement"
                ? currentFileState.importSpecifier
                : ts.getJSXRuntimeImport(currentFileState.importSpecifier, compilerOptions);
            var existing = (_b = (_a = currentFileState.utilizedImplicitRuntimeImports) === null || _a === void 0 ? void 0 : _a.get(importSource)) === null || _b === void 0 ? void 0 : _b.get(name);
            if (existing) {
                return existing.name;
            }
            if (!currentFileState.utilizedImplicitRuntimeImports) {
                currentFileState.utilizedImplicitRuntimeImports = ts.createMap();
            }
            var specifierSourceImports = currentFileState.utilizedImplicitRuntimeImports.get(importSource);
            if (!specifierSourceImports) {
                specifierSourceImports = ts.createMap();
                currentFileState.utilizedImplicitRuntimeImports.set(importSource, specifierSourceImports);
            }
            var generatedName = factory.createUniqueName("_" + name, 16 /* Optimistic */ | 32 /* FileLevel */ | 64 /* AllowNameSubstitution */);
            var specifier = factory.createImportSpecifier(factory.createIdentifier(name), generatedName);
            generatedName.generatedImportReference = specifier;
            specifierSourceImports.set(name, specifier);
            return generatedName;
        }
        /**
         * Transform JSX-specific syntax in a SourceFile.
         *
         * @param node A SourceFile node.
         */
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            currentFileState = {};
            currentFileState.importSpecifier = ts.getJSXImplicitImportBase(compilerOptions, node);
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            var statements = visited.statements;
            if (currentFileState.filenameDeclaration) {
                statements = ts.insertStatementAfterCustomPrologue(statements.slice(), factory.createVariableStatement(/*modifiers*/ undefined, factory.createVariableDeclarationList([currentFileState.filenameDeclaration], 2 /* Const */)));
            }
            if (currentFileState.utilizedImplicitRuntimeImports) {
                for (var _i = 0, _a = ts.arrayFrom(currentFileState.utilizedImplicitRuntimeImports.entries()); _i < _a.length; _i++) {
                    var _b = _a[_i], importSource = _b[0], importSpecifiersMap = _b[1];
                    if (ts.isExternalModule(node)) {
                        // Add `import` statement
                        var importStatement = factory.createImportDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, factory.createImportClause(/*typeOnly*/ false, /*name*/ undefined, factory.createNamedImports(ts.arrayFrom(importSpecifiersMap.values()))), factory.createStringLiteral(importSource));
                        ts.setParentRecursive(importStatement, /*incremental*/ false);
                        statements = ts.insertStatementAfterCustomPrologue(statements.slice(), importStatement);
                    }
                    else if (ts.isExternalOrCommonJsModule(node)) {
                        // Add `require` statement
                        var requireStatement = factory.createVariableStatement(/*modifiers*/ undefined, factory.createVariableDeclarationList([
                            factory.createVariableDeclaration(factory.createObjectBindingPattern(ts.map(ts.arrayFrom(importSpecifiersMap.values()), function (s) { return factory.createBindingElement(/*dotdotdot*/ undefined, s.propertyName, s.name); })), 
                            /*exclaimationToken*/ undefined, 
                            /*type*/ undefined, factory.createCallExpression(factory.createIdentifier("require"), /*typeArguments*/ undefined, [factory.createStringLiteral(importSource)]))
                        ], 2 /* Const */));
                        ts.setParentRecursive(requireStatement, /*incremental*/ false);
                        statements = ts.insertStatementAfterCustomPrologue(statements.slice(), requireStatement);
                    }
                    else {
                        // Do nothing (script file) - consider an error in the checker?
                    }
                }
            }
            if (statements !== visited.statements) {
                visited = factory.updateSourceFile(visited, statements);
            }
            currentFileState = undefined;
            return visited;
        }
        function visitor(node) {
            if (node.transformFlags & 2 /* ContainsJsx */) {
                return visitorWorker(node);
            }
            else {
                return node;
            }
        }
        function visitorWorker(node) {
            switch (node.kind) {
                case 276 /* JsxElement */:
                    return visitJsxElement(node, /*isChild*/ false);
                case 277 /* JsxSelfClosingElement */:
                    return visitJsxSelfClosingElement(node, /*isChild*/ false);
                case 280 /* JsxFragment */:
                    return visitJsxFragment(node, /*isChild*/ false);
                case 286 /* JsxExpression */:
                    return visitJsxExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformJsxChildToExpression(node) {
            switch (node.kind) {
                case 11 /* JsxText */:
                    return visitJsxText(node);
                case 286 /* JsxExpression */:
                    return visitJsxExpression(node);
                case 276 /* JsxElement */:
                    return visitJsxElement(node, /*isChild*/ true);
                case 277 /* JsxSelfClosingElement */:
                    return visitJsxSelfClosingElement(node, /*isChild*/ true);
                case 280 /* JsxFragment */:
                    return visitJsxFragment(node, /*isChild*/ true);
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
        }
        /**
         * The react jsx/jsxs transform falls back to `createElement` when an explicit `key` argument comes after a spread
         */
        function hasKeyAfterPropsSpread(node) {
            var spread = false;
            for (var _i = 0, _a = node.attributes.properties; _i < _a.length; _i++) {
                var elem = _a[_i];
                if (ts.isJsxSpreadAttribute(elem)) {
                    spread = true;
                }
                else if (spread && ts.isJsxAttribute(elem) && elem.name.escapedText === "key") {
                    return true;
                }
            }
            return false;
        }
        function shouldUseCreateElement(node) {
            return currentFileState.importSpecifier === undefined || hasKeyAfterPropsSpread(node);
        }
        function visitJsxElement(node, isChild) {
            var tagTransform = shouldUseCreateElement(node.openingElement) ? visitJsxOpeningLikeElementCreateElement : visitJsxOpeningLikeElementJSX;
            return tagTransform(node.openingElement, node.children, isChild, /*location*/ node);
        }
        function visitJsxSelfClosingElement(node, isChild) {
            var tagTransform = shouldUseCreateElement(node) ? visitJsxOpeningLikeElementCreateElement : visitJsxOpeningLikeElementJSX;
            return tagTransform(node, /*children*/ undefined, isChild, /*location*/ node);
        }
        function visitJsxFragment(node, isChild) {
            var tagTransform = currentFileState.importSpecifier === undefined ? visitJsxOpeningFragmentCreateElement : visitJsxOpeningFragmentJSX;
            return tagTransform(node.openingFragment, node.children, isChild, /*location*/ node);
        }
        function convertJsxChildrenToChildrenPropObject(children) {
            var nonWhitespaceChildren = ts.getSemanticJsxChildren(children);
            if (ts.length(nonWhitespaceChildren) === 1) {
                var result_13 = transformJsxChildToExpression(nonWhitespaceChildren[0]);
                return result_13 && factory.createObjectLiteralExpression([
                    factory.createPropertyAssignment("children", result_13)
                ]);
            }
            var result = ts.mapDefined(children, transformJsxChildToExpression);
            return !result.length ? undefined : factory.createObjectLiteralExpression([
                factory.createPropertyAssignment("children", factory.createArrayLiteralExpression(result))
            ]);
        }
        function visitJsxOpeningLikeElementJSX(node, children, isChild, location) {
            var tagName = getTagName(node);
            var objectProperties;
            var keyAttr = ts.find(node.attributes.properties, function (p) { return !!p.name && ts.isIdentifier(p.name) && p.name.escapedText === "key"; });
            var attrs = keyAttr ? ts.filter(node.attributes.properties, function (p) { return p !== keyAttr; }) : node.attributes.properties;
            var segments = [];
            if (attrs.length) {
                // Map spans of JsxAttribute nodes into object literals and spans
                // of JsxSpreadAttribute nodes into expressions.
                segments = ts.flatten(ts.spanMap(attrs, ts.isJsxSpreadAttribute, function (attrs, isSpread) { return isSpread
                    ? ts.map(attrs, transformJsxSpreadAttributeToExpression)
                    : factory.createObjectLiteralExpression(ts.map(attrs, transformJsxAttributeToObjectLiteralElement)); }));
                if (ts.isJsxSpreadAttribute(attrs[0])) {
                    // We must always emit at least one object literal before a spread
                    // argument.factory.createObjectLiteral
                    segments.unshift(factory.createObjectLiteralExpression());
                }
            }
            if (children && children.length) {
                var result = convertJsxChildrenToChildrenPropObject(children);
                if (result) {
                    segments.push(result);
                }
            }
            if (segments.length === 0) {
                objectProperties = factory.createObjectLiteralExpression([]);
                // When there are no attributes, React wants {}
            }
            else {
                // Either emit one big object literal (no spread attribs), or
                // a call to the __assign helper.
                objectProperties = ts.singleOrUndefined(segments) || emitHelpers().createAssignHelper(segments);
            }
            return visitJsxOpeningLikeElementOrFragmentJSX(tagName, objectProperties, keyAttr, ts.length(ts.getSemanticJsxChildren(children || ts.emptyArray)), isChild, location);
        }
        function visitJsxOpeningLikeElementOrFragmentJSX(tagName, objectProperties, keyAttr, childrenLength, isChild, location) {
            var args = [tagName, objectProperties, !keyAttr ? factory.createVoidZero() : transformJsxAttributeInitializer(keyAttr.initializer)];
            if (compilerOptions.jsx === 5 /* ReactJSXDev */) {
                var originalFile = ts.getOriginalNode(currentSourceFile);
                if (originalFile && ts.isSourceFile(originalFile)) {
                    // isStaticChildren development flag
                    args.push(childrenLength > 1 ? factory.createTrue() : factory.createFalse());
                    // __source development flag
                    var lineCol = ts.getLineAndCharacterOfPosition(originalFile, location.pos);
                    args.push(factory.createObjectLiteralExpression([
                        factory.createPropertyAssignment("fileName", getCurrentFileNameExpression()),
                        factory.createPropertyAssignment("lineNumber", factory.createNumericLiteral(lineCol.line + 1)),
                        factory.createPropertyAssignment("columnNumber", factory.createNumericLiteral(lineCol.character + 1))
                    ]));
                    // __self development flag
                    args.push(factory.createThis());
                }
            }
            var element = ts.setTextRange(factory.createCallExpression(getJsxFactoryCallee(childrenLength), /*typeArguments*/ undefined, args), location);
            if (isChild) {
                ts.startOnNewLine(element);
            }
            return element;
        }
        function visitJsxOpeningLikeElementCreateElement(node, children, isChild, location) {
            var tagName = getTagName(node);
            var objectProperties;
            var attrs = node.attributes.properties;
            if (attrs.length === 0) {
                objectProperties = factory.createNull();
                // When there are no attributes, React wants "null"
            }
            else {
                var target = compilerOptions.target;
                if (target && target >= 5 /* ES2018 */) {
                    objectProperties = factory.createObjectLiteralExpression(ts.flatten(ts.spanMap(attrs, ts.isJsxSpreadAttribute, function (attrs, isSpread) {
                        return isSpread ? ts.map(attrs, transformJsxSpreadAttributeToSpreadAssignment) : ts.map(attrs, transformJsxAttributeToObjectLiteralElement);
                    })));
                }
                else {
                    // Map spans of JsxAttribute nodes into object literals and spans
                    // of JsxSpreadAttribute nodes into expressions.
                    var segments = ts.flatten(ts.spanMap(attrs, ts.isJsxSpreadAttribute, function (attrs, isSpread) { return isSpread
                        ? ts.map(attrs, transformJsxSpreadAttributeToExpression)
                        : factory.createObjectLiteralExpression(ts.map(attrs, transformJsxAttributeToObjectLiteralElement)); }));
                    if (ts.isJsxSpreadAttribute(attrs[0])) {
                        // We must always emit at least one object literal before a spread
                        // argument.factory.createObjectLiteral
                        segments.unshift(factory.createObjectLiteralExpression());
                    }
                    // Either emit one big object literal (no spread attribs), or
                    // a call to the __assign helper.
                    objectProperties = ts.singleOrUndefined(segments);
                    if (!objectProperties) {
                        objectProperties = emitHelpers().createAssignHelper(segments);
                    }
                }
            }
            var callee = currentFileState.importSpecifier === undefined
                ? ts.createJsxFactoryExpression(factory, context.getEmitResolver().getJsxFactoryEntity(currentSourceFile), compilerOptions.reactNamespace, // TODO: GH#18217
                node)
                : getImplicitImportForName("createElement");
            var element = ts.createExpressionForJsxElement(factory, callee, tagName, objectProperties, ts.mapDefined(children, transformJsxChildToExpression), location);
            if (isChild) {
                ts.startOnNewLine(element);
            }
            return element;
        }
        function visitJsxOpeningFragmentJSX(_node, children, isChild, location) {
            var childrenProps;
            if (children && children.length) {
                var result = convertJsxChildrenToChildrenPropObject(children);
                if (result) {
                    childrenProps = result;
                }
            }
            return visitJsxOpeningLikeElementOrFragmentJSX(getImplicitJsxFragmentReference(), childrenProps || factory.createObjectLiteralExpression([]), 
            /*keyAttr*/ undefined, ts.length(ts.getSemanticJsxChildren(children)), isChild, location);
        }
        function visitJsxOpeningFragmentCreateElement(node, children, isChild, location) {
            var element = ts.createExpressionForJsxFragment(factory, context.getEmitResolver().getJsxFactoryEntity(currentSourceFile), context.getEmitResolver().getJsxFragmentFactoryEntity(currentSourceFile), compilerOptions.reactNamespace, // TODO: GH#18217
            ts.mapDefined(children, transformJsxChildToExpression), node, location);
            if (isChild) {
                ts.startOnNewLine(element);
            }
            return element;
        }
        function transformJsxSpreadAttributeToSpreadAssignment(node) {
            return factory.createSpreadAssignment(ts.visitNode(node.expression, visitor, ts.isExpression));
        }
        function transformJsxSpreadAttributeToExpression(node) {
            return ts.visitNode(node.expression, visitor, ts.isExpression);
        }
        function transformJsxAttributeToObjectLiteralElement(node) {
            var name = getAttributeName(node);
            var expression = transformJsxAttributeInitializer(node.initializer);
            return factory.createPropertyAssignment(name, expression);
        }
        function transformJsxAttributeInitializer(node) {
            if (node === undefined) {
                return factory.createTrue();
            }
            else if (node.kind === 10 /* StringLiteral */) {
                // Always recreate the literal to escape any escape sequences or newlines which may be in the original jsx string and which
                // Need to be escaped to be handled correctly in a normal string
                var singleQuote = node.singleQuote !== undefined ? node.singleQuote : !ts.isStringDoubleQuoted(node, currentSourceFile);
                var literal = factory.createStringLiteral(tryDecodeEntities(node.text) || node.text, singleQuote);
                return ts.setTextRange(literal, node);
            }
            else if (node.kind === 286 /* JsxExpression */) {
                if (node.expression === undefined) {
                    return factory.createTrue();
                }
                return ts.visitNode(node.expression, visitor, ts.isExpression);
            }
            else {
                return ts.Debug.failBadSyntaxKind(node);
            }
        }
        function visitJsxText(node) {
            var fixed = fixupWhitespaceAndDecodeEntities(node.text);
            return fixed === undefined ? undefined : factory.createStringLiteral(fixed);
        }
        /**
         * JSX trims whitespace at the end and beginning of lines, except that the
         * start/end of a tag is considered a start/end of a line only if that line is
         * on the same line as the closing tag. See examples in
         * tests/cases/conformance/jsx/tsxReactEmitWhitespace.tsx
         * See also https://www.w3.org/TR/html4/struct/text.html#h-9.1 and https://www.w3.org/TR/CSS2/text.html#white-space-model
         *
         * An equivalent algorithm would be:
         * - If there is only one line, return it.
         * - If there is only whitespace (but multiple lines), return `undefined`.
         * - Split the text into lines.
         * - 'trimRight' the first line, 'trimLeft' the last line, 'trim' middle lines.
         * - Decode entities on each line (individually).
         * - Remove empty lines and join the rest with " ".
         */
        function fixupWhitespaceAndDecodeEntities(text) {
            var acc;
            // First non-whitespace character on this line.
            var firstNonWhitespace = 0;
            // Last non-whitespace character on this line.
            var lastNonWhitespace = -1;
            // These initial values are special because the first line is:
            // firstNonWhitespace = 0 to indicate that we want leading whitsepace,
            // but lastNonWhitespace = -1 as a special flag to indicate that we *don't* include the line if it's all whitespace.
            for (var i = 0; i < text.length; i++) {
                var c = text.charCodeAt(i);
                if (ts.isLineBreak(c)) {
                    // If we've seen any non-whitespace characters on this line, add the 'trim' of the line.
                    // (lastNonWhitespace === -1 is a special flag to detect whether the first line is all whitespace.)
                    if (firstNonWhitespace !== -1 && lastNonWhitespace !== -1) {
                        acc = addLineOfJsxText(acc, text.substr(firstNonWhitespace, lastNonWhitespace - firstNonWhitespace + 1));
                    }
                    // Reset firstNonWhitespace for the next line.
                    // Don't bother to reset lastNonWhitespace because we ignore it if firstNonWhitespace = -1.
                    firstNonWhitespace = -1;
                }
                else if (!ts.isWhiteSpaceSingleLine(c)) {
                    lastNonWhitespace = i;
                    if (firstNonWhitespace === -1) {
                        firstNonWhitespace = i;
                    }
                }
            }
            return firstNonWhitespace !== -1
                // Last line had a non-whitespace character. Emit the 'trimLeft', meaning keep trailing whitespace.
                ? addLineOfJsxText(acc, text.substr(firstNonWhitespace))
                // Last line was all whitespace, so ignore it
                : acc;
        }
        function addLineOfJsxText(acc, trimmedLine) {
            // We do not escape the string here as that is handled by the printer
            // when it emits the literal. We do, however, need to decode JSX entities.
            var decoded = decodeEntities(trimmedLine);
            return acc === undefined ? decoded : acc + " " + decoded;
        }
        /**
         * Replace entities like "&nbsp;", "&#123;", and "&#xDEADBEEF;" with the characters they encode.
         * See https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references
         */
        function decodeEntities(text) {
            return text.replace(/&((#((\d+)|x([\da-fA-F]+)))|(\w+));/g, function (match, _all, _number, _digits, decimal, hex, word) {
                if (decimal) {
                    return ts.utf16EncodeAsString(parseInt(decimal, 10));
                }
                else if (hex) {
                    return ts.utf16EncodeAsString(parseInt(hex, 16));
                }
                else {
                    var ch = entities.get(word);
                    // If this is not a valid entity, then just use `match` (replace it with itself, i.e. don't replace)
                    return ch ? ts.utf16EncodeAsString(ch) : match;
                }
            });
        }
        /** Like `decodeEntities` but returns `undefined` if there were no entities to decode. */
        function tryDecodeEntities(text) {
            var decoded = decodeEntities(text);
            return decoded === text ? undefined : decoded;
        }
        function getTagName(node) {
            if (node.kind === 276 /* JsxElement */) {
                return getTagName(node.openingElement);
            }
            else {
                var name = node.tagName;
                if (ts.isIdentifier(name) && ts.isIntrinsicJsxName(name.escapedText)) {
                    return factory.createStringLiteral(ts.idText(name));
                }
                else {
                    return ts.createExpressionFromEntityName(factory, name);
                }
            }
        }
        /**
         * Emit an attribute name, which is quoted if it needs to be quoted. Because
         * these emit into an object literal property name, we don't need to be worried
         * about keywords, just non-identifier characters
         */
        function getAttributeName(node) {
            var name = node.name;
            var text = ts.idText(name);
            if (/^[A-Za-z_]\w*$/.test(text)) {
                return name;
            }
            else {
                return factory.createStringLiteral(text);
            }
        }
        function visitJsxExpression(node) {
            return ts.visitNode(node.expression, visitor, ts.isExpression);
        }
    }
    ts.transformJsx = transformJsx;
    var entities = new ts.Map(ts.getEntries({
        quot: 0x0022,
        amp: 0x0026,
        apos: 0x0027,
        lt: 0x003C,
        gt: 0x003E,
        nbsp: 0x00A0,
        iexcl: 0x00A1,
        cent: 0x00A2,
        pound: 0x00A3,
        curren: 0x00A4,
        yen: 0x00A5,
        brvbar: 0x00A6,
        sect: 0x00A7,
        uml: 0x00A8,
        copy: 0x00A9,
        ordf: 0x00AA,
        laquo: 0x00AB,
        not: 0x00AC,
        shy: 0x00AD,
        reg: 0x00AE,
        macr: 0x00AF,
        deg: 0x00B0,
        plusmn: 0x00B1,
        sup2: 0x00B2,
        sup3: 0x00B3,
        acute: 0x00B4,
        micro: 0x00B5,
        para: 0x00B6,
        middot: 0x00B7,
        cedil: 0x00B8,
        sup1: 0x00B9,
        ordm: 0x00BA,
        raquo: 0x00BB,
        frac14: 0x00BC,
        frac12: 0x00BD,
        frac34: 0x00BE,
        iquest: 0x00BF,
        Agrave: 0x00C0,
        Aacute: 0x00C1,
        Acirc: 0x00C2,
        Atilde: 0x00C3,
        Auml: 0x00C4,
        Aring: 0x00C5,
        AElig: 0x00C6,
        Ccedil: 0x00C7,
        Egrave: 0x00C8,
        Eacute: 0x00C9,
        Ecirc: 0x00CA,
        Euml: 0x00CB,
        Igrave: 0x00CC,
        Iacute: 0x00CD,
        Icirc: 0x00CE,
        Iuml: 0x00CF,
        ETH: 0x00D0,
        Ntilde: 0x00D1,
        Ograve: 0x00D2,
        Oacute: 0x00D3,
        Ocirc: 0x00D4,
        Otilde: 0x00D5,
        Ouml: 0x00D6,
        times: 0x00D7,
        Oslash: 0x00D8,
        Ugrave: 0x00D9,
        Uacute: 0x00DA,
        Ucirc: 0x00DB,
        Uuml: 0x00DC,
        Yacute: 0x00DD,
        THORN: 0x00DE,
        szlig: 0x00DF,
        agrave: 0x00E0,
        aacute: 0x00E1,
        acirc: 0x00E2,
        atilde: 0x00E3,
        auml: 0x00E4,
        aring: 0x00E5,
        aelig: 0x00E6,
        ccedil: 0x00E7,
        egrave: 0x00E8,
        eacute: 0x00E9,
        ecirc: 0x00EA,
        euml: 0x00EB,
        igrave: 0x00EC,
        iacute: 0x00ED,
        icirc: 0x00EE,
        iuml: 0x00EF,
        eth: 0x00F0,
        ntilde: 0x00F1,
        ograve: 0x00F2,
        oacute: 0x00F3,
        ocirc: 0x00F4,
        otilde: 0x00F5,
        ouml: 0x00F6,
        divide: 0x00F7,
        oslash: 0x00F8,
        ugrave: 0x00F9,
        uacute: 0x00FA,
        ucirc: 0x00FB,
        uuml: 0x00FC,
        yacute: 0x00FD,
        thorn: 0x00FE,
        yuml: 0x00FF,
        OElig: 0x0152,
        oelig: 0x0153,
        Scaron: 0x0160,
        scaron: 0x0161,
        Yuml: 0x0178,
        fnof: 0x0192,
        circ: 0x02C6,
        tilde: 0x02DC,
        Alpha: 0x0391,
        Beta: 0x0392,
        Gamma: 0x0393,
        Delta: 0x0394,
        Epsilon: 0x0395,
        Zeta: 0x0396,
        Eta: 0x0397,
        Theta: 0x0398,
        Iota: 0x0399,
        Kappa: 0x039A,
        Lambda: 0x039B,
        Mu: 0x039C,
        Nu: 0x039D,
        Xi: 0x039E,
        Omicron: 0x039F,
        Pi: 0x03A0,
        Rho: 0x03A1,
        Sigma: 0x03A3,
        Tau: 0x03A4,
        Upsilon: 0x03A5,
        Phi: 0x03A6,
        Chi: 0x03A7,
        Psi: 0x03A8,
        Omega: 0x03A9,
        alpha: 0x03B1,
        beta: 0x03B2,
        gamma: 0x03B3,
        delta: 0x03B4,
        epsilon: 0x03B5,
        zeta: 0x03B6,
        eta: 0x03B7,
        theta: 0x03B8,
        iota: 0x03B9,
        kappa: 0x03BA,
        lambda: 0x03BB,
        mu: 0x03BC,
        nu: 0x03BD,
        xi: 0x03BE,
        omicron: 0x03BF,
        pi: 0x03C0,
        rho: 0x03C1,
        sigmaf: 0x03C2,
        sigma: 0x03C3,
        tau: 0x03C4,
        upsilon: 0x03C5,
        phi: 0x03C6,
        chi: 0x03C7,
        psi: 0x03C8,
        omega: 0x03C9,
        thetasym: 0x03D1,
        upsih: 0x03D2,
        piv: 0x03D6,
        ensp: 0x2002,
        emsp: 0x2003,
        thinsp: 0x2009,
        zwnj: 0x200C,
        zwj: 0x200D,
        lrm: 0x200E,
        rlm: 0x200F,
        ndash: 0x2013,
        mdash: 0x2014,
        lsquo: 0x2018,
        rsquo: 0x2019,
        sbquo: 0x201A,
        ldquo: 0x201C,
        rdquo: 0x201D,
        bdquo: 0x201E,
        dagger: 0x2020,
        Dagger: 0x2021,
        bull: 0x2022,
        hellip: 0x2026,
        permil: 0x2030,
        prime: 0x2032,
        Prime: 0x2033,
        lsaquo: 0x2039,
        rsaquo: 0x203A,
        oline: 0x203E,
        frasl: 0x2044,
        euro: 0x20AC,
        image: 0x2111,
        weierp: 0x2118,
        real: 0x211C,
        trade: 0x2122,
        alefsym: 0x2135,
        larr: 0x2190,
        uarr: 0x2191,
        rarr: 0x2192,
        darr: 0x2193,
        harr: 0x2194,
        crarr: 0x21B5,
        lArr: 0x21D0,
        uArr: 0x21D1,
        rArr: 0x21D2,
        dArr: 0x21D3,
        hArr: 0x21D4,
        forall: 0x2200,
        part: 0x2202,
        exist: 0x2203,
        empty: 0x2205,
        nabla: 0x2207,
        isin: 0x2208,
        notin: 0x2209,
        ni: 0x220B,
        prod: 0x220F,
        sum: 0x2211,
        minus: 0x2212,
        lowast: 0x2217,
        radic: 0x221A,
        prop: 0x221D,
        infin: 0x221E,
        ang: 0x2220,
        and: 0x2227,
        or: 0x2228,
        cap: 0x2229,
        cup: 0x222A,
        int: 0x222B,
        there4: 0x2234,
        sim: 0x223C,
        cong: 0x2245,
        asymp: 0x2248,
        ne: 0x2260,
        equiv: 0x2261,
        le: 0x2264,
        ge: 0x2265,
        sub: 0x2282,
        sup: 0x2283,
        nsub: 0x2284,
        sube: 0x2286,
        supe: 0x2287,
        oplus: 0x2295,
        otimes: 0x2297,
        perp: 0x22A5,
        sdot: 0x22C5,
        lceil: 0x2308,
        rceil: 0x2309,
        lfloor: 0x230A,
        rfloor: 0x230B,
        lang: 0x2329,
        rang: 0x232A,
        loz: 0x25CA,
        spades: 0x2660,
        clubs: 0x2663,
        hearts: 0x2665,
        diams: 0x2666
    }));
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformES2016(context) {
        var factory = context.factory, hoistVariableDeclaration = context.hoistVariableDeclaration;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 256 /* ContainsES2016 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 219 /* BinaryExpression */:
                    return visitBinaryExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitBinaryExpression(node) {
            switch (node.operatorToken.kind) {
                case 67 /* AsteriskAsteriskEqualsToken */:
                    return visitExponentiationAssignmentExpression(node);
                case 42 /* AsteriskAsteriskToken */:
                    return visitExponentiationExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitExponentiationAssignmentExpression(node) {
            var target;
            var value;
            var left = ts.visitNode(node.left, visitor, ts.isExpression);
            var right = ts.visitNode(node.right, visitor, ts.isExpression);
            if (ts.isElementAccessExpression(left)) {
                // Transforms `a[x] **= b` into `(_a = a)[_x = x] = Math.pow(_a[_x], b)`
                var expressionTemp = factory.createTempVariable(hoistVariableDeclaration);
                var argumentExpressionTemp = factory.createTempVariable(hoistVariableDeclaration);
                target = ts.setTextRange(factory.createElementAccessExpression(ts.setTextRange(factory.createAssignment(expressionTemp, left.expression), left.expression), ts.setTextRange(factory.createAssignment(argumentExpressionTemp, left.argumentExpression), left.argumentExpression)), left);
                value = ts.setTextRange(factory.createElementAccessExpression(expressionTemp, argumentExpressionTemp), left);
            }
            else if (ts.isPropertyAccessExpression(left)) {
                // Transforms `a.x **= b` into `(_a = a).x = Math.pow(_a.x, b)`
                var expressionTemp = factory.createTempVariable(hoistVariableDeclaration);
                target = ts.setTextRange(factory.createPropertyAccessExpression(ts.setTextRange(factory.createAssignment(expressionTemp, left.expression), left.expression), left.name), left);
                value = ts.setTextRange(factory.createPropertyAccessExpression(expressionTemp, left.name), left);
            }
            else {
                // Transforms `a **= b` into `a = Math.pow(a, b)`
                target = left;
                value = left;
            }
            return ts.setTextRange(factory.createAssignment(target, ts.setTextRange(factory.createGlobalMethodCall("Math", "pow", [value, right]), node)), node);
        }
        function visitExponentiationExpression(node) {
            // Transforms `a ** b` into `Math.pow(a, b)`
            var left = ts.visitNode(node.left, visitor, ts.isExpression);
            var right = ts.visitNode(node.right, visitor, ts.isExpression);
            return ts.setTextRange(factory.createGlobalMethodCall("Math", "pow", [left, right]), node);
        }
    }
    ts.transformES2016 = transformES2016;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ES2015SubstitutionFlags;
    (function (ES2015SubstitutionFlags) {
        /** Enables substitutions for captured `this` */
        ES2015SubstitutionFlags[ES2015SubstitutionFlags["CapturedThis"] = 1] = "CapturedThis";
        /** Enables substitutions for block-scoped bindings. */
        ES2015SubstitutionFlags[ES2015SubstitutionFlags["BlockScopedBindings"] = 2] = "BlockScopedBindings";
    })(ES2015SubstitutionFlags || (ES2015SubstitutionFlags = {}));
    var LoopOutParameterFlags;
    (function (LoopOutParameterFlags) {
        LoopOutParameterFlags[LoopOutParameterFlags["Body"] = 1] = "Body";
        LoopOutParameterFlags[LoopOutParameterFlags["Initializer"] = 2] = "Initializer";
    })(LoopOutParameterFlags || (LoopOutParameterFlags = {}));
    var CopyDirection;
    (function (CopyDirection) {
        CopyDirection[CopyDirection["ToOriginal"] = 0] = "ToOriginal";
        CopyDirection[CopyDirection["ToOutParameter"] = 1] = "ToOutParameter";
    })(CopyDirection || (CopyDirection = {}))