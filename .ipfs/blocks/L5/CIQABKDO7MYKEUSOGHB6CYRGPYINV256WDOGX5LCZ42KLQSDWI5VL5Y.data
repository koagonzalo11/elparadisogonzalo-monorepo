h);
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 4) {
            text = formatStringFromArgs(text, arguments, 4);
        }
        return {
            file: undefined,
            start: start,
            length: length,
            messageText: text,
            category: message.category,
            code: message.code,
            reportsUnnecessary: message.reportsUnnecessary,
            fileName: fileName,
        };
    }
    ts.createDetachedDiagnostic = createDetachedDiagnostic;
    function isDiagnosticWithDetachedLocation(diagnostic) {
        return diagnostic.file === undefined
            && diagnostic.start !== undefined
            && diagnostic.length !== undefined
            && typeof diagnostic.fileName === "string";
    }
    function attachFileToDiagnostic(diagnostic, file) {
        var fileName = file.fileName || "";
        var length = file.text.length;
        ts.Debug.assertEqual(diagnostic.fileName, fileName);
        ts.Debug.assertLessThanOrEqual(diagnostic.start, length);
        ts.Debug.assertLessThanOrEqual(diagnostic.start + diagnostic.length, length);
        var diagnosticWithLocation = {
            file: file,
            start: diagnostic.start,
            length: diagnostic.length,
            messageText: diagnostic.messageText,
            category: diagnostic.category,
            code: diagnostic.code,
            reportsUnnecessary: diagnostic.reportsUnnecessary
        };
        if (diagnostic.relatedInformation) {
            diagnosticWithLocation.relatedInformation = [];
            for (var _i = 0, _a = diagnostic.relatedInformation; _i < _a.length; _i++) {
                var related = _a[_i];
                if (isDiagnosticWithDetachedLocation(related) && related.fileName === fileName) {
                    ts.Debug.assertLessThanOrEqual(related.start, length);
                    ts.Debug.assertLessThanOrEqual(related.start + related.length, length);
                    diagnosticWithLocation.relatedInformation.push(attachFileToDiagnostic(related, file));
                }
                else {
                    diagnosticWithLocation.relatedInformation.push(related);
                }
            }
        }
        return diagnosticWithLocation;
    }
    function attachFileToDiagnostics(diagnostics, file) {
        var diagnosticsWithLocation = [];
        for (var _i = 0, diagnostics_1 = diagnostics; _i < diagnostics_1.length; _i++) {
            var diagnostic = diagnostics_1[_i];
            diagnosticsWithLocation.push(attachFileToDiagnostic(diagnostic, file));
        }
        return diagnosticsWithLocation;
    }
    ts.attachFileToDiagnostics = attachFileToDiagnostics;
    function createFileDiagnostic(file, start, length, message) {
        assertDiagnosticLocation(file, start, length);
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 4) {
            text = formatStringFromArgs(text, arguments, 4);
        }
        return {
            file: file,
            start: start,
            length: length,
            messageText: text,
            category: message.category,
            code: message.code,
            reportsUnnecessary: message.reportsUnnecessary,
            reportsDeprecated: message.reportsDeprecated
        };
    }
    ts.createFileDiagnostic = createFileDiagnostic;
    function formatMessage(_dummy, message) {
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 2) {
            text = formatStringFromArgs(text, arguments, 2);
        }
        return text;
    }
    ts.formatMessage = formatMessage;
    function createCompilerDiagnostic(message) {
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 1) {
            text = formatStringFromArgs(text, arguments, 1);
        }
        return {
            file: undefined,
            start: undefined,
            length: undefined,
            messageText: text,
            category: message.category,
            code: message.code,
            reportsUnnecessary: message.reportsUnnecessary,
            reportsDeprecated: message.reportsDeprecated
        };
    }
    ts.createCompilerDiagnostic = createCompilerDiagnostic;
    function createCompilerDiagnosticFromMessageChain(chain, relatedInformation) {
        return {
            file: undefined,
            start: undefined,
            length: undefined,
            code: chain.code,
            category: chain.category,
            messageText: chain.next ? chain : chain.messageText,
            relatedInformation: relatedInformation
        };
    }
    ts.createCompilerDiagnosticFromMessageChain = createCompilerDiagnosticFromMessageChain;
    function chainDiagnosticMessages(details, message) {
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 2) {
            text = formatStringFromArgs(text, arguments, 2);
        }
        return {
            messageText: text,
            category: message.category,
            code: message.code,
            next: details === undefined || Array.isArray(details) ? details : [details]
        };
    }
    ts.chainDiagnosticMessages = chainDiagnosticMessages;
    function concatenateDiagnosticMessageChains(headChain, tailChain) {
        var lastChain = headChain;
        while (lastChain.next) {
            lastChain = lastChain.next[0];
        }
        lastChain.next = [tailChain];
    }
    ts.concatenateDiagnosticMessageChains = concatenateDiagnosticMessageChains;
    function getDiagnosticFilePath(diagnostic) {
        return diagnostic.file ? diagnostic.file.path : undefined;
    }
    function compareDiagnostics(d1, d2) {
        return compareDiagnosticsSkipRelatedInformation(d1, d2) ||
            compareRelatedInformation(d1, d2) ||
            0;
    }
    ts.compareDiagnostics = compareDiagnostics;
    function compareDiagnosticsSkipRelatedInformation(d1, d2) {
        return ts.compareStringsCaseSensitive(getDiagnosticFilePath(d1), getDiagnosticFilePath(d2)) ||
            ts.compareValues(d1.start, d2.start) ||
            ts.compareValues(d1.length, d2.length) ||
            ts.compareValues(d1.code, d2.code) ||
            compareMessageText(d1.messageText, d2.messageText) ||
            0;
    }
    ts.compareDiagnosticsSkipRelatedInformation = compareDiagnosticsSkipRelatedInformation;
    function compareRelatedInformation(d1, d2) {
        if (!d1.relatedInformation && !d2.relatedInformation) {
            return 0;
        }
        if (d1.relatedInformation && d2.relatedInformation) {
            return ts.compareValues(d1.relatedInformation.length, d2.relatedInformation.length) || ts.forEach(d1.relatedInformation, function (d1i, index) {
                var d2i = d2.relatedInformation[index];
                return compareDiagnostics(d1i, d2i);
            }) || 0;
        }
        return d1.relatedInformation ? -1 : 1;
    }
    function compareMessageText(t1, t2) {
        if (typeof t1 === "string" && typeof t2 === "string") {
            return ts.compareStringsCaseSensitive(t1, t2);
        }
        else if (typeof t1 === "string") {
            return -1;
        }
        else if (typeof t2 === "string") {
            return 1;
        }
        var res = ts.compareStringsCaseSensitive(t1.messageText, t2.messageText);
        if (res) {
            return res;
        }
        if (!t1.next && !t2.next) {
            return 0;
        }
        if (!t1.next) {
            return -1;
        }
        if (!t2.next) {
            return 1;
        }
        var len = Math.min(t1.next.length, t2.next.length);
        for (var i = 0; i < len; i++) {
            res = compareMessageText(t1.next[i], t2.next[i]);
            if (res) {
                return res;
            }
        }
        if (t1.next.length < t2.next.length) {
            return -1;
        }
        else if (t1.next.length > t2.next.length) {
            return 1;
        }
        return 0;
    }
    function getLanguageVariant(scriptKind) {
        return scriptKind === 4 || scriptKind === 2 || scriptKind === 1 || scriptKind === 6 ? 1 : 0;
    }
    ts.getLanguageVariant = getLanguageVariant;
    function getEmitScriptTarget(compilerOptions) {
        return compilerOptions.target || 0;
    }
    ts.getEmitScriptTarget = getEmitScriptTarget;
    function getEmitModuleKind(compilerOptions) {
        return typeof compilerOptions.module === "number" ?
            compilerOptions.module :
            getEmitScriptTarget(compilerOptions) >= 2 ? ts.ModuleKind.ES2015 : ts.ModuleKind.CommonJS;
    }
    ts.getEmitModuleKind = getEmitModuleKind;
    function getEmitModuleResolutionKind(compilerOptions) {
        var moduleResolution = compilerOptions.moduleResolution;
        if (moduleResolution === undefined) {
            moduleResolution = getEmitModuleKind(compilerOptions) === ts.ModuleKind.CommonJS ? ts.ModuleResolutionKind.NodeJs : ts.ModuleResolutionKind.Classic;
        }
        return moduleResolution;
    }
    ts.getEmitModuleResolutionKind = getEmitModuleResolutionKind;
    function hasJsonModuleEmitEnabled(options) {
        switch (getEmitModuleKind(options)) {
            case ts.ModuleKind.CommonJS:
            case ts.ModuleKind.AMD:
            case ts.ModuleKind.ES2015:
            case ts.ModuleKind.ES2020:
            case ts.ModuleKind.ESNext:
                return true;
            default:
                return false;
        }
    }
    ts.hasJsonModuleEmitEnabled = hasJsonModuleEmitEnabled;
    function unreachableCodeIsError(options) {
        return options.allowUnreachableCode === false;
    }
    ts.unreachableCodeIsError = unreachableCodeIsError;
    function unusedLabelIsError(options) {
        return options.allowUnusedLabels === false;
    }
    ts.unusedLabelIsError = unusedLabelIsError;
    function getAreDeclarationMapsEnabled(options) {
        return !!(getEmitDeclarations(options) && options.declarationMap);
    }
    ts.getAreDeclarationMapsEnabled = getAreDeclarationMapsEnabled;
    function getAllowSyntheticDefaultImports(compilerOptions) {
        var moduleKind = getEmitModuleKind(compilerOptions);
        return compilerOptions.allowSyntheticDefaultImports !== undefined
            ? compilerOptions.allowSyntheticDefaultImports
            : compilerOptions.esModuleInterop ||
                moduleKind === ts.ModuleKind.System;
    }
    ts.getAllowSyntheticDefaultImports = getAllowSyntheticDefaultImports;
    function getEmitDeclarations(compilerOptions) {
        return !!(compilerOptions.declaration || compilerOptions.composite);
    }
    ts.getEmitDeclarations = getEmitDeclarations;
    function shouldPreserveConstEnums(compilerOptions) {
        return !!(compilerOptions.preserveConstEnums || compilerOptions.isolatedModules);
    }
    ts.shouldPreserveConstEnums = shouldPreserveConstEnums;
    function isIncrementalCompilation(options) {
        return !!(options.incremental || options.composite);
    }
    ts.isIncrementalCompilation = isIncrementalCompilation;
    function getStrictOptionValue(compilerOptions, flag) {
        return compilerOptions[flag] === undefined ? !!compilerOptions.strict : !!compilerOptions[flag];
    }
    ts.getStrictOptionValue = getStrictOptionValue;
    function getAllowJSCompilerOption(compilerOptions) {
        return compilerOptions.allowJs === undefined ? !!compilerOptions.checkJs : compilerOptions.allowJs;
    }
    ts.getAllowJSCompilerOption = getAllowJSCompilerOption;
    function getUseDefineForClassFields(compilerOptions) {
        return compilerOptions.useDefineForClassFields === undefined ? compilerOptions.target === 99 : compilerOptions.useDefineForClassFields;
    }
    ts.getUseDefineForClassFields = getUseDefineForClassFields;
    function compilerOptionsAffectSemanticDiagnostics(newOptions, oldOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.semanticDiagnosticsOptionDeclarations);
    }
    ts.compilerOptionsAffectSemanticDiagnostics = compilerOptionsAffectSemanticDiagnostics;
    function compilerOptionsAffectEmit(newOptions, oldOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.affectsEmitOptionDeclarations);
    }
    ts.compilerOptionsAffectEmit = compilerOptionsAffectEmit;
    function getCompilerOptionValue(options, option) {
        return option.strictFlag ? getStrictOptionValue(options, option.name) : options[option.name];
    }
    ts.getCompilerOptionValue = getCompilerOptionValue;
    function getJSXTransformEnabled(options) {
        var jsx = options.jsx;
        return jsx === 2 || jsx === 4 || jsx === 5;
    }
    ts.getJSXTransformEnabled = getJSXTransformEnabled;
    function getJSXImplicitImportBase(compilerOptions, file) {
        var jsxImportSourcePragmas = file === null || file === void 0 ? void 0 : file.pragmas.get("jsximportsource");
        var jsxImportSourcePragma = ts.isArray(jsxImportSourcePragmas) ? jsxImportSourcePragmas[jsxImportSourcePragmas.length - 1] : jsxImportSourcePragmas;
        return compilerOptions.jsx === 4 ||
            compilerOptions.jsx === 5 ||
            compilerOptions.jsxImportSource ||
            jsxImportSourcePragma ?
            (jsxImportSourcePragma === null || jsxImportSourcePragma === void 0 ? void 0 : jsxImportSourcePragma.arguments.factory) || compilerOptions.jsxImportSource || "react" :
            undefined;
    }
    ts.getJSXImplicitImportBase = getJSXImplicitImportBase;
    function getJSXRuntimeImport(base, options) {
        return base ? base + "/" + (options.jsx === 5 ? "jsx-dev-runtime" : "jsx-runtime") : undefined;
    }
    ts.getJSXRuntimeImport = getJSXRuntimeImport;
    function hasZeroOrOneAsteriskCharacter(str) {
        var seenAsterisk = false;
        for (var i = 0; i < str.length; i++) {
            if (str.charCodeAt(i) === 42) {
                if (!seenAsterisk) {
                    seenAsterisk = true;
                }
                else {
                    return false;
                }
            }
        }
        return true;
    }
    ts.hasZeroOrOneAsteriskCharacter = hasZeroOrOneAsteriskCharacter;
    function createSymlinkCache(cwd, getCanonicalFileName) {
        var symlinkedDirectories;
        var symlinkedDirectoriesByRealpath;
        var symlinkedFiles;
        var hasProcessedResolutions = false;
        return {
            getSymlinkedFiles: function () { return symlinkedFiles; },
            getSymlinkedDirectories: function () { return symlinkedDirectories; },
            getSymlinkedDirectoriesByRealpath: function () { return symlinkedDirectoriesByRealpath; },
            setSymlinkedFile: function (path, real) { return (symlinkedFiles || (symlinkedFiles = new ts.Map())).set(path, real); },
            setSymlinkedDirectory: function (symlink, real) {
                var symlinkPath = ts.toPath(symlink, cwd, getCanonicalFileName);
                if (!containsIgnoredPath(symlinkPath)) {
                    symlinkPath = ts.ensureTrailingDirectorySeparator(symlinkPath);
                    if (real !== false && !(symlinkedDirectories === null || symlinkedDirectories === void 0 ? void 0 : symlinkedDirectories.has(symlinkPath))) {
                        (symlinkedDirectoriesByRealpath || (symlinkedDirectoriesByRealpath = ts.createMultiMap())).add(ts.ensureTrailingDirectorySeparator(real.realPath), symlink);
                    }
                    (symlinkedDirectories || (symlinkedDirectories = new ts.Map())).set(symlinkPath, real);
                }
            },
            setSymlinkedDirectoryFromSymlinkedFile: function (symlink, real) {
                this.setSymlinkedFile(ts.toPath(symlink, cwd, getCanonicalFileName), real);
                var _a = guessDirectorySymlink(real, symlink, cwd, getCanonicalFileName) || ts.emptyArray, commonResolved = _a[0], commonOriginal = _a[1];
                if (commonResolved && commonOriginal) {
                    this.setSymlinkedDirectory(commonOriginal, {
                        real: commonResolved,
                        realPath: ts.toPath(commonResolved, cwd, getCanonicalFileName),
                    });
                }
            },
            setSymlinksFromResolutions: function (files, typeReferenceDirectives) {
                var _this = this;
                var _a;
                ts.Debug.assert(!hasProcessedResolutions);
                hasProcessedResolutions = true;
                for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                    var file = files_1[_i];
                    (_a = file.resolvedModules) === null || _a === void 0 ? void 0 : _a.forEach(function (resolution) { return processResolution(_this, resolution); });
                }
                typeReferenceDirectives === null || typeReferenceDirectives === void 0 ? void 0 : typeReferenceDirectives.forEach(function (resolution) { return processResolution(_this, resolution); });
            },
            hasProcessedResolutions: function () { return hasProcessedResolutions; },
        };
        function processResolution(cache, resolution) {
            if (!resolution || !resolution.originalPath || !resolution.resolvedFileName)
                return;
            var resolvedFileName = resolution.resolvedFileName, originalPath = resolution.originalPath;
            cache.setSymlinkedFile(ts.toPath(originalPath, cwd, getCanonicalFileName), resolvedFileName);
            var _a = guessDirectorySymlink(resolvedFileName, originalPath, cwd, getCanonicalFileName) || ts.emptyArray, commonResolved = _a[0], commonOriginal = _a[1];
            if (commonResolved && commonOriginal) {
                cache.setSymlinkedDirectory(commonOriginal, { real: commonResolved, realPath: ts.toPath(commonResolved, cwd, getCanonicalFileName) });
            }
        }
    }
    ts.createSymlinkCache = createSymlinkCache;
    function guessDirectorySymlink(a, b, cwd, getCanonicalFileName) {
        var aParts = ts.getPathComponents(ts.getNormalizedAbsolutePath(a, cwd));
        var bParts = ts.getPathComponents(ts.getNormalizedAbsolutePath(b, cwd));
        var isDirectory = false;
        while (!isNodeModulesOrScopedPackageDirectory(aParts[aParts.length - 2], getCanonicalFileName) &&
            !isNodeModulesOrScopedPackageDirectory(bParts[bParts.length - 2], getCanonicalFileName) &&
            getCanonicalFileName(aParts[aParts.length - 1]) === getCanonicalFileName(bParts[bParts.length - 1])) {
            aParts.pop();
            bParts.pop();
            isDirectory = true;
        }
        return isDirectory ? [ts.getPathFromPathComponents(aParts), ts.getPathFromPathComponents(bParts)] : undefined;
    }
    function isNodeModulesOrScopedPackageDirectory(s, getCanonicalFileName) {
        return getCanonicalFileName(s) === "node_modules" || ts.startsWith(s, "@");
    }
    function stripLeadingDirectorySeparator(s) {
        return ts.isAnyDirectorySeparator(s.charCodeAt(0)) ? s.slice(1) : undefined;
    }
    function tryRemoveDirectoryPrefix(path, dirPath, getCanonicalFileName) {
        var withoutPrefix = ts.tryRemovePrefix(path, dirPath, getCanonicalFileName);
        return withoutPrefix === undefined ? undefined : stripLeadingDirectorySeparator(withoutPrefix);
    }
    ts.tryRemoveDirectoryPrefix = tryRemoveDirectoryPrefix;
    var reservedCharacterPattern = /[^\w\s\/]/g;
    function regExpEscape(text) {
        return text.replace(reservedCharacterPattern, escapeRegExpCharacter);
    }
    ts.regExpEscape = regExpEscape;
    function escapeRegExpCharacter(match) {
        return "\\" + match;
    }
    var wildcardCharCodes = [42, 63];
    ts.commonPackageFolders = ["node_modules", "bower_components", "jspm_packages"];
    var implicitExcludePathRegexPattern = "(?!(" + ts.commonPackageFolders.join("|") + ")(/|$))";
    var filesMatcher = {
        singleAsteriskRegexFragment: "([^./]|(\\.(?!min\\.js$))?)*",
        doubleAsteriskRegexFragment: "(/" + implicitExcludePathRegexPattern + "[^/.][^/]*)*?",
        replaceWildcardCharacter: function (match) { return replaceWildcardCharacter(match, filesMatcher.singleAsteriskRegexFragment); }
    };
    var directoriesMatcher = {
        singleAsteriskRegexFragment: "[^/]*",
        doubleAsteriskRegexFragment: "(/" + implicitExcludePathRegexPattern + "[^/.][^/]*)*?",
        replaceWildcardCharacter: function (match) { return replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment); }
    };
    var excludeMatcher = {
        singleAsteriskRegexFragment: "[^/]*",
        doubleAsteriskRegexFragment: "(/.+?)?",
        replaceWildcardCharacter: function (match) { return replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment); }
    };
    var wildcardMatchers = {
        files: filesMatcher,
        directories: directoriesMatcher,
        exclude: excludeMatcher
    };
    function getRegularExpressionForWildcard(specs, basePath, usage) {
        var patterns = getRegularExpressionsForWildcards(specs, basePath, usage);
        if (!patterns || !patterns.length) {
            return undefined;
        }
        var pattern = patterns.map(function (pattern) { return "(" + pattern + ")"; }).join("|");
        var terminator = usage === "exclude" ? "($|/)" : "$";
        return "^(" + pattern + ")" + terminator;
    }
    ts.getRegularExpressionForWildcard = getRegularExpressionForWildcard;
    function getRegularExpressionsForWildcards(specs, basePath, usage) {
        if (specs === undefined || specs.length === 0) {
            return undefined;
        }
        return ts.flatMap(specs, function (spec) {
            return spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]);
        });
    }
    ts.getRegularExpressionsForWildcards = getRegularExpressionsForWildcards;
    function isImplicitGlob(lastPathComponent) {
        return !/[.*?]/.test(lastPathComponent);
    }
    ts.isImplicitGlob = isImplicitGlob;
    function getPatternFromSpec(spec, basePath, usage) {
        var pattern = spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]);
        return pattern && "^(" + pattern + ")" + (usage === "exclude" ? "($|/)" : "$");
    }
    ts.getPatternFromSpec = getPatternFromSpec;
    function getSubPatternFromSpec(spec, basePath, usage, _a) {
        var singleAsteriskRegexFragment = _a.singleAsteriskRegexFragment, doubleAsteriskRegexFragment = _a.doubleAsteriskRegexFragment, replaceWildcardCharacter = _a.replaceWildcardCharacter;
        var subpattern = "";
        var hasWrittenComponent = false;
        var components = ts.getNormalizedPathComponents(spec, basePath);
        var lastComponent = ts.last(components);
        if (usage !== "exclude" && lastComponent === "**") {
            return undefined;
        }
        components[0] = ts.removeTrailingDirectorySeparator(components[0]);
        if (isImplicitGlob(lastComponent)) {
            components.push("**", "*");
        }
        var optionalCount = 0;
        for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
            var component = components_1[_i];
            if (component === "**") {
                subpattern += doubleAsteriskRegexFragment;
            }
            else {
                if (usage === "directories") {
                    subpattern += "(";
                    optionalCount++;
                }
                if (hasWrittenComponent) {
                    subpattern += ts.directorySeparator;
                }
                if (usage !== "exclude") {
                    var componentPattern = "";
                    if (component.charCodeAt(0) === 42) {
                        componentPattern += "([^./]" + singleAsteriskRegexFragment + ")?";
                        component = component.substr(1);
                    }
                    else if (component.charCodeAt(0) === 63) {
                        componentPattern += "[^./]";
                        component = component.substr(1);
                    }
                    componentPattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);
                    if (componentPattern !== component) {
                        subpattern += implicitExcludePathRegexPattern;
                    }
                    subpattern += componentPattern;
                }
                else {
                    subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);
                }
            }
            hasWrittenComponent = true;
        }
        while (optionalCount > 0) {
            subpattern += ")?";
            optionalCount--;
        }
        return subpattern;
    }
    function replaceWildcardCharacter(match, singleAsteriskRegexFragment) {
        return match === "*" ? singleAsteriskRegexFragment : match === "?" ? "[^/]" : "\\" + match;
    }
    function getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory) {
        path = ts.normalizePath(path);
        currentDirectory = ts.normalizePath(currentDirectory);
        var absolutePath = ts.combinePaths(currentDirectory, path);
        return {
            includeFilePatterns: ts.map(getRegularExpressionsForWildcards(includes, absolutePath, "files"), function (pattern) { return "^" + pattern + "$"; }),
            includeFilePattern: getRegularExpressionForWildcard(includes, absolutePath, "files"),
            includeDirectoryPattern: getRegularExpressionForWildcard(includes, absolutePath, "directories"),
            excludePattern: getRegularExpressionForWildcard(excludes, absolutePath, "exclude"),
            basePaths: getBasePaths(path, includes, useCaseSensitiveFileNames)
        };
    }
    ts.getFileMatcherPatterns = getFileMatcherPatterns;
    function getRegexFromPattern(pattern, useCaseSensitiveFileNames) {
        return new RegExp(pattern, useCaseSensitiveFileNames ? "" : "i");
    }
    ts.getRegexFromPattern = getRegexFromPattern;
    function matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, depth, getFileSystemEntries, realpath, directoryExists) {
        path = ts.normalizePath(path);
        currentDirectory = ts.normalizePath(currentDirectory);
        var patterns = getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory);
        var includeFileRegexes = patterns.includeFilePatterns && patterns.includeFilePatterns.map(function (pattern) { return getRegexFromPattern(pattern, useCaseSensitiveFileNames); });
        var includeDirectoryRegex = patterns.includeDirectoryPattern && getRegexFromPattern(patterns.includeDirectoryPattern, useCaseSensitiveFileNames);
        var excludeRegex = patterns.excludePattern && getRegexFromPattern(patterns.excludePattern, useCaseSensitiveFileNames);
        var results = includeFileRegexes ? includeFileRegexes.map(function () { return []; }) : [[]];
        var visited = new ts.Map();
        var toCanonical = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        for (var _i = 0, _a = patterns.basePaths; _i < _a.length; _i++) {
            var basePath = _a[_i];
            if (directoryExists(basePath)) {
                visitDirectory(basePath, ts.combinePaths(currentDirectory, basePath), depth);
            }
        }
        return ts.flatten(results);
        function visitDirectory(path, absolutePath, depth) {
            var canonicalPath = toCanonical(realpath(absolutePath));
            if (visited.has(canonicalPath))
                return;
            visited.set(canonicalPath, true);
            var _a = getFileSystemEntries(path), files = _a.files, directories = _a.directories;
            var _loop_1 = function (current) {
                var name = ts.combinePaths(path, current);
                var absoluteName = ts.combinePaths(absolutePath, current);
                if (extensions && !ts.fileExtensionIsOneOf(name, extensions))
                    return "continue";
                if (excludeRegex && excludeRegex.test(absoluteName))
                    return "continue";
                if (!includeFileRegexes) {
                    results[0].push(name);
                }
                else {
                    var includeIndex = ts.findIndex(includeFileRegexes, function (re) { return re.test(absoluteName); });
                    if (includeIndex !== -1) {
                        results[includeIndex].push(name);
                    }
                }
            };
            for (var _i = 0, _b = ts.sort(files, ts.compareStringsCaseSensitive); _i < _b.length; _i++) {
                var current = _b[_i];
                _loop_1(current);
            }
            if (depth !== undefined) {
                depth--;
                if (depth === 0) {
                    return;
                }
            }
            for (var _c = 0, _d = ts.sort(directories, ts.compareStringsCaseSensitive); _c < _d.length; _c++) {
                var current = _d[_c];
                var name = ts.combinePaths(path, current);
                var absoluteName = ts.combinePaths(absolutePath, current);
                if ((!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName)) &&
                    (!excludeRegex || !excludeRegex.test(absoluteName))) {
                    visitDirectory(name, absoluteName, depth);
                }
            }
        }
    }
    ts.matchFiles = matchFiles;
    function getBasePaths(path, includes, useCaseSensitiveFileNames) {
        var basePaths = [path];
        if (includes) {
            var includeBasePaths = [];
            for (var _i = 0, includes_1 = includes; _i < includes_1.length; _i++) {
                var include = includes_1[_i];
                var absolute = ts.isRootedDiskPath(include) ? include : ts.normalizePath(ts.combinePaths(path, include));
                includeBasePaths.push(getIncludeBasePath(absolute));
            }
            includeBasePaths.sort(ts.getStringComparer(!useCaseSensitiveFileNames));
            var _loop_2 = function (includeBasePath) {
                if (ts.every(basePaths, function (basePath) { return !ts.containsPath(basePath, includeBasePath, path, !useCaseSensitiveFileNames); })) {
                    basePaths.push(includeBasePath);
                }
            };
            for (var _a = 0, includeBasePaths_1 = includeBasePaths; _a < includeBasePaths_1.length; _a++) {
                var includeBasePath = includeBasePaths_1[_a];
                _loop_2(includeBasePath);
            }
        }
        return basePaths;
    }
    function getIncludeBasePath(absolute) {
        var wildcardOffset = ts.indexOfAnyCharCode(absolute, wildcardCharCodes);
        if (wildcardOffset < 0) {
            return !ts.hasExtension(absolute)
                ? absolute
                : ts.removeTrailingDirectorySeparator(ts.getDirectoryPath(absolute));
        }
        return absolute.substring(0, absolute.lastIndexOf(ts.directorySeparator, wildcardOffset));
    }
    function ensureScriptKind(fileName, scriptKind) {
        return scriptKind || getScriptKindFromFileName(fileName) || 3;
    }
    ts.ensureScriptKind = ensureScriptKind;
    function getScriptKindFromFileName(fileName) {
        var ext = fileName.substr(fileName.lastIndexOf("."));
        switch (ext.toLowerCase()) {
            case ".js":
                return 1;
            case ".jsx":
                return 2;
            case ".ts":
                return 3;
            case ".tsx":
                return 4;
            case ".json":
                return 6;
            default:
                return 0;
        }
    }
    ts.getScriptKindFromFileName = getScriptKindFromFileName;
    ts.supportedTSExtensions = [".ts", ".tsx", ".d.ts"];
    ts.supportedTSExtensionsWithJson = [".ts", ".tsx", ".d.ts", ".json"];
    ts.supportedTSExtensionsForExtractExtension = [".d.ts", ".ts", ".tsx"];
    ts.supportedJSExtensions = [".js", ".jsx"];
    ts.supportedJSAndJsonExtensions = [".js", ".jsx", ".json"];
    var allSupportedExtensions = __spreadArray(__spreadArray([], ts.supportedTSExtensions, true), ts.supportedJSExtensions, true);
    var allSupportedExtensionsWithJson = __spreadArray(__spreadArray(__spreadArray([], ts.supportedTSExtensions, true), ts.supportedJSExtensions, true), [".json"], false);
    function getSupportedExtensions(options, extraFileExtensions) {
        var needJsExtensions = options && getAllowJSCompilerOption(options);
        if (!extraFileExtensions || extraFileExtensions.length === 0) {
            return needJsExtensions ? allSupportedExtensions : ts.supportedTSExtensions;
        }
        var extensions = __spreadArray(__spreadArray([], needJsExtensions ? allSupportedExtensions : ts.supportedTSExtensions, true), ts.mapDefined(extraFileExtensions, function (x) { return x.scriptKind === 7 || needJsExtensions && isJSLike(x.scriptKind) ? x.extension : undefined; }), true);
        return ts.deduplicate(extensions, ts.equateStringsCaseSensitive, ts.compareStringsCaseSensitive);
    }
    ts.getSupportedExtensions = getSupportedExtensions;
    function getSuppoertedExtensionsWithJsonIfResolveJsonModule(options, supportedExtensions) {
        if (!options || !options.resolveJsonModule) {
            return supportedExtensions;
        }
        if (supportedExtensions === allSupportedExtensions) {
            return allSupportedExtensionsWithJson;
        }
        if (supportedExtensions === ts.supportedTSExtensions) {
            return ts.supportedTSExtensionsWithJson;
        }
        return __spreadArray(__spreadArray([], supportedExtensions, true), [".json"], false);
    }
    ts.getSuppoertedExtensionsWithJsonIfResolveJsonModule = getSuppoertedExtensionsWithJsonIfResolveJsonModule;
    function isJSLike(scriptKind) {
        return scriptKind === 1 || scriptKind === 2;
    }
    function hasJSFileExtension(fileName) {
        return ts.some(ts.supportedJSExtensions, function (extension) { return ts.fileExtensionIs(fileName, extension); });
    }
    ts.hasJSFileExtension = hasJSFileExtension;
    function hasTSFileExtension(fileName) {
        return ts.some(ts.supportedTSExtensions, function (extension) { return ts.fileExtensionIs(fileName, extension); });
    }
    ts.hasTSFileExtension = hasTSFileExtension;
    function isSupportedSourceFileName(fileName, compilerOptions, extraFileExtensions) {
        if (!fileName) {
            return false;
        }
        var supportedExtensions = getSupportedExtensions(compilerOptions, extraFileExtensions);
        for (var _i = 0, _a = getSuppoertedExtensionsWithJsonIfResolveJsonModule(compilerOptions, supportedExtensions); _i < _a.length; _i++) {
            var extension = _a[_i];
            if (ts.fileExtensionIs(fileName, extension)) {
                return true;
            }
        }
        return false;
    }
    ts.isSupportedSourceFileName = isSupportedSourceFileName;
    function numberOfDirectorySeparators(str) {
        var match = str.match(/\//g);
        return match ? match.length : 0;
    }
    function compareNumberOfDirectorySeparators(path1, path2) {
        return ts.compareValues(numberOfDirectorySeparators(path1), numberOfDirectorySeparators(path2));
    }
    ts.compareNumberOfDirectorySeparators = compareNumberOfDirectorySeparators;
    function getExtensionPriority(path, supportedExtensions) {
        for (var i = supportedExtensions.length - 1; i >= 0; i--) {
            if (ts.fileExtensionIs(path, supportedExtensions[i])) {
                return adjustExtensionPriority(i, supportedExtensions);
            }
        }
        return 0;
    }
    ts.getExtensionPriority = getExtensionPriority;
    function adjustExtensionPriority(extensionPriority, supportedExtensions) {
        if (extensionPriority < 2) {
            return 0;
        }
        else if (extensionPriority < supportedExtensions.length) {
            return 2;
        }
        else {
            return supportedExtensions.length;
        }
    }
    ts.adjustExtensionPriority = adjustExtensionPriority;
    function getNextLowestExtensionPriority(extensionPriority, supportedExtensions) {
        if (extensionPriority < 2) {
            return 2;
        }
        else {
            return supportedExtensions.length;
        }
    }
    ts.getNextLowestExtensionPriority = getNextLowestExtensionPriority;
    var extensionsToRemove = [".d.ts", ".ts", ".js", ".tsx", ".jsx", ".json"];
    function removeFileExtension(path) {
        for (var _i = 0, extensionsToRemove_1 = extensionsToRemove; _i < extensionsToRemove_1.length; _i++) {
            var ext = extensionsToRemove_1[_i];
            var extensionless = tryRemoveExtension(path, ext);
            if (extensionless !== undefined) {
                return extensionless;
            }
        }
        return path;
    }
    ts.removeFileExtension = removeFileExtension;
    function tryRemoveExtension(path, extension) {
        return ts.fileExtensionIs(path, extension) ? removeExtension(path, extension) : undefined;
    }
    ts.tryRemoveExtension = tryRemoveExtension;
    function removeExtension(path, extension) {
        return path.substring(0, path.length - extension.length);
    }
    ts.removeExtension = removeExtension;
    function changeExtension(path, newExtension) {
        return ts.changeAnyExtension(path, newExtension, extensionsToRemove, false);
    }
    ts.changeExtension = changeExtension;
    function tryParsePattern(pattern) {
        var indexOfStar = pattern.indexOf("*");
        if (indexOfStar === -1) {
            return pattern;
        }
        return pattern.indexOf("*", indexOfStar + 1) !== -1
            ? undefined
            : {
                prefix: pattern.substr(0, indexOfStar),
                suffix: pattern.substr(indexOfStar + 1)
            };
    }
    ts.tryParsePattern = tryParsePattern;
    function tryParsePatterns(paths) {
        return ts.mapDefined(ts.getOwnKeys(paths), function (path) { return tryParsePattern(path); });
    }
    ts.tryParsePatterns = tryParsePatterns;
    function positionIsSynthesized(pos) {
        return !(pos >= 0);
    }
    ts.positionIsSynthesized = positionIsSynthesized;
    function extensionIsTS(ext) {
        return ext === ".ts" || ext === ".tsx" || ext === ".d.ts";
    }
    ts.extensionIsTS = extensionIsTS;
    function resolutionExtensionIsTSOrJson(ext) {
        return extensionIsTS(ext) || ext === ".json";
    }
    ts.resolutionExtensionIsTSOrJson = resolutionExtensionIsTSOrJson;
    function extensionFromPath(path) {
        var ext = tryGetExtensionFromPath(path);
        return ext !== undefined ? ext : ts.Debug.fail("File " + path + " has unknown extension.");
    }
    ts.extensionFromPath = extensionFromPath;
    function isAnySupportedFileExtension(path) {
        return tryGetExtensionFromPath(path) !== undefined;
    }
    ts.isAnySupportedFileExtension = isAnySupportedFileExtension;
    function tryGetExtensionFromPath(path) {
        return ts.find(extensionsToRemove, function (e) { return ts.fileExtensionIs(path, e); });
    }
    ts.tryGetExtensionFromPath = tryGetExtensionFromPath;
    function isCheckJsEnabledForFile(sourceFile, compilerOptions) {
        return sourceFile.checkJsDirective ? sourceFile.checkJsDirective.enabled : compilerOptions.checkJs;
    }
    ts.isCheckJsEnabledForFile = isCheckJsEnabledForFile;
    ts.emptyFileSystemEntries = {
        files: ts.emptyArray,
        directories: ts.emptyArray
    };
    function matchPatternOrExact(patternOrStrings, candidate) {
        var patterns = [];
        for (var _i = 0, patternOrStrings_1 = patternOrStrings; _i < patternOrStrings_1.length; _i++) {
            var patternOrString = patternOrStrings_1[_i];
            if (patternOrString === candidate) {
                return candidate;
            }
            if (!ts.isString(patternOrString)) {
                patterns.push(patternOrString);
            }
        }
        return ts.findBestPatternMatch(patterns, function (_) { return _; }, candidate);
    }
    ts.matchPatternOrExact = matchPatternOrExact;
    function sliceAfter(arr, value) {
        var index = arr.indexOf(value);
        ts.Debug.assert(index !== -1);
        return arr.slice(index);
    }
    ts.sliceAfter = sliceAfter;
    function addRelatedInfo(diagnostic) {
        var _a;
        var relatedInformation = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            relatedInformation[_i - 1] = arguments[_i];
        }
        if (!relatedInformation.length) {
            return diagnostic;
        }
        if (!diagnostic.relatedInformation) {
            diagnostic.relatedInformation = [];
        }
        ts.Debug.assert(diagnostic.relatedInformation !== ts.emptyArray, "Diagnostic had empty array singleton for related info, but is still being constructed!");
        (_a = diagnostic.relatedInformation).push.apply(_a, relatedInformation);
        return diagnostic;
    }
    ts.addRelatedInfo = addRelatedInfo;
    function minAndMax(arr, getValue) {
        ts.Debug.assert(arr.length !== 0);
        var min = getValue(arr[0]);
        var max = min;
        for (var i = 1; i < arr.length; i++) {
            var value = getValue(arr[i]);
            if (value < min) {
                min = value;
            }
            else if (value > max) {
                max = value;
            }
        }
        return { min: min, max: max };
    }
    ts.minAndMax = minAndMax;
    function rangeOfNode(node) {
        return { pos: getTokenPosOfNode(node), end: node.end };
    }
    ts.rangeOfNode = rangeOfNode;
    function rangeOfTypeParameters(sourceFile, typeParameters) {
        var pos = typeParameters.pos - 1;
        var end = ts.skipTrivia(sourceFile.text, typeParameters.end) + 1;
        return { pos: pos, end: end };
    }
    ts.rangeOfTypeParameters = rangeOfTypeParameters;
    function skipTypeChecking(sourceFile, options, host) {
        return (options.skipLibCheck && sourceFile.isDeclarationFile ||
            options.skipDefaultLibCheck && sourceFile.hasNoDefaultLib) ||
            host.isSourceOfProjectReferenceRedirect(sourceFile.fileName);
    }
    ts.skipTypeChecking = skipTypeChecking;
    function isJsonEqual(a, b) {
        return a === b || typeof a === "object" && a !== null && typeof b === "object" && b !== null && ts.equalOwnProperties(a, b, isJsonEqual);
    }
    ts.isJsonEqual = isJsonEqual;
    function parsePseudoBigInt(stringValue) {
        var log2Base;
        switch (stringValue.charCodeAt(1)) {
            case 98:
            case 66:
                log2Base = 1;
                break;
            case 111:
            case 79:
                log2Base = 3;
                break;
            case 120:
            case 88:
                log2Base = 4;
                break;
            default:
                var nIndex = stringValue.length - 1;
                var nonZeroStart = 0;
                while (stringValue.charCodeAt(nonZeroStart) === 48) {
                    nonZeroStart++;
                }
                return stringValue.slice(nonZeroStart, nIndex) || "0";
        }
        var startIndex = 2, endIndex = stringValue.length - 1;
        var bitsNeeded = (endIndex - startIndex) * log2Base;
        var segments = new Uint16Array((bitsNeeded >>> 4) + (bitsNeeded & 15 ? 1 : 0));
        for (var i = endIndex - 1, bitOffset = 0; i >= startIndex; i--, bitOffset += log2Base) {
            var segment = bitOffset >>> 4;
            var digitChar = stringValue.charCodeAt(i);
            var digit = digitChar <= 57
                ? digitChar - 48
                : 10 + digitChar -
                    (digitChar <= 70 ? 65 : 97);
            var shiftedDigit = digit << (bitOffset & 15);
            segments[segment] |= shiftedDigit;
            var residual = shiftedDigit >>> 16;
            if (residual)
                segments[segment + 1] |= residual;
        }
        var base10Value = "";
        var firstNonzeroSegment = segments.length - 1;
        var segmentsRemaining = true;
        while (segmentsRemaining) {
            var mod10 = 0;
            segmentsRemaining = false;
            for (var segment = firstNonzeroSegment; segment >= 0; segment--) {
                var newSegment = mod10 << 16 | segments[segment];
                var segmentValue = (newSegment / 10) | 0;
                segments[segment] = segmentValue;
                mod10 = newSegment - segmentValue * 10;
                if (segmentValue && !segmentsRemaining) {
                    firstNonzeroSegment = segment;
                    segmentsRemaining = true;
                }
            }
            base10Value = mod10 + base10Value;
        }
        return base10Value;
    }
    ts.parsePseudoBigInt = parsePseudoBigInt;
    function pseudoBigIntToString(_a) {
        var negative = _a.negative, base10Value = _a.base10Value;
        return (negative && base10Value !== "0" ? "-" : "") + base10Value;
    }
    ts.pseudoBigIntToString = pseudoBigIntToString;
    function isValidTypeOnlyAliasUseSite(useSite) {
        return !!(useSite.flags & 8388608)
            || isPartOfTypeQuery(useSite)
            || isIdentifierInNonEmittingHeritageClause(useSite)
            || isPartOfPossiblyValidTypeOrAbstractComputedPropertyName(useSite)
            || !(isExpressionNode(useSite) || isShorthandPropertyNameUseSite(useSite));
    }
    ts.isValidTypeOnlyAliasUseSite = isValidTypeOnlyAliasUseSite;
    function typeOnlyDeclarationIsExport(typeOnlyDeclaration) {
        return typeOnlyDeclaration.kind === 273;
    }
    ts.typeOnlyDeclarationIsExport = typeOnlyDeclarationIsExport;
    function isShorthandPropertyNameUseSite(useSite) {
        return ts.isIdentifier(useSite) && ts.isShorthandPropertyAssignment(useSite.parent) && useSite.parent.name === useSite;
    }
    function isPartOfPossiblyValidTypeOrAbstractComputedPropertyName(node) {
        while (node.kind === 79 || node.kind === 204) {
            node = node.parent;
        }
        if (node.kind !== 160) {
            return false;
        }
        if (hasSyntacticModifier(node.parent, 128)) {
            return true;
        }
        var containerKind = node.parent.parent.kind;
        return containerKind === 256 || containerKind === 180;
    }
    function isIdentifierInNonEmittingHeritageClause(node) {
        if (node.kind !== 79)
            return false;
        var heritageClause = ts.findAncestor(node.parent, function (parent) {
            switch (parent.kind) {
                case 289:
                    return true;
                case 204:
                case 226:
                    return false;
                default:
                    return "quit";
            }
        });
        return (heritageClause === null || heritageClause === void 0 ? void 0 : heritageClause.token) === 117 || (heritageClause === null || heritageClause === void 0 ? void 0 : heritageClause.parent.kind) === 256;
    }
    function isIdentifierTypeReference(node) {
        return ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName);
    }
    ts.isIdentifierTypeReference = isIdentifierTypeReference;
    function arrayIsHomogeneous(array, comparer) {
        if (comparer === void 0) { comparer = ts.equateValues; }
        if (array.length < 2)
            return true;
        var first = array[0];
        for (var i = 1, length_1 = array.length; i < length_1; i++) {
            var target = array[i];
            if (!comparer(first, target))
                return false;
        }
        return true;
    }
    ts.arrayIsHomogeneous = arrayIsHomogeneous;
    function setTextRangePos(range, pos) {
        range.pos = pos;
        return range;
    }
    ts.setTextRangePos = setTextRangePos;
    function setTextRangeEnd(range, end) {
        range.end = end;
        return range;
    }
    ts.setTextRangeEnd = setTextRangeEnd;
    function setTextRangePosEnd(range, pos, end) {
        return setTextRangeEnd(setTextRangePos(range, pos), end);
    }
    ts.setTextRangePosEnd = setTextRangePosEnd;
    function setTextRangePosWidth(range, pos, width) {
        return setTextRangePosEnd(range, pos, pos + width);
    }
    ts.setTextRangePosWidth = setTextRangePosWidth;
    function setNodeFlags(node, newFlags) {
        if (node) {
            node.flags = newFlags;
        }
        return node;
    }
    ts.setNodeFlags = setNodeFlags;
    function setParent(child, parent) {
        if (child && parent) {
            child.parent = parent;
        }
        return child;
    }
    ts.setParent = setParent;
    function setEachParent(children, parent) {
        if (children) {
            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                var child = children_1[_i];
                setParent(child, parent);
            }
        }
        return children;
    }
    ts.setEachParent = setEachParent;
    function setParentRecursive(rootNode, incremental) {
        if (!rootNode)
            return rootNode;
        ts.forEachChildRecursively(rootNode, ts.isJSDocNode(rootNode) ? bindParentToChildIgnoringJSDoc : bindParentToChild);
        return rootNode;
        function bindParentToChildIgnoringJSDoc(child, parent) {
            if (incremental && child.parent === parent) {
                return "skip";
            }
            setParent(child, parent);
        }
        function bindJSDoc(child) {
            if (ts.hasJSDocNodes(child)) {
                for (var _i = 0, _a = child.jsDoc; _i < _a.length; _i++) {
                    var doc = _a[_i];
                    bindParentToChildIgnoringJSDoc(doc, child);
                    ts.forEachChildRecursively(doc, bindParentToChildIgnoringJSDoc);
                }
            }
        }
        function bindParentToChild(child, parent) {
            return bindParentToChildIgnoringJSDoc(child, parent) || bindJSDoc(child);
        }
    }
    ts.setParentRecursive = setParentRecursive;
    function isPackedElement(node) {
        return !ts.isOmittedExpression(node);
    }
    function isPackedArrayLiteral(node) {
        return ts.isArrayLiteralExpression(node) && ts.every(node.elements, isPackedElement);
    }
    ts.isPackedArrayLiteral = isPackedArrayLiteral;
    function expressionResultIsUnused(node) {
        ts.Debug.assertIsDefined(node.parent);
        while (true) {
            var parent = node.parent;
            if (ts.isParenthesizedExpression(parent)) {
                node = parent;
                continue;
            }
            if (ts.isExpressionStatement(parent) ||
                ts.isVoidExpression(parent) ||
                ts.isForStatement(parent) && (parent.initializer === node || parent.incrementor === node)) {
                return true;
            }
            if (ts.isCommaListExpression(parent)) {
                if (node !== ts.last(parent.elements))
                    return true;
                node = parent;
                continue;
            }
            if (ts.isBinaryExpression(parent) && parent.operatorToken.kind === 27) {
                if (node === parent.left)
                    return true;
                node = parent;
                continue;
            }
            return false;
        }
    }
    ts.expressionResultIsUnused = expressionResultIsUnused;
    function containsIgnoredPath(path) {
        return ts.some(ts.ignoredPaths, function (p) { return ts.stringContains(path, p); });
    }
    ts.containsIgnoredPath = containsIgnoredPath;
    function getContainingNodeArray(node) {
        if (!node.parent)
            return undefined;
        switch (node.kind) {
            case 161:
                var parent_1 = node.parent;
                return parent_1.kind === 188 ? undefined : parent_1.typeParameters;
            case 162:
                return node.parent.parameters;
            case 197:
                return node.parent.templateSpans;
            case 231:
                return node.parent.templateSpans;
            case 163:
                return node.parent.decorators;
            case 289:
                return node.parent.heritageClauses;
        }
        var parent = node.parent;
        if (ts.isJSDocTag(node)) {
            return ts.isJSDocTypeLiteral(node.parent) ? undefined : node.parent.tags;
        }
        switch (parent.kind) {
            case 180:
            case 256:
                return ts.isTypeElement(node) ? parent.members : undefined;
            case 185:
            case 186:
                return parent.types;
            case 182:
            case 202:
            case 346:
            case 267:
            case 271:
                return parent.elements;
            case 203:
            case 284:
                return parent.properties;
            case 206:
            case 207:
                return ts.isTypeNode(node) ? parent.typeArguments :
                    parent.expression === node ? undefined :
                        parent.arguments;
            case 276:
            case 280:
                return ts.isJsxChild(node) ? parent.children : undefined;
            case 278:
            case 277:
                return ts.isTypeNode(node) ? parent.typeArguments : undefined;
            case 233:
            case 287:
            case 288:
            case 260:
                return parent.statements;
            case 261:
                return parent.clauses;
            case 255:
            case 224:
                return ts.isClassElement(node) ? parent.members : undefined;
            case 258:
                return ts.isEnumMember(node) ? parent.members : undefined;
            case 300:
                return parent.statements;
        }
    }
    ts.getContainingNodeArray = getContainingNodeArray;
    function hasContextSensitiveParameters(node) {
        if (!node.typeParameters) {
            if (ts.some(node.parameters, function (p) { return !getEffectiveTypeAnnotationNode(p); })) {
                return true;
            }
            if (node.kind !== 212) {
                var parameter = ts.firstOrUndefined(node.parameters);
                if (!(parameter && parameterIsThisKeyword(parameter))) {
                    return true;
                }
            }
        }
        return false;
    }
    ts.hasContextSensitiveParameters = hasContextSensitiveParameters;
    function isInfinityOrNaNString(name) {
        return name === "Infinity" || name === "-Infinity" || name === "NaN";
    }
    ts.isInfinityOrNaNString = isInfinityOrNaNString;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createBaseNodeFactory() {
        var NodeConstructor;
        var TokenConstructor;
        var IdentifierConstructor;
        var PrivateIdentifierConstructor;
        var SourceFileConstructor;
        return {
            createBaseSourceFileNode: createBaseSourceFileNode,
            createBaseIdentifierNode: createBaseIdentifierNode,
            createBasePrivateIdentifierNode: createBasePrivateIdentifierNode,
            createBaseTokenNode: createBaseTokenNode,
            createBaseNode: createBaseNode
        };
        function createBaseSourceFileNode(kind) {
            return new (SourceFileConstructor || (SourceFileConstructor = ts.objectAllocator.getSourceFileConstructor()))(kind, -1, -1);
        }
        function createBaseIdentifierNode(kind) {
            return new (IdentifierConstructor || (IdentifierConstructor = ts.objectAllocator.getIdentifierConstructor()))(kind, -1, -1);
        }
        function createBasePrivateIdentifierNode(kind) {
            return new (PrivateIdentifierConstructor || (PrivateIdentifierConstructor = ts.objectAllocator.getPrivateIdentifierConstructor()))(kind, -1, -1);
        }
        function createBaseTokenNode(kind) {
            return new (TokenConstructor || (TokenConstructor = ts.objectAllocator.getTokenConstructor()))(kind, -1, -1);
        }
        function createBaseNode(kind) {
            return new (NodeConstructor || (NodeConstructor = ts.objectAllocator.getNodeConstructor()))(kind, -1, -1);
        }
    }
    ts.createBaseNodeFactory = createBaseNodeFactory;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createParenthesizerRules(factory) {
        var binaryLeftOperandParenthesizerCache;
        var binaryRightOperandParenthesizerCache;
        return {
            getParenthesizeLeftSideOfBinaryForOperator: getParenthesizeLeftSideOfBinaryForOperator,
            getParenthesizeRightSideOfBinaryForOperator: getParenthesizeRightSideOfBinaryForOperator,
            parenthesizeLeftSideOfBinary: parenthesizeLeftSideOfBinary,
            parenthesizeRightSideOfBinary: parenthesizeRightSideOfBinary,
            parenthesizeExpressionOfComputedPropertyName: parenthesizeExpressionOfComputedPropertyName,
            parenthesizeConditionOfConditionalExpression: parenthesizeConditionOfConditionalExpression,
            parenthesizeBranchOfConditionalExpression: parenthesizeBranchOfConditionalExpression,
            parenthesizeExpressionOfExportDefault: parenthesizeExpressionOfExportDefault,
            parenthesizeExpressionOfNew: parenthesizeExpressionOfNew,
            parenthesizeLeftSideOfAccess: parenthesizeLeftSideOfAccess,
            parenthesizeOperandOfPostfixUnary: parenthesizeOperandOfPostfixUnary,
            parenthesizeOperandOfPrefixUnary: parenthesizeOperandOfPrefixUnary,
            parenthesizeExpressionsOfCommaDelimitedList: parenthesizeExpressionsOfCommaDelimitedList,
            parenthesizeExpressionForDisallowedComma: parenthesizeExpressionForDisallowedComma,
            parenthesizeExpressionOfExpressionStatement: parenthesizeExpressionOfExpressionStatement,
            parenthesizeConciseBodyOfArrowFunction: parenthesizeConciseBodyOfArrowFunction,
            parenthesizeMemberOfConditionalType: parenthesizeMemberOfConditionalType,
            parenthesizeMemberOfElementType: parenthesizeMemberOfElementType,
            parenthesizeElementTypeOfArrayType: parenthesizeElementTypeOfArrayType,
            parenthesizeConstituentTypesOfUnionOrIntersectionType: parenthesizeConstituentTypesOfUnionOrIntersectionType,
            parenthesizeTypeArguments: parenthesizeTypeArguments,
        };
        function getParenthesizeLeftSideOfBinaryForOperator(operatorKind) {
            binaryLeftOperandParenthesizerCache || (binaryLeftOperandParenthesizerCache = new ts.Map());
            var parenthesizerRule = binaryLeftOperandParenthesizerCache.get(operatorKind);
            if (!parenthesizerRule) {
                parenthesizerRule = function (node) { return parenthesizeLeftSideOfBinary(operatorKind, node); };
                binaryLeftOperandParenthesizerCache.set(operatorKind, parenthesizerRule);
            }
            return parenthesizerRule;
        }
        function getParenthesizeRightSideOfBinaryForOperator(operatorKind) {
            binaryRightOperandParenthesizerCache || (binaryRightOperandParenthesizerCache = new ts.Map());
            var parenthesizerRule = binaryRightOperandParenthesizerCache.get(operatorKind);
            if (!parenthesizerRule) {
                parenthesizerRule = function (node) { return parenthesizeRightSideOfBinary(operatorKind, undefined, node); };
                binaryRightOperandParenthesizerCache.set(operatorKind, parenthesizerRule);
            }
            return parenthesizerRule;
        }
        function binaryOperandNeedsParentheses(binaryOperator, operand, isLeftSideOfBinary, leftOperand) {
            var binaryOperatorPrecedence = ts.getOperatorPrecedence(219, binaryOperator);
            var binaryOperatorAssociativity = ts.getOperatorAssociativity(219, binaryOperator);
            var emittedOperand = ts.skipPartiallyEmittedExpressions(operand);
            if (!isLeftSideOfBinary && operand.kind === 212 && binaryOperatorPrecedence > 3) {
                return true;
            }
            var operandPrecedence = ts.getExpressionPrecedence(emittedOperand);
            switch (ts.compareValues(operandPrecedence, binaryOperatorPrecedence)) {
                case -1:
                    if (!isLeftSideOfBinary
                        && binaryOperatorAssociativity === 1
                        && operand.kind === 222) {
                        return false;
                    }
                    return true;
                case 1:
                    return false;
                case 0:
                    if (isLeftSideOfBinary) {
                        return binaryOperatorAssociativity === 1;
                    }
                    else {
                        if (ts.isBinaryExpression(emittedOperand)
                            && emittedOperand.operatorToken.kind === binaryOperator) {
                            if (operatorHasAssociativeProperty(binaryOperator)) {
                                return false;
                            }
                            if (binaryOperator === 39) {
                                var leftKind = leftOperand ? getLiteralKindOfBinaryPlusOperand(leftOperand) : 0;
                                if (ts.isLiteralKind(leftKind) && leftKind === getLiteralKindOfBinaryPlusOperand(emittedOperand)) {
                                    return false;
                                }
                            }
                        }
                        var operandAssociativity = ts.getExpressionAssociativity(emittedOperand);
                        return operandAssociativity === 0;
                    }
            }
        }
        function operatorHasAssociativeProperty(binaryOperator) {
            return binaryOperator === 41
                || binaryOperator === 51
                || binaryOperator === 50
                || binaryOperator === 52;
        }
        function getLiteralKindOfBinaryPlusOperand(node) {
            node = ts.skipPartiallyEmittedExpressions(node);
            if (ts.isLiteralKind(node.kind)) {
                return node.kind;
            }
            if (node.kind === 219 && node.operatorToken.kind === 39) {
                if (node.cachedLiteralKind !== undefined) {
                    return node.cachedLiteralKind;
                }
                var leftKind = getLiteralKindOfBinaryPlusOperand(node.left);
                var literalKind = ts.isLiteralKind(leftKind)
                    && leftKind === getLiteralKindOfBinaryPlusOperand(node.right)
                    ? leftKind
                    : 0;
                node.cachedLiteralKind = literalKind;
                return literalKind;
            }
            return 0;
        }
        function parenthesizeBinaryOperand(binaryOperator, operand, isLeftSideOfBinary, leftOperand) {
            var skipped = ts.skipPartiallyEmittedExpressions(operand);
            if (skipped.kind === 210) {
                return operand;
            }
            return binaryOperandNeedsParentheses(binaryOperator, operand, isLeftSideOfBinary, leftOperand)
                ? factory.createParenthesizedExpression(operand)
                : operand;
        }
        function parenthesizeLeftSideOfBinary(binaryOperator, leftSide) {
            return parenthesizeBinaryOperand(binaryOperator, leftSide, true);
        }
        function parenthesizeRightSideOfBinary(binaryOperator, leftSide, rightSide) {
            return parenthesizeBinaryOperand(binaryOperator, rightSide, false, leftSide);
        }
        function parenthesizeExpressionOfComputedPropertyName(expression) {
            return ts.isCommaSequence(expression) ? factory.createParenthesizedExpression(expression) : expression;
        }
        function parenthesizeConditionOfConditionalExpression(condition) {
            var conditionalPrecedence = ts.getOperatorPrecedence(220, 57);
            var emittedCondition = ts.skipPartiallyEmittedExpressions(condition);
            var conditionPrecedence = ts.getExpressionPrecedence(emittedCondition);
            if (ts.compareValues(conditionPrecedence, conditionalPrecedence) !== 1) {
                return factory.createParenthesizedExpression(condition);
            }
            return condition;
        }
        function parenthesizeBranchOfConditionalExpression(branch) {
            var emittedExpression = ts.skipPartiallyEmittedExpressions(branch);
            return ts.isCommaSequence(emittedExpression)
                ? factory.createParenthesizedExpression(branch)
                : branch;
        }
        function parenthesizeExpressionOfExportDefault(expression) {
            var check = ts.skipPartiallyEmittedExpressions(expression);
            var needsParens = ts.isCommaSequence(check);
            if (!needsParens) {
                switch (ts.getLeftmostExpression(check, false).kind) {
                    case 224:
                    case 211:
                        needsParens = true;
                }
            }
            return needsParens ? factory.createParenthesizedExpression(expression) : expression;
        }
        function parenthesizeExpressionOfNew(expression) {
            var leftmostExpr = ts.getLeftmostExpression(expression, true);
            switch (leftmostExpr.kind) {
                case 206:
                    return factory.createParenthesizedExpression(expression);
                case 207:
                    return !leftmostExpr.arguments
                        ? factory.createParenthesizedExpression(expression)
                        : expression;
            }
            return parenthesizeLeftSideOfAccess(expression);
        }
        function parenthesizeLeftSideOfAccess(expression) {
            var emittedExpression = ts.skipPartiallyEmittedExpressions(expression);
            if (ts.isLeftHandSideExpression(emittedExpression)
                && (emittedExpression.kind !== 207 || emittedExpression.arguments)) {
                return expression;
            }
            return ts.setTextRange(factory.createParenthesizedExpression(expression), expression);
        }
        function parenthesizeOperandOfPostfixUnary(operand) {
            return ts.isLeftHandSideExpression(operand) ? operand : ts.setTextRange(factory.createParenthesizedExpression(operand), operand);
        }
        function parenthesizeOperandOfPrefixUnary(operand) {
            return ts.isUnaryExpression(operand) ? operand : ts.setTextRange(factory.createParenthesizedExpression(operand), operand);
        }
        function parenthesizeExpressionsOfCommaDelimitedList(elements) {
            var result = ts.sameMap(elements, parenthesizeExpressionForDisallowedComma);
            return ts.setTextRange(factory.createNodeArray(result, elements.hasTrailingComma), elements);
        }
        function parenthesizeExpressionForDisallowedComma(expression) {
            var emittedExpression = ts.skipPartiallyEmittedExpressions(expression);
            var expressionPrecedence = ts.getExpressionPrecedence(emittedExpression);
            var commaPrecedence = ts.getOperatorPrecedence(219, 27);
            return expressionPrecedence > commaPrecedence ? expression : ts.setTextRange(factory.createParenthesizedExpression(expression), expression);
        }
        function parenthesizeExpressionOfExpressionStatement(expression) {
            var emittedExpression = ts.skipPartiallyEmittedExpressions(expression);
            if (ts.isCallExpression(emittedExpression)) {
                var callee = emittedExpression.expression;
                var kind = ts.skipPartiallyEmittedExpressions(callee).kind;
                if (kind === 211 || kind === 212) {
                    var updated = factory.updateCallExpression(emittedExpression, ts.setTextRange(factory.createParenthesizedExpression(callee), callee), emittedExpression.typeArguments, emittedExpression.arguments);
                    return factory.restoreOuterExpressions(expression, updated, 8);
                }
            }
            var leftmostExpressionKind = ts.getLeftmostExpression(emittedExpression, false).kind;
            if (leftmostExpressionKind === 203 || leftmostExpressionKind === 211) {
                return ts.setTextRange(factory.createParenthesizedExpression(expression), expression);
            }
            return expression;
        }
        function parenthesizeConciseBodyOfArrowFunction(body) {
            if (!ts.isBlock(body) && (ts.isCommaSequence(body) || ts.getLeftmostExpression(body, false).kind === 203)) {
                return ts.setTextRange(factory.createParenthesizedExpression(body), body);
            }
            return body;
        }
        function parenthesizeMemberOfConditionalType(member) {
            return member.kind === 187 ? factory.createParenthesizedType(member) : member;
        }
        function parenthesizeMemberOfElementType(member) {
            switch (member.kind) {
                case 185:
                case 186:
                case 177:
                case 178:
                    return factory.createParenthesizedType(member);
            }
            return parenthesizeMemberOfConditionalType(member);
        }
        function parenthesizeElementTypeOfArrayType(member) {
            switch (member.kind) {
                case 179:
                case 191:
                case 188:
                    return factory.createParenthesizedType(member);
            }
            return parenthesizeMemberOfElementType(member);
        }
        function parenthesizeConstituentTypesOfUnionOrIntersectionType(members) {
            return factory.createNodeArray(ts.sameMap(members, parenthesizeMemberOfElementType));
        }
        function parenthesizeOrdinalTypeArgument(node, i) {
            return i === 0 && ts.isFunctionOrConstructorTypeNode(node) && node.typeParameters ? factory.createParenthesizedType(node) : node;
        }
        function parenthesizeTypeArguments(typeArguments) {
            if (ts.some(typeArguments)) {
                return factory.createNodeArray(ts.sameMap(typeArguments, parenthesizeOrdinalTypeArgument));
            }
        }
    }
    ts.createParenthesizerRules = createParenthesizerRules;
    ts.nullParenthesizerRules = {
        getParenthesizeLeftSideOfBinaryForOperator: function (_) { return ts.identity; },
        getParenthesizeRightSideOfBinaryForOperator: function (_) { return ts.identity; },
        parenthesizeLeftSideOfBinary: function (_binaryOperator, leftSide) { return leftSide; },
        parenthesizeRightSideOfBinary: function (_binaryOperator, _leftSide, rightSide) { return rightSide; },
        parenthesizeExpressionOfComputedPropertyName: ts.identity,
        parenthesizeConditionOfConditionalExpression: ts.identity,
        parenthesizeBranchOfConditionalExpression: ts.identity,
        parenthesizeExpressionOfExportDefault: ts.identity,
        parenthesizeExpressionOfNew: function (expression) { return ts.cast(expression, ts.isLeftHandSideExpression); },
        parenthesizeLeftSideOfAccess: function (expression) { return ts.cast(expression, ts.isLeftHandSideExpression); },
        parenthesizeOperandOfPostfixUnary: function (operand) { return ts.cast(operand, ts.isLeftHandSideExpression); },
        parenthesizeOperandOfPrefixUnary: function (operand) { return ts.cast(operand, ts.isUnaryExpression); },
        parenthesizeExpressionsOfCommaDelimitedList: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeExpressionForDisallowedComma: ts.identity,
        parenthesizeExpressionOfExpressionStatement: ts.identity,
        parenthesizeConciseBodyOfArrowFunction: ts.identity,
        parenthesizeMemberOfConditionalType: ts.identity,
        parenthesizeMemberOfElementType: ts.identity,
        parenthesizeElementTypeOfArrayType: ts.identity,
        parenthesizeConstituentTypesOfUnionOrIntersectionType: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeTypeArguments: function (nodes) { return nodes && ts.cast(nodes, ts.isNodeArray); },
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createNodeConverters(factory) {
        return {
            convertToFunctionBlock: convertToFunctionBlock,
            convertToFunctionExpression: convertToFunctionExpression,
            convertToArrayAssignmentElement: convertToArrayAssignmentElement,
            convertToObjectAssignmentElement: convertToObjectAssignmentElement,
            convertToAssignmentPattern: convertToAssignmentPattern,
            convertToObjectAssignmentPattern: convertToObjectAssignmentPattern,
            convertToArrayAssignmentPattern: convertToArrayAssignmentPattern,
            convertToAssignmentElementTarget: convertToAssignmentElementTarget,
        };
        function convertToFunctionBlock(node, multiLine) {
            if (ts.isBlock(node))
                return node;
            var returnStatement = factory.createReturnStatement(node);
            ts.setTextRange(returnStatement, node);
            var body = factory.createBlock([returnStatement], multiLine);
            ts.setTextRange(body, node);
            return body;
        }
        function convertToFunctionExpression(node) {
            if (!node.body)
                return ts.Debug.fail("Cannot convert a FunctionDeclaration without a body");
            var updated = factory.createFunctionExpression(node.modifiers, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body);
            ts.setOriginalNode(updated, node);
            ts.setTextRange(updated, node);
            if (ts.getStartsOnNewLine(node)) {
                ts.setStartsOnNewLine(updated, true);
            }
            return updated;
        }
        function convertToArrayAssignmentElement(element) {
            if (ts.isBindingElement(element)) {
                if (element.dotDotDotToken) {
                    ts.Debug.assertNode(element.name, ts.isIdentifier);
                    return ts.setOriginalNode(ts.setTextRange(factory.createSpreadElement(element.name), element), element);
                }
                var expression = convertToAssignmentElementTarget(element.name);
                return element.initializer
                    ? ts.setOriginalNode(ts.setTextRange(factory.createAssignment(expression, element.initializer), element), element)
                    : expression;
            }
            return ts.cast(element, ts.isExpression);
        }
        function convertToObjectAssignmentElement(element) {
            if (ts.isBindingElement(element)) {
                if (element.dotDotDotToken) {
                    ts.Debug.assertNode(element.name, ts.isIdentifier);
                    return ts.setOriginalNode(ts.setTextRange(factory.createSpreadAssignment(element.name), element), element);
                }
                if (element.propertyName) {
                    var expression = convertToAssignmentElementTarget(element.name);
                    return ts.setOriginalNode(ts.setTextRange(factory.createPropertyAssignment(element.propertyName, element.initializer ? factory.createAssignment(expression, element.initializer) : expression), element), element);
                }
                ts.Debug.assertNode(element.name, ts.isIdentifier);
                return ts.setOriginalNode(ts.setTextRange(factory.createShorthandPropertyAssignment(element.name, element.initializer), element), element);
            }
            return ts.cast(element, ts.isObjectLiteralElementLike);
        }
        function convertToAssignmentPattern(node) {
            switch (node.kind) {
                case 200:
                case 202:
                    return convertToArrayAssignmentPattern(node);
                case 199:
                case 203:
                    return convertToObjectAssignmentPattern(node);
            }
        }
        function convertToObjectAssignmentPattern(node) {
            if (ts.isObjectBindingPattern(node)) {
                return ts.setOriginalNode(ts.setTextRange(factory.createObjectLiteralExpression(ts.map(node.elements, convertToObjectAssignmentElement)), node), node);
            }
            return ts.cast(node, ts.isObjectLiteralExpression);
        }
        function convertToArrayAssignmentPattern(node) {
            if (ts.isArrayBindingPattern(node)) {
                return ts.setOriginalNode(ts.setTextRange(factory.createArrayLiteralExpression(ts.map(node.elements, convertToArrayAssignmentElement)), node), node);
            }
            return ts.cast(node, ts.isArrayLiteralExpression);
        }
        function convertToAssignmentElementTarget(node) {
            if (ts.isBindingPattern(node)) {
                return convertToAssignmentPattern(node);
            }
            return ts.cast(node, ts.isExpression);
        }
    }
    ts.createNodeConverters = createNodeConverters;
    ts.nullNodeConverters = {
        convertToFunctionBlock: ts.notImplemented,
        convertToFunctionExpression: ts.notImplemented,
        convertToArrayAssignmentElement: ts.notImplemented,
        convertToObjectAssignmentElement: ts.notImplemented,
        convertToAssignmentPattern: ts.notImplemented,
        convertToObjectAssignmentPattern: ts.notImplemented,
        convertToArrayAssignmentPattern: ts.notImplemented,
        convertToAssignmentElementTarget: ts.notImplemented,
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    var nextAutoGenerateId = 0;
    function createNodeFactory(flags, baseFactory) {
        var update = flags & 8 ? updateWithoutOriginal : updateWithOriginal;
        var parenthesizerRules = ts.memoize(function () { return flags & 1 ? ts.nullParenthesizerRules : ts.createParenthesizerRules(factory); });
        var converters = ts.memoize(function () { return flags & 2 ? ts.nullNodeConverters : ts.createNodeConverters(factory); });
        var getBinaryCreateFunction = ts.memoizeOne(function (operator) { return function (left, right) { return createBinaryExpression(left, operator, right); }; });
        var getPrefixUnaryCreateFunction = ts.memoizeOne(function (operator) { return function (operand) { return createPrefixUnaryExpression(operator, operand); }; });
        var getPostfixUnaryCreateFunction = ts.memoizeOne(function (operator) { return function (operand) { return createPostfixUnaryExpression(operand, operator); }; });
        var getJSDocPrimaryTypeCreateFunction = ts.memoizeOne(function (kind) { return function () { return createJSDocPrimaryTypeWorker(kind); }; });
        var getJSDocUnaryTypeCreateFunction = ts.memoizeOne(function (kind) { return function (type) { return createJSDocUnaryTypeWorker(kind, type); }; });
        var getJSDocUnaryTypeUpdateFunction = ts.memoizeOne(function (kind) { return function (node, type) { return updateJSDocUnaryTypeWorker(kind, node, type); }; });
        var getJSDocSimpleTagCreateFunction = ts.memoizeOne(function (kind) { return function (tagName, comment) { return createJSDocSimpleTagWorker(kind, tagName, comment); }; });
        var getJSDocSimpleTagUpdateFunction = ts.memoizeOne(function (kind) { return function (node, tagName, comment) { return updateJSDocSimpleTagWorker(kind, node, tagName, comment); }; });
        var getJSDocTypeLikeTagCreateFunction = ts.memoizeOne(function (kind) { return function (tagName, typeExpression, comment) { return createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment); }; });
        var getJSDocTypeLikeTagUpdateFunction = ts.memoizeOne(function (kind) { return function (node, tagName, typeExpression, comment) { return updateJSDocTypeLikeTagWorker(kind, node, tagName, typeExpression, comment); }; });
        var factory = {
            get parenthesizer() { return parenthesizerRules(); },
            get converters() { return converters(); },
            createNodeArray: createNodeArray,
            createNumericLiteral: createNumericLiteral,
            createBigIntLiteral: createBigIntLiteral,
            createStringLiteral: createStringLiteral,
            createStringLiteralFromNode: createStringLiteralFromNode,
            createRegularExpressionLiteral: createRegularExpressionLiteral,
            createLiteralLikeNode: createLiteralLikeNode,
            createIdentifier: createIdentifier,
            updateIdentifier: updateIdentifier,
            createTempVariable: createTempVariable,
            createLoopVariable: createLoopVariable,
            createUniqueName: createUniqueName,
            getGeneratedNameForNode: getGeneratedNameForNode,
            createPrivateIdentifier: createPrivateIdentifier,
            createToken: createToken,
            createSuper: createSuper,
            createThis: createThis,
            createNull: createNull,
            createTrue: createTrue,
            createFalse: createFalse,
            createModifier: createModifier,
            createModifiersFromModifierFlags: createModifiersFromModifierFlags,
            createQualifiedName: createQualifiedName,
            updateQualifiedName: updateQualifiedName,
            createComputedPropertyName: createComputedPropertyName,
            updateComputedPropertyName: updateComputedPropertyName,
            createTypeParameterDeclaration: createTypeParameterDeclaration,
            updateTypeParameterDeclaration: updateTypeParameterDeclaration,
            createParameterDeclaration: createParameterDeclaration,
            updateParameterDeclaration: updateParameterDeclaration,
            createDecorator: createDecorator,
            updateDecorator: updateDecorator,
            createPropertySignature: createPropertySignature,
            updatePropertySignature: updatePropertySignature,
            createPropertyDeclaration: createPropertyDeclaration,
            updatePropertyDeclaration: updatePropertyDeclaration,
            createMethodSignature: createMethodSignature,
            updateMethodSignature: updateMethodSignature,
            createMethodDeclaration: createMethodDeclaration,
            updateMethodDeclaration: updateMethodDeclaration,
            createConstructorDeclaration: createConstructorDeclaration,
            updateConstructorDeclaration: updateConstructorDeclaration,
            createGetAccessorDeclaration: createGetAccessorDeclaration,
            updateGetAccessorDeclaration: updateGetAccessorDeclaration,
            createSetAccessorDeclaration: createSetAccessorDeclaration,
            updateSetAccessorDeclaration: updateSetAccessorDeclaration,
            createCallSignature: createCallSignature,
            updateCallSignature: updateCallSignature,
            createConstructSignature: createConstructSignature,
            updateConstructSignature: updateConstructSignature,
            createIndexSignature: createIndexSignature,
            updateIndexSignature: updateIndexSignature,
            createClassStaticBlockDeclaration: createClassStaticBlockDeclaration,
            updateClassStaticBlockDeclaration: updateClassStaticBlockDeclaration,
            createTemplateLiteralTypeSpan: createTemplateLiteralTypeSpan,
            updateTemplateLiteralTypeSpan: updateTemplateLiteralTypeSpan,
            createKeywordTypeNode: createKeywordTypeNode,
            createTypePredicateNode: createTypePredicateNode,
            updateTypePredicateNode: updateTypePredicateNode,
            createTypeReferenceNode: createTypeReferenceNode,
            updateTypeReferenceNode: updateTypeReferenceNode,
            createFunctionTypeNode: createFunctionTypeNode,
            updateFunctionTypeNode: updateFunctionTypeNode,
            createConstructorTypeNode: createConstructorTypeNode,
            updateConstructorTypeNode: updateConstructorTypeNode,
            createTypeQueryNode: createTypeQueryNode,
            updateTypeQueryNode: updateTypeQueryNode,
            createTypeLiteralNode: createTypeLiteralNode,
            updateTypeLiteralNode: updateTypeLiteralNode,
            createArrayTypeNode: createArrayTypeNode,
            updateArrayTypeNode: updateArrayTypeNode,
            createTupleTypeNode: createTupleTypeNode,
            updateTupleTypeNode: updateTupleTypeNode,
            createNamedTupleMember: createNamedTupleMember,
            updateNamedTupleMember: updateNamedTupleMember,
            createOptionalTypeNode: createOptionalTypeNode,
            updateOptionalTypeNode: updateOptionalTypeNode,
            createRestTypeNode: createRestTypeNode,
            updateRestTypeNode: updateRestTypeNode,
            createUnionTypeNode: createUnionTypeNode,
            updateUnionTypeNode: updateUnionTypeNode,
            createIntersectionTypeNode: createIntersectionTypeNode,
            updateIntersectionTypeNode: updateIntersectionTypeNode,
            createConditionalTypeNode: createConditionalTypeNode,
            updateConditionalTypeNode: updateConditionalTypeNode,
            createInferTypeNode: createInferTypeNode,
            updateInferTypeNode: updateInferTypeNode,
            createImportTypeNode: createImportTypeNode,
            updateImportTypeNode: updateImportTypeNode,
            createParenthesizedType: createParenthesizedType,
            updateParenthesizedType: updateParenthesizedType,
            createThisTypeNode: createThisTypeNode,
            createTypeOperatorNode: createTypeOperatorNode,
            updateTypeOperatorNode: updateTypeOperatorNode,
            createIndexedAccessTypeNode: createIndexedAccessTypeNode,
            updateIndexedAccessTypeNode: updateIndexedAccessTypeNode,
            createMappedTypeNode: createMappedTypeNode,
            updateMappedTypeNode: updateMappedTypeNode,
            createLiteralTypeNode: createLiteralTypeNode,
            updateLiteralTypeNode: updateLiteralTypeNode,
            createTemplateLiteralType: createTemplateLiteralType,
            updateTemplateLiteralType: updateTemplateLiteralType,
            createObjectBindingPattern: createObjectBindingPattern,
            updateObjectBindingPattern: updateObjectBindingPattern,
            createArrayBindingPattern: createArrayBindingPattern,
            updateArrayBindingPattern: updateArrayBindingPattern,
            createBindingElement: createBindingElement,
            updateBindingElement: updateBindingElement,
            createArrayLiteralExpression: createArrayLiteralExpression,
            updateArrayLiteralExpression: updateArrayLiteralExpression,
            createObjectLiteralExpression: createObjectLiteralExpression,
            updateObjectLiteralExpression: updateObjectLiteralExpression,
            createPropertyAccessExpression: flags & 4 ?
                function (expression, name) { return ts.setEmitFlags(createPropertyAccessExpression(expression, name), 131072); } :
                createPropertyAccessExpression,
            updatePropertyAccessExpression: updatePropertyAccessExpression,
            createPropertyAccessChain: flags & 4 ?
                function (expression, questionDotToken, name) { return ts.setEmitFlags(createPropertyAccessChain(expression, questionDotToken, name), 131072); } :
                createPropertyAccessChain,
            updatePropertyAccessChain: updatePropertyAccessChain,
            createElementAccessExpression: createElementAccessExpression,
            updateElementAccessExpression: updateElementAccessExpression,
            createElementAccessChain: createElementAccessChain,
            updateElementAccessChain: updateElementAccessChain,
            createCallExpression: createCallExpression,
            updateCallExpression: updateCallExpression,
            createCallChain: createCallChain,
            updateCallChain: updateCallChain,
            createNewExpression: createNewExpression,
            updateNewExpression: updateNewExpression,
            createTaggedTemplateExpression: createTaggedTemplateExpression,
            updateTaggedTemplateExpression: updateTaggedTemplateExpression,
            createTypeAssertion: createTypeAssertion,
            updateTypeAssertion: updateTypeAssertion,
            createParenthesizedExpression: createParenthesizedExpression,
            updateParenthesizedExpression: updateParenthesizedExpression,
            createFunctionExpression: createFunctionExpression,
            updateFunctionExpression: updateFunctionExpression,
            createArrowFunction: createArrowFunction,
            updateArrowFunction: updateArrowFunction,
            createDeleteExpression: createDeleteExpression,
            updateDeleteExpression: updateDeleteExpression,
            createTypeOfExpression: createTypeOfExpression,
            updateTypeOfExpression: updateTypeOfExpression,
            createVoidExpression: createVoidExpression,
            updateVoidExpression: updateVoidExpression,
            createAwaitExpression: createAwaitExpression,
            updateAwaitExpression: updateAwaitExpression,
            createPrefixUnaryExpression: createPrefixUnaryExpression,
            updatePrefixUnaryExpression: updatePrefixUnaryExpression,
            createPostfixUnaryExpression: createPostfixUnaryExpression,
            updatePostfixUnaryExpression: updatePostfixUnaryExpression,
            createBinaryExpression: createBinaryExpression,
            updateBinaryExpression: updateBinaryExpression,
            createConditionalExpression: createConditionalExpression,
            updateConditionalExpression: updateConditionalExpression,
            createTemplateExpression: createTemplateExpression,
            updateTemplateExpression: updateTemplateExpression,
            createTemplateHead: createTemplateHead,
            createTemplateMiddle: createTemplateMiddle,
            createTemplateTail: createTemplateTail,
            createNoSubstitutionTemplateLiteral: createNoSubstitutionTemplateLiteral,
            createTemplateLiteralLikeNode: createTemplateLiteralLikeNode,
            createYieldExpression: createYieldExpression,
            updateYieldExpression: updateYieldExpression,
            createSpreadElement: createSpreadElement,
            updateSpreadElement: updateSpreadElement,
            createClassExpression: createClassExpression,
            updateClassExpression: updateClassExpression,
            createOmittedExpression: createOmittedExpression,
            createExpressionWithTypeArguments: createExpressionWithTypeArguments,
            updateExpressionWithTypeArguments: updateExpressionWithTypeArguments,
            createAsExpression: createAsExpression,
            updateAsExpression: updateAsExpression,
            createNonNullExpression: createNonNullExpression,
            updateNonNullExpression: updateNonNullExpression,
            createNonNullChain: createNonNullChain,
            updateNonNullChain: updateNonNullChain,
            createMetaProperty: createMetaProperty,
            updateMetaProperty: updateMetaProperty,
            createTemplateSpan: createTemplateSpan,
            updateTemplateSpan: updateTemplateSpan,
            createSemicolonClassElement: createSemicolonClassElement,
            createBlock: createBlock,
            updateBlock: updateBlock,
            createVariableStatement: createVariableStatement,
            updateVariableStatement: updateVariableStatement,
            createEmptyStatement: createEmptyStatement,
            createExpressionStatement: createExpressionStatement,
            updateExpressionStatement: updateExpressionStatement,
            createIfStatement: createIfStatement,
            updateIfStatement: updateIfStatement,
            createDoStatement: createDoStatement,
            updateDoStatement: updateDoStatement,
            createWhileStatement: createWhileStatement,
            updateWhileStatement: updateWhileStatement,
            createForStatement: createForStatement,
            updateForStatement: updateForStatement,
            createForInStatement: createForInStatement,
            updateForInStatement: updateForInStatement,
            createForOfStatement: createForOfStatement,
            updateForOfStatement: updateForOfStatement,
            createContinueStatement: createContinueStatement,
            updateContinueStatement: updateContinueStatement,
            createBreakStatement: createBreakStatement,
            updateBreakStatement: updateBreakStatement,
            createReturnStatement: createReturnStatement,
            updateReturnStatement: updateReturnStatement,
            createWithStatement: createWithStatement,
            updateWithStatement: updateWithStatement,
            createSwitchStatement: createSwitchStatement,
            updateSwitchStatement: updateSwitchStatement,
            createLabeledStatement: createLabeledStatement,
            updateLabeledStatement: updateLabeledStatement,
            createThrowStatement: createThrowStatement,
            updateThrowStatement: updateThrowStatement,
            createTryStatement: createTryStatement,
            updateTryStatement: updateTryStatement,
            createDebuggerStatement: createDebuggerStatement,
            createVariableDeclaration: createVariableDeclaration,
            updateVariableDeclaration: updateVariableDeclaration,
            createVariableDeclarationList: createVariableDeclarationList,
            updateVariableDeclarationList: updateVariableDeclarationList,
            createFunctionDeclaration: createFunctionDeclaration,
            updateFunctionDeclaration: updateFunctionDeclaration,
            createClassDeclaration: createClassDeclaration,
            updateClassDeclaration: updateClassDeclaration,
            createInterfaceDeclaration: createInterfaceDeclaration,
            updateInterfaceDeclaration: updateInterfaceDeclaration,
            createTypeAliasDeclaration: createTypeAliasDeclaration,
            updateTypeAliasDeclaration: updateTypeAliasDeclaration,
            createEnumDeclaration: createEnumDeclaration,
            updateEnumDeclaration: updateEnumDeclaration,
            createModuleDeclaration: createModuleDeclaration,
            updateModuleDeclaration: updateModuleDeclaration,
            createModuleBlock: createModuleBlock,
            updateModuleBlock: updateModuleBlock,
            createCaseBlock: createCaseBlock,
            updateCaseBlock: updateCaseBlock,
            createNamespaceExportDeclaration: createNamespaceExportDeclaration,
            updateNamespaceExportDeclaration: updateNamespaceExportDeclaration,
            createImportEqualsDeclaration: createImportEqualsDeclaration,
            updateImportEqualsDeclaration: updateImportEqualsDeclaration,
            createImportDeclaration: createImportDeclaration,
            updateImportDeclaration: updateImportDeclaration,
            createImportClause: createImportClause,
            updateImportClause: updateImportClause,
            createNamespaceImport: createNamespaceImport,
            updateNamespaceImport: updateNamespaceImport,
            createNamespaceExport: createNamespaceExport,
            updateNamespaceExport: updateNamespaceExport,
            createNamedImports: createNamedImports,
            updateNamedImports: updateNamedImports,
            createImportSpecifier: createImportSpecifier,
            updateImportSpecifier: updateImportSpecifier,
            createExportAssignment: createExportAssignment,
            updateExportAssignment: updateExportAssignment,
            createExportDeclaration: createExportDeclaration,
            updateExportDeclaration: updateExportDeclaration,
            createNamedExports: createNamedExports,
            updateNamedExports: updateNamedExports,
            createExportSpecifier: createExportSpecifier,
            updateExportSpecifier: updateExportSpecifier,
            createMissingDeclaration: createMissingDeclaration,
            createExternalModuleReference: createExternalModuleReference,
            updateExternalModuleReference: updateExternalModuleReference,
            get createJSDocAllType() { return getJSDocPrimaryTypeCreateFunction(307); },
            get createJSDocUnknownType() { return getJSDocPrimaryTypeCreateFunction(308); },
            get createJSDocNonNullableType() { return getJSDocUnaryTypeCreateFunction(310); },
            get updateJSDocNonNullableType() { return getJSDocUnaryTypeUpdateFunction(310); },
            get createJSDocNullableType() { return getJSDocUnaryTypeCreateFunction(309); },
            get updateJSDocNullableType() { return getJSDocUnaryTypeUpdateFunction(309); },
            get createJSDocOptionalType() { return getJSDocUnaryTypeCreateFunction(311); },
            get updateJSDocOptionalType() { return getJSDocUnaryTypeUpdateFunction(311); },
            get createJSDocVariadicType() { return getJSDocUnaryTypeCreateFunction(313); },
            get updateJSDocVariadicType() { return getJSDocUnaryTypeUpdateFunction(313); },
            get createJSDocNamepathType() { return getJSDocUnaryTypeCreateFunction(314); },
            get updateJSDocNamepathType() { return getJSDocUnaryTypeUpdateFunction(314); },
            createJSDocFunctionType: createJSDocFunctionType,
            updateJSDocFunctionType: updateJSDocFunctionType,
            createJSDocTypeLiteral: createJSDocTypeLiteral,
            updateJSDocTypeLiteral: updateJSDocTypeLiteral,
            createJSDocTypeExpression: createJSDocTypeExpression,
            updateJSDocTypeExpression: updateJSDocTypeExpression,
            createJSDocSignature: createJSDocSignature,
            updateJSDocSignature: updateJSDocSignature,
            createJSDocTemplateTag: createJSDocTemplateTag,
            updateJSDocTemplateTag: updateJSDocTemplateTag,
            createJSDocTypedefTag: createJSDocTypedefTag,
            updateJSDocTypedefTag: updateJSDocTypedefTag,
            createJSDocParameterTag: createJSDocParameterTag,
            updateJSDocParameterTag: updateJSDocParameterTag,
            createJSDocPropertyTag: createJSDocPropertyTag,
            updateJSDocPropertyTag: updateJSDocPropertyTag,
            createJSDocCallbackTag: createJSDocCallbackTag,
            updateJSDocCallbackTag: updateJSDocCallbackTag,
            createJSDocAugmentsTag: createJSDocAugmentsTag,
            updateJSDocAugmentsTag: updateJSDocAugmentsTag,
            createJSDocImplementsTag: createJSDocImplementsTag,
            updateJSDocImplementsTag: updateJSDocImplementsTag,
            createJSDocSeeTag: createJSDocSeeTag,
            updateJSDocSeeTag: updateJSDocSeeTag,
            createJSDocNameReference: createJSDocNameReference,
            updateJSDocNameReference: updateJSDocNameReference,
            createJSDocMemberName: createJSDocMemberName,
            updateJSDocMemberName: updateJSDocMemberName,
            createJSDocLink: createJSDocLink,
            updateJSDocLink: updateJSDocLink,
            createJSDocLinkCode: createJSDocLinkCode,
            updateJSDocLinkCode: updateJSDocLinkCode,
            createJSDocLinkPlain: createJSDocLinkPlain,
            updateJSDocLinkPlain: updateJSDocLinkPlain,
            get createJSDocTypeTag() { return getJSDocTypeLikeTagCreateFunction(338); },
            get updateJSDocTypeTag() { return getJSDocTypeLikeTagUpdateFunction(338); },
            get createJSDocReturnTag() { return getJSDocTypeLikeTagCreateFunction(336); },
            get updateJSDocReturnTag() { return getJSDocTypeLikeTagUpdateFunction(336); },
            get createJSDocThisTag() { return getJSDocTypeLikeTagCreateFunction(337); },
            get updateJSDocThisTag() { return getJSDocTypeLikeTagUpdateFunction(337); },
            get createJSDocEnumTag() { return getJSDocTypeLikeTagCreateFunction(334); },
            get updateJSDocEnumTag() { return getJSDocTypeLikeTagUpdateFunction(334); },
            get createJSDocAuthorTag() { return getJSDocSimpleTagCreateFunction(325); },
            get updateJSDocAuthorTag() { return getJSDocSimpleTagUpdateFunction(325); },
            get createJSDocClassTag() { return getJSDocSimpleTagCreateFunction(327); },
            get updateJSDocClassTag() { return getJSDocSimpleTagUpdateFunction(327); },
            get createJSDocPublicTag() { return getJSDocSimpleTagCreateFunction(328); },
            get updateJSDocPublicTag() { return getJSDocSimpleTagUpdateFunction(328); },
            get createJSDocPrivateTag() { return getJSDocSimpleTagCreateFunction(329); },
            get updateJSDocPrivateTag() { return getJSDocSimpleTagUpdateFunction(329); },
            get createJSDocProtectedTag() { return getJSDocSimpleTagCreateFunction(330); },
            get updateJSDocProtectedTag() { return getJSDocSimpleTagUpdateFunction(330); },
            get createJSDocReadonlyTag() { return getJSDocSimpleTagCreateFunction(331); },
            get updateJSDocReadonlyTag() { return getJSDocSimpleTagUpdateFunction(331); },
            get createJSDocOverrideTag() { return getJSDocSimpleTagCreateFunction(332); },
            get updateJSDocOverrideTag() { return getJSDocSimpleTagUpdateFunction(332); },
            get createJSDocDeprecatedTag() { return getJSDocSimpleTagCreateFunction(326); },
            get updateJSDocDeprecatedTag() { return getJSDocSimpleTagUpdateFunction(326); },
            createJSDocUnknownTag: createJSDocUnknownTag,
            updateJSDocUnknownTag: updateJSDocUnknownTag,
            createJSDocText: createJSDocText,
            updateJSDocText: updateJSDocText,
            createJSDocComment: createJSDocComment,
            updateJSDocComment: updateJSDocComment,
            createJsxElement: createJsxElement,
            updateJsxElement: updateJsxElement,
            createJsxSelfClosingElement: createJsxSelfClosingElement,
            updateJsxSelfClosingElement: updateJsxSelfClosingElement,
            createJsxOpeningElement: createJsxOpeningElement,
            updateJsxOpeningElement: updateJsxOpeningElement,
            createJsxClosingElement: createJsxClosingElement,
            updateJsxClosingElement: updateJsxClosingElement,
            createJsxFragment: createJsxFragment,
            createJsxText: createJsxText,
            updateJsxText: updateJsxText,
            createJsxOpeningFragment: createJsxOpeningFragment,
            createJsxJsxClosingFragment: createJsxJsxClosingFragment,
            updateJsxFragment: updateJsxFragment,
            createJsxAttribute: createJsxAttribute,
            updateJsxAttribute: updateJsxAttribute,
            createJsxAttributes: createJsxAttributes,
            updateJsxAttributes: updateJsxAttributes,
            createJsxSpreadAttribute: createJsxSpreadAttribute,
            updateJsxSpreadAttribute: updateJsxSpreadAttribute,
            createJsxExpression: createJsxExpression,
            updateJsxExpression: updateJsxExpression,
            createCaseClause: createCaseClause,
            updateCaseClause: updateCaseClause,
            createDefaultClause: createDefaultClause,
            updateDefaultClause: updateDefaultClause,
            createHeritageClause: createHeritageClause,
            updateHeritageClause: updateHeritageClause,
            createCatchClause: createCatchClause,
            updateCatchClause: updateCatchClause,
            createPropertyAssignment: createPropertyAssignment,
            updatePropertyAssignment: updatePropertyAssignment,
            createShorthandPropertyAssignment: createShorthandPropertyAssignment,
            updateShorthandPropertyAssignment: updateShorthandPropertyAssignment,
            createSpreadAssignment: createSpreadAssignment,
            updateSpreadAssignment: updateSpreadAssignment,
            createEnumMember: createEnumMember,
            updateEnumMember: updateEnumMember,
            createSourceFile: createSourceFile,
            updateSourceFile: updateSourceFile,
            createBundle: createBundle,
            updateBundle: updateBundle,
            createUnparsedSource: createUnparsedSource,
            createUnparsedPrologue: createUnparsedPrologue,
            createUnparsedPrepend: createUnparsedPrepend,
            createUnparsedTextLike: createUnparsedTextLike,
            createUnparsedSyntheticReference: createUnparsedSyntheticReference,
            createInputFiles: createInputFiles,
            createSyntheticExpression: createSyntheticExpression,
            createSyntaxList: createSyntaxList,
            createNotEmittedStatement: createNotEmittedStatement,
            createPartiallyEmittedExpression: createPartiallyEmittedExpression,
            updatePartiallyEmittedExpression: updatePartiallyEmittedExpression,
            createCommaListExpression: createCommaListExpression,
            updateCommaListExpression: updateCommaListExpression,
            createEndOfDeclarationMarker: createEndOfDeclarationMarker,
            createMergeDeclarationMarker: createMergeDeclarationMarker,
            createSyntheticReferenceExpression: createSyntheticReferenceExpression,
            updateSyntheticReferenceExpression: updateSyntheticReferenceExpression,
            cloneNode: cloneNode,
            get createComma() { return getBinaryCreateFunction(27); },
            get createAssignment() { return getBinaryCreateFunction(63); },
            get createLogicalOr() { return getBinaryCreateFunction(56); },
            get createLogicalAnd() { return getBinaryCreateFunction(55); },
            get createBitwiseOr() { return getBinaryCreateFunction(51); },
            get createBitwiseXor() { return getBinaryCreateFunction(52); },
            get createBitwiseAnd() { return getBinaryCreateFunction(50); },
            get createStrictEquality() { return getBinaryCreateFunction(36); },
            get createStrictInequality() { return getBinaryCreateFunction(37); },
            get createEquality() { return getBinaryCreateFunction(34); },
            get createInequality() { return getBinaryCreateFunction(35); },
            get createLessThan() { return getBinaryCreateFunction(29); },
            get createLessThanEquals() { return getBinaryCreateFunction(32); },
            get createGreaterThan() { return getBinaryCreateFunction(31); },
            get createGreaterThanEquals() { return getBinaryCreateFunction(33); },
            get createLeftShift() { return getBinaryCreateFunction(47); },
            get createRightShift() { return getBinaryCreateFunction(48); },
            get createUnsignedRightShift() { return getBinaryCreateFunction(49); },
            get createAdd() { return getBinaryCreateFunction(39); },
            get createSubtract() { return getBinaryCreateFunction(40); },
            get createMultiply() { return getBinaryCreateFunction(41); },
            get createDivide() { return getBinaryCreateFunction(43); },
            get createModulo() { return getBinaryCreateFunction(44); },
            get createExponent() { return getBinaryCreateFunction(42); },
            get createPrefixPlus() { return getPrefixUnaryCreateFunction(39); },
            get createPrefixMinus() { return getPrefixUnaryCreateFunction(40); },
            get createPrefixIncrement() { return getPrefixUnaryCreateFunction(45); },
            get createPrefixDecrement() { return getPrefixUnaryCreateFunction(46); },
            get createBitwiseNot() { return getPrefixUnaryCreateFunction(54); },
            get createLogicalNot() { return getPrefixUnaryCreateFunction(53); },
            get createPostfixIncrement() { return getPostfixUnaryCreateFunction(45); },
            get createPostfixDecrement() { return getPostfixUnaryCreateFunction(46); },
            createImmediatelyInvokedFunctionExpression: createImmediatelyInvokedFunctionExpression,
            createImmediatelyInvokedArrowFunction: createImmediatelyInvokedArrowFunction,
            createVoidZero: createVoidZero,
            createExportDefault: createExportDefault,
            createExternalModuleExport: createExternalModuleExport,
            createTypeCheck: createTypeCheck,
            createMethodCall: createMethodCall,
            createGlobalMethodCall: createGlobalMethodCall,
            createFunctionBindCall: createFunctionBindCall,
            createFunctionCallCall: createFunctionCallCall,
            createFunctionApplyCall: createFunctionApplyCall,
            createArraySliceCall: createArraySliceCall,
            createArrayConcatCall: createArrayConcatCall,
            createObjectDefinePropertyCall: createObjectDefinePropertyCall,
            createReflectGetCall: createReflectGetCall,
            createReflectSetCall: createReflectSetCall,
            createPropertyDescriptor: createPropertyDescriptor,
            createCallBinding: createCallBinding,
            createAssignmentTargetWrapper: createAssignmentTargetWrapper,
            inlineExpressions: inlineExpressions,
            getInternalName: getInternalName,
            getLocalName: getLocalName,
            getExportName: getExportName,
            getDeclarationName: getDeclarationName,
            getNamespaceMemberName: getNamespaceMemberName,
            getExternalModuleOrNamespaceExportName: getExternalModuleOrNamespaceExportName,
            restoreOuterExpressions: restoreOuterExpressions,
            restoreEnclosingLabel: restoreEnclosingLabel,
            createUseStrictPrologue: createUseStrictPrologue,
            copyPrologue: copyPrologue,
            copyStandardPrologue: copyStandardPrologue,
            copyCustomPrologue: copyCustomPrologue,
            ensureUseStrict: ensureUseStrict,
            liftToBlock: liftToBlock,
            mergeLexicalEnvironment: mergeLexicalEnvironment,
            updateModifiers: updateModifiers,
        };
        return factory;
        function createNodeArray(elements, hasTrailingComma) {
            if (elements === undefined || elements === ts.emptyArray) {
                elements = [];
            }
            else if (ts.isNodeArray(elements)) {
                if (hasTrailingComma === undefined || elements.hasTrailingComma === hasTrailingComma) {
                    if (elements.transformFlags === undefined) {
                        aggregateChildrenFlags(elements);
                    }
                    ts.Debug.attachNodeArrayDebugInfo(elements);
                    return elements;
                }
                var array_8 = elements.slice();
                array_8.pos = elements.pos;
                array_8.end = elements.end;
                array_8.hasTrailingComma = hasTrailingComma;
                array_8.transformFlags = elements.transformFlags;
                ts.Debug.attachNodeArrayDebugInfo(array_8);
                return array_8;
            }
            var length = elements.length;
            var array = (length >= 1 && length <= 4 ? elements.slice() : elements);
            ts.setTextRangePosEnd(array, -1, -1);
            array.hasTrailingComma = !!hasTrailingComma;
            aggregateChildrenFlags(array);
            ts.Debug.attachNodeArrayDebugInfo(array);
            return array;
        }
        function createBaseNode(kind) {
            return baseFactory.createBaseNode(kind);
        }
        function createBaseDeclaration(kind, decorators, modifiers) {
            var node = createBaseNode(kind);
            node.decorators = asNodeArray(decorators);
            node.modifiers = asNodeArray(modifiers);
            node.transformFlags |=
                propagateChildrenFlags(node.decorators) |
                    propagateChildrenFlags(node.modifiers);
            node.symbol = undefined;
            node.localSymbol = undefined;
            node.locals = undefined;
            node.nextContainer = undefined;
            return node;
        }
        function createBaseNamedDeclaration(kind, decorators, modifiers, name) {
            var node = createBaseDeclaration(kind, decorators, modifiers);
            name = asName(name);
            node.name = name;
            if (name) {
                switch (node.kind) {
                    case 167:
                    case 170:
                    case 171:
                    case 165:
                    case 291:
                        if (ts.isIdentifier(name)) {
                            node.transformFlags |= propagateIdentifierNameFlags(name);
                            break;
                        }
                    default:
                        node.transformFlags |= propagateChildFlags(name);
                        break;
                }
            }
            return node;
        }
        function createBaseGenericNamedDeclaration(kind, decorators, modifiers, name, typeParameters) {
            var node = createBaseNamedDeclaration(kind, decorators, modifiers, name);
            node.typeParameters = asNodeArray(typeParameters);
            node.transformFlags |= propagateChildrenFlags(node.typeParameters);
            if (typeParameters)
                node.transformFlags |= 1;
            return node;
        }
        function createBaseSignatureDeclaration(kind, decorators, modifiers, name, typeParameters, parameters, type) {
            var node = createBaseGenericNamedDeclaration(kind, decorators, modifiers, name, typeParameters);
            node.parameters = createNodeArray(parameters);
            node.type = type;
            node.transformFlags |=
                propagateChildrenFlags(node.parameters) |
                    propagateChildFlags(node.type);
            if (type)
                node.transformFlags |= 1;
            return node;
        }
        function updateBaseSignatureDeclaration(updated, original) {
            if (original.typeArguments)
                updated.typeArguments = original.typeArguments;
            return update(updated, original);
        }
        function createBaseFunctionLikeDeclaration(kind, decorators, modifiers, name, typeParameters, parameters, type, body) {
            var node = createBaseSignatureDeclaration(kind, decorators, modifiers, name, typeParameters, parameters, type);
            node.body = body;
            node.transformFlags |= propagateChildFlags(node.body) & ~16777216;
            if (!body)
                node.transformFlags |= 1;
            return node;
        }
        function updateBaseFunctionLikeDeclaration(updated, original) {
            if (original.exclamationToken)
                updated.exclamationToken = original.exclamationToken;
            if (original.typeArguments)
                updated.typeArguments = original.typeArguments;
            return updateBaseSignatureDeclaration(updated, original);
        }
        function createBaseInterfaceOrClassLikeDeclaration(kind, decorators, modifiers, name, typeParameters, heritageClauses) {
            var node = createBaseGenericNamedDeclaration(kind, decorators, modifiers, name, typeParameters);
            node.heritageClauses = asNodeArray(heritageClauses);
            node.transformFlags |= propagateChildrenFlags(node.heritageClauses);
            return node;
        }
        function createBaseClassLikeDeclaration(kind, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseInterfaceOrClassLikeDeclaration(kind, decorators, modifiers, name, typeParameters, heritageClauses);
            node.members = createNodeArray(members);
            node.transformFlags |= propagateChildrenFlags(node.members);
            return node;
        }
        function createBaseBindingLikeDeclaration(kind, decorators, modifiers, name, initializer) {
            var node = createBaseNamedDeclaration(kind, decorators, modifiers, name);
            node.initializer = initializer;
            node.transformFlags |= propagateChildFlags(node.initializer);
            return node;
        }
        function createBaseVariableLikeDeclaration(kind, decorators, modifiers, name, type, initializer) {
            var node = createBaseBindingLikeDeclaration(kind, decorators, modifiers, name, initializer);
            node.type = type;
            node.transformFlags |= propagateChildFlags(type);
            if (type)
                node.transformFlags |= 1;
            return node;
        }
        function createBaseLiteral(kind, text) {
            var node = createBaseToken(kind);
            node.text = text;
            return node;
        }
        function createNumericLiteral(value, numericLiteralFlags) {
            if (numericLiteralFlags === void 0) { numericLiteralFlags = 0; }
            var node = createBaseLiteral(8, typeof value === "number" ? value + "" : value);
            node.numericLiteralFlags = numericLiteralFlags;
            if (numericLiteralFlags & 384)
                node.transformFlags |= 512;
            return node;
        }
        function createBigIntLiteral(value) {
            var node = createBaseLiteral(9, typeof value === "string" ? value : ts.pseudoBigIntToString(value) + "n");
            node.transformFlags |= 4;
            return node;
        }
        function createBaseStringLiteral(text, isSingleQuote) {
            var node = createBaseLiteral(10, text);
            node.singleQuote = isSingleQuote;
            return node;
        }
        function createStringLiteral(text, isSingleQuote, hasExtendedUnicodeEscape) {
            var node = createBaseStringLiteral(text, isSingleQuote);
            node.hasExtendedUnicodeEscape = hasExtendedUnicodeEscape;
            if (hasExtendedUnicodeEscape)
                node.transformFlags |= 512;
            return node;
        }
        function createStringLiteralFromNode(sourceNode) {
            var node = createBaseStringLiteral(ts.getTextOfIdentifierOrLiteral(sourceNode), undefined);
            node.textSourceNode = sourceNode;
            return node;
        }
        function createRegularExpressionLiteral(text) {
            var node = createBaseLiteral(13, text);
            return node;
        }
        function createLiteralLikeNode(kind, text) {
            switch (kind) {
                case 8: return createNumericLiteral(text, 0);
                case 9: return createBigIntLiteral(text);
                case 10: return createStringLiteral(text, undefined);
                case 11: return createJsxText(text, false);
                case 12: return createJsxText(text, true);
                case 13: return createRegularExpressionLiteral(text);
                case 14: return createTemplateLiteralLikeNode(kind, text, undefined, 0);
            }
        }
        function createBaseIdentifier(text, originalKeywordKind) {
            if (originalKeywordKind === undefined && text) {
                originalKeywordKind = ts.stringToToken(text);
            }
            if (originalKeywordKind === 79) {
                originalKeywordKind = undefined;
            }
            var node = baseFactory.createBaseIdentifierNode(79);
            node.originalKeywordKind = originalKeywordKind;
            node.escapedText = ts.escapeLeadingUnderscores(text);
            return node;
        }
        function createBaseGeneratedIdentifier(text, autoGenerateFlags) {
            var node = createBaseIdentifier(text, undefined);
            node.autoGenerateFlags = autoGenerateFlags;
            node.autoGenerateId = nextAutoGenerateId;
            nextAutoGenerateId++;
            return node;
        }
        function createIdentifier(text, typeArguments, originalKeywordKind) {
            var node = createBaseIdentifier(text, originalKeywordKind);
            if (typeArguments) {
                node.typeArguments = createNodeArray(typeArguments);
            }
            if (node.originalKeywordKind === 131) {
                node.transformFlags |= 16777216;
            }
            return node;
        }
        function updateIdentifier(node, typeArguments) {
            return node.typeArguments !== typeArguments
                ? update(createIdentifier(ts.idText(node), typeArguments), node)
                : node;
        }
        function createTempVariable(recordTempVariable, reservedInNestedScopes) {
            var flags = 1;
            if (reservedInNestedScopes)
                flags |= 8;
            var name = createBaseGeneratedIdentifier("", flags);
            if (recordTempVariable) {
                recordTempVariable(name);
            }
            return name;
        }
        function createLoopVariable(reservedInNestedScopes) {
            var flags = 2;
            if (reservedInNestedScopes)
                flags |= 8;
            return createBaseGeneratedIdentifier("", flags);
        }
        function createUniqueName(text, flags) {
            if (flags === void 0) { flags = 0; }
            ts.Debug.assert(!(flags & 7), "Argument out of range: flags");
            ts.Debug.assert((flags & (16 | 32)) !== 32, "GeneratedIdentifierFlags.FileLevel cannot be set without also setting GeneratedIdentifierFlags.Optimistic");
            return createBaseGeneratedIdentifier(text, 3 | flags);
        }
        function getGeneratedNameForNode(node, flags) {
            if (flags === void 0) { flags = 0; }
            ts.Debug.assert(!(flags & 7), "Argument out of range: flags");
            var name = createBaseGeneratedIdentifier(node && ts.isIdentifier(node) ? ts.idText(node) : "", 4 | flags);
            name.original = node;
            return name;
        }
        function createPrivateIdentifier(text) {
            if (!ts.startsWith(text, "#"))
                ts.Debug.fail("First character of private identifier must be #: " + text);
            var node = baseFactory.createBasePrivateIdentifierNode(80);
            node.escapedText = ts.escapeLeadingUnderscores(text);
            node.transformFlags |= 8388608;
            return node;
        }
        function createBaseToken(kind) {
            return baseFactory.createBaseTokenNode(kind);
        }
        function createToken(token) {
            ts.Debug.assert(token >= 0 && token <= 158, "Invalid token");
            ts.Debug.assert(token <= 14 || token >= 17, "Invalid token. Use 'createTemplateLiteralLikeNode' to create template literals.");
            ts.Debug.assert(token <= 8 || token >= 14, "Invalid token. Use 'createLiteralLikeNode' to create literals.");
            ts.Debug.assert(token !== 79, "Invalid token. Use 'createIdentifier' to create identifiers");
            var node = createBaseToken(token);
            var transformFlags = 0;
            switch (token) {
                case 130:
                    transformFlags =
                        128 |
                            64;
                    break;
                case 123:
                case 121:
                case 122:
                case 143:
                case 126:
                case 134:
                case 85:
                case 129:
                case 145:
                case 156:
                case 142:
                case 146:
                case 157:
                case 148:
                case 132:
                case 149:
                case 114:
                case 153:
                case 151:
                    transformFlags = 1;
                    break;
                case 106:
                    transformFlags = 512 | 33554432;
                    break;
                case 124:
                    transformFlags = 512;
                    break;
                case 108:
                    transformFlags = 8192;
                    break;
            }
            if (transformFlags) {
                node.transformFlags |= transformFlags;
            }
            return node;
        }
        function createSuper() {
            return createToken(106);
        }
        function createThis() {
            return createToken(108);
        }
        function createNull() {
            return createToken(104);
        }
        function createTrue() {
            return createToken(110);
        }
        function createFalse() {
            return createToken(95);
        }
        function createModifier(kind) {
            return createToken(kind);
        }
        function createModifiersFromModifierFlags(flags) {
            var result = [];
            if (flags & 1) {
                result.push(createModifier(93));
            }
            if (flags & 2) {
                result.push(createModifier(134));
            }
            if (flags & 512) {
                result.push(createModifier(88));
            }
            if (flags & 2048) {
                result.push(createModifier(85));
            }
            if (flags & 4) {
                result.push(createModifier(123));
            }
            if (flags & 8) {
                result.push(createModifier(121));
            }
            if (flags & 16) {
                result.push(createModifier(122));
            }
            if (flags & 128) {
                result.push(createModifier(126));
            }
            if (flags & 32) {
                result.push(createModifier(124));
            }
            if (flags & 16384) {
                result.push(createModifier(157));
            }
            if (flags & 64) {
                result.push(createModifier(143));
            }
            if (flags & 256) {
                result.push(createModifier(130));
            }
            return result;
        }
        function createQualifiedName(left, right) {
            var node = createBaseNode(159);
            node.left = left;
            node.right = asName(right);
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateIdentifierNameFlags(node.right);
            return node;
        }
        function updateQualifiedName(node, left, right) {
            return node.left !== left
                || node.right !== right
                ? update(createQualifiedName(left, right), node)
                : node;
        }
        function createComputedPropertyName(expression) {
            var node = createBaseNode(160);
            node.expression = parenthesizerRules().parenthesizeExpressionOfComputedPropertyName(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    512 |
                    65536;
            return node;
        }
        function updateComputedPropertyName(node, expression) {
            return node.expression !== expression
                ? update(createComputedPropertyName(expression), node)
                : node;
        }
        function createTypeParameterDeclaration(name, constraint, defaultType) {
            var node = createBaseNamedDeclaration(161, undefined, undefined, name);
            node.constraint = constraint;
            node.default = defaultType;
            node.transformFlags = 1;
            return node;
        }
        function updateTypeParameterDeclaration(node, name, constraint, defaultType) {
            return node.name !== name
                || node.constraint !== constraint
                || node.default !== defaultType
                ? update(createTypeParameterDeclaration(name, constraint, defaultType), node)
                : node;
        }
        function createParameterDeclaration(decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(162, decorators, modifiers, name, type, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.dotDotDotToken = dotDotDotToken;
            node.questionToken = questionToken;
            if (ts.isThisIdentifier(node.name)) {
                node.transformFlags = 1;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.dotDotDotToken) |
                        propagateChildFlags(node.questionToken);
                if (questionToken)
                    node.transformFlags |= 1;
                if (ts.modifiersToFlags(node.modifiers) & 16476)
                    node.transformFlags |= 4096;
                if (initializer || dotDotDotToken)
                    node.transformFlags |= 512;
            }
            return node;
        }
        function updateParameterDeclaration(node, decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.dotDotDotToken !== dotDotDotToken
                || node.name !== name
                || node.questionToken !== questionToken
                || node.type !== type
                || node.initializer !== initializer
                ? update(createParameterDeclaration(decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer), node)
                : node;
        }
        function createDecorator(expression) {
            var node = createBaseNode(163);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 |
                    4096;
            return node;
        }
        function updateDecorator(node, expression) {
            return node.expression !== expression
                ? update(createDecorator(expression), node)
                : node;
        }
        function createPropertySignature(modifiers, name, questionToken, type) {
            var node = createBaseNamedDeclaration(164, undefined, modifiers, name);
            node.type = type;
            node.questionToken = questionToken;
            node.transformFlags = 1;
            return node;
        }
        function updatePropertySignature(node, modifiers, name, questionToken, type) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.questionToken !== questionToken
                || node.type !== type
                ? update(createPropertySignature(modifiers, name, questionToken, type), node)
                : node;
        }
        function createPropertyDeclaration(decorators, modifiers, name, questionOrExclamationToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(165, decorators, modifiers, name, type, initializer);
            node.questionToken = questionOrExclamationToken && ts.isQuestionToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined;
            node.exclamationToken = questionOrExclamationToken && ts.isExclamationToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined;
            node.transformFlags |=
                propagateChildFlags(node.questionToken) |
                    propagateChildFlags(node.exclamationToken) |
                    8388608;
            if (ts.isComputedPropertyName(node.name) || (ts.hasStaticModifier(node) && node.initializer)) {
                node.transformFlags |= 4096;
            }
            if (questionOrExclamationToken || ts.modifiersToFlags(node.modifiers) & 2) {
                node.transformFlags |= 1;
            }
            return node;
        }
        function updatePropertyDeclaration(node, decorators, modifiers, name, questionOrExclamationToken, type, initializer) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.questionToken !== (questionOrExclamationToken !== undefined && ts.isQuestionToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined)
                || node.exclamationToken !== (questionOrExclamationToken !== undefined && ts.isExclamationToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined)
                || node.type !== type
                || node.initializer !== initializer
                ? update(createPropertyDeclaration(decorators, modifiers, name, questionOrExclamationToken, type, initializer), node)
                : node;
        }
        function createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(166, undefined, modifiers, name, typeParameters, parameters, type);
            node.questionToken = questionToken;
            node.transformFlags = 1;
            return node;
        }
        function updateMethodSignature(node, modifiers, name, questionToken, typeParameters, parameters, type) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.questionToken !== questionToken
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type), node)
                : node;
        }
        function createMethodDeclaration(decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(167, decorators, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            node.questionToken = questionToken;
            node.transformFlags |=
                propagateChildFlags(node.asteriskToken) |
                    propagateChildFlags(node.questionToken) |
                    512;
            if (questionToken) {
                node.transformFlags |= 1;
            }
            if (ts.modifiersToFlags(node.modifiers) & 256) {
                if (asteriskToken) {
                    node.transformFlags |= 64;
                }
                else {
                    node.transformFlags |= 128;
                }
            }
            else if (asteriskToken) {
                node.transformFlags |= 1024;
            }
            return node;
        }
        function updateMethodDeclaration(node, decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.name !== name
                || node.questionToken !== questionToken
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createMethodDeclaration(decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body), node)
                : node;
        }
        function createClassStaticBlockDeclaration(decorators, modifiers, body) {
            var node = createBaseGenericNamedDeclaration(168, decorators, modifiers, undefined, undefined);
            node.body = body;
            node.transformFlags = propagateChildFlags(body) | 8388608;
            return node;
        }
        function updateClassStaticBlockDeclaration(node, decorators, modifiers, body) {
            return node.decorators !== decorators
                || node.modifier !== modifiers
                || node.body !== body
                ? update(createClassStaticBlockDeclaration(decorators, modifiers, body), node)
                : node;
        }
        function createConstructorDeclaration(decorators, modifiers, parameters, body) {
            var node = createBaseFunctionLikeDeclaration(169, decorators, modifiers, undefined, undefined, parameters, undefined, body);
            node.transformFlags |= 512;
            return node;
        }
        function updateConstructorDeclaration(node, decorators, modifiers, parameters, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.parameters !== parameters
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createConstructorDeclaration(decorators, modifiers, parameters, body), node)
                : node;
        }
        function createGetAccessorDeclaration(decorators, modifiers, name, parameters, type, body) {
            return createBaseFunctionLikeDeclaration(170, decorators, modifiers, name, undefined, parameters, type, body);
        }
        function updateGetAccessorDeclaration(node, decorators, modifiers, name, parameters, type, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createGetAccessorDeclaration(decorators, modifiers, name, parameters, type, body), node)
                : node;
        }
        function createSetAccessorDeclaration(decorators, modifiers, name, parameters, body) {
            return createBaseFunctionLikeDeclaration(171, decorators, modifiers, name, undefined, parameters, undefined, body);
        }
        function updateSetAccessorDeclaration(node, decorators, modifiers, name, parameters, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.parameters !== parameters
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createSetAccessorDeclaration(decorators, modifiers, name, parameters, body), node)
                : node;
        }
        function createCallSignature(typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(172, undefined, undefined, undefined, typeParameters, parameters, type);
            node.transformFlags = 1;
            return node;
        }
        function updateCallSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createCallSignature(typeParameters, parameters, type), node)
                : node;
        }
        function createConstructSignature(typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(173, undefined, undefined, undefined, typeParameters, parameters, type);
            node.transformFlags = 1;
            return node;
        }
        function updateConstructSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createConstructSignature(typeParameters, parameters, type), node)
                : node;
        }
        function createIndexSignature(decorators, modifiers, parameters, type) {
            var node = createBaseSignatureDeclaration(174, decorators, modifiers, undefined, undefined, parameters, type);
            node.transformFlags = 1;
            return node;
        }
        function updateIndexSignature(node, decorators, modifiers, parameters, type) {
            return node.parameters !== parameters
                || node.type !== type
                || node.decorators !== decorators
                || node.modifiers !== modifiers
                ? updateBaseSignatureDeclaration(createIndexSignature(decorators, modifiers, parameters, type), node)
                : node;
        }
        function createTemplateLiteralTypeSpan(type, literal) {
            var node = createBaseNode(197);
            node.type = type;
            node.literal = literal;
            node.transformFlags = 1;
            return node;
        }
        function updateTemplateLiteralTypeSpan(node, type, literal) {
            return node.type !== type
                || node.literal !== literal
                ? update(createTemplateLiteralTypeSpan(type, literal), node)
                : node;
        }
        function createKeywordTypeNode(kind) {
            return createToken(kind);
        }
        function createTypePredicateNode(assertsModifier, parameterName, type) {
            var node = createBaseNode(175);
            node.assertsModifier = assertsModifier;
            node.parameterName = asName(parameterName);
            node.type = type;
            node.transformFlags = 1;
            return node;
        }
        function updateTypePredicateNode(node, assertsModifier, parameterName, type) {
            return node.assertsModifier !== assertsModifier
                || node.parameterName !== parameterName
                || node.type !== type
                ? update(createTypePredicateNode(assertsModifier, parameterName, type), node)
                : node;
        }
        function createTypeReferenceNode(typeName, typeArguments) {
            var node = createBaseNode(176);
            node.typeName = asName(typeName);
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(createNodeArray(typeArguments));
            node.transformFlags = 1;
            return node;
        }
        function updateTypeReferenceNode(node, typeName, typeArguments) {
            return node.typeName !== typeName
                || node.typeArguments !== typeArguments
                ? update(createTypeReferenceNode(typeName, typeArguments), node)
                : node;
        }
        function createFunctionTypeNode(typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(177, undefined, undefined, undefined, typeParameters, parameters, type);
            node.transformFlags = 1;
            return node;
        }
        function updateFunctionTypeNode(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createFunctionTypeNode(typeParameters, parameters, type), node)
                : node;
        }
        function createConstructorTypeNode() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return args.length === 4 ? createConstructorTypeNode1.apply(void 0, args) :
                args.length === 3 ? createConstructorTypeNode2.apply(void 0, args) :
                    ts.Debug.fail("Incorrect number of arguments specified.");
        }
        function createConstructorTypeNode1(modifiers, typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(178, undefined, modifiers, undefined, typeParameters, parameters, type);
            node.transformFlags = 1;
            return node;
        }
        function createConstructorTypeNode2(typeParameters, parameters, type) {
            return createConstructorTypeNode1(undefined, typeParameters, parameters, type);
        }
        function updateConstructorTypeNode() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return args.length === 5 ? updateConstructorTypeNode1.apply(void 0, args) :
                args.length === 4 ? updateConstructorTypeNode2.apply(void 0, args) :
                    ts.Debug.fail("Incorrect number of arguments specified.");
        }
        function updateConstructorTypeNode1(node, modifiers, typeParameters, parameters, type) {
            return node.modifiers !== modifiers
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createConstructorTypeNode(modifiers, typeParameters, parameters, type), node)
                : node;
        }
        function updateConstructorTypeNode2(node, typeParameters, parameters, type) {
            return updateConstructorTypeNode1(node, node.modifiers, typeParameters, parameters, type);
        }
        function createTypeQueryNode(exprName) {
            var node = createBaseNode(179);
            node.exprName = exprName;
            node.transformFlags = 1;
            return node;
        }
        function updateTypeQueryNode(node, exprName) {
            return node.exprName !== exprName
                ? update(createTypeQueryNode(exprName), node)
                : node;
        }
        function createTypeLiteralNode(members) {
            var node = createBaseNode(180);
            node.members = createNodeArray(members);
            node.transformFlags = 1;
            return node;
        }
        function updateTypeLiteralNode(node, members) {
            return node.members !== members
                ? update(createTypeLiteralNode(members), node)
                : node;
        }
        function createArrayTypeNode(elementType) {
            var node = createBaseNode(181);
            node.elementType = parenthesizerRules().parenthesizeElementTypeOfArrayType(elementType);
            node.transformFlags = 1;
            return node;
        }
        function updateArrayTypeNode(node, elementType) {
            return node.elementType !== elementType
                ? update(createArrayTypeNode(elementType), node)
                : node;
        }
        function createTupleTypeNode(elements) {
            var node = createBaseNode(182);
            node.elements = createNodeArray(elements);
            node.transformFlags = 1;
            return node;
        }
        function updateTupleTypeNode(node, elements) {
            return node.elements !== elements
                ? update(createTupleTypeNode(elements), node)
                : node;
        }
        function createNamedTupleMember(dotDotDotToken, name, questionToken, type) {
            var node = createBaseNode(195);
            node.dotDotDotToken = dotDotDotToken;
            node.name = name;
            node.questionToken = questionToken;
            node.type = type;
            node.transformFlags = 1;
            return node;
        }
        function updateNamedTupleMember(node, dotDotDotToken, name, questionToken, type) {
            return node.dotDotDotToken !== dotDotDotToken
                || node.name !== name
                || node.questionToken !== questionToken
                || node.type !== type
                ? update(createNamedTupleMember(dotDotDotToken, name, questionToken, type), node)
                : node;
        }
        function createOptionalTypeNode(type) {
            var node = createBaseNode(183);
            node.type = parenthesizerRules().parenthesizeElementTypeOfArrayType(type);
            node.transformFlags = 1;
            return node;
        }
        function updateOptionalTypeNode(node, type) {
            return node.type !== type
                ? update(createOptionalTypeNode(type), node)
                : node;
        }
        function createRestTypeNode(type) {
            var node = createBaseNode(184);
            node.type = type;
            node.transformFlags = 1;
            return node;
        }
        function updateRestTypeNode(node, type) {
            return node.type !== type
                ? update(createRestTypeNode(type), node)
                : node;
        }
        function createUnionOrIntersectionTypeNode(kind, types) {
            var node = createBaseNode(kind);
            node.types = parenthesizerRules().parenthesizeConstituentTypesOfUnionOrIntersectionType(types);
            node.transformFlags = 1;
            return node;
        }
        function updateUnionOrIntersectionTypeNode(node, types) {
            return node.types !== types
                ? update(createUnionOrIntersectionTypeNode(node.kind, types), node)
                : node;
        }
        function createUnionTypeNode(types) {
            return createUnionOrIntersectionTypeNode(185, types);
        }
        function updateUnionTypeNode(node, types) {
            return updateUnionOrIntersectionTypeNode(node, types);
        }
        function createIntersectionTypeNode(types) {
            return createUnionOrIntersectionTypeNode(186, types);
        }
        function updateIntersectionTypeNode(node, types) {
            return updateUnionOrIntersectionTypeNode(node, types);
        }
        function createConditionalTypeNode(checkType, extendsType, trueType, falseType) {
            var node = createBaseNode(187);
            node.checkType = parenthesizerRules().parenthesizeMemberOfConditionalType(checkType);
            node.extendsType = parenthesizerRules().parenthesizeMemberOfConditionalType(extendsType);
            node.trueType = trueType;
            node.falseType = falseType;
            node.transformFlags = 1;
            return node;
        }
        function updateConditionalTypeNode(node, checkType, extendsType, trueType, falseType) {
            return node.checkType !== checkType
                || node.extendsType !== extendsType
                || node.trueType !== trueType
                || node.falseType !== falseType
                ? update(createConditionalTypeNode(checkType, extendsType, trueType, falseType), node)
                : node;
        }
        function createInferTypeNode(typeParameter) {
            var node = createBaseNode(188);
            node.typeParameter = typeParameter;
            node.transformFlags = 1;
            return node;
        }
        function updateInferTypeNode(node, typeParameter) {
            return node.typeParameter !== typeParameter
                ? update(createInferTypeNode(typeParameter), node)
                : node;
        }
        function createTemplateLiteralType(head, templateSpans) {
            var node = createBaseNode(196);
            node.head = head;
            node.templateSpans = createNodeArray(templateSpans);
            node.transformFlags = 1;
            return node;
        }
        function updateTemplateLiteralType(node, head, templateSpans) {
            return node.head !== head
                || node.templateSpans !== templateSpans
                ? update(createTemplateLiteralType(head, templateSpans), node)
                : node;
        }
        function createImportTypeNode(argument, qualifier, typeArguments, isTypeOf) {
            if (isTypeOf === void 0) { isTypeOf = false; }
            var node = createBaseNode(198);
            node.argument = argument;
            node.qualifier = qualifier;
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(typeArguments);
            node.isTypeOf = isTypeOf;
            node.transformFlags = 1;
            return node;
        }
        function updateImportTypeNode(node, argument, qualifier, typeArguments, isTypeOf) {
            if (isTypeOf === void 0) { isTypeOf = node.isTypeOf; }
            return node.argument !== argument
                || node.qualifier !== qualifier
                || node.typeArguments !== typeArguments
                || node.isTypeOf !== isTypeOf
                ? update(createImportTypeNode(argument, qualifier, typeArguments, isTypeOf), node)
                : node;
        }
        function createParenthesizedType(type) {
            var node = createBaseNode(189);
            node.type = type;
            node.transformFlags = 1;
            return node;
        }
        function updateParenthesizedType(node, type) {
            return node.type !== type
                ? update(createParenthesizedType(type), node)
                : node;
        }
        function createThisTypeNode() {
            var node = createBaseNode(190);
            node.transformFlags = 1;
            return node;
        }
        function createTypeOperatorNode(operator, type) {
            var node = createBaseNode(191);
            node.operator = operator;
            node.type = parenthesizerRules().parenthesizeMemberOfElementType(type);
            node.transformFlags = 1;
            return node;
        }
        function updateTypeOperatorNode(node, type) {
            return node.type !== type
                ? update(createTypeOperatorNode(node.operator, type), node)
                : node;
        }
        function createIndexedAccessTypeNode(objectType, indexType) {
            var node = createBaseNode(192);
            node.objectType = parenthesizerRules().parenthesizeMemberOfElementType(objectType);
            node.indexType = indexType;
            node.transformFlags = 1;
            return node;
        }
        function updateIndexedAccessTypeNode(node, objectType, indexType) {
            return node.objectType !== objectType
                || node.indexType !== indexType
                ? update(createIndexedAccessTypeNode(objectType, indexType), node)
                : node;
        }
        function createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type) {
            var node = createBaseNode(193);
            node.readonlyToken = readonlyToken;
            node.typeParameter = typeParameter;
            node.nameType = nameType;
            node.questionToken = questionToken;
            node.type = type;
            node.transformFlags = 1;
            return node;
        }
        function updateMappedTypeNode(node, readonlyToken, typeParameter, nameType, questionToken, type) {
            return node.readonlyToken !== readonlyToken
                || node.typeParameter !== typeParameter
                || node.nameType !== nameType
                || node.questionToken !== questionToken
                || node.type !== type
                ? update(createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type), node)
                : node;
        }
        function createLiteralTypeNode(literal) {
            var node = createBaseNode(194);
            node.literal = literal;
            node.transformFlags = 1;
            return node;
        }
        function updateLiteralTypeNode(node, literal) {
            return node.literal !== literal
                ? update(createLiteralTypeNode(literal), node)
                : node;
        }
        function createObjectBindingPattern(elements) {
            var node = createBaseNode(199);
            node.elements = createNodeArray(elements);
            node.transformFlags |=
                propagateChildrenFlags(node.elements) |
                    512 |
                    262144;
            if (node.transformFlags & 16384) {
                node.transformFlags |=
                    64 |
                        32768;
            }
            return node;
        }
        function updateObjectBindingPattern(node, elements) {
            return node.elements !== elements
                ? update(createObjectBindingPattern(elements), node)
                : node;
        }
        function createArrayBindingPattern(elements) {
            var node = createBaseNode(200);
            node.elements = createNodeArray(elements);
            node.transformFlags |=
                propagateChildrenFlags(node.elements) |
                    512 |
                    262144;
            return node;
        }
        function updateArrayBindingPattern(node, elements) {
            return node.elements !== elements
                ? update(createArrayBindingPattern(elements), node)
                : node;
        }
        function createBindingElement(dotDotDotToken, propertyName, name, initializer) {
            var node = createBaseBindingLikeDeclaration(201, undefined, undefined, name, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.propertyName = asName(propertyName);
            node.dotDotDotToken = dotDotDotToken;
            node.transformFlags |=
                propagateChildFlags(node.dotDotDotToken) |
                    512;
            if (node.propertyName) {
                node.transformFlags |= ts.isIdentifier(node.propertyName) ?
                    propagateIdentifierNameFlags(node.propertyName) :
                    propagateChildFlags(node.propertyName);
            }
            if (dotDotDotToken)
                node.transformFlags |= 16384;
            return node;
        }
        function updateBindingElement(node, dotDotDotToken, propertyName, name, initializer) {
            return node.propertyName !== propertyName
                || node.dotDotDotToken !== dotDotDotToken
                || node.name !== name
                || node.initializer !== initializer
                ? update(createBindingElement(dotDotDotToken, propertyName, name, initializer), node)
                : node;
        }
        function createBaseExpression(kind) {
            var node = createBaseNode(kind);
            return node;
        }
        function createArrayLiteralExpression(elements, multiLine) {
            var node = createBaseExpression(202);
            var lastElement = elements && ts.lastOrUndefined(elements);
            var elementsArray = createNodeArray(elements, lastElement && ts.isOmittedExpression(lastElement) ? true : undefined);
            node.elements = parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(elementsArray);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.elements);
            return node;
        }
        function updateArrayLiteralExpression(node, elements) {
            return node.elements !== elements
                ? update(createArrayLiteralExpression(elements, node.multiLine), node)
                : node;
        }
        function createObjectLiteralExpression(properties, multiLine) {
            var node = createBaseExpression(203);
            node.properties = createNodeArray(properties);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.properties);
            return node;
        }
        function updateObjectLiteralExpression(node, properties) {
            return node.properties !== properties
                ? update(createObjectLiteralExpression(properties, node.multiLine), node)
                : node;
        }
        function createPropertyAccessExpression(expression, name) {
            var node = createBaseExpression(204);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.name = asName(name);
            node.transformFlags =
                propagateChildFlags(node.expression) |
                    (ts.isIdentifier(node.name) ?
                        propagateIdentifierNameFlags(node.name) :
                        propagateChildFlags(node.name));
            if (ts.isSuperKeyword(expression)) {
                node.transformFlags |=
                    128 |
                        64;
            }
            return node;
        }
        function updatePropertyAccessExpression(node, expression, name) {
            if (ts.isPropertyAccessChain(node)) {
                return updatePropertyAccessChain(node, expression, node.questionDotToken, ts.cast(name, ts.isIdentifier));
            }
            return node.expression !== expression
                || node.name !== name
                ? update(createPropertyAccessExpression(expression, name), node)
                : node;
        }
        function createPropertyAccessChain(expression, questionDotToken, name) {
            var node = createBaseExpression(204);
            node.flags |= 32;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.questionDotToken = questionDotToken;
            node.name = asName(name);
            node.transformFlags |=
                16 |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.questionDotToken) |
                    (ts.isIdentifier(node.name) ?
                        propagateIdentifierNameFlags(node.name) :
                        propagateChildFlags(node.name));
            return node;
        }
        function updatePropertyAccessChain(node, expression, questionDotToken, name) {
            ts.Debug.assert(!!(node.flags & 32), "Cannot update a PropertyAccessExpression using updatePropertyAccessChain. Use updatePropertyAccess instead.");
            return node.expression !== expression
                || node.questionDotToken !== questionDotToken
                || node.name !== name
                ? update(createPropertyAccessChain(expression, questionDotToken, name), node)
                : node;
        }
        function createElementAccessExpression(expression, index) {
            var node = createBaseExpression(205);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.argumentExpression = asExpression(index);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.argumentExpression);
            if (ts.isSuperKeyword(expression)) {
                node.transformFlags |=
                    128 |
                        64;
            }
            return node;
        }
        function updateElementAccessExpression(node, expression, argumentExpression) {
            if (ts.isElementAccessChain(node)) {
                return updateElementAccessChain(node, expression, node.questionDotToken, argumentExpression);
            }
            return node.expression !== expression
                || node.argumentExpression !== argumentExpression
                ? update(createElementAccessExpression(expression, argumentExpression), node)
                : node;
        }
        function createElementAccessChain(expression, questionDotToken, index) {
            var node = createBaseExpression(205);
            node.flags |= 32;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.questionDotToken = questionDotToken;
            node.argumentExpression = asExpression(index);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.questionDotToken) |
                    propagateChildFlags(node.argumentExpression) |
                    16;
            return node;
        }
        function updateElementAccessChain(node, expression, questionDotToken, argumentExpression) {
            ts.Debug.assert(!!(node.flags & 32), "Cannot update a ElementAccessExpression using updateElementAccessChain. Use updateElementAccess instead.");
            return node.expression !== expression
                || node.questionDotToken !== questionDotToken
                || node.argumentExpression !== argumentExpression
                ? update(createElementAccessChain(expression, questionDotToken, argumentExpression), node)
                : node;
        }
        function createCallExpression(expression, typeArguments, argumentsArray) {
            var node = createBaseExpression(206);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.typeArguments = asNodeArray(typeArguments);
            node.arguments = parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(createNodeArray(argumentsArray));
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildrenFlags(node.arguments);
            if (node.typeArguments) {
                node.transformFlags |= 1;
            }
            if (ts.isImportKeyword(node.expression)) {
                node.transformFlags |= 4194304;
            }
            else if (ts.isSuperProperty(node.expression)) {
                node.transformFlags |= 8192;
            }
            return node;
        }
        function updateCallExpression(node, expression, typeArguments, argumentsArray) {
            if (ts.isCallChain(node)) {
                return updateCallChain(node, expression, node.questionDotToken, typeArguments, argumentsArray);
            }
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                || node.arguments !== argumentsArray
                ? update(createCallExpression(expression, typeArguments, argumentsArray), node)
                : node;
        }
        function createCallChain(expression, questionDotToken, typeArguments, argumentsArray) {
            var node = createBaseExpression(206);
            node.flags |= 32;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.questionDotToken = questionDotToken;
            node.typeArguments = asNodeArray(typeArguments);
            node.arguments = parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(createNodeArray(argumentsArray));
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.questionDotToken) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildrenFlags(node.arguments) |
                    16;
            if (node.typeArguments) {
                node.transformFlags |= 1;
            }
            if (ts.isSuperProperty(node.expression)) {
                node.transformFlags |= 8192;
            }
            return node;
        }
        function updateCallChain(node, expression, questionDotToken, typeArguments, argumentsArray) {
            ts.Debug.assert(!!(node.flags & 32), "Cannot update a CallExpression using updateCallChain. Use updateCall instead.");
            return node.expression !== expression
                || node.questionDotToken !== questionDotToken
                || node.typeArguments !== typeArguments
                || node.arguments !== argumentsArray
                ? update(createCallChain(expression, questionDotToken, typeArguments, argumentsArray), node)
                : node;
        }
        function createNewExpression(expression, typeArguments, argumentsArray) {
            var node = createBaseExpression(207);
            node.expression = parenthesizerRules().parenthesizeExpressionOfNew(expression);
            node.typeArguments = asNodeArray(typeArguments);
            node.arguments = argumentsArray ? parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(argumentsArray) : undefined;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildrenFlags(node.arguments) |
                    16;
            if (node.typeArguments) {
                node.transformFlags |= 1;
            }
            return node;
        }
        function updateNewExpression(node, expression, typeArguments, argumentsArray) {
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                || node.arguments !== argumentsArray
                ? update(createNewExpression(expression, typeArguments, argumentsArray), node)
                : node;
        }
        function createTaggedTemplateExpression(tag, typeArguments, template) {
            var node = createBaseExpression(208);
            node.tag = parenthesizerRules().parenthesizeLeftSideOfAccess(tag);
            node.typeArguments = asNodeArray(typeArguments);
            node.template = template;
            node.transformFlags |=
                propagateChildFlags(node.tag) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.template) |
                    512;
            if (node.typeArguments) {
                node.transformFlags |= 1;
            }
            if (ts.hasInvalidEscape(node.template)) {
                node.transformFlags |= 64;
            }
            return node;
        }
        function updateTaggedTemplateExpression(node, tag, typeArguments, template) {
            return node.tag !== tag
                || node.typeArguments !== typeArguments
                || node.template !== template
                ? update(createTaggedTemplateExpression(tag, typeArguments, template), node)
                : node;
        }
        function createTypeAssertion(type, expression) {
            var node = createBaseExpression(209);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.type = type;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.type) |
                    1;
            return node;
        }
        function updateTypeAssertion(node, type, expression) {
            return node.type !== type
                || node.expression !== expression
                ? update(createTypeAssertion(type, expression), node)
                : node;
        }
        function createParenthesizedExpression(expression) {
            var node = createBaseExpression(210);
            node.expression = expression;
            node.transformFlags = propagateChildFlags(node.expression);
            return node;
        }
        function updateParenthesizedExpression(node, expression) {
            return node.expression !== expression
                ? update(createParenthesizedExpression(expression), node)
                : node;
        }
        function createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(211, undefined, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            node.transformFlags |= propagateChildFlags(node.asteriskToken);
            if (node.typeParameters) {
                node.transformFlags |= 1;
            }
            if (ts.modifiersToFlags(node.modifiers) & 256) {
                if (node.asteriskToken) {
                    node.transformFlags |= 64;
                }
                else {
                    node.transformFlags |= 128;
                }
            }
            else if (node.asteriskToken) {
                node.transformFlags |= 1024;
            }
            return node;
        }
        function updateFunctionExpression(node, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            return node.name !== name
                || node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body), node)
                : node;
        }
        function createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body) {
            var node = createBaseFunctionLikeDeclaration(212, undefined, modifiers, undefined, typeParameters, parameters, type, parenthesizerRules().parenthesizeConciseBodyOfArrowFunction(body));
            node.equalsGreaterThanToken = equalsGreaterThanToken !== null && equalsGreaterThanToken !== void 0 ? equalsGreaterThanToken : createToken(38);
            node.transformFlags |=
                propagateChildFlags(node.equalsGreaterThanToken) |
                    512;
            if (ts.modifiersToFlags(node.modifiers) & 256) {
                node.transformFlags |= 128 | 8192;
            }
            return node;
        }
        function updateArrowFunction(node, modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body) {
            return node.modifiers !== modifiers
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.equalsGreaterThanToken !== equalsGreaterThanToken
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body), node)
                : node;
        }
        function createDeleteExpression(expression) {
            var node = createBaseExpression(213);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        function updateDeleteExpression(node, expression) {
            return node.expression !== expression
                ? update(createDeleteExpression(expression), node)
                : node;
        }
        function createTypeOfExpression(expression) {
            var node = createBaseExpression(214);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        function updateTypeOfExpression(node, expression) {
            return node.expression !== expression
                ? update(createTypeOfExpression(expression), node)
                : node;
        }
        function createVoidExpression(expression) {
            var node = createBaseExpression(215);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        function updateVoidExpression(node, expression) {
            return node.expression !== expression
                ? update(createVoidExpression(expression), node)
                : node;
        }
        function createAwaitExpression(expression) {
            var node = createBaseExpression(216);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    128 |
                    64 |
                    1048576;
            return node;
        }
        function updateAwaitExpression(node, expression) {
            return node.expression !== expression
                ? update(createAwaitExpression(expression), node)
                : node;
        }
        function createPrefixUnaryExpression(operator, operand) {
            var node = createBaseExpression(217);
            node.operator = operator;
            node.operand = parenthesizerRules().parenthesizeOperandOfPrefixUnary(operand);
            node.transformFlags |= propagateChildFlags(node.operand);
            if ((operator === 45 || operator === 46) &&
                ts.isIdentifier(node.operand) &&
                !ts.isGeneratedIdentifier(node.operand) &&
                !ts.isLocalName(node.operand)) {
                node.transformFlags |= 67108864;
            }
            return node;
        }
        function updatePrefixUnaryExpression(node, operand) {
            return node.operand !== operand
                ? update(createPrefixUnaryExpression(node.operator, operand), node)
                : node;
        }
        function createPostfixUnaryExpression(operand, operator) {
            var node = createBaseExpression(218);
            node.operator = operator;
            node.operand = parenthesizerRules().parenthesizeOperandOfPostfixUnary(operand);
            node.transformFlags |= propagateChildFlags(node.operand);
            if (ts.isIdentifier(node.operand) &&
                !ts.isGeneratedIdentifier(node.operand) &&
                !ts.isLocalName(node.operand)) {
                node.transformFlags |= 67108864;
            }
            return node;
        }
        function updatePostfixUnaryExpression(node, operand) {
            return node.operand !== operand
                ? update(createPostfixUnaryExpression(operand, node.operator), node)
                : node;
        }
        function createBinaryExpression(left, operator, right) {
            var node = createBaseExpression(219);
            var operatorToken = asToken(operator);
            var operatorKind = operatorToken.kind;
            node.left = parenthesizerRules().parenthesizeLeftSideOfBinary(operatorKind, left);
            node.operatorToken = operatorToken;
            node.right = parenthesizerRules().parenthesizeRightSideOfBinary(operatorKind, node.left, right);
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateChildFlags(node.operatorToken) |
                    propagateChildFlags(node.right);
            if (operatorKind === 60) {
                node.transformFlags |= 16;
            }
            else if (operatorKind === 63) {
                if (ts.isObjectLiteralExpression(node.left)) {
                    node.transformFlags |=
                        512 |
                            64 |
                            2048 |
                            propagateAssignmentPatternFlags(node.left);
                }
                else if (ts.isArrayLiteralExpression(node.left)) {
                    node.transformFlags |=
                        512 |
                            2048 |
                            propagateAssignmentPatternFlags(node.left);
                }
            }
            else if (operatorKind === 42 || operatorKind === 67) {
                node.transformFlags |= 256;
            }
            else if (ts.isLogicalOrCoalescingAssignmentOperator(operatorKind)) {
                node.transformFlags |= 8;
            }
            return node;
        }
        function propagateAssignmentPatternFlags(node) {
            if (node.transformFlags & 32768)
                return 32768;
            if (node.transformFlags & 64) {
                for (var _i = 0, _a = ts.getElementsOfBindingOrAssignmentPattern(node); _i < _a.length; _i++) {
                    var element = _a[_i];
                    var target = ts.getTargetOfBindingOrAssignmentElement(element);
                    if (target && ts.isAssignmentPattern(target)) {
                        if (target.transformFlags & 32768) {
                            return 32768;
                        }
                        if (target.transformFlags & 64) {
                            var flags_1 = propagateAssignmentPatternFlags(target);
                            if (flags_1)
                                return flags_1;
                        }
                    }
                }
            }
            return 0;
        }
        function updateBinaryExpression(node, left, operator, right) {
            return node.left !== left
                || node.operatorToken !== operator
                || node.right !== right
                ? update(createBinaryExpression(left, operator, right), node)
                : node;
        }
        function createConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse) {
            var node = createBaseExpression(220);
            node.condition = parenthesizerRules().parenthesizeConditionOfConditionalExpression(condition);
            node.questionToken = questionToken !== null && questionToken !== void 0 ? questionToken : createToken(57);
            node.whenTrue = parenthesizerRules().parenthesizeBranchOfConditionalExpression(whenTrue);
            node.colonToken = colonToken !== null && colonToken !== void 0 ? colonToken : createToken(58);
            node.whenFalse = parenthesizerRules().parenthesizeBranchOfConditionalExpression(whenFalse);
            node.transformFlags |=
                propagateChildFlags(node.condition) |
                    propagateChildFlags(node.questionToken) |
                    propagateChildFlags(node.whenTrue) |
                    propagateChildFlags(node.colonToken) |
                    propagateChildFlags(node.whenFalse);
            return node;
        }
        function updateConditionalExpression(node, condition, questionToken, whenTrue, colonToken, whenFalse) {
            return node.condition !== condition
                || node.questionToken !== questionToken
                || node.whenTrue !== whenTrue
                || node.colonToken !== colonToken
                || node.whenFalse !== whenFalse
                ? update(createConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse), node)
                : node;
        }
        function createTemplateExpression(head, templateSpans) {
            var node = createBaseExpression(221);
            node.head = head;
            node.templateSpans = createNodeArray(templateSpans);
            node.transformFlags |=
                propagateChildFlags(node.head) |
                    propagateChildrenFlags(node.templateSpans) |
                    512;
            return node;
        }
        function updateTemplateExpression(node, head, templateSpans) {
            return node.head !== head
                || node.templateSpans !== templateSpans
                ? update(createTemplateExpression(head, templateSpans), node)
                : node;
        }
        function createTemplateLiteralLikeNodeChecked(kind, text, rawText, templateFlags) {
            if (templateFlags === void 0) { templateFlags = 0; }
            ts.Debug.assert(!(templateFlags & ~2048), "Unsupported template flags.");
            var cooked = undefined;
            if (rawText !== undefined && rawText !== text) {
                cooked = getCookedText(kind, rawText);
                if (typeof cooked === "object") {
                    return ts.Debug.fail("Invalid raw text");
                }
            }
            if (text === undefined) {
                if (cooked === undefined) {
                    return ts.Debug.fail("Arguments 'text' and 'rawText' may not both be undefined.");
                }
                text = cooked;
            }
            else if (cooked !== undefined) {
                ts.Debug.assert(text === cooked, "Expected argument 'text' to be the normalized (i.e. 'cooked') version of argument 'rawText'.");
            }
            return createTemplateLiteralLikeNode(kind, text, rawText, templateFlags);
        }
        function createTemplateLiteralLikeNode(kind, text, rawText, templateFlags) {
            var node = createBaseToken(kind);
            node.text = text;
            node.rawText = rawText;
            node.templateFlags = templateFlags & 2048;
            node.transformFlags |= 512;
            if (node.templateFlags) {
                node.transformFlags |= 64;
            }
            return node;
        }
        function createTemplateHead(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(15, text, rawText, templateFlags);
        }
        function createTemplateMiddle(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(16, text, rawText, templateFlags);
        }
        function createTemplateTail(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(17, text, rawText, templateFlags);
        }
        function createNoSubstitutionTemplateLiteral(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(14, text, rawText, templateFlags);
        }
        function createYieldExpression(asteriskToken, expression) {
            ts.Debug.assert(!asteriskToken || !!expression, "A `YieldExpression` with an asteriskToken must have an expression.");
            var node = createBaseExpression(222);
            node.expression = expression && parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.asteriskToken = asteriskToken;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.asteriskToken) |
                    512 |
                    64 |
                    524288;
            return node;
        }
        function updateYieldExpression(node, asteriskToken, expression) {
            return node.expression !== expression
                || node.asteriskToken !== asteriskToken
                ? update(createYieldExpression(asteriskToken, expression), node)
                : node;
        }
        function createSpreadElement(expression) {
            var node = createBaseExpression(223);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    512 |
                    16384;
            return node;
        }
        function updateSpreadElement(node, expression) {
            return node.expression !== expression
                ? update(createSpreadElement(expression), node)
                : node;
        }
        function createClassExpression(decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseClassLikeDeclaration(224, decorators, modifiers, name, typeParameters, heritageClauses, members);
            node.transformFlags |= 512;
            return node;
        }
        function updateClassExpression(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createClassExpression(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        function createOmittedExpression() {
            return createBaseExpression(225);
        }
        function createExpressionWithTypeArguments(expression, typeArguments) {
            var node = createBaseNode(226);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(typeArguments);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    512;
            return node;
        }
        function updateExpressionWithTypeArguments(node, expression, typeArguments) {
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                ? update(createExpressionWithTypeArguments(expression, typeArguments), node)
                : node;
        }
        function createAsExpression(expression, type) {
            var node = createBaseExpression(227);
            node.expression = expression;
            node.type = type;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.type) |
                    1;
            return node;
        }
        function updateAsExpression(node, expression, type) {
            return node.expression !== expression
                || node.type !== type
                ? update(createAsExpression(expression, type), node)
                : node;
        }
        function createNonNullExpression(expression) {
            var node = createBaseExpression(228);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1;
            return node;
        }
        function updateNonNullExpression(node, expression) {
            if (ts.isNonNullChain(node)) {
                return updateNonNullChain(node, expression);
            }
            return node.expression !== expression
                ? update(createNonNullExpression(expression), node)
                : node;
        }
        function createNonNullChain(expression) {
            var node = createBaseExpression(228);
            node.flags |= 32;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1;
            return node;
        }
        function updateNonNullChain(node, expression) {
            ts.Debug.assert(!!(node.flags & 32), "Cannot update a NonNullExpression using updateNonNullChain. Use updateNonNullExpression instead.");
            return node.expression !== expression
                ? update(createNonNullChain(expression), node)
                : node;
        }
        function createMetaProperty(keywordToken, name) {
            var node = createBaseExpression(229);
            node.keywordToken = keywordToken;
            node.name = name;
            node.transformFlags |= propagateChildFlags(node.name);
            switch (keywordToken) {
                case 103:
                    node.transformFlags |= 512;
                    break;
                case 100:
                    node.transformFlags |= 4;
                    break;
                default:
                    return ts.Debug.assertNever(keywordToken);
            }
            return node;
        }
        function updateMetaProperty(node, name) {
            return node.name !== name
                ? update(createMetaProperty(node.keywordToken, name), node)
                : node;
        }
        function createTemplateSpan(expression, literal) {
            var node = createBaseNode(231);
            node.expression = expression;
            node.literal = literal;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.literal) |
                    512;
            return node;
        }
        function updateTemplateSpan(node, expression, literal) {
            return node.expression !== expression
                || node.literal !== literal
                ? update(createTemplateSpan(expression, literal), node)
                : node;
        }
        function createSemicolonClassElement() {
            var node = createBaseNode(232);
            node.transformFlags |= 512;
            return node;
        }
        function createBlock(statements, multiLine) {
            var node = createBaseNode(233);
            node.statements = createNodeArray(statements);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.statements);
            return node;
        }
        function updateBlock(node, statements) {
            return node.statements !== statements
                ? update(createBlock(statements, node.multiLine), node)
                : node;
        }
        function createVariableStatement(modifiers, declarationList) {
            var node = createBaseDeclaration(235, undefined, modifiers);
            node.declarationList = ts.isArray(declarationList) ? createVariableDeclarationList(declarationList) : declarationList;
            node.transformFlags |=
                propagateChildFlags(node.declarationList);
            if (ts.modifiersToFlags(node.modifiers) & 2) {
                node.transformFlags = 1;
            }
            return node;
        }
        function updateVariableStatement(node, modifiers, declarationList) {
            return node.modifiers !== modifiers
                || node.declarationList !== declarationList
                ? update(createVariableStatement(modifiers, declarationList), node)
                : node;
        }
        function createEmptyStatement() {
            return createBaseNode(234);
        }
        function createExpressionStatement(expression) {
            var node = createBaseNode(236);
            node.expression = parenthesizerRules().parenthesizeExpressionOfExpressionStatement(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        function updateExpressionStatement(node, expression) {
            return node.expression !== expression
                ? update(createExpressionStatement(expression), node)
                : node;
        }
        function createIfStatement(expression, thenStatement, elseStatement) {
            var node = createBaseNode(237);
            node.expression = expression;
            node.thenStatement = asEmbeddedStatement(thenStatement);
            node.elseStatement = asEmbeddedStatement(elseStatement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.thenStatement) |
                    propagateChildFlags(node.elseStatement);
            return node;
        }
        function updateIfStatement(node, expression, thenStatement, elseStatement) {
            return node.expression !== expression
                || node.thenStatement !== thenStatement
                || node.elseStatement !== elseStatement
                ? update(createIfStatement(expression, thenStatement, elseStatement), node)
                : node;
        }
        function createDoStatement(statement, expression) {
            var node = createBaseNode(238);
            node.statement = asEmbeddedStatement(statement);
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.statement) |
                    propagateChildFlags(node.expression);
            return node;
        }
        function updateDoStatement(node, statement, expression) {
            return node.statement !== statement
                || node.expression !== expression
                ? update(createDoStatement(statement, expression), node)
                : node;
        }
        function createWhileStatement(expression, statement) {
            var node = createBaseNode(239);
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        function updateWhileStatement(node, expression, statement) {
            return node.expression !== expression
                || node.statement !== statement
                ? update(createWhileStatement(expression, statement), node)
                : node;
        }
        function createForStatement(initializer, condition, incrementor, statement) {
            var node = createBaseNode(240);
            node.initializer = initializer;
            node.condition = condition;
            node.incrementor = incrementor;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.condition) |
                    propagateChildFlags(node.incrementor) |
                    propagateChildFlags(node.statement);
            return node;
        }
        function updateForStatement(node, initializer, condition, incrementor, statement) {
            return node.initializer !== initializer
                || node.condition !== condition
                || node.incrementor !== incrementor
                || node.statement !== statement
                ? update(createForStatement(initializer, condition, incrementor, statement), node)
                : node;
        }
        function createForInStatement(initializer, expression, statement) {
            var node = createBaseNode(241);
            node.initializer = initializer;
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        function updateForInStatement(node, initializer, expression, statement) {
            return node.initializer !== initializer
                || node.expression !== expression
                || node.statement !== statement
                ? update(createForInStatement(initializer, expression, statement), node)
                : node;
        }
        function createForOfStatement(awaitModifier, initializer, expression, statement) {
            var node = createBaseNode(242);
            node.awaitModifier = awaitModifier;
            node.initializer = initializer;
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.awaitModifier) |
                    propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement) |
                    512;
            if (awaitModifier)
                node.transformFlags |= 64;
            return node;
        }
        function updateForOfStatement(node, awaitModifier, initializer, expression, statement) {
            return node.awaitModifier !== awaitModifier
                || node.initializer !== initializer
                || node.expression !== expression
                || node.statement !== statement
                ? update(createForOfStatement(awaitModifier, initializer, expression, statement), node)
                : node;
        }
        function createContinueStatement(label) {
            var node = createBaseNode(243);
            node.label = asName(label);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    2097152;
            return node;
        }
        function updateContinueStatement(node, label) {
            return node.label !== label
                ? update(createContinueStatement(label), node)
                : node;
        }
        function createBreakStatement(label) {
            var node = createBaseNode(244);
            node.label = asName(label);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    2097152;
            return node;
        }
        function updateBreakStatement(node, label) {
            return node.label !== label
                ? update(createBreakStatement(label), node)
                : node;
        }
        function createReturnStatement(expression) {
            var node = createBaseNode(245);
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    64 |
                    2097152;
            return node;
        }
        function updateReturnStatement(node, expression) {
            return node.expression !== expression
                ? update(createReturnStatement(expression), node)
                : node;
        }
        function createWithStatement(expression, statement) {
            var node = createBaseNode(246);
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        function updateWithStatement(node, expression, statement) {
            return node.expression !== expression
                || node.statement !== statement
                ? update(createWithStatement(expression, statement), node)
                : node;
        }
        function createSwitchStatement(expression, caseBlock) {
            var node = createBaseNode(247);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.caseBlock = caseBlock;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.caseBlock);
            return node;
        }
        function updateSwitchStatement(node, expression, caseBlock) {
            return node.expression !== expression
                || node.caseBlock !== caseBlock
                ? update(createSwitchStatement(expression, caseBlock), node)
                : node;
        }
        function createLabeledStatement(label, statement) {
            var node = createBaseNode(248);
            node.label = asName(label);
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    propagateChildFlags(node.statement);
            return node;
        }
        function updateLabeledStatement(node, label, statement) {
            return node.label !== label
                || node.statement !== statement
                ? update(createLabeledStatement(label, statement), node)
                : node;
        }
        function createThrowStatement(expression) {
            var node = createBaseNode(249);
            node.expression = expression;
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        function updateThrowStatement(node, expression) {
            return node.expression !== expression
                ? update(createThrowStatement(expression), node)
                : node;
        }
        function createTryStatement(tryBlock, catchClause, finallyBlock) {
            var node = createBaseNode(250);
            node.tryBlock = tryBlock;
            node.catchClause = catchClause;
            node.finallyBlock = finallyBlock;
            node.transformFlags |=
                propagateChildFlags(node.tryBlock) |
                    propagateChildFlags(node.catchClause) |
                    propagateChildFlags(node.finallyBlock);
            return node;
        }
        function updateTryStatement(node, tryBlock, catchClause, finallyBlock) {
            return node.tryBlock !== tryBlock
                || node.catchClause !== catchClause
                || node.finallyBlock !== finallyBlock
                ? update(createTryStatement(tryBlock, catchClause, finallyBlock), node)
                : node;
        }
        function createDebuggerStatement() {
            return createBaseNode(251);
        }
        function createVariableDeclaration(name, exclamationToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(252, undefined, undefined, name, type, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.exclamationToken = exclamationToken;
            node.transformFlags |= propagateChildFlags(node.exclamationToken);
            if (exclamationToken) {
                node.transformFlags |= 1;
            }
            return node;
        }
        function updateVariableDeclaration(node, name, exclamationToken, type, initializer) {
            return node.name !== name
                || node.type !== type
                || node.exclamationToken !== exclamationToken
                || node.initializer !== initializer
                ? update(createVariableDeclaration(name, exclamationToken, type, initializer), node)
                : node;
        }
        function createVariableDeclarationList(declarations, flags) {
            if (flags === void 0) { flags = 0; }
            var node = createBaseNode(253);
            node.flags |= flags & 3;
            node.declarations = createNodeArray(declarations);
            node.transformFlags |=
                propagateChildrenFlags(node.declarations) |
                    2097152;
            if (flags & 3) {
                node.transformFlags |=
                    512 |
                        131072;
            }
            return node;
        }
        function updateVariableDeclarationList(node, declarations) {
            return node.declarations !== declarations
                ? update(createVariableDeclarationList(declarations, node.flags), node)
                : node;
        }
        function createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(254, decorators, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            if (!node.body || ts.modifiersToFlags(node.modifiers) & 2) {
                node.transformFlags = 1;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.asteriskToken) |
                        2097152;
                if (ts.modifiersToFlags(node.modifiers) & 256) {
                    if (node.asteriskToken) {
                        node.transformFlags |= 64;
                    }
                    else {
                        node.transformFlags |= 128;
                    }
                }
                else if (node.asteriskToken) {
                    node.transformFlags |= 1024;
                }
            }
            return node;
        }
        function updateFunctionDeclaration(node, decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body), node)
                : node;
        }
        function createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseClassLikeDeclaration(255, decorators, modifiers, name, typeParameters, heritageClauses, members);
            if (ts.modifiersToFlags(node.modifiers) & 2) {
                node.transformFlags = 1;
            }
            else {
                node.transformFlags |= 512;
                if (node.transformFlags & 4096) {
                    node.transformFlags |= 1;
                }
            }
            return node;
        }
        function updateClassDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        function createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseInterfaceOrClassLikeDeclaration(256, decorators, modifiers, name, typeParameters, heritageClauses);
            node.members = createNodeArray(members);
            node.transformFlags = 1;
            return node;
        }
        function updateInterfaceDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        function createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type) {
            var node = createBaseGenericNamedDeclaration(257, decorators, modifiers, name, typeParameters);
            node.type = type;
            node.transformFlags = 1;
            return node;
        }
        function updateTypeAliasDeclaration(node, decorators, modifiers, name, typeParameters, type) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.type !== type
                ? update(createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type), node)
                : node;
        }
        function createEnumDeclaration(decorators, modifiers, name, members) {
            var node = createBaseNamedDeclaration(258, decorators, modifiers, name);
            node.members = createNodeArray(members);
            node.transformFlags |=
                propagateChildrenFlags(node.members) |
                    1;
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateEnumDeclaration(node, decorators, modifiers, name, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.members !== members
                ? update(createEnumDeclaration(decorators, modifiers, name, members), node)
                : node;
        }
        function createModuleDeclaration(decorators, modifiers, name, body, flags) {
            if (flags === void 0) { flags = 0; }
            var node = createBaseDeclaration(259, decorators, modifiers);
            node.flags |= flags & (16 | 4 | 1024);
            node.name = name;
            node.body = body;
            if (ts.modifiersToFlags(node.modifiers) & 2) {
                node.transformFlags = 1;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.name) |
                        propagateChildFlags(node.body) |
                        1;
            }
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateModuleDeclaration(node, decorators, modifiers, name, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.body !== body
                ? update(createModuleDeclaration(decorators, modifiers, name, body, node.flags), node)
                : node;
        }
        function createModuleBlock(statements) {
            var node = createBaseNode(260);
            node.statements = createNodeArray(statements);
            node.transformFlags |= propagateChildrenFlags(node.statements);
            return node;
        }
        function updateModuleBlock(node, statements) {
            return node.statements !== statements
                ? update(createModuleBlock(statements), node)
                : node;
        }
        function createCaseBlock(clauses) {
            var node = createBaseNode(261);
            node.clauses = createNodeArray(clauses);
            node.transformFlags |= propagateChildrenFlags(node.clauses);
            return node;
        }
        function updateCaseBlock(node, clauses) {
            return node.clauses !== clauses
                ? update(createCaseBlock(clauses), node)
                : node;
        }
        function createNamespaceExportDeclaration(name) {
            var node = createBaseNamedDeclaration(262, undefined, undefined, name);
            node.transformFlags = 1;
            return node;
        }
        function updateNamespaceExportDeclaration(node, name) {
            return node.name !== name
                ? update(createNamespaceExportDeclaration(name), node)
                : node;
        }
        function createImportEqualsDeclaration(decorators, modifiers, isTypeOnly, name, moduleReference) {
            var node = createBaseNamedDeclaration(263, decorators, modifiers, name);
            node.isTypeOnly = isTypeOnly;
            node.moduleReference = moduleReference;
            node.transformFlags |= propagateChildFlags(node.moduleReference);
            if (!ts.isExternalModuleReference(node.moduleReference))
                node.transformFlags |= 1;
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateImportEqualsDeclaration(node, decorators, modifiers, isTypeOnly, name, moduleReference) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.isTypeOnly !== isTypeOnly
                || node.name !== name
                || node.moduleReference !== moduleReference
                ? update(createImportEqualsDeclaration(decorators, modifiers, isTypeOnly, name, moduleReference), node)
                : node;
        }
        function createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier) {
            var node = createBaseDeclaration(264, decorators, modifiers);
            node.importClause = importClause;
            node.moduleSpecifier = moduleSpecifier;
            node.transformFlags |=
                propagateChildFlags(node.importClause) |
                    propagateChildFlags(node.moduleSpecifier);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateImportDeclaration(node, decorators, modifiers, importClause, moduleSpecifier) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.importClause !== importClause
                || node.moduleSpecifier !== moduleSpecifier
                ? update(createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier), node)
                : node;
        }
        function createImportClause(isTypeOnly, name, namedBindings) {
            var node = createBaseNode(265);
            node.isTypeOnly = isTypeOnly;
            node.name = name;
            node.namedBindings = namedBindings;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.namedBindings);
            if (isTypeOnly) {
                node.transformFlags |= 1;
            }
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateImportClause(node, isTypeOnly, name, namedBindings) {
            return node.isTypeOnly !== isTypeOnly
                || node.name !== name
                || node.namedBindings !== namedBindings
                ? update(createImportClause(isTypeOnly, name, namedBindings), node)
                : node;
        }
        function createNamespaceImport(name) {
            var node = createBaseNode(266);
            node.name = name;
            node.transformFlags |= propagateChildFlags(node.name);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateNamespaceImport(node, name) {
            return node.name !== name
                ? update(createNamespaceImport(name), node)
                : node;
        }
        function createNamespaceExport(name) {
            var node = createBaseNode(272);
            node.name = name;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    4;
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateNamespaceExport(node, name) {
            return node.name !== name
                ? update(createNamespaceExport(name), node)
                : node;
        }
        function createNamedImports(elements) {
            var node = createBaseNode(267);
            node.elements = createNodeArray(elements);
            node.transformFlags |= propagateChildrenFlags(node.elements);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateNamedImports(node, elements) {
            return node.elements !== elements
                ? update(createNamedImports(elements), node)
                : node;
        }
        function createImportSpecifier(propertyName, name) {
            var node = createBaseNode(268);
            node.propertyName = propertyName;
            node.name = name;
            node.transformFlags |=
                propagateChildFlags(node.propertyName) |
                    propagateChildFlags(node.name);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateImportSpecifier(node, propertyName, name) {
            return node.propertyName !== propertyName
                || node.name !== name
                ? update(createImportSpecifier(propertyName, name), node)
                : node;
        }
        function createExportAssignment(decorators, modifiers, isExportEquals, expression) {
            var node = createBaseDeclaration(269, decorators, modifiers);
            node.isExportEquals = isExportEquals;
            node.expression = isExportEquals
                ? parenthesizerRules().parenthesizeRightSideOfBinary(63, undefined, expression)
                : parenthesizerRules().parenthesizeExpressionOfExportDefault(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateExportAssignment(node, decorators, modifiers, expression) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.expression !== expression
                ? update(createExportAssignment(decorators, modifiers, node.isExportEquals, expression), node)
                : node;
        }
        function createExportDeclaration(decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier) {
            var node = createBaseDeclaration(270, decorators, modifiers);
            node.isTypeOnly = isTypeOnly;
            node.exportClause = exportClause;
            node.moduleSpecifier = moduleSpecifier;
            node.transformFlags |=
                propagateChildFlags(node.exportClause) |
                    propagateChildFlags(node.moduleSpecifier);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateExportDeclaration(node, decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.isTypeOnly !== isTypeOnly
                || node.exportClause !== exportClause
                || node.moduleSpecifier !== moduleSpecifier
                ? update(createExportDeclaration(decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier), node)
                : node;
        }
        function createNamedExports(elements) {
            var node = createBaseNode(271);
            node.elements = createNodeArray(elements);
            node.transformFlags |= propagateChildrenFlags(node.elements);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateNamedExports(node, elements) {
            return node.elements !== elements
                ? update(createNamedExports(elements), node)
                : node;
        }
        function createExportSpecifier(propertyName, name) {
            var node = createBaseNode(273);
            node.propertyName = asName(propertyName);
            node.name = asName(name);
            node.transformFlags |=
                propagateChildFlags(node.propertyName) |
                    propagateChildFlags(node.name);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateExportSpecifier(node, propertyName, name) {
            return node.propertyName !== propertyName
                || node.name !== name
                ? update(createExportSpecifier(propertyName, name), node)
                : node;
        }
        function createMissingDeclaration() {
            var node = createBaseDeclaration(274, undefined, undefined);
            return node;
        }
        function createExternalModuleReference(expression) {
            var node = createBaseNode(275);
            node.expression = expression;
            node.transformFlags |= propagateChildFlags(node.expression);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateExternalModuleReference(node, expression) {
            return node.expression !== expression
                ? update(createExternalModuleReference(expression), node)
                : node;
        }
        function createJSDocPrimaryTypeWorker(kind) {
            return createBaseNode(kind);
        }
        function createJSDocUnaryTypeWorker(kind, type) {
            var node = createBaseNode(kind);
            node.type = type;
            return node;
        }
        function updateJSDocUnaryTypeWorker(kind, node, type) {
            return node.type !== type
                ? update(createJSDocUnaryTypeWorker(kind, type), node)
                : node;
        }
        function createJSDocFunctionType(parameters, type) {
            var node = createBaseSignatureDeclaration(312, undefined, undefined, undefined, undefined, parameters, type);
            return node;
        }
        function updateJSDocFunctionType(node, parameters, type) {
            return node.parameters !== parameters
                || node.type !== type
                ? update(createJSDocFunctionType(parameters, type), node)
                : node;
        }
        function createJSDocTypeLiteral(propertyTags, isArrayType) {
            if (isArrayType === void 0) { isArrayType = false; }
            var node = createBaseNode(317);
            node.jsDocPropertyTags = asNodeArray(propertyTags);
            node.isArrayType = isArrayType;
            return node;
        }
        function updateJSDocTypeLiteral(node, propertyTags, isArrayType) {
            return node.jsDocPropertyTags !== propertyTags
                || node.isArrayType !== isArrayType
                ? update(createJSDocTypeLiteral(propertyTags, isArrayType), node)
                : node;
        }
        function createJSDocTypeExpression(type) {
            var node = createBaseNode(304);
            node.type = type;
            return node;
        }
        function updateJSDocTypeExpression(node, type) {
            return node.type !== type
                ? update(createJSDocTypeExpression(type), node)
                : node;
        }
        function createJSDocSignature(typeParameters, parameters, type) {
            var node = createBaseNode(318);
            node.typeParameters = asNodeArray(typeParameters);
            node.parameters = createNodeArray(parameters);
            node.type = type;
            return node;
        }
        function updateJSDocSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? update(createJSDocSignature(typeParameters, parameters, type), node)
                : node;
        }
        function getDefaultTagName(node) {
            var defaultTagName = getDefaultTagNameForKind(node.kind);
            return node.tagName.escapedText === ts.escapeLeadingUnderscores(defaultTagName)
                ? node.tagName
                : createIdentifier(defaultTagName);
        }
        function createBaseJSDocTag(kind, tagName, comment) {
            var node = createBaseNode(kind);
            node.tagName = tagName;
            node.comment = comment;
            return node;
        }
        function createJSDocTemplateTag(tagName, constraint, typeParameters, comment) {
            var node = createBaseJSDocTag(339, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("template"), comment);
            node.constraint = constraint;
            node.typeParameters = createNodeArray(typeParameters);
            return node;
        }
        function updateJSDocTemplateTag(node, tagName, constraint, typeParameters, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.constraint !== constraint
                || node.typeParameters !== typeParameters
                || node.comment !== comment
                ? update(createJSDocTemplateTag(tagName, constraint, typeParameters, comment), node)
                : node;
        }
        function createJSDocTypedefTag(tagName, typeExpression, fullName, comment) {
            var node = createBaseJSDocTag(340, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("typedef"), comment);
            node.typeExpression = typeExpression;
            node.fullName = fullName;
            node.name = ts.getJSDocTypeAliasName(fullName);
            return node;
        }
        function updateJSDocTypedefTag(node, tagName, typeExpression, fullName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.fullName !== fullName
                || node.comment !== comment
                ? update(createJSDocTypedefTag(tagName, typeExpression, fullName, comment), node)
                : node;
        }
        function createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            var node = createBaseJSDocTag(335, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("param"), comment);
            node.typeExpression = typeExpression;
            node.name = name;
            node.isNameFirst = !!isNameFirst;
            node.isBracketed = isBracketed;
            return node;
        }
        function updateJSDocParameterTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.name !== name
                || node.isBracketed !== isBracketed
                || node.typeExpression !== typeExpression
                || node.isNameFirst !== isNameFirst
                || node.comment !== comment
                ? update(createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node)
                : node;
        }
        function createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            var node = createBaseJSDocTag(342, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("prop"), comment);
            node.typeExpression = typeExpression;
            node.name = name;
            node.isNameFirst = !!isNameFirst;
            node.isBracketed = isBracketed;
            return node;
        }
        function updateJSDocPropertyTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.name !== name
                || node.isBracketed !== isBracketed
                || node.typeExpression !== typeExpression
                || node.isNameFirst !== isNameFirst
                || node.comment !== comment
                ? update(createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node)
                : node;
        }
        function createJSDocCallbackTag(tagName, typeExpression, fullName, comment) {
            var node = createBaseJSDocTag(333, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("callback"), comment);
            node.typeExpression = typeExpression;
            node.fullName = fullName;
            node.name = ts.getJSDocTypeAliasName(fullName);
            return node;
        }
        function updateJSDocCallbackTag(node, tagName, typeExpression, fullName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.fullName !== fullName
                || node.comment !== comment
                ? update(createJSDocCallbackTag(tagName, typeExpression, fullName, comment), node)
                : node;
        }
        function createJSDocAugmentsTag(tagName, className, comment) {
            var node = createBaseJSDocTag(323, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("augments"), comment);
            node.class = className;
            return node;
        }
        function updateJSDocAugmentsTag(node, tagName, className, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.class !== className
                || node.comment !== comment
                ? update(createJSDocAugmentsTag(tagName, className, comment), node)
                : node;
        }
        function createJSDocImplementsTag(tagName, className, comment) {
            var node = createBaseJSDocTag(324, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("implements"), comment);
            node.class = className;
            return node;
        }
        function createJSDocSeeTag(tagName, name, comment) {
            var node = createBaseJSDocTag(341, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("see"), comment);
            node.name = name;
            return node;
        }
        function updateJSDocSeeTag(node, tagName, name, comment) {
            return node.tagName !== tagName
                || node.name !== name
                || node.comment !== comment
                ? update(createJSDocSeeTag(tagName, name, comment), node)
                : node;
        }
        function createJSDocNameReference(name) {
            var node = createBaseNode(305);
            node.name = name;
            return node;
        }
        function updateJSDocNameReference(node, name) {
            return node.name !== name
                ? update(createJSDocNameReference(name), node)
                : node;
        }
        function createJSDocMemberName(left, right) {
            var node = createBaseNode(306);
            node.left = left;
            node.right = right;
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateChildFlags(node.right);
            return node;
        }
        function updateJSDocMemberName(node, left, right) {
            return node.left !== left
                || node.right !== right
                ? update(createJSDocMemberName(left, right), node)
                : node;
        }
        function createJSDocLink(name, text) {
            var node = createBaseNode(319);
            node.name = name;
            node.text = text;
            return node;
        }
        function updateJSDocLink(node, name, text) {
            return node.name !== name
                ? update(createJSDocLink(name, text), node)
                : node;
        }
        function createJSDocLinkCode(name, text) {
            var node = createBaseNode(320);
            node.name = name;
            node.text = text;
            return node;
        }
        function updateJSDocLinkCode(node, name, text) {
            return node.name !== name
                ? update(createJSDocLinkCode(name, text), node)
                : node;
        }
        function createJSDocLinkPlain(name, text) {
            var node = createBaseNode(321);
            node.name = name;
            node.text = text;
            return node;
        }
        function updateJSDocLinkPlain(node, name, text) {
            return node.name !== name
                ? update(createJSDocLinkPlain(name, text), node)
                : node;
        }
        function updateJSDocImplementsTag(node, tagName, className, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.class !== className
                || node.comment !== comment
                ? update(createJSDocImplementsTag(tagName, className, comment), node)
                : node;
        }
        function createJSDocSimpleTagWorker(kind, tagName, comment) {
            var node = createBaseJSDocTag(kind, tagName !== null && tagName !== void 0 ? tagName : createIdentifier(getDefaultTagNameForKind(kind)), comment);
            return node;
        }
        function updateJSDocSimpleTagWorker(kind, node, tagName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.comment !== comment
                ? update(createJSDocSimpleTagWorker(kind, tagName, comment), node) :
                node;
        }
        function createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment) {
            var node = createBaseJSDocTag(kind, tagName !== null && tagName !== void 0 ? tagName : createIdentifier(getDefaultTagNameForKind(kind)), comment);
            node.typeExpression = typeExpression;
            return node;
        }
        function updateJSDocTypeLikeTagWorker(kind, node, tagName, typeExpression, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.comment !== comment
                ? update(createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment), node)
                : node;
        }
        function createJSDocUnknownTag(tagName, comment) {
            var node = createBaseJSDocTag(322, tagName, comment);
            return node;
        }
        function updateJSDocUnknownTag(node, tagName, comment) {
            return node.tagName !== tagName
                || node.comment !== comment
                ? update(createJSDocUnknownTag(tagName, comment), node)
                : node;
        }
        function createJSDocText(text) {
            var node = createBaseNode(316);
            node.text = text;
            return node;
        }
        function updateJSDocText(node, text) {
            return node.text !== text
                ? update(createJSDocText(text), node)
                : node;
        }
        function createJSDocComment(comment, tags) {
            var node = createBaseNode(315);
            node.comment = comment;
            node.tags = asNodeArray(tags);
            return node;
        }
        function updateJSDocComment(node, comment, tags) {
            return node.comment !== comment
                || node.tags !== tags
                ? update(createJSDocComment(comment, tags), node)
                : node;
        }
        function createJsxElement(openingElement, children, closingElement) {
            var node = createBaseNode(276);
            node.openingElement = openingElement;
            node.children = createNodeArray(children);
            node.closingElement = closingElement;
            node.transformFlags |=
                propagateChildFlags(node.openingElement) |
                    propagateChildrenFlags(node.children) |
                    propagateChildFlags(node.closingElement) |
                    2;
            return node;
        }
        function updateJsxElement(node, openingElement, children, closingElement) {
            return node.openingElement !== openingElement
                || node.children !== children
                || node.closingElement !== closingElement
                ? update(createJsxElement(openingElement, children, closingElement), node)
                : node;
        }
        function createJsxSelfClosingElement(tagName, typeArguments, attributes) {
            var node = createBaseNode(277);
            node.tagName = tagName;
            node.typeArguments = asNodeArray(typeArguments);
            node.attributes = attributes;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.attributes) |
                    2;
            if (node.typeArguments) {
                node.transformFlags |= 1;
            }
            return node;
        }
        function updateJsxSelfClosingElement(node, tagName, typeArguments, attributes) {
            return node.tagName !== tagName
                || node.typeArguments !== typeArguments
                || node.attributes !== attributes
                ? update(createJsxSelfClosingElement(tagName, typeArguments, attributes), node)
                : node;
        }
        function createJsxOpeningElement(tagName, typeArguments, attributes) {
            var node = createBaseNode(278);
            node.tagName = tagName;
            node.typeArguments = asNodeArray(typeArguments);
            node.attributes = attributes;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.attributes) |
                    2;
            if (typeArguments) {
                node.transformFlags |= 1;
            }
            return node;
        }
        function updateJsxOpeningElement(node, tagName, typeArguments, attributes) {
            return node.tagName !== tagName
                || node.typeArguments !== typeArguments
                || node.attributes !== attributes
                ? update(createJsxOpeningElement(tagName, typeArguments, attributes), node)
                : node;
        }
        function createJsxClosingElement(tagName) {
            var node = createBaseNode(279);
            node.tagName = tagName;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    2;
            return node;
        }
        function updateJsxClosingElement(node, tagName) {
            return node.tagName !== tagName
                ? update(createJsxClosingElement(tagName), node)
                : node;
        }
        function createJsxFragment(openingFragment, children, closingFragment) {
            var node = createBaseNode(280);
            node.openingFragment = openingFragment;
            node.children = createNodeArray(children);
            node.closingFragment = closingFragment;
            node.transformFlags |=
                propagateChildFlags(node.openingFragment) |
                    propagateChildrenFlags(node.children) |
                    propagateChildFlags(node.closingFragment) |
                    2;
            return node;
        }
        function updateJsxFragment(node, openingFragment, children, closingFragment) {
            return node.openingFragment !== openingFragment
                || node.children !== children
                || node.closingFragment !== closingFragment
                ? update(createJsxFragment(openingFragment, children, closingFragment), node)
                : node;
        }
        function createJsxText(text, containsOnlyTriviaWhiteSpaces) {
            var node = createBaseNode(11);
            node.text = text;
            node.containsOnlyTriviaWhiteSpaces = !!containsOnlyTriviaWhiteSpaces;
            node.transformFlags |= 2;
            return node;
        }
        function updateJsxText(node, text, containsOnlyTriviaWhiteSpaces) {
            return node.text !== text
                || node.containsOnlyTriviaWhiteSpaces !== containsOnlyTriviaWhiteSpaces
                ? update(createJsxText(text, containsOnlyTriviaWhiteSpaces), node)
                : node;
        }
        function createJsxOpeningFragment() {
            var node = createBaseNode(281);
            node.transformFlags |= 2;
            return node;
        }
        function createJsxJsxClosingFragment() {
            var node = createBaseNode(282);
            node.transformFlags |= 2;
            return node;
        }
        function createJsxAttribute(name, initializer) {
            var node = createBaseNode(283);
            node.name = name;
            node.initializer = initializer;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer) |
                    2;
            return node;
        }
        function updateJsxAttribute(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? update(createJsxAttribute(name, initializer), node)
                : node;
        }
        function createJsxAttributes(properties) {
            var node = createBaseNode(284);
            node.properties = createNodeArray(properties);
            node.transformFlags |=
                propagateChildrenFlags(node.properties) |
                    2;
            return node;
        }
        function updateJsxAttributes(node, properties) {
            return node.properties !== properties
                ? update(createJsxAttributes(properties), node)
                : node;
        }
        function createJsxSpreadAttribute(expression) {
            var node = createBaseNode(285);
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    2;
            return node;
        }
        function updateJsxSpreadAttribute(node, expression) {
            return node.expression !== expression
                ? update(createJsxSpreadAttribute(expression), node)
                : node;
        }
        function createJsxExpression(dotDotDotToken, expression) {
            var node = createBaseNode(286);
            node.dotDotDotToken = dotDotDotToken;
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.dotDotDotToken) |
                    propagateChildFlags(node.expression) |
                    2;
            return node;
        }
        function updateJsxExpression(node, expression) {
            return node.expression !== expression
                ? update(createJsxExpression(node.dotDotDotToken, expression), node)
                : node;
        }
        function createCaseClause(expression, statements) {
            var node = createBaseNode(287);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.statements = createNodeArray(statements);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.statements);
            return node;
        }
        function updateCaseClause(node, expression, statements) {
            return node.expression !== expression
                || node.statements !== statements
                ? update(createCaseClause(expression, statements), node)
                : node;
        }
        function createDefaultClause(statements) {
            var node = createBaseNode(288);
            node.statements = createNodeArray(statements);
            node.transformFlags = propagateChildrenFlags(node.statements);
            return node;
        }
        function updateDefaultClause(node, statements) {
            return node.statements !== statements
                ? update(createDefaultClause(statements), node)
                : node;
        }
        function createHeritageClause(token, types) {
            var node = createBaseNode(289);
            node.token = token;
            node.types = createNodeArray(types);
            node.transformFlags |= propagateChildrenFlags(node.types);
            switch (token) {
                case 94:
                    node.transformFlags |= 512;
                    break;
                case 117:
                    node.transformFlags |= 1;
                    break;
                default:
                    return ts.Debug.assertNever(token);
            }
            return node;
        }
        function updateHeritageClause(node, types) {
            return node.types !== types
                ? update(createHeritageClause(node.token, types), node)
                : node;
        }
        function createCatchClause(variableDeclaration, block) {
            var node = createBaseNode(290);
            variableDeclaration = !ts.isString(variableDeclaration) ? variableDeclaration : createVariableDeclaration(variableDeclaration, undefined, undefined, undefined);
            node.variableDeclaration = variableDeclaration;
            node.block = block;
            node.transformFlags |=
                propagateChildFlags(node.variableDeclaration) |
                    propagateChildFlags(node.block);
            if (!variableDeclaration)
                node.transformFlags |= 32;
            return node;
        }
        function updateCatchClause(node, variableDeclaration, block) {
            return node.variableDeclaration !== variableDeclaration
                || node.block !== block
                ? update(createCatchClause(variableDeclaration, block), node)
                : node;
        }
        function createPropertyAssignment(name, initializer) {
            var node = createBaseNamedDeclaration(291, undefined, undefined, name);
            node.initializer = parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer);
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer);
            return node;
        }
        function finishUpdatePropertyAssignment(updated, original) {
            if (original.decorators)
                updated.decorators = original.decorators;
            if (original.modifiers)
                updated.modifiers = original.modifiers;
            if (original.questionToken)
                updated.questionToken = original.questionToken;
            if (original.exclamationToken)
                updated.exclamationToken = original.exclamationToken;
            return update(updated, original);
        }
        function updatePropertyAssignment(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? finishUpdatePropertyAssignment(createPropertyAssignment(name, initializer), node)
                : node;
        }
        function createShorthandPropertyAssignment(name, objectAssignmentInitializer) {
            var node = createBaseNamedDeclaration(292, undefined, undefined, name);
            node.objectAssignmentInitializer = objectAssignmentInitializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(objectAssignmentInitializer);
            node.transformFlags |=
                propagateChildFlags(node.objectAssignmentInitializer) |
                    512;
            return node;
        }
        function finishUpdateShorthandPropertyAssignment(updated, original) {
            if (original.decorators)
                updated.decorators = original.decorators;
            if (original.modifiers)
                updated.modifiers = original.modifiers;
            if (original.equalsToken)
                updated.equalsToken = original.equalsToken;
            if (original.questionToken)
                updated.questionToken = original.questionToken;
            if (original.exclamationToken)
                updated.exclamationToken = original.exclamationToken;
            return update(updated, original);
        }
        function updateShorthandPropertyAssignment(node, name, objectAssignmentInitializer) {
            return node.name !== name
                || node.objectAssignmentInitializer !== objectAssignmentInitializer
                ? finishUpdateShorthandPropertyAssignment(createShorthandPropertyAssignment(name, objectAssignmentInitializer), node)
                : node;
        }
        function createSpreadAssignment(expression) {
            var node = createBaseNode(293);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    64 |
                    32768;
            return node;
        }
        function updateSpreadAssignment(node, expression) {
            return node.expression !== expression
                ? update(createSpreadAssignment(expression), node)
                : node;
        }
        function createEnumMember(name, initializer) {
            var node = createBaseNode(294);
            node.name = asName(name);
            node.initializer = initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer);
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer) |
                    1;
            return node;
        }
        function updateEnumMember(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? update(createEnumMember(name, initializer), node)
                : node;
        }
        function createSourceFile(statements, endOfFileToken, flags) {
            var node = baseFactory.createBaseSourceFileNode(300);
            node.statements = createNodeArray(statements);
            node.endOfFileToken = endOfFileToken;
            node.flags |= flags;
            node.fileName = "";
            node.text = "";
            node.languageVersion = 0;
            node.languageVariant = 0;
            node.scriptKind = 0;
            node.isDeclarationFile = false;
            node.hasNoDefaultLib = false;
            node.transformFlags |=
                propagateChildrenFlags(node.statements) |
                    propagateChildFlags(node.endOfFileToken);
            return node;
        }
        function cloneSourceFileWithChanges(source, statements, isDeclarationFile, referencedFiles, typeReferences, hasNoDefaultLib, libReferences) {
            var node = baseFactory.createBaseSourceFileNode(300);
            for (var p in source) {
                if (p === "emitNode" || ts.hasProperty(node, p) || !ts.hasProperty(source, p))
                    continue;
                node[p] = source[p];
            }
            node.flags |= source.flags;
            node.statements = createNodeArray(statements);
            node.endOfFileToken = source.endOfFileToken;
            node.isDeclarationFile = isDeclarationFile;
            node.referencedFiles = referencedFiles;
            node.typeReferenceDirectives = typeReferences;
            node.hasNoDefaultLib = hasNoDefaultLib;
            node.libReferenceDirectives = libReferences;
            node.transformFlags =
                propagateChildrenFlags(node.statements) |
                    propagateChildFlags(node.endOfFileToken);
            return node;
        }
        function updateSourceFile(node, statements, isDeclarationFile, referencedFiles, typeReferenceDirectives, hasNoDefaultLib, libReferenceDirectives) {
            if (isDeclarationFile === void 0) { isDeclarationFile = node.isDeclarationFile; }
            if (referencedFiles === void 0) { referencedFiles = node.referencedFiles; }
            if (typeReferenceDirectives === void 0) { typeReferenceDirectives = node.typeReferenceDirectives; }
            if (hasNoDefaultLib === void 0) { hasNoDefaultLib = node.hasNoDefaultLib; }
            if (libReferenceDirectives === void 0) { libReferenceDirectives = node.libReferenceDirectives; }
            return node.statements !== statements
                || node.isDeclarationFile !== isDeclarationFile
                || node.referencedFiles !== referencedFiles
                || node.typeReferenceDirectives !== typeReferenceDirectives
                || node.hasNoDefaultLib !== hasNoDefaultLib
                || node.libReferenceDirectives !== libReferenceDirectives
                ? update(cloneSourceFileWithChanges(node, statements, isDeclarationFile, referencedFiles, typeReferenceDirectives, hasNoDefaultLib, libReferenceDirectives), node)
                : node;
        }
        function createBundle(sourceFiles, prepends) {
            if (prepends === void 0) { prepends = ts.emptyArray; }
            var node = createBaseNode(301);
            node.prepends = prepends;
            node.sourceFiles = sourceFiles;
            return node;
        }
        function updateBundle(node, sourceFiles, prepends) {
            if (prepends === void 0) { prepends = ts.emptyArray; }
            return node.sourceFiles !== sourceFiles
                || node.prepends !== prepends
                ? update(createBundle(sourceFiles, prepends), node)
                : node;
        }
        function createUnparsedSource(prologues, syntheticReferences, texts) {
            var node = createBaseNode(302);
            node.prologues = prologues;
            node.syntheticReferences = syntheticReferences;
            node.texts = texts;
            node.fileName = "";
            node.text = "";
            node.referencedFiles = ts.emptyArray;
            node.libReferenceDirectives = ts.emptyArray;
            node.getLineAndCharacterOfPosition = function (pos) { return ts.getLineAndCharacterOfPosition(node, pos); };
            return node;
        }
        function createBaseUnparsedNode(kind, data) {
            var node = createBaseNode(kind);
            node.data = data;
            return node;
        }
        function createUnparsedPrologue(data) {
            return createBaseUnparsedNode(295, data);
        }
        function createUnparsedPrepend(data, texts) {
            var node = createBaseUnparsedNode(296, data);
            node.texts = texts;
            return node;
        }
        function createUnparsedTextLike(data, internal) {
            return createBaseUnparsedNode(internal ? 298 : 297, data);
        }
        function createUnparsedSyntheticReference(section) {
            var node = createBaseNode(299);
            node.data = section.data;
            node.section = section;
            return node;
        }
        function createInputFiles() {
            var node = createBaseNode(303);
            node.javascriptText = "";
            node.declarationText = "";
            return node;
        }
        function createSyntheticExpression(type, isSpread, tupleNameSource) {
            if (isSpread === void 0) { isSpread = false; }
            var node = createBaseNode(230);
            node.type = type;
            node.isSpread = isSpread;
            node.tupleNameSource = tupleNameSource;
            return node;
        }
        function createSyntaxList(children) {
            var node = createBaseNode(343);
            node._children = children;
            return node;
        }
        function createNotEmittedStatement(original) {
            var node = createBaseNode(344);
            node.original = original;
            ts.setTextRange(node, original);
            return node;
        }
        function createPartiallyEmittedExpression(expression, original) {
            var node = createBaseNode(345);
            node.expression = expression;
            node.original = original;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1;
            ts.setTextRange(node, original);
            return node;
        }
        function updatePartiallyEmittedExpression(node, expression) {
            return node.expression !== expression
                ? update(createPartiallyEmittedExpression(expression, node.original), node)
                : node;
        }
        function flattenCommaElements(node) {
            if (ts.nodeIsSynthesized(node) && !ts.isParseTreeNode(node) && !node.original && !node.emitNode && !node.id) {
                if (ts.isCommaListExpression(node)) {
                    return node.elements;
                }
                if (ts.isBinaryExpression(node) && ts.isCommaToken(node.operatorToken)) {
                    return [node.left, node.right];
                }
            }
            return node;
        }
        function createCommaListExpression(elements) {
            var node = createBaseNode(346);
            node.elements = createNodeArray(ts.sameFlatMap(elements, flattenCommaElements));
            node.transformFlags |= propagateChildrenFlags(node.elements);
            return node;
        }
        function updateCommaListExpression(node, elements) {
            return node.elements !== elements
                ? update(createCommaListExpression(elements), node)
                : node;
        }
        function createEndOfDeclarationMarker(original) {
            var node = createBaseNode(348);
            node.emitNode = {};
            node.original = original;
            return node;
        }
        function createMergeDeclarationMarker(original) {
            var node = createBaseNode(347);
            node.emitNode = {};
            node.original = original;
            return node;
        }
        function createSyntheticReferenceExpression(expression, thisArg) {
            var node = createBaseNode(349);
            node.expression = expression;
            node.thisArg = thisArg;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.thisArg);
            return node;
        }
        function updateSyntheticReferenceExpression(node, expression, thisArg) {
            return node.expression !== expression
                || node.thisArg !== thisArg
                ? update(createSyntheticReferenceExpression(expression, thisArg), node)
                : node;
        }
        function cloneNode(node) {
            if (node === undefined) {
                return node;
            }
            var clone = ts.isSourceFile(node) ? baseFactory.createBaseSourceFileNode(300) :
                ts.isIdentifier(node) ? baseFactory.createBaseIdentifierNode(79) :
                    ts.isPrivateIdentifier(node) ? baseFactory.createBasePrivateIdentifierNode(80) :
                        !ts.isNodeKind(node.kind) ? baseFactory.createBaseTokenNode(node.kind) :
                            baseFactory.createBaseNode(node.kind);
            clone.flags |= (node.flags & ~8);
            clone.transformFlags = node.transformFlags;
            setOriginalNode(clone, node);
            for (var key in node) {
                if (clone.hasOwnProperty(key) || !node.hasOwnProperty(key)) {
                    continue;
                }
                clone[key] = node[key];
            }
            return clone;
        }
        function createImmediatelyInvokedFunctionExpression(statements, param, paramValue) {
            return createCallExpression(createFunctionExpression(undefined, undefined, undefined, undefined, param ? [param] : [], undefined, createBlock(statements, true)), undefined, paramValue ? [paramValue] : []);
        }
        function createImmediatelyInvokedArrowFunction(statements, param, paramValue) {
            return createCallExpression(createArrowFunction(undefined, undefined, param ? [param] : [], undefined, undefined, createBlock(statements, true)), undefined, paramValue ? [paramValue] : []);
        }
        function createVoidZero() {
            return createVoidExpression(createNumericLiteral("0"));
        }
        function createExportDefault(expression) {
            return createExportAssignment(undefined, undefined, false, 