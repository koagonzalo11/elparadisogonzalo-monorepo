REFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

var glob_1 = glob;
var EE = events$1.EventEmitter;
var setopts$2 = common$2.setopts;
var ownProp$2 = common$2.ownProp;
var childrenIgnored$2 = common$2.childrenIgnored;
var isIgnored$2 = common$2.isIgnored;

function glob(pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {};
  if (!options) options = {};

  if (options.sync) {
    if (cb) throw new TypeError('callback provided to sync glob');
    return sync$1(pattern, options);
  }

  return new Glob(pattern, options, cb);
}

glob.sync = sync$1;
var GlobSync$1 = glob.GlobSync = sync$1.GlobSync; // old api surface

glob.glob = glob;

function extend(origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin;
  }

  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_);
  options.noprocess = true;
  var g = new Glob(pattern, options);
  var set = g.minimatch.set;
  if (!pattern) return false;
  if (set.length > 1) return true;

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string') return true;
  }

  return false;
};

glob.Glob = Glob;
inherits(Glob, EE);

function Glob(pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = null;
  }

  if (options && options.sync) {
    if (cb) throw new TypeError('callback provided to sync glob');
    return new GlobSync$1(pattern, options);
  }

  if (!(this instanceof Glob)) return new Glob(pattern, options, cb);
  setopts$2(this, pattern, options);
  this._didRealPath = false; // process each pattern in the minimatch set

  var n = this.minimatch.set.length; // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.

  this.matches = new Array(n);

  if (typeof cb === 'function') {
    cb = once_1(cb);
    this.on('error', cb);
    this.on('end', function (matches) {
      cb(null, matches);
    });
  }

  var self = this;
  this._processing = 0;
  this._emitQueue = [];
  this._processQueue = [];
  this.paused = false;
  if (this.noprocess) return this;
  if (n === 0) return done();
  var sync = true;

  for (var i = 0; i < n; i++) {
    this._process(this.minimatch.set[i], i, false, done);
  }

  sync = false;

  function done() {
    --self._processing;

    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish();
        });
      } else {
        self._finish();
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert$1(this instanceof Glob);
  if (this.aborted) return;
  if (this.realpath && !this._didRealpath) return this._realpath();
  common$2.finish(this);
  this.emit('end', this.found);
};

Glob.prototype._realpath = function () {
  if (this._didRealpath) return;
  this._didRealpath = true;
  var n = this.matches.length;
  if (n === 0) return this._finish();
  var self = this;

  for (var i = 0; i < this.matches.length; i++) {
    this._realpathSet(i, next);
  }

  function next() {
    if (--n === 0) self._finish();
  }
};

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index];
  if (!matchset) return cb();
  var found = Object.keys(matchset);
  var self = this;
  var n = found.length;
  if (n === 0) return cb();
  var set = this.matches[index] = Object.create(null);
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p);
    fs_realpath.realpath(p, self.realpathCache, function (er, real) {
      if (!er) set[real] = true;else if (er.syscall === 'stat') set[p] = true;else self.emit('error', er); // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set;
        cb();
      }
    });
  });
};

Glob.prototype._mark = function (p) {
  return common$2.mark(this, p);
};

Glob.prototype._makeAbs = function (f) {
  return common$2.makeAbs(this, f);
};

Glob.prototype.abort = function () {
  this.aborted = true;
  this.emit('abort');
};

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true;
    this.emit('pause');
  }
};

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume');
    this.paused = false;

    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0);

      this._emitQueue.length = 0;

      for (var i = 0; i < eq.length; i++) {
        var e = eq[i];

        this._emitMatch(e[0], e[1]);
      }
    }

    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0);

      this._processQueue.length = 0;

      for (var i = 0; i < pq.length; i++) {
        var p = pq[i];
        this._processing--;

        this._process(p[0], p[1], p[2], p[3]);
      }
    }
  }
};

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert$1(this instanceof Glob);
  assert$1(typeof cb === 'function');
  if (this.aborted) return;
  this._processing++;

  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb]);

    return;
  } //console.error('PROCESS %d', this._processing, pattern)
  // Get the first [n] parts of pattern that are all strings.


  var n = 0;

  while (typeof pattern[n] === 'string') {
    n++;
  } // now n is the index of the first one that is *not* a string.
  // see if there's anything else


  var prefix;

  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb);

      return;

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break;

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break;
  }

  var remain = pattern.slice(n); // get the list of entries.

  var read;
  if (prefix === null) read = '.';else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join('/'))) {
    if (!prefix || !pathIsAbsolute(prefix)) prefix = '/' + prefix;
    read = prefix;
  } else read = prefix;

  var abs = this._makeAbs(read); //if ignored, skip _processing


  if (childrenIgnored$2(this, read)) return cb();
  var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;
  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
};

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;

  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
  });
};

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  // if the abs isn't a dir, then nothing can match!
  if (!entries) return cb(); // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.

  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';
  var matchedEntries = [];

  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];

    if (e.charAt(0) !== '.' || dotOk) {
      var m;

      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }

      if (m) matchedEntries.push(e);
    }
  } //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)


  var len = matchedEntries.length; // If there are no matched entries, then nothing matches.

  if (len === 0) return cb(); // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index]) this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];

      if (prefix) {
        if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path$2.join(this.root, e);
      }

      this._emitMatch(index, e);
    } // This was the last one, and no stats were needed


    return cb();
  } // now test all matched entries as stand-ins for that part
  // of the pattern.


  remain.shift();

  for (var i = 0; i < len; i++) {
    var e = matchedEntries[i];

    if (prefix) {
      if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;
    }

    this._process([e].concat(remain), index, inGlobStar, cb);
  }

  cb();
};

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted) return;
  if (isIgnored$2(this, e)) return;

  if (this.paused) {
    this._emitQueue.push([index, e]);

    return;
  }

  var abs = pathIsAbsolute(e) ? e : this._makeAbs(e);
  if (this.mark) e = this._mark(e);
  if (this.absolute) e = abs;
  if (this.matches[index][e]) return;

  if (this.nodir) {
    var c = this.cache[abs];
    if (c === 'DIR' || Array.isArray(c)) return;
  }

  this.matches[index][e] = true;
  var st = this.statCache[abs];
  if (st) this.emit('stat', e, st);
  this.emit('match', e);
};

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted) return; // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation

  if (this.follow) return this._readdir(abs, false, cb);
  var lstatkey = 'lstat\0' + abs;
  var self = this;
  var lstatcb = inflight_1(lstatkey, lstatcb_);
  if (lstatcb) fs$1.lstat(abs, lstatcb);

  function lstatcb_(er, lstat) {
    if (er && er.code === 'ENOENT') return cb();
    var isSym = lstat && lstat.isSymbolicLink();
    self.symlinks[abs] = isSym; // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.

    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE';
      cb();
    } else self._readdir(abs, false, cb);
  }
};

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted) return;
  cb = inflight_1('readdir\0' + abs + '\0' + inGlobStar, cb);
  if (!cb) return; //console.error('RD %j %j', +inGlobStar, abs)

  if (inGlobStar && !ownProp$2(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);

  if (ownProp$2(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE') return cb();
    if (Array.isArray(c)) return cb(null, c);
  }
  fs$1.readdir(abs, readdirCb(this, abs, cb));
};

function readdirCb(self, abs, cb) {
  return function (er, entries) {
    if (er) self._readdirError(abs, er, cb);else self._readdirEntries(abs, entries, cb);
  };
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted) return; // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.

  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (abs === '/') e = abs + e;else e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries;
  return cb(null, entries);
};

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted) return; // handle errors, and cache the information

  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205

    case 'ENOTDIR':
      // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);

      this.cache[abs] = 'FILE';

      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        this.emit('error', error);
        this.abort();
      }

      break;

    case 'ENOENT': // not terribly unusual

    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break;

    default:
      // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;

      if (this.strict) {
        this.emit('error', er); // If the error is handled, then we abort
        // if not, we threw out of here

        this.abort();
      }

      if (!this.silent) console.error('glob error', er);
      break;
  }

  return cb();
};

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;

  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
  });
};

Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)
  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries) return cb(); // test without the globstar, and with every child both below
  // and replacing the globstar.

  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [prefix] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar); // the noGlobStar pattern exits the inGlobStar state

  this._process(noGlobStar, index, false, cb);

  var isSym = this.symlinks[abs];
  var len = entries.length; // If it's a symlink, and we're in a globstar, then stop

  if (isSym && inGlobStar) return cb();

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot) continue; // these two cases enter the inGlobStar state

    var instead = gspref.concat(entries[i], remainWithoutGlobStar);

    this._process(instead, index, true, cb);

    var below = gspref.concat(entries[i], remain);

    this._process(below, index, true, cb);
  }

  cb();
};

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this;

  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb);
  });
};

Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
  //console.error('ps2', prefix, exists)
  if (!this.matches[index]) this.matches[index] = Object.create(null); // If it doesn't exist, then just mark the lack of results

  if (!exists) return cb();

  if (prefix && pathIsAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix);

    if (prefix.charAt(0) === '/') {
      prefix = path$2.join(this.root, prefix);
    } else {
      prefix = path$2.resolve(this.root, prefix);
      if (trail) prefix += '/';
    }
  }

  if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/'); // Mark this as a match

  this._emitMatch(index, prefix);

  cb();
}; // Returns either 'DIR', 'FILE', or false


Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f);

  var needDir = f.slice(-1) === '/';
  if (f.length > this.maxLength) return cb();

  if (!this.stat && ownProp$2(this.cache, abs)) {
    var c = this.cache[abs];
    if (Array.isArray(c)) c = 'DIR'; // It exists, but maybe not how we need it

    if (!needDir || c === 'DIR') return cb(null, c);
    if (needDir && c === 'FILE') return cb(); // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }
  var stat = this.statCache[abs];

  if (stat !== undefined) {
    if (stat === false) return cb(null, stat);else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE';
      if (needDir && type === 'FILE') return cb();else return cb(null, type, stat);
    }
  }

  var self = this;
  var statcb = inflight_1('stat\0' + abs, lstatcb_);
  if (statcb) fs$1.lstat(abs, statcb);

  function lstatcb_(er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs$1.stat(abs, function (er, stat) {
        if (er) self._stat2(f, abs, null, lstat, cb);else self._stat2(f, abs, er, stat, cb);
      });
    } else {
      self._stat2(f, abs, er, lstat, cb);
    }
  }
};

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false;
    return cb();
  }

  var needDir = f.slice(-1) === '/';
  this.statCache[abs] = stat;
  if (abs.slice(-1) === '/' && stat && !stat.isDirectory()) return cb(null, false, stat);
  var c = true;
  if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';
  this.cache[abs] = this.cache[abs] || c;
  if (needDir && c === 'FILE') return cb();
  return cb(null, c, stat);
};

var pify_1 = createCommonjsModule(function (module) {

  var processFn = function processFn(fn, P, opts) {
    return function () {
      var that = this;
      var args = new Array(arguments.length);

      for (var i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      return new P(function (resolve, reject) {
        args.push(function (err, result) {
          if (err) {
            reject(err);
          } else if (opts.multiArgs) {
            var results = new Array(arguments.length - 1);

            for (var i = 1; i < arguments.length; i++) {
              results[i - 1] = arguments[i];
            }

            resolve(results);
          } else {
            resolve(result);
          }
        });
        fn.apply(that, args);
      });
    };
  };

  var pify = module.exports = function (obj, P, opts) {
    if (typeof P !== 'function') {
      opts = P;
      P = Promise;
    }

    opts = opts || {};
    opts.exclude = opts.exclude || [/.+Sync$/];

    var filter = function filter(key) {
      var match = function match(pattern) {
        return typeof pattern === 'string' ? key === pattern : pattern.test(key);
      };

      return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
    };

    var ret = typeof obj === 'function' ? function () {
      if (opts.excludeMain) {
        return obj.apply(this, arguments);
      }

      return processFn(obj, P, opts).apply(this, arguments);
    } : {};
    return Object.keys(obj).reduce(function (ret, key) {
      var x = obj[key];
      ret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;
      return ret;
    }, ret);
  };

  pify.all = pify;
});

var globP = pify_1(glob_1, pinkiePromise).bind(glob_1);

function isNegative(pattern) {
  return pattern[0] === '!';
}

function isString(value) {
  return typeof value === 'string';
}

function assertPatternsInput(patterns) {
  if (!patterns.every(isString)) {
    throw new TypeError('patterns must be a string or an array of strings');
  }
}

function generateGlobTasks(patterns, opts) {
  patterns = [].concat(patterns);
  assertPatternsInput(patterns);
  var globTasks = [];
  opts = objectAssign({
    cache: Object.create(null),
    statCache: Object.create(null),
    realpathCache: Object.create(null),
    symlinks: Object.create(null),
    ignore: []
  }, opts);
  patterns.forEach(function (pattern, i) {
    if (isNegative(pattern)) {
      return;
    }

    var ignore = patterns.slice(i).filter(isNegative).map(function (pattern) {
      return pattern.slice(1);
    });
    globTasks.push({
      pattern: pattern,
      opts: objectAssign({}, opts, {
        ignore: opts.ignore.concat(ignore)
      })
    });
  });
  return globTasks;
}

var globby = function globby(patterns, opts) {
  var globTasks;

  try {
    globTasks = generateGlobTasks(patterns, opts);
  } catch (err) {
    return pinkiePromise.reject(err);
  }

  return pinkiePromise.all(globTasks.map(function (task) {
    return globP(task.pattern, task.opts);
  })).then(function (paths) {
    return arrayUnion.apply(null, paths);
  });
};

var sync$2 = function sync(patterns, opts) {
  var globTasks = generateGlobTasks(patterns, opts);
  return globTasks.reduce(function (matches, task) {
    return arrayUnion(matches, glob_1.sync(task.pattern, task.opts));
  }, []);
};

var generateGlobTasks_1 = generateGlobTasks;

var hasMagic = function hasMagic(patterns, opts) {
  return [].concat(patterns).some(function (pattern) {
    return glob_1.hasMagic(pattern, opts);
  });
};
globby.sync = sync$2;
globby.generateGlobTasks = generateGlobTasks_1;
globby.hasMagic = hasMagic;

var addLeadingComment$2 = utilShared.addLeadingComment,
    addTrailingComment$2 = utilShared.addTrailingComment,
    addDanglingComment$2 = utilShared.addDanglingComment;

function handleOwnLineComment(comment, text, options, ast, isLastComment) {
  var precedingNode = comment.precedingNode,
      enclosingNode = comment.enclosingNode,
      followingNode = comment.followingNode;

  if (handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleMemberExpressionComments(enclosingNode, followingNode, comment) || handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) || handleClassComments(enclosingNode, precedingNode, followingNode, comment) || handleImportSpecifierComments(enclosingNode, comment) || handleForComments(enclosingNode, precedingNode, comment) || handleUnionTypeComments(precedingNode, enclosingNode, followingNode, comment) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleImportDeclarationComments(text, enclosingNode, precedingNode, comment, options) || handleAssignmentPatternComments(enclosingNode, comment) || handleMethodNameComments(text, enclosingNode, precedingNode, comment, options)) {
    return true;
  }

  return false;
}

function handleEndOfLineComment(comment, text, options, ast, isLastComment) {
  var precedingNode = comment.precedingNode,
      enclosingNode = comment.enclosingNode,
      followingNode = comment.followingNode;

  if (handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleConditionalExpressionComments(enclosingNode, precedingNode, followingNode, comment, text, options) || handleImportSpecifierComments(enclosingNode, comment) || handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) || handleClassComments(enclosingNode, precedingNode, followingNode, comment) || handleLabeledStatementComments(enclosingNode, comment) || handleCallExpressionComments(precedingNode, enclosingNode, comment) || handlePropertyComments(enclosingNode, comment) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleTypeAliasComments(enclosingNode, followingNode, comment) || handleVariableDeclaratorComments(enclosingNode, followingNode, comment)) {
    return true;
  }

  return false;
}

function handleRemainingComment(comment, text, options, ast, isLastComment) {
  var precedingNode = comment.precedingNode,
      enclosingNode = comment.enclosingNode,
      followingNode = comment.followingNode;

  if (handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) || handleCommentInEmptyParens(text, enclosingNode, comment, options) || handleMethodNameComments(text, enclosingNode, precedingNode, comment, options) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleCommentAfterArrowParams(text, enclosingNode, comment, options) || handleFunctionNameComments(text, enclosingNode, precedingNode, comment, options) || handleTSMappedTypeComments(text, enclosingNode, precedingNode, followingNode, comment) || handleBreakAndContinueStatementComments(enclosingNode, comment)) {
    return true;
  }

  return false;
}

function addBlockStatementFirstComment(node, comment) {
  var body = node.body.filter(function (n) {
    return n.type !== "EmptyStatement";
  });

  if (body.length === 0) {
    addDanglingComment$2(node, comment);
  } else {
    addLeadingComment$2(body[0], comment);
  }
}

function addBlockOrNotComment(node, comment) {
  if (node.type === "BlockStatement") {
    addBlockStatementFirstComment(node, comment);
  } else {
    addLeadingComment$2(node, comment);
  }
} // There are often comments before the else clause of if statements like
//
//   if (1) { ... }
//   // comment
//   else { ... }
//
// They are being attached as leading comments of the BlockExpression which
// is not well printed. What we want is to instead move the comment inside
// of the block and make it leadingComment of the first element of the block
// or dangling comment of the block if there is nothing inside
//
//   if (1) { ... }
//   else {
//     // comment
//     ...
//   }


function handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) {
  if (!enclosingNode || enclosingNode.type !== "IfStatement" || !followingNode) {
    return false;
  } // We unfortunately have no way using the AST or location of nodes to know
  // if the comment is positioned before the condition parenthesis:
  //   if (a /* comment */) {}
  // The only workaround I found is to look at the next character to see if
  // it is a ).


  var nextCharacter = util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd);

  if (nextCharacter === ")") {
    addTrailingComment$2(precedingNode, comment);
    return true;
  } // Comments before `else`:
  // - treat as trailing comments of the consequent, if it's a BlockStatement
  // - treat as a dangling comment otherwise


  if (precedingNode === enclosingNode.consequent && followingNode === enclosingNode.alternate) {
    if (precedingNode.type === "BlockStatement") {
      addTrailingComment$2(precedingNode, comment);
    } else {
      addDanglingComment$2(enclosingNode, comment);
    }

    return true;
  }

  if (followingNode.type === "BlockStatement") {
    addBlockStatementFirstComment(followingNode, comment);
    return true;
  }

  if (followingNode.type === "IfStatement") {
    addBlockOrNotComment(followingNode.consequent, comment);
    return true;
  } // For comments positioned after the condition parenthesis in an if statement
  // before the consequent without brackets on, such as
  // if (a) /* comment */ true,
  // we look at the next character to see if the following node
  // is the consequent for the if statement


  if (enclosingNode.consequent === followingNode) {
    addLeadingComment$2(followingNode, comment);
    return true;
  }

  return false;
}

function handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) {
  if (!enclosingNode || enclosingNode.type !== "WhileStatement" || !followingNode) {
    return false;
  } // We unfortunately have no way using the AST or location of nodes to know
  // if the comment is positioned before the condition parenthesis:
  //   while (a /* comment */) {}
  // The only workaround I found is to look at the next character to see if
  // it is a ).


  var nextCharacter = util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd);

  if (nextCharacter === ")") {
    addTrailingComment$2(precedingNode, comment);
    return true;
  }

  if (followingNode.type === "BlockStatement") {
    addBlockStatementFirstComment(followingNode, comment);
    return true;
  }

  return false;
} // Same as IfStatement but for TryStatement


function handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) {
  if (!enclosingNode || enclosingNode.type !== "TryStatement" && enclosingNode.type !== "CatchClause" || !followingNode) {
    return false;
  }

  if (enclosingNode.type === "CatchClause" && precedingNode) {
    addTrailingComment$2(precedingNode, comment);
    return true;
  }

  if (followingNode.type === "BlockStatement") {
    addBlockStatementFirstComment(followingNode, comment);
    return true;
  }

  if (followingNode.type === "TryStatement") {
    addBlockOrNotComment(followingNode.finalizer, comment);
    return true;
  }

  if (followingNode.type === "CatchClause") {
    addBlockOrNotComment(followingNode.body, comment);
    return true;
  }

  return false;
}

function handleMemberExpressionComments(enclosingNode, followingNode, comment) {
  if (enclosingNode && (enclosingNode.type === "MemberExpression" || enclosingNode.type === "OptionalMemberExpression") && followingNode && followingNode.type === "Identifier") {
    addLeadingComment$2(enclosingNode, comment);
    return true;
  }

  return false;
}

function handleConditionalExpressionComments(enclosingNode, precedingNode, followingNode, comment, text, options) {
  var isSameLineAsPrecedingNode = precedingNode && !util.hasNewlineInRange(text, options.locEnd(precedingNode), options.locStart(comment));

  if ((!precedingNode || !isSameLineAsPrecedingNode) && enclosingNode && enclosingNode.type === "ConditionalExpression" && followingNode) {
    addLeadingComment$2(followingNode, comment);
    return true;
  }

  return false;
}

function handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) {
  if (enclosingNode && (enclosingNode.type === "ObjectProperty" || enclosingNode.type === "Property") && enclosingNode.shorthand && enclosingNode.key === precedingNode && enclosingNode.value.type === "AssignmentPattern") {
    addTrailingComment$2(enclosingNode.value.left, comment);
    return true;
  }

  return false;
}

function handleClassComments(enclosingNode, precedingNode, followingNode, comment) {
  if (enclosingNode && (enclosingNode.type === "ClassDeclaration" || enclosingNode.type === "ClassExpression") && enclosingNode.decorators && enclosingNode.decorators.length > 0 && !(followingNode && followingNode.type === "Decorator")) {
    if (!enclosingNode.decorators || enclosingNode.decorators.length === 0) {
      addLeadingComment$2(enclosingNode, comment);
    } else {
      addTrailingComment$2(enclosingNode.decorators[enclosingNode.decorators.length - 1], comment);
    }

    return true;
  }

  return false;
}

function handleMethodNameComments(text, enclosingNode, precedingNode, comment, options) {
  // This is only needed for estree parsers (flow, typescript) to attach
  // after a method name:
  // obj = { fn /*comment*/() {} };
  if (enclosingNode && precedingNode && (enclosingNode.type === "Property" || enclosingNode.type === "MethodDefinition") && precedingNode.type === "Identifier" && enclosingNode.key === precedingNode && // special Property case: { key: /*comment*/(value) };
  // comment should be attached to value instead of key
  util.getNextNonSpaceNonCommentCharacter(text, precedingNode, options.locEnd) !== ":") {
    addTrailingComment$2(precedingNode, comment);
    return true;
  } // Print comments between decorators and class methods as a trailing comment
  // on the decorator node instead of the method node


  if (precedingNode && enclosingNode && precedingNode.type === "Decorator" && (enclosingNode.type === "ClassMethod" || enclosingNode.type === "ClassProperty" || enclosingNode.type === "TSAbstractClassProperty" || enclosingNode.type === "TSAbstractMethodDefinition" || enclosingNode.type === "MethodDefinition")) {
    addTrailingComment$2(precedingNode, comment);
    return true;
  }

  return false;
}

function handleFunctionNameComments(text, enclosingNode, precedingNode, comment, options) {
  if (util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) !== "(") {
    return false;
  }

  if (precedingNode && enclosingNode && (enclosingNode.type === "FunctionDeclaration" || enclosingNode.type === "FunctionExpression" || enclosingNode.type === "ClassMethod" || enclosingNode.type === "MethodDefinition" || enclosingNode.type === "ObjectMethod")) {
    addTrailingComment$2(precedingNode, comment);
    return true;
  }

  return false;
}

function handleCommentAfterArrowParams(text, enclosingNode, comment, options) {
  if (!(enclosingNode && enclosingNode.type === "ArrowFunctionExpression")) {
    return false;
  }

  var index = utilShared.getNextNonSpaceNonCommentCharacterIndex(text, comment, options);

  if (text.substr(index, 2) === "=>") {
    addDanglingComment$2(enclosingNode, comment);
    return true;
  }

  return false;
}

function handleCommentInEmptyParens(text, enclosingNode, comment, options) {
  if (util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) !== ")") {
    return false;
  } // Only add dangling comments to fix the case when no params are present,
  // i.e. a function without any argument.


  if (enclosingNode && ((enclosingNode.type === "FunctionDeclaration" || enclosingNode.type === "FunctionExpression" || enclosingNode.type === "ArrowFunctionExpression" || enclosingNode.type === "ClassMethod" || enclosingNode.type === "ObjectMethod") && enclosingNode.params.length === 0 || (enclosingNode.type === "CallExpression" || enclosingNode.type === "OptionalCallExpression" || enclosingNode.type === "NewExpression") && enclosingNode.arguments.length === 0)) {
    addDanglingComment$2(enclosingNode, comment);
    return true;
  }

  if (enclosingNode && enclosingNode.type === "MethodDefinition" && enclosingNode.value.params.length === 0) {
    addDanglingComment$2(enclosingNode.value, comment);
    return true;
  }

  return false;
}

function handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) {
  // Type definitions functions
  if (precedingNode && precedingNode.type === "FunctionTypeParam" && enclosingNode && enclosingNode.type === "FunctionTypeAnnotation" && followingNode && followingNode.type !== "FunctionTypeParam") {
    addTrailingComment$2(precedingNode, comment);
    return true;
  } // Real functions


  if (precedingNode && (precedingNode.type === "Identifier" || precedingNode.type === "AssignmentPattern") && enclosingNode && (enclosingNode.type === "ArrowFunctionExpression" || enclosingNode.type === "FunctionExpression" || enclosingNode.type === "FunctionDeclaration" || enclosingNode.type === "ObjectMethod" || enclosingNode.type === "ClassMethod") && util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) === ")") {
    addTrailingComment$2(precedingNode, comment);
    return true;
  }

  if (enclosingNode && enclosingNode.type === "FunctionDeclaration" && followingNode && followingNode.type === "BlockStatement") {
    var functionParamRightParenIndex = function () {
      if (enclosingNode.params.length !== 0) {
        return util.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, options.locEnd(util.getLast(enclosingNode.params)));
      }

      var functionParamLeftParenIndex = util.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, options.locEnd(enclosingNode.id));
      return util.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, functionParamLeftParenIndex + 1);
    }();

    if (options.locStart(comment) > functionParamRightParenIndex) {
      addBlockStatementFirstComment(followingNode, comment);
      return true;
    }
  }

  return false;
}

function handleImportSpecifierComments(enclosingNode, comment) {
  if (enclosingNode && enclosingNode.type === "ImportSpecifier") {
    addLeadingComment$2(enclosingNode, comment);
    return true;
  }

  return false;
}

function handleLabeledStatementComments(enclosingNode, comment) {
  if (enclosingNode && enclosingNode.type === "LabeledStatement") {
    addLeadingComment$2(enclosingNode, comment);
    return true;
  }

  return false;
}

function handleBreakAndContinueStatementComments(enclosingNode, comment) {
  if (enclosingNode && (enclosingNode.type === "ContinueStatement" || enclosingNode.type === "BreakStatement") && !enclosingNode.label) {
    addTrailingComment$2(enclosingNode, comment);
    return true;
  }

  return false;
}

function handleCallExpressionComments(precedingNode, enclosingNode, comment) {
  if (enclosingNode && (enclosingNode.type === "CallExpression" || enclosingNode.type === "OptionalCallExpression") && precedingNode && enclosingNode.callee === precedingNode && enclosingNode.arguments.length > 0) {
    addLeadingComment$2(enclosingNode.arguments[0], comment);
    return true;
  }

  return false;
}

function handleUnionTypeComments(precedingNode, enclosingNode, followingNode, comment) {
  if (enclosingNode && (enclosingNode.type === "UnionTypeAnnotation" || enclosingNode.type === "TSUnionType")) {
    addTrailingComment$2(precedingNode, comment);
    return true;
  }

  return false;
}

function handlePropertyComments(enclosingNode, comment) {
  if (enclosingNode && (enclosingNode.type === "Property" || enclosingNode.type === "ObjectProperty")) {
    addLeadingComment$2(enclosingNode, comment);
    return true;
  }

  return false;
}

function handleOnlyComments(enclosingNode, ast, comment, isLastComment) {
  // With Flow the enclosingNode is undefined so use the AST instead.
  if (ast && ast.body && ast.body.length === 0) {
    if (isLastComment) {
      addDanglingComment$2(ast, comment);
    } else {
      addLeadingComment$2(ast, comment);
    }

    return true;
  } else if (enclosingNode && enclosingNode.type === "Program" && enclosingNode.body.length === 0 && enclosingNode.directives && enclosingNode.directives.length === 0) {
    if (isLastComment) {
      addDanglingComment$2(enclosingNode, comment);
    } else {
      addLeadingComment$2(enclosingNode, comment);
    }

    return true;
  }

  return false;
}

function handleForComments(enclosingNode, precedingNode, comment) {
  if (enclosingNode && (enclosingNode.type === "ForInStatement" || enclosingNode.type === "ForOfStatement")) {
    addLeadingComment$2(enclosingNode, comment);
    return true;
  }

  return false;
}

function handleImportDeclarationComments(text, enclosingNode, precedingNode, comment, options) {
  if (precedingNode && precedingNode.type === "ImportSpecifier" && enclosingNode && enclosingNode.type === "ImportDeclaration" && util.hasNewline(text, options.locEnd(comment))) {
    addTrailingComment$2(precedingNode, comment);
    return true;
  }

  return false;
}

function handleAssignmentPatternComments(enclosingNode, comment) {
  if (enclosingNode && enclosingNode.type === "AssignmentPattern") {
    addLeadingComment$2(enclosingNode, comment);
    return true;
  }

  return false;
}

function handleTypeAliasComments(enclosingNode, followingNode, comment) {
  if (enclosingNode && enclosingNode.type === "TypeAlias") {
    addLeadingComment$2(enclosingNode, comment);
    return true;
  }

  return false;
}

function handleVariableDeclaratorComments(enclosingNode, followingNode, comment) {
  if (enclosingNode && (enclosingNode.type === "VariableDeclarator" || enclosingNode.type === "AssignmentExpression") && followingNode && (followingNode.type === "ObjectExpression" || followingNode.type === "ArrayExpression" || followingNode.type === "TemplateLiteral" || followingNode.type === "TaggedTemplateExpression")) {
    addLeadingComment$2(followingNode, comment);
    return true;
  }

  return false;
}

function handleTSMappedTypeComments(text, enclosingNode, precedingNode, followingNode, comment) {
  if (!enclosingNode || enclosingNode.type !== "TSMappedType") {
    return false;
  }

  if (followingNode && followingNode.type === "TSTypeParameter" && followingNode.name) {
    addLeadingComment$2(followingNode.name, comment);
    return true;
  }

  if (precedingNode && precedingNode.type === "TSTypeParameter" && precedingNode.constraint) {
    addTrailingComment$2(precedingNode.constraint, comment);
    return true;
  }

  return false;
}

function isBlockComment(comment) {
  return comment.type === "Block" || comment.type === "CommentBlock";
}

function hasLeadingComment(node) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
    return true;
  };

  if (node.leadingComments) {
    return node.leadingComments.some(fn);
  }

  if (node.comments) {
    return node.comments.some(function (comment) {
      return comment.leading && fn(comment);
    });
  }

  return false;
}

var comments$1 = {
  handleOwnLineComment,
  handleEndOfLineComment,
  handleRemainingComment,
  hasLeadingComment,
  isBlockComment
};

var isBlockComment$1 = comments$1.isBlockComment,
    hasLeadingComment$1 = comments$1.hasLeadingComment;
var _require$$1$builders = doc.builders,
    indent$2 = _require$$1$builders.indent,
    join$2 = _require$$1$builders.join,
    hardline$3 = _require$$1$builders.hardline,
    softline$1 = _require$$1$builders.softline,
    literalline$1 = _require$$1$builders.literalline,
    concat$4 = _require$$1$builders.concat,
    group$1 = _require$$1$builders.group,
    dedentToRoot$1 = _require$$1$builders.dedentToRoot,
    _require$$1$utils = doc.utils,
    mapDoc$3 = _require$$1$utils.mapDoc,
    stripTrailingHardline$1 = _require$$1$utils.stripTrailingHardline;

function embed(path, print, textToDoc, options) {
  var node = path.getValue();
  var parent = path.getParentNode();
  var parentParent = path.getParentNode(1);

  switch (node.type) {
    case "TemplateLiteral":
      {
        var isCss = [isStyledJsx, isStyledComponents, isCssProp, isAngularComponentStyles].some(function (isIt) {
          return isIt(path);
        });

        if (isCss) {
          // Get full template literal with expressions replaced by placeholders
          var rawQuasis = node.quasis.map(function (q) {
            return q.value.raw;
          });
          var placeholderID = 0;
          var text = rawQuasis.reduce(function (prevVal, currVal, idx) {
            return idx == 0 ? currVal : prevVal + "@prettier-placeholder-" + placeholderID++ + "-id" + currVal;
          }, "");
          var doc = textToDoc(text, {
            parser: "css"
          });
          return transformCssDoc(doc, path, print);
        }
        /*
         * react-relay and graphql-tag
         * graphql`...`
         * graphql.experimental`...`
         * gql`...`
         *
         * This intentionally excludes Relay Classic tags, as Prettier does not
         * support Relay Classic formatting.
         */


        if (isGraphQL(path)) {
          var expressionDocs = node.expressions ? path.map(print, "expressions") : [];
          var numQuasis = node.quasis.length;

          if (numQuasis === 1 && node.quasis[0].value.raw.trim() === "") {
            return "``";
          }

          var parts = [];

          for (var i = 0; i < numQuasis; i++) {
            var templateElement = node.quasis[i];
            var isFirst = i === 0;
            var isLast = i === numQuasis - 1;
            var _text = templateElement.value.cooked; // Bail out if any of the quasis have an invalid escape sequence
            // (which would make the `cooked` value be `null` or `undefined`)

            if (typeof _text !== "string") {
              return null;
            }

            var lines = _text.split("\n");

            var numLines = lines.length;
            var expressionDoc = expressionDocs[i];
            var startsWithBlankLine = numLines > 2 && lines[0].trim() === "" && lines[1].trim() === "";
            var endsWithBlankLine = numLines > 2 && lines[numLines - 1].trim() === "" && lines[numLines - 2].trim() === "";
            var commentsAndWhitespaceOnly = lines.every(function (line) {
              return /^\s*(?:#[^\r\n]*)?$/.test(line);
            }); // Bail out if an interpolation occurs within a comment.

            if (!isLast && /#[^\r\n]*$/.test(lines[numLines - 1])) {
              return null;
            }

            var _doc = null;

            if (commentsAndWhitespaceOnly) {
              _doc = printGraphqlComments(lines);
            } else {
              _doc = stripTrailingHardline$1(textToDoc(_text, {
                parser: "graphql"
              }));
            }

            if (_doc) {
              _doc = escapeTemplateCharacters(_doc, false);

              if (!isFirst && startsWithBlankLine) {
                parts.push("");
              }

              parts.push(_doc);

              if (!isLast && endsWithBlankLine) {
                parts.push("");
              }
            } else if (!isFirst && !isLast && startsWithBlankLine) {
              parts.push("");
            }

            if (expressionDoc) {
              parts.push(concat$4(["${", expressionDoc, "}"]));
            }
          }

          return concat$4(["`", indent$2(concat$4([hardline$3, join$2(hardline$3, parts)])), hardline$3, "`"]);
        }

        var htmlParser = isHtml(path) ? "html" : isAngularComponentTemplate(path) ? "angular" : undefined;

        if (htmlParser) {
          return printHtmlTemplateLiteral(path, print, textToDoc, htmlParser, options.embeddedInHtml);
        }

        break;
      }

    case "TemplateElement":
      {
        /**
         * md`...`
         * markdown`...`
         */
        if (parentParent && parentParent.type === "TaggedTemplateExpression" && parent.quasis.length === 1 && parentParent.tag.type === "Identifier" && (parentParent.tag.name === "md" || parentParent.tag.name === "markdown")) {
          var _text2 = parent.quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, function (_, backslashes) {
            return "\\".repeat(backslashes.length / 2) + "`";
          });

          var indentation = getIndentation(_text2);
          var hasIndent = indentation !== "";
          return concat$4([hasIndent ? indent$2(concat$4([softline$1, printMarkdown(_text2.replace(new RegExp(`^${indentation}`, "gm"), ""))])) : concat$4([literalline$1, dedentToRoot$1(printMarkdown(_text2))]), softline$1]);
        }

        break;
      }
  }

  function printMarkdown(text) {
    var doc = textToDoc(text, {
      parser: "markdown",
      __inJsTemplate: true
    });
    return stripTrailingHardline$1(escapeTemplateCharacters(doc, true));
  }
}

function getIndentation(str) {
  var firstMatchedIndent = str.match(/^([^\S\n]*)\S/m);
  return firstMatchedIndent === null ? "" : firstMatchedIndent[1];
}

function uncook(cookedValue) {
  return cookedValue.replace(/([\\`]|\$\{)/g, "\\$1");
}

function escapeTemplateCharacters(doc, raw) {
  return mapDoc$3(doc, function (currentDoc) {
    if (!currentDoc.parts) {
      return currentDoc;
    }

    var parts = [];
    currentDoc.parts.forEach(function (part) {
      if (typeof part === "string") {
        parts.push(raw ? part.replace(/(\\*)`/g, "$1$1\\`") : uncook(part));
      } else {
        parts.push(part);
      }
    });
    return Object.assign({}, currentDoc, {
      parts
    });
  });
}

function transformCssDoc(quasisDoc, path, print) {
  var parentNode = path.getValue();
  var isEmpty = parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();

  if (isEmpty) {
    return "``";
  }

  var expressionDocs = parentNode.expressions ? path.map(print, "expressions") : [];
  var newDoc = replacePlaceholders(quasisDoc, expressionDocs);
  /* istanbul ignore if */

  if (!newDoc) {
    throw new Error("Couldn't insert all the expressions");
  }

  return concat$4(["`", indent$2(concat$4([hardline$3, stripTrailingHardline$1(newDoc)])), softline$1, "`"]);
} // Search all the placeholders in the quasisDoc tree
// and replace them with the expression docs one by one
// returns a new doc with all the placeholders replaced,
// or null if it couldn't replace any expression


function replacePlaceholders(quasisDoc, expressionDocs) {
  if (!expressionDocs || !expressionDocs.length) {
    return quasisDoc;
  }

  var expressions = expressionDocs.slice();
  var replaceCounter = 0;
  var newDoc = mapDoc$3(quasisDoc, function (doc) {
    if (!doc || !doc.parts || !doc.parts.length) {
      return doc;
    }

    var parts = doc.parts;
    var atIndex = parts.indexOf("@");
    var placeholderIndex = atIndex + 1;

    if (atIndex > -1 && typeof parts[placeholderIndex] === "string" && parts[placeholderIndex].startsWith("prettier-placeholder")) {
      // If placeholder is split, join it
      var at = parts[atIndex];
      var placeholder = parts[placeholderIndex];
      var rest = parts.slice(placeholderIndex + 1);
      parts = parts.slice(0, atIndex).concat([at + placeholder]).concat(rest);
    }

    var atPlaceholderIndex = parts.findIndex(function (part) {
      return typeof part === "string" && part.startsWith("@prettier-placeholder");
    });

    if (atPlaceholderIndex > -1) {
      var _placeholder = parts[atPlaceholderIndex];

      var _rest = parts.slice(atPlaceholderIndex + 1);

      var placeholderMatch = _placeholder.match(/@prettier-placeholder-(.+)-id([\s\S]*)/);

      var placeholderID = placeholderMatch[1]; // When the expression has a suffix appended, like:
      // animation: linear ${time}s ease-out;

      var suffix = placeholderMatch[2];
      var expression = expressions[placeholderID];
      replaceCounter++;
      parts = parts.slice(0, atPlaceholderIndex).concat(["${", expression, "}" + suffix]).concat(_rest);
    }

    return Object.assign({}, doc, {
      parts: parts
    });
  });
  return expressions.length === replaceCounter ? newDoc : null;
}

function printGraphqlComments(lines) {
  var parts = [];
  var seenComment = false;
  lines.map(function (textLine) {
    return textLine.trim();
  }).forEach(function (textLine, i, array) {
    // Lines are either whitespace only, or a comment (with potential whitespace
    // around it). Drop whitespace-only lines.
    if (textLine === "") {
      return;
    }

    if (array[i - 1] === "" && seenComment) {
      // If a non-first comment is preceded by a blank (whitespace only) line,
      // add in a blank line.
      parts.push(concat$4([hardline$3, textLine]));
    } else {
      parts.push(textLine);
    }

    seenComment = true;
  }); // If `lines` was whitespace only, return `null`.

  return parts.length === 0 ? null : join$2(hardline$3, parts);
}
/**
 * Template literal in these contexts:
 * <style jsx>{`div{color:red}`}</style>
 * css``
 * css.global``
 * css.resolve``
 */


function isStyledJsx(path) {
  var node = path.getValue();
  var parent = path.getParentNode();
  var parentParent = path.getParentNode(1);
  return parentParent && node.quasis && parent.type === "JSXExpressionContainer" && parentParent.type === "JSXElement" && parentParent.openingElement.name.name === "style" && parentParent.openingElement.attributes.some(function (attribute) {
    return attribute.name.name === "jsx";
  }) || parent && parent.type === "TaggedTemplateExpression" && parent.tag.type === "Identifier" && parent.tag.name === "css" || parent && parent.type === "TaggedTemplateExpression" && parent.tag.type === "MemberExpression" && parent.tag.object.name === "css" && (parent.tag.property.name === "global" || parent.tag.property.name === "resolve");
}
/**
 * Angular Components can have:
 * - Inline HTML template
 * - Inline CSS styles
 *
 * ...which are both within template literals somewhere
 * inside of the Component decorator factory.
 *
 * E.g.
 * @Component({
 *  template: `<div>...</div>`,
 *  styles: [`h1 { color: blue; }`]
 * })
 */


function isAngularComponentStyles(path) {
  return isPathMatch(path, [function (node) {
    return node.type === "TemplateLiteral";
  }, function (node, name) {
    return node.type === "ArrayExpression" && name === "elements";
  }, function (node, name) {
    return node.type === "Property" && node.key.type === "Identifier" && node.key.name === "styles" && name === "value";
  }].concat(getAngularComponentObjectExpressionPredicates()));
}

function isAngularComponentTemplate(path) {
  return isPathMatch(path, [function (node) {
    return node.type === "TemplateLiteral";
  }, function (node, name) {
    return node.type === "Property" && node.key.type === "Identifier" && node.key.name === "template" && name === "value";
  }].concat(getAngularComponentObjectExpressionPredicates()));
}

function getAngularComponentObjectExpressionPredicates() {
  return [function (node, name) {
    return node.type === "ObjectExpression" && name === "properties";
  }, function (node, name) {
    return node.type === "CallExpression" && node.callee.type === "Identifier" && node.callee.name === "Component" && name === "arguments";
  }, function (node, name) {
    return node.type === "Decorator" && name === "expression";
  }];
}
/**
 * styled-components template literals
 */


function isStyledComponents(path) {
  var parent = path.getParentNode();

  if (!parent || parent.type !== "TaggedTemplateExpression") {
    return false;
  }

  var tag = parent.tag;

  switch (tag.type) {
    case "MemberExpression":
      return (// styled.foo``
        isStyledIdentifier(tag.object) || // Component.extend``
        isStyledExtend(tag)
      );

    case "CallExpression":
      return (// styled(Component)``
        isStyledIdentifier(tag.callee) || tag.callee.type === "MemberExpression" && (tag.callee.object.type === "MemberExpression" && ( // styled.foo.attrs({})``
        isStyledIdentifier(tag.callee.object.object) || // Component.extend.attrs({})``
        isStyledExtend(tag.callee.object)) || // styled(Component).attrs({})``
        tag.callee.object.type === "CallExpression" && isStyledIdentifier(tag.callee.object.callee))
      );

    case "Identifier":
      // css``
      return tag.name === "css";

    default:
      return false;
  }
}
/**
 * JSX element with CSS prop
 */


function isCssProp(path) {
  var parent = path.getParentNode();
  var parentParent = path.getParentNode(1);
  return parentParent && parent.type === "JSXExpressionContainer" && parentParent.type === "JSXAttribute" && parentParent.name.type === "JSXIdentifier" && parentParent.name.name === "css";
}

function isStyledIdentifier(node) {
  return node.type === "Identifier" && node.name === "styled";
}

function isStyledExtend(node) {
  return /^[A-Z]/.test(node.object.name) && node.property.name === "extend";
}
/*
 * react-relay and graphql-tag
 * graphql`...`
 * graphql.experimental`...`
 * gql`...`
 * GraphQL comment block
 *
 * This intentionally excludes Relay Classic tags, as Prettier does not
 * support Relay Classic formatting.
 */


function isGraphQL(path) {
  var node = path.getValue();
  var parent = path.getParentNode();
  return hasLanguageComment(node, "GraphQL") || parent && (parent.type === "TaggedTemplateExpression" && (parent.tag.type === "MemberExpression" && parent.tag.object.name === "graphql" && parent.tag.property.name === "experimental" || parent.tag.type === "Identifier" && (parent.tag.name === "gql" || parent.tag.name === "graphql")) || parent.type === "CallExpression" && parent.callee.type === "Identifier" && parent.callee.name === "graphql");
}

function hasLanguageComment(node, languageName) {
  // This checks for a leading comment that is exactly `/* GraphQL */`
  // In order to be in line with other implementations of this comment tag
  // we will not trim the comment value and we will expect exactly one space on
  // either side of the GraphQL string
  // Also see ./clean.js
  return hasLeadingComment$1(node, function (comment) {
    return isBlockComment$1(comment) && comment.value === ` ${languageName} `;
  });
}

function isPathMatch(path, predicateStack) {
  var stack = path.stack.slice();
  var name = null;
  var node = stack.pop();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = predicateStack[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var predicate = _step.value;

      if (node === undefined) {
        return false;
      } // skip index/array


      if (typeof name === "number") {
        name = stack.pop();
        node = stack.pop();
      }

      if (!predicate(node, name)) {
        return false;
      }

      name = stack.pop();
      node = stack.pop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return true;
}
/**
 *     - html`...`
 *     - HTML comment block
 */


function isHtml(path) {
  var node = path.getValue();
  return hasLanguageComment(node, "HTML") || isPathMatch(path, [function (node) {
    return node.type === "TemplateLiteral";
  }, function (node, name) {
    return node.type === "TaggedTemplateExpression" && node.tag.type === "Identifier" && node.tag.name === "html" && name === "quasi";
  }]);
} // The counter is needed to distinguish nested embeds.


var htmlTemplateLiteralCounter = 0;

function printHtmlTemplateLiteral(path, print, textToDoc, parser, escapeClosingScriptTag) {
  var node = path.getValue();
  var counter = htmlTemplateLiteralCounter;
  htmlTemplateLiteralCounter = htmlTemplateLiteralCounter + 1 >>> 0;

  var composePlaceholder = function composePlaceholder(index) {
    return `PRETTIER_HTML_PLACEHOLDER_${index}_${counter}_IN_JS`;
  };

  var text = node.quasis.map(function (quasi, index, quasis) {
    return index === quasis.length - 1 ? quasi.value.cooked : quasi.value.cooked + composePlaceholder(index);
  }).join("");
  var expressionDocs = path.map(print, "expressions");

  if (expressionDocs.length === 0 && text.trim().length === 0) {
    return "``";
  }

  var placeholderRegex = RegExp(composePlaceholder("(\\d+)"), "g");
  var contentDoc = mapDoc$3(stripTrailingHardline$1(textToDoc(text, {
    parser
  })), function (doc) {
    if (typeof doc !== "string") {
      return doc;
    }

    var parts = [];
    var components = doc.split(placeholderRegex);

    for (var i = 0; i < components.length; i++) {
      var component = components[i];

      if (i % 2 === 0) {
        if (component) {
          component = uncook(component);

          if (escapeClosingScriptTag) {
            component = component.replace(/<\/(script)\b/gi, "<\\/$1");
          }

          parts.push(component);
        }

        continue;
      }

      var placeholderIndex = +component;
      parts.push(concat$4(["${", group$1(expressionDocs[placeholderIndex]), "}"]));
    }

    return concat$4(parts);
  });
  return group$1(concat$4(["`", indent$2(concat$4([hardline$3, group$1(contentDoc)])), softline$1, "`"]));
}

var embed_1 = embed;

function clean(ast, newObj, parent) {
  ["range", "raw", "comments", "leadingComments", "trailingComments", "extra", "start", "end", "flags", "errors"].forEach(function (name) {
    delete newObj[name];
  });

  if (ast.type === "BigIntLiteral") {
    newObj.value = newObj.value.toLowerCase();
  } // We remove extra `;` and add them when needed


  if (ast.type === "EmptyStatement") {
    return null;
  } // We move text around, including whitespaces and add {" "}


  if (ast.type === "JSXText") {
    return null;
  }

  if (ast.type === "JSXExpressionContainer" && ast.expression.type === "Literal" && ast.expression.value === " ") {
    return null;
  } // We remove unneeded parens around same-operator LogicalExpressions


  if (isUnbalancedLogicalTree(newObj)) {
    return rebalanceLogicalTree(newObj);
  } // (TypeScript) Ignore `static` in `constructor(static p) {}`
  // and `export` in `constructor(export p) {}`


  if (ast.type === "TSParameterProperty" && ast.accessibility === null && !ast.readonly) {
    return {
      type: "Identifier",
      name: ast.parameter.name,
      typeAnnotation: newObj.parameter.typeAnnotation,
      decorators: newObj.decorators
    };
  } // (TypeScript) ignore empty `specifiers` array


  if (ast.type === "TSNamespaceExportDeclaration" && ast.specifiers && ast.specifiers.length === 0) {
    delete newObj.specifiers;
  } // We convert <div></div> to <div />


  if (ast.type === "JSXOpeningElement") {
    delete newObj.selfClosing;
  }

  if (ast.type === "JSXElement") {
    delete newObj.closingElement;
  } // We change {'key': value} into {key: value}


  if ((ast.type === "Property" || ast.type === "ObjectProperty" || ast.type === "MethodDefinition" || ast.type === "ClassProperty" || ast.type === "TSPropertySignature" || ast.type === "ObjectTypeProperty") && typeof ast.key === "object" && ast.key && (ast.key.type === "Literal" || ast.key.type === "StringLiteral" || ast.key.type === "Identifier")) {
    delete newObj.key;
  }

  if (ast.type === "OptionalMemberExpression" && ast.optional === false) {
    newObj.type = "MemberExpression";
    delete newObj.optional;
  } // Remove raw and cooked values from TemplateElement when it's CSS
  // styled-jsx


  if (ast.type === "JSXElement" && ast.openingElement.name.name === "style" && ast.openingElement.attributes.some(function (attr) {
    return attr.name.name === "jsx";
  })) {
    var templateLiterals = newObj.children.filter(function (child) {
      return child.type === "JSXExpressionContainer" && child.expression.type === "TemplateLiteral";
    }).map(function (container) {
      return container.expression;
    });
    var quasis = templateLiterals.reduce(function (quasis, templateLiteral) {
      return quasis.concat(templateLiteral.quasis);
    }, []);
    quasis.forEach(function (q) {
      return delete q.value;
    });
  } // CSS template literals in css prop


  if (ast.type === "JSXAttribute" && ast.name.name === "css" && ast.value.type === "JSXExpressionContainer" && ast.value.expression.type === "TemplateLiteral") {
    newObj.value.expression.quasis.forEach(function (q) {
      return delete q.value;
    });
  } // Angular Components: Inline HTML template and Inline CSS styles


  var expression = ast.expression || ast.callee;

  if (ast.type === "Decorator" && expression.type === "CallExpression" && expression.callee.name === "Component" && expression.arguments.length === 1) {
    var astProps = ast.expression.arguments[0].properties;
    newObj.expression.arguments[0].properties.forEach(function (prop, index) {
      var templateLiteral = null;

      switch (astProps[index].key.name) {
        case "styles":
          if (prop.value.type === "ArrayExpression") {
            templateLiteral = prop.value.elements[0];
          }

          break;

        case "template":
          if (prop.value.type === "TemplateLiteral") {
            templateLiteral = prop.value;
          }

          break;
      }

      if (templateLiteral) {
        templateLiteral.quasis.forEach(function (q) {
          return delete q.value;
        });
      }
    });
  } // styled-components, graphql, markdown


  if (ast.type === "TaggedTemplateExpression" && (ast.tag.type === "MemberExpression" || ast.tag.type === "Identifier" && (ast.tag.name === "gql" || ast.tag.name === "graphql" || ast.tag.name === "css" || ast.tag.name === "md" || ast.tag.name === "markdown" || ast.tag.name === "html") || ast.tag.type === "CallExpression")) {
    newObj.quasi.quasis.forEach(function (quasi) {
      return delete quasi.value;
    });
  }

  if (ast.type === "TemplateLiteral") {
    // This checks for a leading comment that is exactly `/* GraphQL */`
    // In order to be in line with other implementations of this comment tag
    // we will not trim the comment value and we will expect exactly one space on
    // either side of the GraphQL string
    // Also see ./embed.js
    var hasLanguageComment = ast.leadingComments && ast.leadingComments.some(function (comment) {
      return comment.type === "CommentBlock" && ["GraphQL", "HTML"].some(function (languageName) {
        return comment.value === ` ${languageName} `;
      });
    });

    if (hasLanguageComment || parent.type === "CallExpression" && parent.callee.name === "graphql") {
      newObj.quasis.forEach(function (quasi) {
        return delete quasi.value;
      });
    }
  }
}

function isUnbalancedLogicalTree(newObj) {
  return newObj.type === "LogicalExpression" && newObj.right.type === "LogicalExpression" && newObj.operator === newObj.right.operator;
}

function rebalanceLogicalTree(newObj) {
  if (isUnbalancedLogicalTree(newObj)) {
    return rebalanceLogicalTree({
      type: "LogicalExpression",
      operator: newObj.operator,
      left: rebalanceLogicalTree({
        type: "LogicalExpression",
        operator: newObj.operator,
        left: newObj.left,
        right: newObj.right.left,
        loc: {}
      }),
      right: newObj.right.right,
      loc: {}
    });
  }

  return newObj;
}

var clean_1 = clean;

var detectNewline = createCommonjsModule(function (module) {

  module.exports = function (str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string');
    }

    var newlines = str.match(/(?:\r?\n)/g) || [];

    if (newlines.length === 0) {
      return null;
    }

    var crlf = newlines.filter(function (el) {
      return el === '\r\n';
    }).length;
    var lf = newlines.length - crlf;
    return crlf > lf ? '\r\n' : '\n';
  };

  module.exports.graceful = function (str) {
    return module.exports(str) || '\n';
  };
});
var detectNewline_1 = detectNewline.graceful;

var build = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.extract = extract;
  exports.strip = strip;
  exports.parse = parse;
  exports.parseWithComments = parseWithComments;
  exports.print = print;

  function _os() {
    var data = os$1;

    _os = function _os() {
      return data;
    };

    return data;
  }

  function _detectNewline() {
    var data = _interopRequireDefault(detectNewline);

    _detectNewline = function _detectNewline() {
      return data;
    };

    return data;
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  /**
   * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */


  var commentEndRe = /\*\/$/;
  var commentStartRe = /^\/\*\*/;
  var docblockRe = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/;
  var lineCommentRe = /(^|\s+)\/\/([^\r\n]*)/g;
  var ltrimNewlineRe = /^(\r?\n)+/;
  var multilineRe = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g;
  var propertyRe = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g;
  var stringStartRe = /(\r?\n|^) *\* ?/g;

  function extract(contents) {
    var match = contents.match(docblockRe);
    return match ? match[0].trimLeft() : '';
  }

  function strip(contents) {
    var match = contents.match(docblockRe);
    return match && match[0] ? contents.substring(match[0].length) : contents;
  }

  function parse(docblock) {
    return parseWithComments(docblock).pragmas;
  }

  function parseWithComments(docblock) {
    var line = (0, _detectNewline().default)(docblock) || _os().EOL;

    docblock = docblock.replace(commentStartRe, '').replace(commentEndRe, '').replace(stringStartRe, '$1'); // Normalize multi-line directives

    var prev = '';

    while (prev !== docblock) {
      prev = docblock;
      docblock = docblock.replace(multilineRe, `${line}$1 $2${line}`);
    }

    docblock = docblock.replace(ltrimNewlineRe, '').trimRight();
    var result = Object.create(null);
    var comments = docblock.replace(propertyRe, '').replace(ltrimNewlineRe, '').trimRight();
    var match;

    while (match = propertyRe.exec(docblock)) {
      // strip linecomments from pragmas
      var nextPragma = match[2].replace(lineCommentRe, '');

      if (typeof result[match[1]] === 'string' || Array.isArray(result[match[1]])) {
        result[match[1]] = [].concat(result[match[1]], nextPragma);
      } else {
        result[match[1]] = nextPragma;
      }
    }

    return {
      comments,
      pragmas: result
    };
  }

  function print(_ref) {
    var _ref$comments = _ref.comments,
        comments = _ref$comments === void 0 ? '' : _ref$comments,
        _ref$pragmas = _ref.pragmas,
        pragmas = _ref$pragmas === void 0 ? {} : _ref$pragmas;

    var line = (0, _detectNewline().default)(comments) || _os().EOL;

    var head = '/**';
    var start = ' *';
    var tail = ' */';
    var keys = Object.keys(pragmas);
    var printedObject = keys.map(function (key) {
      return printKeyValues(key, pragmas[key]);
    }).reduce(function (arr, next) {
      return arr.concat(next);
    }, []).map(function (keyValue) {
      return start + ' ' + keyValue + line;
    }).join('');

    if (!comments) {
      if (keys.length === 0) {
        return '';
      }

      if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {
        var value = pragmas[keys[0]];
        return `${head} ${printKeyValues(keys[0], value)[0]}${tail}`;
      }
    }

    var printedComments = comments.split(line).map(function (textLine) {
      return `${start} ${textLine}`;
    }).join(line) + line;
    return head + line + (comments ? printedComments : '') + (comments && keys.length ? start + line : '') + printedObject + tail;
  }

  function printKeyValues(key, valueOrArray) {
    return [].concat(valueOrArray).map(function (value) {
      return `@${key} ${value}`.trim();
    });
  }
});
unwrapExports(build);
var build_1 = build.extract;
var build_2 = build.strip;
var build_3 = build.parse;
var build_4 = build.parseWithComments;
var build_5 = build.print;

function hasPragma(text) {
  var pragmas = Object.keys(build.parse(build.extract(text)));
  return pragmas.indexOf("prettier") !== -1 || pragmas.indexOf("format") !== -1;
}

function insertPragma(text) {
  var parsedDocblock = build.parseWithComments(build.extract(text));
  var pragmas = Object.assign({
    format: ""
  }, parsedDocblock.pragmas);
  var newDocblock = build.print({
    pragmas,
    comments: parsedDocblock.comments.replace(/^(\s+?\r?\n)+/, "") // remove leading newlines

  }).replace(/(\r\n|\r)/g, "\n"); // normalise newlines (mitigate use of os.EOL by jest-docblock)

  var strippedText = build.strip(text);
  var separatingNewlines = strippedText.startsWith("\n") ? "\n" : "\n\n";
  return newDocblock + separatingNewlines + strippedText;
}

var pragma = {
  hasPragma,
  insertPragma
};

var getLast$1 = util.getLast,
    hasNewline$2 = util.hasNewline,
    hasNewlineInRange$1 = util.hasNewlineInRange,
    hasIgnoreComment$1 = util.hasIgnoreComment,
    hasNodeIgnoreComment$1 = util.hasNodeIgnoreComment,
    skipWhitespace$1 = util.skipWhitespace;
var isIdentifierName = utils$1.keyword.isIdentifierNameES5; // We match any whitespace except line terminators because
// Flow annotation comments cannot be split across lines. For example:
//
// (this /*
// : any */).foo = 5;
//
// is not picked up by Flow (see https://github.com/facebook/flow/issues/7050), so
// removing the newline would create a type annotation that the user did not intend
// to create.

var NON_LINE_TERMINATING_WHITE_SPACE = "(?:(?=.)\\s)";
var FLOW_SHORTHAND_ANNOTATION = new RegExp(`^${NON_LINE_TERMINATING_WHITE_SPACE}*:`);
var FLOW_ANNOTATION = new RegExp(`^${NON_LINE_TERMINATING_WHITE_SPACE}*::`);

function hasFlowShorthandAnnotationComment(node) {
  // https://flow.org/en/docs/types/comments/
  // Syntax example: const r = new (window.Request /*: Class<Request> */)("");
  return node.extra && node.extra.parenthesized && node.trailingComments && node.trailingComments[0].value.match(FLOW_SHORTHAND_ANNOTATION);
}

function hasFlowAnnotationComment(comments) {
  return comments && comments[0].value.match(FLOW_ANNOTATION);
}

function hasNode(node, fn) {
  if (!node || typeof node !== "object") {
    return false;
  }

  if (Array.isArray(node)) {
    return node.some(function (value) {
      return hasNode(value, fn);
    });
  }

  var result = fn(node);
  return typeof result === "boolean" ? result : Object.keys(node).some(function (key) {
    return hasNode(node[key], fn);
  });
}

function hasNakedLeftSide(node) {
  return node.type === "AssignmentExpression" || node.type === "BinaryExpression" || node.type === "LogicalExpression" || node.type === "NGPipeExpression" || node.type === "ConditionalExpression" || node.type === "CallExpression" || node.type === "OptionalCallExpression" || node.type === "MemberExpression" || node.type === "OptionalMemberExpression" || node.type === "SequenceExpression" || node.type === "TaggedTemplateExpression" || node.type === "BindExpression" || node.type === "UpdateExpression" && !node.prefix || node.type === "TSAsExpression" || node.type === "TSNonNullExpression";
}

function getLeftSide(node) {
  if (node.expressions) {
    return node.expressions[0];
  }

  return node.left || node.test || node.callee || node.object || node.tag || node.argument || node.expression;
}

function getLeftSidePathName(path, node) {
  if (node.expressions) {
    return ["expressions", 0];
  }

  if (node.left) {
    return ["left"];
  }

  if (node.test) {
    return ["test"];
  }

  if (node.object) {
    return ["object"];
  }

  if (node.callee) {
    return ["callee"];
  }

  if (node.tag) {
    return ["tag"];
  }

  if (node.argument) {
    return ["argument"];
  }

  if (node.expression) {
    return ["expression"];
  }

  throw new Error("Unexpected node has no left side", node);
}

function isLiteral(node) {
  return node.type === "BooleanLiteral" || node.type === "DirectiveLiteral" || node.type === "Literal" || node.type === "NullLiteral" || node.type === "NumericLiteral" || node.type === "RegExpLiteral" || node.type === "StringLiteral" || node.type === "TemplateLiteral" || node.type === "TSTypeLiteral" || node.type === "JSXText";
}

function isNumericLiteral(node) {
  return node.type === "NumericLiteral" || node.type === "Literal" && typeof node.value === "number";
}

function isStringLiteral(node) {
  return node.type === "StringLiteral" || node.type === "Literal" && typeof node.value === "string";
}

function isObjectType(n) {
  return n.type === "ObjectTypeAnnotation" || n.type === "TSTypeLiteral";
}

function isFunctionOrArrowExpression(node) {
  return node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
}

function isFunctionOrArrowExpressionWithBody(node) {
  return node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement";
}

function isTemplateLiteral(node) {
  return node.type === "TemplateLiteral";
} // `inject` is used in AngularJS 1.x, `async` in Angular 2+
// example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-


function isAngularTestWrapper(node) {
  return (node.type === "CallExpression" || node.type === "OptionalCallExpression") && node.callee.type === "Identifier" && (node.callee.name === "async" || node.callee.name === "inject" || node.callee.name === "fakeAsync");
}

function isJSXNode(node) {
  return node.type === "JSXElement" || node.type === "JSXFragment";
}

function isTheOnlyJSXElementInMarkdown(options, path) {
  if (options.parentParser !== "markdown" && options.parentParser !== "mdx") {
    return false;
  }

  var node = path.getNode();

  if (!node.expression || !isJSXNode(node.expression)) {
    return false;
  }

  var parent = path.getParentNode();
  return parent.type === "Program" && parent.body.length == 1;
} // Detect an expression node representing `{" "}`


function isJSXWhitespaceExpression(node) {
  return node.type === "JSXExpressionContainer" && isLiteral(node.expression) && node.expression.value === " " && !node.expression.comments;
}

function isMemberExpressionChain(node) {
  if (node.type !== "MemberExpression" && node.type !== "OptionalMemberExpression") {
    return false;
  }

  if (node.object.type === "Identifier") {
    return true;
  }

  return isMemberExpressionChain(node.object);
}

function isGetterOrSetter(node) {
  return node.kind === "get" || node.kind === "set";
}

function sameLocStart(nodeA, nodeB, options) {
  return options.locStart(nodeA) === options.locStart(nodeB);
} // TODO: This is a bad hack and we need a better way to distinguish between
// arrow functions and otherwise


function isFunctionNotation(node, options) {
  return isGetterOrSetter(node) || sameLocStart(node, node.value, options);
} // Hack to differentiate between the following two which have the same ast
// type T = { method: () => void };
// type T = { method(): void };


function isObjectTypePropertyAFunction(node, options) {
  return (node.type === "ObjectTypeProperty" || node.type === "ObjectTypeInternalSlot") && node.value.type === "FunctionTypeAnnotation" && !node.static && !isFunctionNotation(node, options);
} // Hack to differentiate between the following two which have the same ast
// declare function f(a): void;
// var f: (a) => void;


function isTypeAnnotationAFunction(node, options) {
  return (node.type === "TypeAnnotation" || node.type === "TSTypeAnnotation") && node.typeAnnotation.type === "FunctionTypeAnnotation" && !node.static && !sameLocStart(node, node.typeAnnotation, options);
}

function isBinaryish(node) {
  return node.type === "BinaryExpression" || node.type === "LogicalExpression" || node.type === "NGPipeExpression";
}

function isMemberish(node) {
  return node.type === "MemberExpression" || node.type === "OptionalMemberExpression" || node.type === "BindExpression" && node.object;
}

function isSimpleFlowType(node) {
  var flowTypeAnnotations = ["AnyTypeAnnotation", "NullLiteralTypeAnnotation", "GenericTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation", "BooleanTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringTypeAnnotation"];
  return node && flowTypeAnnotations.indexOf(node.type) !== -1 && !(node.type === "GenericTypeAnnotation" && node.typeParameters);
}

var unitTestRe = /^(skip|[fx]?(it|describe|test))$/;

function isSkipOrOnlyBlock(node) {
  return (node.callee.type === "MemberExpression" || node.callee.type === "OptionalMemberExpression") && node.callee.object.type === "Identifier" && node.callee.property.type === "Identifier" && unitTestRe.test(node.callee.object.name) && (node.callee.property.name === "only" || node.callee.property.name === "skip");
}

function isUnitTestSetUp(n) {
  var unitTestSetUpRe = /^(before|after)(Each|All)$/;
  return n.callee.type === "Identifier" && unitTestSetUpRe.test(n.callee.name) && n.arguments.length === 1;
} // eg; `describe("some string", (done) => {})`


function isTestCall(n, parent) {
  if (n.type !== "CallExpression") {
    return false;
  }

  if (n.arguments.length === 1) {
    if (isAngularTestWrapper(n) && parent && isTestCall(parent)) {
      return isFunctionOrArrowExpression(n.arguments[0]);
    }

    if (isUnitTestSetUp(n)) {
      return isAngularTestWrapper(n.arguments[0]);
    }
  } else if (n.arguments.length === 2 || n.arguments.length === 3) {
    if ((n.callee.type === "Identifier" && unitTestRe.test(n.callee.name) || isSkipOrOnlyBlock(n)) && (isTemplateLiteral(n.arguments[0]) || isStringLiteral(n.arguments[0]))) {
      // it("name", () => { ... }, 2500)
      if (n.arguments[2] && !isNumericLiteral(n.arguments[2])) {
        return false;
      }

      return (n.arguments.length === 2 ? isFunctionOrArrowExpression(n.arguments[1]) : isFunctionOrArrowExpressionWithBody(n.arguments[1]) && n.arguments[1].params.length <= 1) || isAngularTestWrapper(n.arguments[1]);
    }
  }

  return false;
}

function hasLeadingComment$2(node) {
  return node.comments && node.comments.some(function (comment) {
    return comment.leading;
  });
}

function hasTrailingComment(node) {
  return node.comments && node.comments.some(function (comment) {
    return comment.trailing;
  });
}

function isCallOrOptionalCallExpression(node) {
  return node.type === "CallExpression" || node.type === "OptionalCallExpression";
}

function hasDanglingComments(node) {
  return node.comments && node.comments.some(function (comment) {
    return !comment.leading && !comment.trailing;
  });
}
/** identify if an angular expression seems to have side effects */


function hasNgSideEffect(path) {
  return hasNode(path.getValue(), function (node) {
    switch (node.type) {
      case undefined:
        return false;

      case "CallExpression":
      case "OptionalCallExpression":
      case "AssignmentExpression":
        return true;
    }
  });
}

function isNgForOf(node, index, parentNode) {
  return node.type === "NGMicrosyntaxKeyedExpression" && node.key.name === "of" && index === 1 && parentNode.body[0].type === "NGMicrosyntaxLet" && parentNode.body[0].value === null;
}
/** @param node {import("estree").TemplateLiteral} */


function isSimpleTemplateLiteral(node) {
  if (node.expressions.length === 0) {
    return false;
  }

  return node.expressions.every(function (expr) {
    // Disallow comments since printDocToString can't print them here
    if (expr.comments) {
      return false;
    } // Allow `x` and `this`


    if (expr.type === "Identifier" || expr.type === "ThisExpression") {
      return true;
    } // Allow `a.b.c`, `a.b[c]`, and `this.x.y`


    if (expr.type === "MemberExpression" || expr.type === "OptionalMemberExpression") {
      var head = expr;

      while (head.type === "MemberExpression" || head.type === "OptionalMemberExpression") {
        if (head.property.type !== "Identifier" && head.property.type !== "Literal" && head.property.type !== "StringLiteral" && head.property.type !== "NumericLiteral") {
          return false;
        }

        head = head.object;

        if (head.comments) {
          return false;
        }
      }

      if (head.type === "Identifier" || head.type === "ThisExpression") {
        return true;
      }

      return false;
    }

    return false;
  });
}

function getFlowVariance(path) {
  if (!path.variance) {
    return null;
  } // Babel 7.0 currently uses variance node type, and flow should
  // follow suit soon:
  // https://github.com/babel/babel/issues/4722


  var variance = path.variance.kind || path.variance;

  switch (variance) {
    case "plus":
      return "+";

    case "minus":
      return "-";

    default:
      /* istanbul ignore next */
      return variance;
  }
}

function classPropMayCauseASIProblems(path) {
  var node = path.getNode();

  if (node.type !== "ClassProperty") {
    return false;
  }

  var name = node.key && node.key.name; // this isn't actually possible yet with most parsers available today
  // so isn't properly tested yet.

  if ((name === "static" || name === "get" || name === "set") && !node.value && !node.typeAnnotation) {
    return true;
  }
}

function classChildNeedsASIProtection(node) {
  if (!node) {
    return;
  }

  if (node.static || node.accessibility // TypeScript
  ) {
      return false;
    }

  if (!node.computed) {
    var name = node.key && node.key.name;

    if (name === "in" || name === "instanceof") {
      return true;
    }
  }

  switch (node.type) {
    case "ClassProperty":
    case "TSAbstractClassProperty":
      return node.computed;

    case "MethodDefinition": // Flow

    case "TSAbstractMethodDefinition": // TypeScript

    case "ClassMethod":
    case "ClassPrivateMethod":
      {
        // Babel
        var isAsync = node.value ? node.value.async : node.async;
        var isGenerator = node.value ? node.value.generator : node.generator;

        if (isAsync || node.kind === "get" || node.kind === "set") {
          return false;
        }

        if (node.computed || isGenerator) {
          return true;
        }

        return false;
      }

    case "TSIndexSignature":
      return true;

    default:
      /* istanbul ignore next */
      return false;
  }
}

function getTypeScriptMappedTypeModifier(tokenNode, keyword) {
  if (tokenNode === "+") {
    return "+" + keyword;
  } else if (tokenNode === "-") {
    return "-" + keyword;
  }

  return keyword;
}

function hasNewlineBetweenOrAfterDecorators(node, options) {
  return hasNewlineInRange$1(options.originalText, options.locStart(node.decorators[0]), options.locEnd(getLast$1(node.decorators))) || hasNewline$2(options.originalText, options.locEnd(getLast$1(node.decorators)));
} // Only space, newline, carriage return, and tab are treated as whitespace
// inside JSX.


var jsxWhitespaceChars = " \n\r\t";
var matchJsxWhitespaceRegex = new RegExp("([" + jsxWhitespaceChars + "]+)");
var containsNonJsxWhitespaceRegex = new RegExp("[^" + jsxWhitespaceChars + "]"); // Meaningful if it contains non-whitespace characters,
// or it contains whitespace without a new line.

function isMeaningfulJSXText(node) {
  return isLiteral(node) && (containsNonJsxWhitespaceRegex.test(rawText(node)) || !/\n/.test(rawText(node)));
}

function hasJsxIgnoreComment(path) {
  var node = path.getValue();
  var parent = path.getParentNode();

  if (!parent || !node || !isJSXNode(node) || !isJSXNode(parent)) {
    return false;
  } // Lookup the previous sibling, ignoring any empty JSXText elements


  var index = parent.children.indexOf(node);
  var prevSibling = null;

  for (var i = index; i > 0; i--) {
    var candidate = parent.children[i - 1];

    if (candidate.type === "JSXText" && !isMeaningfulJSXText(candidate)) {
      continue;
    }

    prevSibling = candidate;
    break;
  }

  return prevSibling && prevSibling.type === "JSXExpressionContainer" && prevSibling.expression.type === "JSXEmptyExpression" && prevSibling.expression.comments && prevSibling.expression.comments.find(function (comment) {
    return comment.value.trim() === "prettier-ignore";
  });
}

function isEmptyJSXElement(node) {
  if (node.children.length === 0) {
    return true;
  }

  if (node.children.length > 1) {
    return false;
  } // if there is one text child and does not contain any meaningful text
  // we can treat the element as empty.


  var child = node.children[0];
  return isLiteral(child) && !isMeaningfulJSXText(child);
}

function hasPrettierIgnore(path) {
  return hasIgnoreComment$1(path) || hasJsxIgnoreComment(path);
}

function isLastStatement(path) {
  var parent = path.getParentNode();

  if (!parent) {
    return true;
  }

  var node = path.getValue();
  var body = (parent.body || parent.consequent).filter(function (stmt) {
    return stmt.type !== "EmptyStatement";
  });
  return body && body[body.length - 1] === node;
}

function isFlowAnnotationComment(text, typeAnnotation, options) {
  var start = options.locStart(typeAnnotation);
  var end = skipWhitespace$1(text, options.locEnd(typeAnnotation));
  return text.substr(start, 2) === "/*" && text.substr(end, 2) === "*/";
}

function hasLeadingOwnLineComment(text, node, options) {
  if (isJSXNode(node)) {
    return hasNodeIgnoreComment$1(node);
  }

  var res = node.comments && node.comments.some(function (comment) {
    return comment.leading && hasNewline$2(text, options.locEnd(comment));
  });
  return res;
} // This recurses the return argument, looking for the first token
// (the leftmost leaf node) and, if it (or its parents) has any
// leadingComments, returns true (so it can be wrapped in parens).


function returnArgumentHasLeadingComment(options, argument) {
  if (hasLeadingOwnLineComment(options.originalText, argument, options)) {
    return true;
  }

  if (hasNakedLeftSide(argument)) {
    var leftMost = argument;
    var newLeftMost;

    while (newLeftMost = getLeftSide(leftMost)) {
      leftMost = newLeftMost;

      if (hasLeadingOwnLineComment(options.originalText, leftMost, options)) {
        return true;
      }
    }
  }

  return false;
}

function isStringPropSafeToCoerceToIdentifier(node, options) {
  return isStringLiteral(node.key) && isIdentifierName(node.key.value) && options.parser !== "json" && !(options.parser === "typescript" && node.type === "ClassProperty");
}

function isJestEachTemplateLiteral(node, parentNode) {
  /**
   * describe.each`table`(name, fn)
   * describe.only.each`table`(name, fn)
   * describe.skip.each`table`(name, fn)
   * test.each`table`(name, fn)
   * test.only.each`table`(name, fn)
   * test.skip.each`table`(name, fn)
   *
   * Ref: https://github.com/facebook/jest/pull/6102
   */
  var jestEachTriggerRegex = /^[xf]?(describe|it|test)$/;
  return parentNode.type === "TaggedTemplateExpression" && parentNode.quasi === node && parentNode.tag.type === "MemberExpression" && parentNode.tag.property.type === "Identifier" && parentNode.tag.property.name === "each" && (parentNode.tag.object.type === "Identifier" && jestEachTriggerRegex.test(parentNode.tag.object.name) || parentNode.tag.object.type === "MemberExpression" && parentNode.tag.object.property.type === "Identifier" && (parentNode.tag.object.property.name === "only" || parentNode.tag.object.property.name === "skip") && parentNode.tag.object.object.type === "Identifier" && jestEachTriggerRegex.test(parentNode.tag.object.object.name));
}

function templateLiteralHasNewLines(template) {
  return template.quasis.some(function (quasi) {
    return quasi.value.raw.includes("\n");
  });
}

function isTemplateOnItsOwnLine(n, text, options) {
  return (n.type === "TemplateLiteral" && templateLiteralHasNewLines(n) || n.type === "TaggedTemplateExpression" && templateLiteralHasNewLines(n.quasi)) && !hasNewline$2(text, options.locStart(n), {
    backwards: true
  });
}

function needsHardlineAfterDanglingComment(node) {
  if (!node.comments) {
    return false;
  }

  var lastDanglingComment = getLast$1(node.comments.filter(function (comment) {
    return !comment.leading && !comment.trailing;
  }));
  return lastDanglingComment && !comments$1.isBlockComment(lastDanglingComment);
} // If we have nested conditional expressions, we want to print them in JSX mode
// if there's at least one JSXElement somewhere in the tree.
//
// A conditional expression chain like this should be printed in normal mode,
// because there aren't JSXElements anywhere in it:
//
// isA ? "A" : isB ? "B" : isC ? "C" : "Unknown";
//
// But a conditional expression chain like this should be printed in JSX mode,
// because there is a JSXElement in the last ConditionalExpression:
//
// isA ? "A" : isB ? "B" : isC ? "C" : <span className="warning">Unknown</span>;
//
// This type of ConditionalExpression chain is structured like this in the AST:
//
// ConditionalExpression {
//   test: ...,
//   consequent: ...,
//   alternate: ConditionalExpression {
//     test: ...,
//     consequent: ...,
//     alternate: ConditionalExpression {
//       test: ...,
//       consequent: ...,
//       alternate: ...,
//     }
//   }
// }
//
// We want to traverse over that shape and convert it into a flat structure so
// that we can find if there's a JSXElement somewhere inside.


function getConditionalChainContents(node) {
  // Given this code:
  //
  // // Using a ConditionalExpression as the consequent is uncommon, but should
  // // be handled.
  // A ? B : C ? D : E ? F ? G : H : I
  //
  // which has this AST:
  //
  // ConditionalExpression {
  //   test: Identifier(A),
  //   consequent: Identifier(B),
  //   alternate: ConditionalExpression {
  //     test: Identifier(C),
  //     consequent: Identifier(D),
  //     alternate: ConditionalExpression {
  //       test: Identifier(E),
  //       consequent: ConditionalExpression {
  //         test: Identifier(F),
  //         consequent: Identifier(G),
  //         alternate: Identifier(H),
  //       },
  //       alternate: Identifier(I),
  //     }
  //   }
  // }
  //
  // we should return this Array:
  //
  // [
  //   Identifier(A),
  //   Identifier(B),
  //   Identifier(C),
  //   Identifier(D),
  //   Identifier(E),
  //   Identifier(F),
  //   Identifier(G),
  //   Identifier(H),
  //   Identifier(I)
  // ];
  //
  // This loses the information about whether each node was the test,
  // consequent, or alternate, but we don't care about that here- we are only
  // flattening this structure to find if there's any JSXElements inside.
  var nonConditionalExpressions = [];

  function recurse(node) {
    if (node.type === "ConditionalExpression") {
      recurse(node.test);
      recurse(node.consequent);
      recurse(node.alternate);
    } else {
      nonConditionalExpressions.push(node);
    }
  }

  recurse(node);
  return nonConditionalExpressions;
}

function conditionalExpressionChainContainsJSX(node) {
  return Boolean(getConditionalChainContents(node).find(isJSXNode));
} // Logic to check for args with multiple anonymous functions. For instance,
// the following call should be split on multiple lines for readability:
// source.pipe(map((x) => x + x), filter((x) => x % 2 === 0))


function isFunctionCompositionArgs(args) {
  if (args.length <= 1) {
    return false;
  }

  var count = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var arg = _step.value;

      if (isFunctionOrArrowExpression(arg)) {
        count += 1;

        if (count > 1) {
          return true;
        }
      } else if (isCallOrOptionalCallExpression(arg)) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = arg.arguments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var childArg = _step2.value;

            if (isFunctionOrArrowExpression(childArg)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return false;
} // Logic to determine if a call is a “long curried function call”.
// See https://github.com/prettier/prettier/issues/1420.
//
// `connect(a, b, c)(d)`
// In the above call expression, the second call is the parent node and the
// first call is the current node.


function isLongCurriedCallExpression(path) {
  var node = path.getValue();
  var parent = path.getParentNode();
  return isCallOrOptionalCallExpression(node) && isCallOrOptionalCallExpression(parent) && parent.callee === node && node.arguments.length > parent.arguments.length && parent.arguments.length > 0;
}

function rawText(node) {
  return node.extra ? node.extra.raw : node.raw;
}

function identity(x) {
  return x;
}

function isTSXFile(options) {
  return options.filepath && /\.tsx$/i.test(options.filepath);
}

var utils$2 = {
  classChildNeedsASIProtection,
  classPropMayCauseASIProblems,
  conditionalExpressionChainContainsJSX,
  getFlowVariance,
  getLeftSidePathName,
  getTypeScriptMappedTypeModifier,
  hasDanglingComments,
  hasFlowAnnotationComment,
  hasFlowShorthandAnnotationComment,
  hasLeadingComment: hasLeadingComment$2,
  hasLeadingOwnLineComment,
  hasNakedLeftSide,
  hasNewlineBetweenOrAfterDecorators,
  hasNgSideEffect,
  hasNode,
  hasPrettierIgnore,
  hasTrailingComment,
  identity,
  isBinaryish,
  isCallOrOptionalCallExpression,
  isEmptyJSXElement,
  isFlowAnnotationComment,
  isFunctionCompositionArgs,
  isFunctionNotation,
  isFunctionOrArrowExpression,
  isGetterOrSetter,
  isJestEachTemplateLiteral,
  isJSXNode,
  isJSXWhitespaceExpression,
  isLastStatement,
  isLiteral,
  isLongCurriedCallExpression,
  isMeaningfulJSXText,
  isMemberExpressionChain,
  isMemberish,
  isNgForOf,
  isNumericLiteral,
  isObjectType,
  isObjectTypePropertyAFunction,
  isSimpleFlowType,
  isSimpleTemplateLiteral,
  isStringLiteral,
  isStringPropSafeToCoerceToIdentifier,
  isTemplateOnItsOwnLine,
  isTestCall,
  isTheOnlyJSXElementInMarkdown,
  isTSXFile,
  isTypeAnnotationAFunction,
  matchJsxWhitespaceRegex,
  needsHardlineAfterDanglingComment,
  rawText,
  returnArgumentHasLeadingComment
};

var getLeftSidePathName$1 = utils$2.getLeftSidePathName,
    hasFlowShorthandAnnotationComment$1 = utils$2.hasFlowShorthandAnnotationComment,
    hasNakedLeftSide$1 = utils$2.hasNakedLeftSide,
    hasNode$1 = utils$2.hasNode;

function hasClosureCompilerTypeCastComment(text, path) {
  // https://github.com/google/closure-compiler/wiki/Annotating-Types#type-casts
  // Syntax example: var x = /** @type {string} */ (fruit);
  var n = path.getValue();
  return isParenthesized(n) && (hasTypeCastComment(n) || hasAncestorTypeCastComment(0)); // for sub-item: /** @type {array} */ (numberOrString).map(x => x);

  function hasAncestorTypeCastComment(index) {
    var ancestor = path.getParentNode(index);
    return ancestor && !isParenthesized(ancestor) ? hasTypeCastComment(ancestor) || hasAncestorTypeCastComment(index + 1) : false;
  }

  function hasTypeCastComment(node) {
    return node.comments && node.comments.some(function (comment) {
      return comment.leading && comments$1.isBlockComment(comment) && isTypeCastComment(comment.value);
    });
  }

  function isParenthesized(node) {
    // Closure typecast comments only really make sense when _not_ using
    // typescript or flow parsers, so we take advantage of the babel parser's
    // parenthesized expressions.
    return node.extra && node.extra.parenthesized;
  }

  function isTypeCastComment(comment) {
    var cleaned = comment.trim().split("\n").map(function (line) {
      return line.replace(/^[\s*]+/, "");
    }).join(" ").trim();

    if (!/^@type\s*\{[^]+\}$/.test(cleaned)) {
      return false;
    }

    var isCompletelyClosed = false;
    var unpairedBracketCount = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = cleaned[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var char = _step.value;

        if (char === "{") {
          if (isCompletelyClosed) {
            return false;
          }

          unpairedBracketCount++;
        } else if (char === "}") {
          if (unpairedBracketCount === 0) {
            return false;
          }

          unpairedBracketCount--;

          if (unpairedBracketCount === 0) {
            isCompletelyClosed = true;
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return unpairedBracketCount === 0;
  }
}

function needsParens(path, options) {
  var parent = path.getParentNode();

  if (!parent) {
    return false;
  }

  var name = path.getName();
  var node = path.getNode(); // If the value of this path is some child of a Node and not a Node
  // itself, then it doesn't need parentheses. Only Node objects (in
  // fact, only Expression nodes) need parentheses.

  if (path.getValue() !== node) {
    return false;
  } // to avoid unexpected `}}` in HTML interpolations


  if (options.__isInHtmlInterpolation && !options.bracketSpacing && endsWithRightBracket(node) && isFollowedByRightBracket(path)) {
    return true;
  } // Only statements don't need parentheses.


  if (isStatement(node)) {
    return false;
  } // Closure compiler requires that type casted expressions to be surrounded by
  // parentheses.


  if (hasClosureCompilerTypeCastComment(options.originalText, path)) {
    return true;
  }

  if ( // Preserve parens if we have a Flow annotation comment, unless we're using the Flow
  // parser. The Flow parser turns Flow comments into type annotation nodes in its
  // AST, which we handle separately.
  options.parser !== "flow" && hasFlowShorthandAnnotationComment$1(path.getValue())) {
    return true;
  } // Identifiers never need parentheses.


  if (node.type === "Identifier") {
    // ...unless those identifiers are embed placeholders. They might be substituted by complex
    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):
    //     let tpl = html`<script> f((${expr}) / 2); </script>`;
    // If the inner JS formatter removes the parens, the expression might change its meaning:
    //     f((a + b) / 2)  vs  f(a + b / 2)
    if (node.extra && node.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(node.name)) {
      return true;
    }

    return false;
  }

  if (parent.type === "ParenthesizedExpression") {
    return false;
  } // Add parens around the extends clause of a class. It is needed for almost
  // all expressions.


  if ((parent.type === "ClassDeclaration" || parent.type === "ClassExpression") && parent.superClass === node && (node.type === "ArrowFunctionExpression" || node.type === "AssignmentExpression" || node.type === "AwaitExpression" || node.type === "BinaryExpression" || node.type === "ConditionalExpression" || node.type === "LogicalExpression" || node.type === "NewExpression" || node.type === "ObjectExpression" || node.type === "ParenthesizedExpression" || node.type === "SequenceExpression" || node.type === "TaggedTemplateExpression" || node.type === "UnaryExpression" || node.type === "UpdateExpression" || node.type === "YieldExpression")) {
    return true;
  } // `export default function` or `export default class` can't be followed by
  // anything after. So an expression like `export default (function(){}).toString()`
  // needs to be followed by a parentheses


  if (parent.type === "ExportDefaultDeclaration") {
    return shouldWrapFunctionForExportDefault(path, options);
  }

  if (parent.type === "Decorator" && parent.expression === node) {
    var hasCallExpression = false;
    var hasMemberExpression = false;
    var current = node;

    while (current) {
      switch (current.type) {
        case "MemberExpression":
          hasMemberExpression = true;
          current = current.object;
          break;

        case "CallExpression":
          if (
          /** @(x().y) */
          hasMemberExpression ||
          /** @(x().y()) */
          hasCallExpression) {
            return true;
          }

          hasCallExpression = true;
          current = current.callee;
          break;

        case "Identifier":
          return false;

        default:
          return true;
      }
    }

    return true;
  }

  if (parent.type === "ArrowFunctionExpression" && parent.body === node && node.type !== "SequenceExpression" && // these have parens added anyway
  util.startsWithNoLookaheadToken(node,
  /* forbidFunctionClassAndDoExpr */
  false) || parent.type === "ExpressionStatement" && util.startsWithNoLookaheadToken(node,
  /* forbidFunctionClassAndDoExpr */
  true)) {
    return true;
  }

  switch (node.type) {
    case "SpreadElement":
    case "SpreadProperty":
      return parent.type === "MemberExpression" && name === "object" && parent.object === node;

    case "UpdateExpression":
      if (parent.type === "UnaryExpression") {
        return node.prefix && (node.operator === "++" && parent.operator === "+" || node.operator === "--" && parent.operator === "-");
      }

    // else fallthrough

    case "UnaryExpression":
      switch (parent.type) {
        case "UnaryExpression":
          return node.operator === parent.operator && (node.operator === "+" || node.operator === "-");

        case "BindExpression":
          return true;

        case "MemberExpression":
        case "OptionalMemberExpression":
          return name === "object";

        case "TaggedTemplateExpression":
          return true;

        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return name === "callee";

        case "BinaryExpression":
          return parent.operator === "**" && name === "left";

        case "TSNonNullExpression":
          return true;

        default:
          return false;
      }

    case "BinaryExpression":
      {
        if (parent.type === "UpdateExpression") {
          return true;
        }

        var isLeftOfAForStatement = function isLeftOfAForStatement(node) {
          var i = 0;

          while (node) {
            var _parent = path.getParentNode(i++);

            if (!_parent) {
              return false;
            }

            if (_parent.type === "ForStatement" && _parent.init === node) {
              return true;
            }

            node = _parent;
          }

          return false;
        };

        if (node.operator === "in" && isLeftOfAForStatement(node)) {
          return true;
        }
      }
    // fallthrough

    case "TSTypeAssertion":
    case "TSAsExpression":
    case "LogicalExpression":
      switch (parent.type) {
        case "ConditionalExpression":
          return node.type === "TSAsExpression";

        case "CallExpression":
        case "NewExpression":
        case "OptionalCallExpression":
          return name === "callee";

        case "ClassExpression":
        case "ClassDeclaration":
          return name === "superClass" && parent.superClass === node;

        case "TSTypeAssertion":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "JSXSpreadAttribute":
        case "SpreadElement":
        case "SpreadProperty":
        case "BindExpression":
        case "AwaitExpression":
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "UpdateExpression":
          return true;

        case "MemberExpression":
        case "OptionalMemberExpression":
          return name === "object";

        case "AssignmentExpression":
          return parent.left === node && (node.type === "TSTypeAssertion" || node.type === "TSAsExpression");

        case "LogicalExpression":
          if (node.type === "LogicalExpression") {
            return parent.operator !== node.operator;
          }

        // else fallthrough

        case "BinaryExpression":
          {
            if (!node.operator && node.type !== "TSTypeAssertion") {
              return true;
            }

            var po = parent.operator;
            var pp = util.getPrecedence(po);
            var no = node.operator;
            var np = util.getPrecedence(no);

            if (pp > np) {
              return true;
            }

            if (pp === np && name === "right") {
              assert$1.strictEqual(parent.right, node);
              return true;
            }

            if (pp === np && !util.shouldFlatten(po, no)) {
              return true;
            }

            if (pp < np && no === "%") {
              return po === "+" || po === "-";
            } // Add parenthesis when working with bitwise operators
            // It's not strictly needed but helps with code understanding


            if (util.isBitwiseOperator(po)) {
              return true;
            }

            return false;
          }

        default:
          return false;
      }

    case "SequenceExpression":
      switch (parent.type) {
        case "ReturnStatement":
          return false;

        case "ForStatement":
          // Although parentheses wouldn't hurt around sequence
          // expressions in the head of for loops, traditional style
          // dictates that e.g. i++, j++ should not be wrapped with
          // parentheses.
          return false;

        case "ExpressionStatement":
          return name !== "expression";

        case "ArrowFunctionExpression":
          // We do need parentheses, but SequenceExpressions are handled
          // specially when printing bodies of arrow functions.
          return name !== "body";

        default:
          // Otherwise err on the side of overparenthesization, adding
          // explicit exceptions above if this proves overzealous.
          return true;
      }

    case "YieldExpression":
      if (parent.type === "UnaryExpression" || parent.type === "AwaitExpression" || parent.type === "TSAsExpression" || parent.type === "TSNonNullExpression") {
        return true;
      }

    // else fallthrough

    case "AwaitExpression":
      switch (parent.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "BinaryExpression":
        case "LogicalExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "BindExpression":
          return true;

        case "MemberExpression":
        case "OptionalMemberExpression":
          return name === "object";

        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return name === "callee";

        case "ConditionalExpression":
          return parent.test === node;

        default:
          return false;
      }

    case "TSConditionalType":
      if (parent.type === "TSConditionalType" && node === parent.extendsType) {
        return true;
      }

    // fallthrough

    case "TSFunctionType":
    case "TSConstructorType":
      if (parent.type === "TSConditionalType" && node === parent.checkType) {
        return true;
      }

    // fallthrough

    case "TSUnionType":
    case "TSIntersectionType":
      if (parent.type === "TSUnionType" || parent.type === "TSIntersectionType") {
        return true;
      }

    // fallthrough

    case "TSTypeOperator":
    case "TSInferType":
      return parent.type === "TSArrayType" || parent.type === "TSOptionalType" || parent.type === "TSRestType" || parent.type === "TSIndexedAccessType" && node === parent.objectType || parent.type === "TSTypeOperator";

    case "ArrayTypeAnnotation":
      return parent.type === "NullableTypeAnnotation";

    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation":
      return parent.type === "ArrayTypeAnnotation" || parent.type === "NullableTypeAnnotation" || parent.type === "IntersectionTypeAnnotation" || parent.type === "UnionTypeAnnotation";

    case "NullableTypeAnnotation":
      return parent.type === "ArrayTypeAnnotation";

    case "FunctionTypeAnnotation":
      {
        var ancestor = parent.type === "NullableTypeAnnotation" ? path.getParentNode(1) : parent;
        return ancestor.type === "UnionTypeAnnotation" || ancestor.type === "IntersectionTypeAnnotation" || ancestor.type === "ArrayTypeAnnotation" || // We should check ancestor's parent to know whether the parentheses
        // are really needed, but since ??T doesn't make sense this check
        // will almost never be true.
        ancestor.type === "NullableTypeAnnotation";
      }

    case "StringLiteral":
    case "NumericLiteral":
    case "Literal":
      if (typeof node.value === "string" && parent.type === "ExpressionStatement" && ( // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2
      // See corresponding workaround in printer.js case: "Literal"
      options.parser !== "typescript" && !parent.directive || options.parser === "typescript" && options.originalText.substr(options.locStart(node) - 1, 1) === "(")) {
        // To avoid becoming a directive
        var grandParent = path.getParentNode(1);
        return grandParent.type === "Program" || grandParent.type === "BlockStatement";
      }

      return parent.type === "MemberExpression" && typeof node.value === "number" && name === "object" && parent.object === node;

    case "AssignmentExpression":
      {
        var _grandParent = path.getParentNode(1);

        if (parent.type === "ArrowFunctionExpression" && parent.body === node) {
          return true;
        } else if (parent.type === "ClassProperty" && parent.key === node && parent.computed) {
          return false;
        } else if (parent.type === "TSPropertySignature" && parent.name === node) {
          return false;
        } else if (parent.type === "ForStatement" && (parent.init === node || parent.update === node)) {
          return false;
        } else if (parent.type === "ExpressionStatement") {
          return node.left.type === "ObjectPattern";
        } else if (parent.type === "TSPropertySignature" && parent.key === node) {
          return false;
        } else if (parent.type === "AssignmentExpression") {
          return false;
        } else if (parent.type === "SequenceExpression" && _grandParent && _grandParent.type === "ForStatement" && (_grandParent.init === parent || _grandParent.update === parent)) {
          return false;
        } else if (parent.type === "Property" && parent.value === node) {
          return false;
        } else if (parent.type === "NGChainedExpression") {
          return false;
        }

        return true;
      }

    case "ConditionalExpression":
      switch (parent.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "BinaryExpression":
        case "LogicalExpression":
        case "NGPipeExpression":
        case "ExportDefaultDeclaration":
        case "AwaitExpression":
        case "JSXSpreadAttribute":
        case "TSTypeAssertion":
        case "TypeCastExpression":
        case "TSAsExpression":
        case "TSNonNullExpression":
          return true;

        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return name === "callee";

        case "ConditionalExpression":
          return name === "test" && parent.test === node;

        case "MemberExpression":
        case "OptionalMemberExpression":
          return name === "object";

        default:
          return false;
      }

    case "FunctionExpression":
      switch (parent.type) {
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          // Not always necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.
          // Is necessary if it is `expression` of `ExpressionStatement`.
          return name === "callee";

        case "TaggedTemplateExpression":
          return true;
        // This is basically a kind of IIFE.

        default:
          return false;
      }

    case "ArrowFunctionExpression":
      switch (parent.type) {
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return name === "callee";

        case "MemberExpression":
        case "OptionalMemberExpression":
          return name === "object";

        case "TSAsExpression":
        case "BindExpression":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "BinaryExpression":
        case "AwaitExpression":
        case "TSTypeAssertion":
          return true;

        case "ConditionalExpression":
          return name === "test";

        default:
          return false;
      }

    case "ClassExpression":
      switch (parent.type) {
        case "NewExpression":
          return name === "callee" && parent.callee === node;

        default:
          return false;
      }

    case "OptionalMemberExpression":
    case "OptionalCallExpression":
      if ((parent.type === "MemberExpression" && name === "object" || parent.type === "CallExpression" && name === "callee") && // workaround for https://github.com/facebook/flow/issues/8159
      !(options.parser === "flow" && parent.range[0] === node.range[0])) {
        return true;
      }

    // fallthrough

    case "CallExpression":
    case "MemberExpression":
    case "TaggedTemplateExpression":
    case "TSNonNullExpression":
      if ((parent.type === "BindExpression" || parent.type === "NewExpression") && name === "callee") {
        var object = node;

        while (object) {
          switch (object.type) {
            case "CallExpression":
            case "OptionalCallExpression":
              return true;

            case "MemberExpression":
            case "OptionalMemberExpression":
            case "BindExpression":
              object = object.object;
              break;
            // tagged templates are basically member expressions from a grammar perspective
            // see https://tc39.github.io/ecma262/#prod-MemberExpression

            case "TaggedTemplateExpression":
              object = object.tag;
              break;

            case "TSNonNullExpression":
              object = object.expression;
              break;

            default:
              return false;
          }
        }
      }

      return false;

    case "BindExpression":
      return (parent.type === "BindExpression" || parent.type === "NewExpression") && name === "callee" || (parent.type === "MemberExpression" || parent.type === "OptionalMemberExpression") && name === "object";

    case "NGPipeExpression":
      if (parent.type === "NGRoot" || parent.type === "NGMicrosyntaxExpression" || parent.type === "ObjectProperty" || parent.type === "ArrayExpression" || (parent.type === "CallExpression" || parent.type === "OptionalCallExpression") && parent.arguments[name] === node || parent.type === "NGPipeExpression" && name === "right" || parent.type === "MemberExpression" && name === "property" || parent.type === "AssignmentExpression") {
        return false;
      }

      return true;

    case "JSXFragment":
    case "JSXElement":
      return name === "callee" || parent.type !== "ArrayExpression" && parent.type !== "ArrowFunctionExpression" && parent.type !== "AssignmentExpression" && parent.type !== "AssignmentPattern" && parent.type !== "BinaryExpression" && parent.type !== "CallExpression" && parent.type !== "ConditionalExpression" && parent.type !== "ExpressionStatement" && parent.type !== "JsExpressionRoot" && parent.type !== "JSXAttribute" && parent.type !== "JSXElement" && parent.type !== "JSXExpressionContainer" && parent.type !== "JSXFragment" && parent.type !== "LogicalExpression" && parent.type !== "ObjectProperty" && parent.type !== "OptionalCallExpression" && parent.type !== "Property" && parent.type !== "ReturnStatement" && parent.type !== "TypeCastExpression" && parent.type !== "VariableDeclarator";

    case "TypeAnnotation":
      return name === "returnType" && parent.type === "ArrowFunctionExpression" && includesFunctionTypeInObjectType(node);
  }

  return false;
}

function isStatement(node) {
  return node.type === "BlockStatement" || node.type === "BreakStatement" || node.type === "ClassBody" || node.type === "ClassDeclaration" || node.type === "ClassMethod" || node.type === "ClassProperty" || node.type === "ClassPrivateProperty" || node.type === "ContinueStatement" || node.type === "DebuggerStatement" || node.type === "DeclareClass" || node.type === "DeclareExportAllDeclaration" || node.type === "DeclareExportDeclaration" || node.type === "DeclareFunction" || node.type === "DeclareInterface" || node.type === "DeclareModule" || node.type === "DeclareModuleExports" || node.type === "DeclareVariable" || node.type === "DoWhileStatement" || node.type === "EnumDeclaration" || node.type === "ExportAllDeclaration" || node.type === "ExportDefaultDeclaration" || node.type === "ExportNamedDeclaration" || node.type === "ExpressionStatement" || node.type === "ForAwaitStatement" || node.type === "ForInStatement" || node.type === "ForOfStatement" || node.type === "ForStatement" || node.type === "FunctionDeclaration" || node.type === "IfStatement" || node.type === "ImportDeclaration" || node.type === "InterfaceDeclaration" || node.type === "LabeledStatement" || node.type === "MethodDefinition" || node.type === "ReturnStatement" || node.type === "SwitchStatement" || node.type === "ThrowStatement" || node.type === "TryStatement" || node.type === "TSDeclareFunction" || node.type === "TSEnumDeclaration" || node.type === "TSImportEqualsDeclaration" || node.type === "TSInterfaceDeclaration" || node.type === "TSModuleDeclaration" || node.type === "TSNamespaceExportDeclaration" || node.type === "TypeAlias" || node.type === "VariableDeclaration" || node.type === "WhileStatement" || node.type === "WithStatement";
}

function includesFunctionTypeInObjectType(node) {
  return hasNode$1(node, function (n1) {
    return n1.type === "ObjectTypeAnnotation" && hasNode$1(n1, function (n2) {
      return n2.type === "FunctionTypeAnnotation" || undefined;
    }) || undefined;
  });
}

function endsWithRightBracket(node) {
  switch (node.type) {
    case "ObjectExpression":
      return true;

    default:
      return false;
  }
}

function isFollowedByRightBracket(path) {
  var node = path.getValue();
  var parent = path.getParentNode();
  var name = path.getName();

  switch (parent.type) {
    case "NGPipeExpression":
      if (typeof name === "number" && parent.arguments[name] === node && parent.arguments.length - 1 === name) {
        return path.callParent(isFollowedByRightBracket);
      }

      break;

    case "ObjectProperty":
      if (name === "value") {
        var parentParent = path.getParentNode(1);
        return parentParent.properties[parentParent.properties.length - 1] === parent;
      }

      break;

    case "BinaryExpression":
    case "LogicalExpression":
      if (name === "right") {
        return path.callParent(isFollowedByRightBracket);
      }

      break;

    case "ConditionalExpression":
      if (name === "alternate") {
        return path.callParent(isFollowedByRightBracket);
      }

      break;

    case "UnaryExpression":
      if (parent.prefix) {
        return path.callParent(isFollowedByRightBracket);
      }

      break;
  }

  return false;
}

function shouldWrapFunctionForExportDefault(path, options) {
  var node = path.getValue();
  var parent = path.getParentNode();

  if (node.type === "FunctionExpression" || node.type === "ClassExpression") {
    return parent.type === "ExportDefaultDeclaration" || // in some cases the function is already wrapped
    // (e.g. `export default (function() {})();`)
    // in this case we don't need to add extra parens
    !needsParens(path, options);
  }

  if (!hasNakedLeftSide$1(node) || parent.type !== "ExportDefaultDeclaration" && needsParens(path, options)) {
    return false;
  }

  return path.call.apply(path, [function (childPath) {
    return shouldWrapFunctionForExportDefault(childPath, options);
  }].concat(getLeftSidePathName$1(path, node)));
}

var needsParens_1 = needsParens;

var _require$$0$builders$1 = doc.builders,
    concat$5 = _require$$0$builders$1.concat,
    join$3 = _require$$0$builders$1.join,
    line$1 = _require$$0$builders$1.line;

function printHtmlBinding(path, options, print) {
  var node = path.getValue();

  if (options.__onHtmlBindingRoot && path.getName() === null) {
    options.__onHtmlBindingRoot(node);
  }

  if (node.type !== "File") {
    return;
  }

  if (options.__isVueForBindingLeft) {
    return path.call(function (functionDeclarationPath) {
      var _functionDeclarationP = functionDeclarationPath.getValue(),
          params = _functionDeclarationP.params;

      return concat$5([params.length > 1 ? "(" : "", join$3(concat$5([",", line$1]), functionDeclarationPath.map(print, "params")), params.length > 1 ? ")" : ""]);
    }, "program", "body", 0);
  }

  if (options.__isVueSlotScope) {
    return path.call(function (functionDeclarationPath) {
      return join$3(concat$5([",", line$1]), functionDeclarationPath.map(print, "params"));
    }, "program", "body", 0);
  }
} // based on https://github.com/prettier/prettier/blob/master/src/language-html/syntax-vue.js isVueEventBindingExpression()


function isVueEventBindingExpression(node) {
  switch (node.type) {
    case "MemberExpression":
      switch (node.property.type) {
        case "Identifier":
        case "NumericLiteral":
        case "StringLiteral":
          return isVueEventBindingExpression(node.object);
      }

      return false;

    case "Identifier":
      return true;

    default:
      return false;
  }
}

var htmlBinding = {
  isVueEventBindingExpression,
  printHtmlBinding
};

function preprocess(ast, options) {
  switch (options.parser) {
    case "json":
    case "json5":
    case "json-stringify":
    case "__js_expression":
    case "__vue_expression":
      return Object.assign({}, ast, {
        type: options.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot",
        node: ast,
        comments: []
      });

    default:
      return ast;
  }
}

var preprocess_1 = preprocess;

var getParentExportDeclaration$1 = util.getParentExportDeclaration,
    isExportDeclaration$1 = util.isExportDeclaration,
    shouldFlatten$1 = util.shouldFlatten,
    getNextNonSpaceNonCommentCharacter$1 = util.getNextNonSpaceNonCommentCharacter,
    hasNewline$3 = util.hasNewline,
    hasNewlineInRange$2 = util.hasNewlineInRange,
    getLast$2 = util.getLast,
    getStringWidth$2 = util.getStringWidth,
    printString$1 = util.printString,
    printNumber$1 = util.printNumber,
    hasIgnoreComment$2 = util.hasIgnoreComment,
    hasNodeIgnoreComment$2 = util.hasNodeIgnoreComment,
    getPenultimate$1 = util.getPenultimate,
    startsWithNoLookaheadToken$1 = util.startsWithNoLookaheadToken,
    getIndentSize$1 = util.getIndentSize,
    matchAncestorTypes$1 = util.matchAncestorTypes,
    getPreferredQuote$1 = util.getPreferredQuote;
var isNextLineEmpty$2 = utilShared.isNextLineEmpty,
    isNextLineEmptyAfterIndex$1 = utilShared.isNextLineEmptyAfterIndex,
    getNextNonSpaceNonCommentCharacterIndex$2 = utilShared.getNextNonSpaceNonCommentCharacterIndex;
var insertPragma$1 = pragma.insertPragma;
var printHtmlBinding$1 = htmlBinding.printHtmlBinding,
    isVueEventBindingExpression$1 = htmlBinding.isVueEventBindingExpression;
var classChildNeedsASIProtection$1 = utils$2.classChildNeedsASIProtection,
    classPropMayCauseASIProblems$1 = utils$2.classPropMayCauseASIProblems,
    conditionalExpressionChainContainsJSX$1 = utils$2.conditionalExpressionChainContainsJSX,
    getFlowVariance$1 = utils$2.getFlowVariance,
    getLeftSidePathName$2 = utils$2.getLeftSidePathName,
    getTypeScriptMappedTypeModifier$1 = utils$2.getTypeScriptMappedTypeModifier,
    hasDanglingComments$1 = utils$2.hasDanglingComments,
    hasFlowAnnotationComment$1 = utils$2.hasFlowAnnotationComment,
    hasFlowShorthandAnnotationComment$2 = utils$2.hasFlowShorthandAnnotationComment,
    hasLeadingComment$3 = utils$2.hasLeadingComment,
    hasLeadingOwnLineComment$1 = utils$2.hasLeadingOwnLineComment,
    hasNakedLeftSide$2 = utils$2.hasNakedLeftSide,
    hasNewlineBetweenOrAfterDecorators$1 = utils$2.hasNewlineBetweenOrAfterDecorators,
    hasNgSideEffect$1 = utils$2.hasNgSideEffect,
    hasPrettierIgnore$1 = utils$2.hasPrettierIgnore,
    hasTrailingComment$1 = utils$2.hasTrailingComment,
    identity$1 = utils$2.identity,
    isBinaryish$1 = utils$2.isBinaryish,
    isCallOrOptionalCallExpression$1 = utils$2.isCallOrOptionalCallExpression,
    isEmptyJSXElement$1 = utils$2.isEmptyJSXElement,
    isFlowAnnotationComment$1 = utils$2.isFlowAnnotationComment,
    isFunctionCompositionArgs$1 = utils$2.isFunctionCompositionArgs,
    isFunctionNotation$1 = utils$2.isFunctionNotation,
    isFunctionOrArrowExpression$1 = utils$2.isFunctionOrArrowExpression,
    isGetterOrSetter$1 = utils$2.isGetterOrSetter,
    isJestEachTemplateLiteral$1 = utils$2.isJestEachTemplateLiteral,
    isJSXNode$1 = utils$2.isJSXNode,
    isJSXWhitespaceExpression$1 = utils$2.isJSXWhitespaceExpression,
    isLastStatement$1 = utils$2.isLastStatement,
    isLiteral$1 = utils$2.isLiteral,
    isLongCurriedCallExpression$1 = utils$2.isLongCurriedCallExpression,
    isMeaningfulJSXText$1 = utils$2.isMeaningfulJSXText,
    isMemberExpressionChain$1 = utils$2.isMemberExpressionChain,
    isMemberish$1 = utils$2.isMemberish,
    isNgForOf$1 = utils$2.isNgForOf,
    isNumericLiteral$1 = utils$2.isNumericLiteral,
    isObjectType$1 = utils$2.isObjectType,
    isObjectTypePropertyAFunction$1 = utils$2.isObjectTypePropertyAFunction,
    isSimpleFlowType$1 = utils$2.isSimpleFlowType,
    isSimpleTemplateLiteral$1 = utils$2.isSimpleTemplateLiteral,
    isStringLiteral$1 = utils$2.isStringLiteral,
    isStringPropSafeToCoerceToIdentifier$1 = utils$2.isStringPropSafeToCoerceToIdentifier,
    isTemplateOnItsOwnLine$1 = utils$2.isTemplateOnItsOwnLine,
    isTestCall$1 = utils$2.isTestCall,
    isTheOnlyJSXElementInMarkdown$1 = utils$2.isTheOnlyJSXElementInMarkdown,
    isTSXFile$1 = utils$2.isTSXFile,
    isTypeAnnotationAFunction$1 = utils$2.isTypeAnnotationAFunction,
    matchJsxWhitespaceRegex$1 = utils$2.matchJsxWhitespaceRegex,
    needsHardlineAfterDanglingComment$1 = utils$2.needsHardlineAfterDanglingComment,
    rawText$1 = utils$2.rawText,
    returnArgumentHasLeadingComment$1 = utils$2.returnArgumentHasLeadingComment;
var needsQuoteProps = new WeakMap();
var _require$$5$builders = doc.builders,
    concat$6 = _require$$5$builders.concat,
    join$4 = _require$$5$builders.join,
    line$2 = _require$$5$builders.line,
    hardline$4 = _require$$5$builders.hardline,
    softline$2 = _require$$5$builders.softline,
    literalline$2 = _require$$5$builders.literalline,
    group$2 = _require$$5$builders.group,
    indent$3 = _require$$5$builders.indent,
    align$1 = _require$$5$builders.align,
    conditionalGroup$1 = _require$$5$builders.conditionalGroup,
    fill$2 = _require$$5$builders.fill,
    ifBreak$1 = _require$$5$builders.ifBreak,
    breakParent$2 = _require$$5$builders.breakParent,
    lineSuffixBoundary$1 = _require$$5$builders.lineSuffixBoundary,
    addAlignmentToDoc$2 = _require$$5$builders.addAlignmentToDoc,
    dedent$1 = _require$$5$builders.dedent,
    _require$$5$utils = doc.utils,
    willBreak$1 = _require$$5$utils.willBreak,
    isLineNext$1 = _require$$5$utils.isLineNext,
    isEmpty$1 = _require$$5$utils.isEmpty,
    removeLines$1 = _require$$5$utils.removeLines,
    printDocToString$2 = doc.printer.printDocToString;
var uid = 0;

function shouldPrintComma(options, level) {
  level = level || "es5";

  switch (options.trailingComma) {
    case "all":
      if (level === "all") {
        return true;
      }

    // fallthrough

    case "es5":
      if (level === "es5") {
        return true;
      }

    // fallthrough

    case "none":
    default:
      return false;
  }
}

function genericPrint(path, options, printPath, args) {
  var node = path.getValue();
  var needsParens = false;
  var linesWithoutParens = printPathNoParens(path, options, printPath, args);

  if (!node || isEmpty$1(linesWithoutParens)) {
    return linesWithoutParens;
  }

  var parentExportDecl = getParentExportDeclaration$1(path);
  var decorators = [];

  if (node.type === "ClassMethod" || node.type === "ClassPrivateMethod" || node.type === "ClassProperty" || node.type === "TSAbstractClassProperty" || node.type === "ClassPrivateProperty" || node.type === "MethodDefinition" || node.type === "TSAbstractMethodDefinition") ; else if (node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration and the decorator
  // was written before the export, the export will be responsible
  // for printing the decorators.
  !(parentExportDecl && options.locStart(parentExportDecl, {
    ignoreDecorators: true
  }) > options.locStart(node.decorators[0]))) {
    var shouldBreak = node.type === "ClassExpression" || node.type === "ClassDeclaration" || hasNewlineBetweenOrAfterDecorators$1(node, options);
    var separator = shouldBreak ? hardline$4 : line$2;
    path.each(function (decoratorPath) {
      var decorator = decoratorPath.getValue();

      if (decorator.expression) {
        decorator = decorator.expression;
      } else {
        decorator = decorator.callee;
      }

      decorators.push(printPath(decoratorPath), separator);
    }, "decorators");

    if (parentExportDecl) {
      decorators.unshift(hardline$4);
    }
  } else if (isExportDeclaration$1(node) && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0 && // Only print decorators here if they were written before the export,
  // otherwise they are printed by the node.declaration
  options.locStart(node, {
    ignoreDecorators: true
  }) > options.locStart(node.declaration.decorators[0])) {
    // Export declarations are responsible for printing any decorators
    // that logically apply to node.declaration.
    path.each(function (decoratorPath) {
      var decorator = decoratorPath.getValue();
      var prefix = decorator.type === "Decorator" ? "" : "@";
      decorators.push(prefix, printPath(decoratorPath), hardline$4);
    }, "declaration", "decorators");
  } else {
    // Nodes with decorators can't have parentheses, so we can avoid
    // computing pathNeedsParens() except in this case.
    needsParens = needsParens_1(path, options);
  }

  var parts = [];

  if (needsParens) {
    parts.unshift("(");
  }

  parts.push(linesWithoutParens);

  if (needsParens) {
    var _node = path.getValue();

    if (hasFlowShorthandAnnotationComment$2(_node)) {
      parts.push(" /*");
      parts.push(_node.trailingComments[0].value.trimLeft());
      parts.push("*/");
      _node.trailingComments[0].printed = true;
    }

    parts.push(")");
  }

  if (decorators.length > 0) {
    return group$2(concat$6(decorators.concat(parts)));
  }

  return concat$6(parts);
}

function printDecorators(path, options, print) {
  var node = path.getValue();
  return group$2(concat$6([join$4(line$2, path.map(print, "decorators")), hasNewlineBetweenOrAfterDecorators$1(node, options) ? hardline$4 : line$2]));
}
/**
 * The following is the shared logic for
 * ternary operators, namely ConditionalExpression
 * and TSConditionalType
 * @typedef {Object} OperatorOptions
 * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.
 * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.
 * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.
 * @property {string} conditionalNodeType - The type of the conditional expression node, ie "ConditionalExpression" or "TSConditionalType".
 * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg "consequent".
 * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg "alternate".
 * @property {string} testNodePropertyName - The property at which the test node can be found on the main node, eg "test".
 * @property {boolean} breakNested - Whether to break all nested ternaries when one breaks.
 * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.
 * @param {Options} options - Prettier options
 * @param {Function} print - Print function to call recursively
 * @param {OperatorOptions} operatorOptions
 * @returns Doc
 */


function printTernaryOperator(path, options, print, operatorOptions) {
  var node = path.getValue();
  var testNode = node[operatorOptions.testNodePropertyName];
  var consequentNode = node[operatorOptions.consequentNodePropertyName];
  var alternateNode = node[operatorOptions.alternateNodePropertyName];
  var parts = []; // We print a ConditionalExpression in either "JSX mode" or "normal mode".
  // See tests/jsx/conditional-expression.js for more info.

  var jsxMode = false;
  var parent = path.getParentNode();
  var forceNoIndent = parent.type === operatorOptions.conditionalNodeType; // Find the outermost non-ConditionalExpression parent, and the outermost
  // ConditionalExpression parent. We'll use these to determine if we should
  // print in JSX mode.

  var currentParent;
  var previousParent;
  var i = 0;

  do {
    previousParent = currentParent || node;
    currentParent = path.getParentNode(i);
    i++;
  } while (currentParent && currentParent.type === operatorOptions.conditionalNodeType);

  var firstNonConditionalParent = currentParent || parent;
  var lastConditionalParent = previousParent;

  if (operatorOptions.shouldCheckJsx && (isJSXNode$1(testNode) || isJSXNode$1(consequentNode) || isJSXNode$1(alternateNode) || conditionalExpressionChainContainsJSX$1(lastConditionalParent))) {
    jsxMode = true;
    forceNoIndent = true; // Even though they don't need parens, we wrap (almost) everything in
    // parens when using ?: within JSX, because the parens are analogous to
    // curly braces in an if statement.

    var wrap = function wrap(doc) {
      return concat$6([ifBreak$1("(", ""), indent$3(concat$6([softline$2, doc])), softline$2, ifBreak$1(")", "")]);
    }; // The only things we don't wrap are:
    // * Nested conditional expressions in alternates
    // * null


    var isNull = function isNull(node) {
      return node.type === "NullLiteral" || node.type === "Literal" && node.value === null;
    };

    parts.push(" ? ", isNull(consequentNode) ? path.call(print, operatorOptions.consequentNodePropertyName) : wrap(path.call(print, operatorOptions.consequentNodePropertyName)), " : ", alternateNode.type === operatorOptions.conditionalNodeType || isNull(alternateNode) ? path.call(print, operatorOptions.alternateNodePropertyName) : wrap(path.call(print, operatorOptions.alternateNodePropertyName)));
  } else {
    // normal mode
    var part = concat$6([line$2, "? ", consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak$1("", "(") : "", align$1(2, path.call(print, operatorOptions.consequentNodePropertyName)), consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak$1("", ")") : "", line$2, ": ", alternateNode.type === operatorOptions.conditionalNodeType ? path.call(print, operatorOptions.alternateNodePropertyName) : align$1(2, path.call(print, operatorOptions.alternateNodePropertyName))]);
    parts.push(parent.type !== operatorOptions.conditionalNodeType || parent[operatorOptions.alternateNodePropertyName] === node ? part : options.useTabs ? dedent$1(indent$3(part)) : align$1(Math.max(0, options.tabWidth - 2), part));
  } // We want a whole chain of ConditionalExpressions to all
  // break if any of them break. That means we should only group around the
  // outer-most ConditionalExpression.


  var maybeGroup = function maybeGroup(doc) {
    return operatorOptions.breakNested ? parent === firstNonConditionalParent ? group$2(doc) : doc : group$2(doc);
  }; // Break the closing paren to keep the chain right after it:
  // (a
  //   ? b
  //   : c
  // ).call()


  var breakClosingParen = !jsxMode && (parent.type === "MemberExpression" || parent.type === "OptionalMemberExpression" || parent.type === "NGPipeExpression" && parent.left === node && operatorOptions.breakNested) && !parent.computed;
  return maybeGroup(concat$6([].concat(function (testDoc) {
    return (
      /**
       *     a
       *       ? b
       *       : multiline
       *         test
       *         node
       *       ^^ align(2)
       *       ? d
       *       : e
       */
      parent.type === operatorOptions.conditionalNodeType && parent[operatorOptions.alternateNodePropertyName] === node ? align$1(2, testDoc) : testDoc
    );
  }(concat$6(operatorOptions.beforeParts())), forceNoIndent ? concat$6(parts) : indent$3(concat$6(parts)), operatorOptions.afterParts(breakClosingParen))));
}

function printPathNoParens(path, options, print, args) {
  var n = path.getValue();
  var semi = options.semi ? ";" : "";

  if (!n) {
    return "";
  }

  if (typeof n === "string") {
    return n;
  }

  var htmlBinding = printHtmlBinding$1(path, options, print);

  if (htmlBinding) {
    return htmlBinding;
  }

  var parts = [];

  switch (n.type) {
    case "JsExpressionRoot":
      return path.call(print, "node");

    case "JsonRoot":
      return concat$6([path.call(print, "node"), hardline$4]);

    case "File":
      // Print @babel/parser's InterpreterDirective here so that
      // leading comments on the `Program` node get printed after the hashbang.
      if (n.program && n.program.interpreter) {
        parts.push(path.call(function (programPath) {
          return programPath.call(print, "interpreter");
        }, "program"));
      }

      parts.push(path.call(print, "program"));
      return concat$6(parts);

    case "Program":
      // Babel 6
      if (n.directives) {
        path.each(function (childPath) {
          parts.push(print(childPath), semi, hardline$4);

          if (isNextLineEmpty$2(options.originalText, childPath.getValue(), options)) {
            parts.push(hardline$4);
          }
        }, "directives");
      }

      parts.push(path.call(function (bodyPath) {
        return printStatementSequence(bodyPath, options, print);
      }, "body"));
      parts.push(comments.printDanglingComments(path, options,
      /* sameIndent */
      true)); // Only force a trailing newline if there were any contents.

      if (n.body.length || n.comments) {
        parts.push(hardline$4);
      }

      return concat$6(parts);
    // Babel extension.

    case "EmptyStatement":
      return "";

    case "ExpressionStatement":
      // Detect Flow-parsed directives
      if (n.directive) {
        return concat$6([nodeStr(n.expression, options, true), semi]);
      }

      if (options.parser === "__vue_event_binding") {
        var parent = path.getParentNode();

        if (parent.type === "Program" && parent.body.length === 1 && parent.body[0] === n) {
          return concat$6([path.call(print, "expression"), isVueEventBindingExpression$1(n.expression) ? ";" : ""]);
        }
      } // Do not append semicolon after the only JSX element in a program


      return concat$6([path.call(print, "expression"), isTheOnlyJSXElementInMarkdown$1(options, path) ? "" : semi]);
    // Babel extension.

    case "ParenthesizedExpression":
      return concat$6(["(", path.call(print, "expression"), ")"]);

    case "AssignmentExpression":
      return printAssignment(n.left, path.call(print, "left"), concat$6([" ", n.operator]), n.right, path.call(print, "right"), options);

    case "BinaryExpression":
    case "LogicalExpression":
    case "NGPipeExpression":
      {
        var _parent = path.getParentNode();

        var parentParent = path.getParentNode(1);
        var isInsideParenthesis = n !== _parent.body && (_parent.type === "IfStatement" || _parent.type === "WhileStatement" || _parent.type === "SwitchStatement" || _parent.type === "DoWhileStatement");

        var _parts = printBinaryishExpressions(path, print, options,
        /* isNested */
        false, isInsideParenthesis); //   if (
        //     this.hasPlugin("dynamicImports") && this.lookahead().type === tt.parenLeft
        //   ) {
        //
        // looks super weird, we want to break the children if the parent breaks
        //
        //   if (
        //     this.hasPlugin("dynamicImports") &&
        //     this.lookahead().type === tt.parenLeft
        //   ) {


        if (isInsideParenthesis) {
          return concat$6(_parts);
        } // Break between the parens in
        // unaries or in a member or specific call expression, i.e.
        //
        //   (
        //     a &&
        //     b &&
        //     c
        //   ).call()


        if ((_parent.type === "CallExpression" || _parent.type === "OptionalCallExpression") && _parent.callee === n || _parent.type === "UnaryExpression" || (_parent.type === "MemberExpression" || _parent.type === "OptionalMemberExpression") && !_parent.computed) {
          return group$2(concat$6([indent$3(concat$6([softline$2, concat$6(_parts)])), softline$2]));
        } // Avoid indenting sub-expressions in some cases where the first sub-expression is already
        // indented accordingly. We should indent sub-expressions where the first case isn't indented.


        var shouldNotIndent = _parent.type === "ReturnStatement" || _parent.type === "JSXExpressionContainer" && parentParent.type === "JSXAttribute" || n.type !== "NGPipeExpression" && (_parent.type === "NGRoot" && options.parser === "__ng_binding" || _parent.type === "NGMicrosyntaxExpression" && parentParent.type === "NGMicrosyntax" && parentParent.body.length === 1) || n === _parent.body && _parent.type === "ArrowFunctionExpression" || n !== _parent.body && _parent.type === "ForStatement" || _parent.type === "ConditionalExpression" && parentParent.type !== "ReturnStatement" && parentParent.type !== "CallExpression" && parentParent.type !== "OptionalCallExpression";
        var shouldIndentIfInlining = _parent.type === "AssignmentExpression" || _parent.type === "VariableDeclarator" || _parent.type === "ClassProperty" || _parent.type === "TSAbstractClassProperty" || _parent.type === "ClassPrivateProperty" || _parent.type === "ObjectProperty" || _parent.type === "Property";
        var samePrecedenceSubExpression = isBinaryish$1(n.left) && shouldFlatten$1(n.operator, n.left.operator);

        if (shouldNotIndent || shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(n) && shouldIndentIfInlining) {
          return group$2(concat$6(_parts));
        }

        if (_parts.length === 0) {
          return "";
        } // If the right part is a JSX node, we include it in a separate group to
        // prevent it breaking the whole chain, so we can print the expression like:
        //
        //   foo && bar && (
        //     <Foo>
        //       <Bar />
        //     </Foo>
        //   )


        var hasJSX = isJSXNode$1(n.right);
        var rest = concat$6(hasJSX ? _parts.slice(1, -1) : _parts.slice(1));
        var groupId = Symbol("logicalChain-" + ++uid);
        var chain = group$2(concat$6([// Don't include the initial expression in the indentation
        // level. The first item is guaranteed to be the first
        // left-most expression.
        _parts.length > 0 ? _parts[0] : "", indent$3(rest)]), {
          id: groupId
        });

        if (!hasJSX) {
          return chain;
        }

        var jsxPart = getLast$2(_parts);
        return group$2(concat$6([chain, ifBreak$1(indent$3(jsxPart), jsxPart, {
          groupId
        })]));
      }

    case "AssignmentPattern":
      return concat$6([path.call(print, "left"), " = ", path.call(print, "right")]);

    case "TSTypeAssertion":
      {
        var shouldBreakAfterCast = !(n.expression.type === "ArrayExpression" || n.expression.type === "ObjectExpression");
        var castGroup = group$2(concat$6(["<", indent$3(concat$6([softline$2, path.call(print, "typeAnnotation")])), softline$2, ">"]));
        var exprContents = concat$6([ifBreak$1("("), indent$3(concat$6([softline$2, path.call(print, "expression")])), softline$2, ifBreak$1(")")]);

        if (shouldBreakAfterCast) {
          return conditionalGroup$1([concat$6([castGroup, path.call(print, "expression")]), concat$6([castGroup, group$2(exprContents, {
            shouldBreak: true
          })]), concat$6([castGroup, path.call(print, "expression")])]);
        }

        return group$2(concat$6([castGroup, path.call(print, "expression")]));
      }

    case "OptionalMemberExpression":
    case "MemberExpression":
      {
        var _parent2 = path.getParentNode();

        var firstNonMemberParent;
        var i = 0;

        do {
          firstNonMemberParent = path.getParentNode(i);
          i++;
        } while (firstNonMemberParent && (firstNonMemberParent.type === "MemberExpression" || firstNonMemberParent.type === "OptionalMemberExpression" || firstNonMemberParent.type === "TSNonNullExpression"));

        var shouldInline = firstNonMemberParent && (firstNonMemberParent.type === "NewExpression" || firstNonMemberParent.type === "BindExpression" || firstNonMemberParent.type === "VariableDeclarator" && firstNonMemberParent.id.type !== "Identifier" || firstNonMemberParent.type === "AssignmentExpression" && firstNonMemberParent.left.type !== "Identifier") || n.computed || n.object.type === "Identifier" && n.property.type === "Identifier" && _parent2.type !== "MemberExpression" && _parent2.type !== "OptionalMemberExpression";
        return concat$6([path.call(print, "object"), shouldInline ? printMemberLookup(path, options, print) : group$2(indent$3(concat$6([softline$2, printMemberLookup(path, options, print)])))]);
      }

    case "MetaProperty":
      return concat$6([path.call(print, "meta"), ".", path.call(print, "property")]);

    case "BindExpression":
      if (n.object) {
        parts.push(path.call(print, "object"));
      }

      parts.push(group$2(indent$3(concat$6([softline$2, printBindExpressionCallee(path, options, print)]))));
      return concat$6(parts);

    case "Identifier":
      {
        return concat$6([n.name, printOptionalToken(path), printTypeAnnotation(path, options, print)]);
      }

    case "V8IntrinsicIdentifier":
      return concat$6(["%", n.name]);

    case "SpreadElement":
    case "SpreadElementPattern":
    case "RestProperty":
    case "SpreadProperty":
    case "SpreadPropertyPattern":
    case "RestElement":
    case "ObjectTypeSpreadProperty":
      return concat$6(["...", path.call(print, "argument"), printTypeAnnotation(path, options, print)]);

    case "FunctionDeclaration":
    case "FunctionExpression":
      parts.push(printFunctionDeclaration(path, print, options));

      if (!n.body) {
        parts.push(semi);
      }

      return concat$6(parts);

    case "ArrowFunctionExpression":
      {
        if (n.async) {
          parts.push("async ");
        }

        if (shouldPrintParamsWithoutParens(path, options)) {
          parts.push(path.call(print, "params", 0));
        } else {
          parts.push(group$2(concat$6([printFunctionParams(path, print, options,
          /* expandLast */
          args && (args.expandLastArg || args.expandFirstArg),
          /* printTypeParams */
          true), printReturnType(path, print, options)])));
        }

        var dangling = comments.printDanglingComments(path, options,
        /* sameIndent */
        true, function (comment) {
          var nextCharacter = getNextNonSpaceNonCommentCharacterIndex$2(options.originalText, comment, options);
          return options.originalText.substr(nextCharacter, 2) === "=>";
        });

        if (dangling) {
          parts.push(" ", dangling);
        }

        parts.push(" =>");
        var body = path.call(function (bodyPath) {
          return print(bodyPath, args);
        }, "body"); // We want to always keep these types of nodes on the same line
        // as the arrow.

        if (!hasLeadingOwnLineComment$1(options.originalText, n.body, options) && (n.body.type === "ArrayExpression" || n.body.type === "ObjectExpression" || n.body.type === "BlockStatement" || isJSXNode$1(n.body) || isTemplateOnItsOwnLine$1(n.body, options.originalText, options) || n.body.type === "ArrowFunctionExpression" || n.body.type === "DoExpression")) {
          return group$2(concat$6([concat$6(parts), " ", body]));
        } // We handle sequence expressions as the body of arrows specially,
        // so that the required parentheses end up on their own lines.


        if (n.body.type === "SequenceExpression") {
          return group$2(concat$6([concat$6(parts), group$2(concat$6([" (", indent$3(concat$6([softline$2, body])), softline$2, ")"]))]));
        } // if the arrow function is expanded as last argument, we are adding a
        // level of indentation and need to add a softline to align the closing )
        // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)
        // we should align the expression's closing } with the line with the opening {.


        var shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === "JSXExpressionContainer") && !(n.comments && n.comments.length);
        var printTrailingComma = args && args.expandLastArg && shouldPrintComma(options, "all"); // In order to avoid confusion between
        // a => a ? a : a
        // a <= a ? a : a

        var shouldAddParens = n.body.type === "ConditionalExpression" && !startsWithNoLookaheadToken$1(n.body,
        /* forbidFunctionAndClass */
        false);
        return group$2(concat$6([concat$6(parts), group$2(concat$6([indent$3(concat$6([line$2, shouldAddParens ? ifBreak$1("", "(") : "", body, shouldAddParens ? ifBreak$1("", ")") : ""])), shouldAddSoftLine ? concat$6([ifBreak$1(printTrailingComma ? "," : ""), softline$2]) : ""]))]));
      }

    case "YieldExpression":
      parts.push("yield");

      if (n.delegate) {
        parts.push("*");
      }

      if (n.argument) {
        parts.push(" ", path.call(print, "argument"));
      }

      return concat$6(parts);

    case "AwaitExpression":
      {
        parts.push("await ", path.call(print, "argument"));

        var _parent3 = path.getParentNode();

        if ((_parent3.type === "CallExpression" || _parent3.type === "OptionalCallExpression") && _parent3.callee === n || (_parent3.type === "MemberExpression" || _parent3.type === "OptionalMemberExpression") && _parent3.object === n) {
          return group$2(concat$6([indent$3(concat$6([softline$2, concat$6(parts)])), softline$2]));
        }

        return concat$6(parts);
      }

    case "ImportSpecifier":
      if (n.importKind) {
        parts.push(path.call(print, "importKind"), " ");
      }

      parts.push(path.call(print, "imported"));

      if (n.local && n.local.name !== n.imported.name) {
        parts.push(" as ", path.call(print, "local"));
      }

      return concat$6(parts);

    case "ExportSpecifier":
      parts.push(path.call(print, "local"));

      if (n.exported && n.exported.name !== n.local.name) {
        parts.push(" as ", path.call(print, "exported"));
      }

      return concat$6(parts);

    case "ImportNamespaceSpecifier":
      parts.push("* as ");
      parts.push(path.call(print, "local"));
      return concat$6(parts);

    case "ImportDefaultSpecifier":
      return path.call(print, "local");

    case "TSExportAssignment":
      return concat$6(["export = ", path.call(print, "expression"), semi]);

    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
      return printExportDeclaration(path, options, print);

    case "ExportAllDeclaration":
      parts.push("export ");

      if (n.exportKind === "type") {
        parts.push("type ");
      }

      parts.push("* from ", path.call(print, "source"), semi);
      return concat$6(parts);

    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return path.call(print, "exported");

    case "ImportDeclaration":
      {
        parts.push("import ");

        if (n.importKind && n.importKind !== "value") {
          parts.push(n.importKind + " ");
        }

        var standalones = [];
        var grouped = [];

        if (n.specifiers && n.specifiers.length > 0) {
          path.each(function (specifierPath) {
            var value = specifierPath.getValue();

            if (value.type === "ImportDefaultSpecifier" || value.type === "ImportNamespaceSpecifier") {
              standalones.push(print(specifierPath));
            } else {
              grouped.push(print(specifierPath));
            }
          }, "specifiers");

          if (standalones.length > 0) {
            parts.push(join$4(", ", standalones));
          }

          if (standalones.length > 0 && grouped.length > 0) {
            parts.push(", ");
          }

          if (grouped.length === 1 && standalones.length === 0 && n.specifiers && !n.specifiers.some(function (node) {
            return node.comments;
          })) {
            parts.push(concat$6(["{", options.bracketSpacing ? " " : "", concat$6(grouped), options.bracketSpacing ? " " : "", "}"]));
          } else if (grouped.length >= 1) {
            parts.push(group$2(concat$6(["{", indent$3(concat$6([options.bracketSpacing ? line$2 : softline$2, join$4(concat$6([",", line$2]), grouped)])), ifBreak$1(shouldPrintComma(options) ? "," : ""), options.bracketSpacing ? line$2 : softline$2, "}"])));
          }

          parts.push(" from ");
        } else if (n.importKind && n.importKind === "type" || // import {} from 'x'
        /{\s*}/.test(options.originalText.slice(options.locStart(n), options.locStart(n.source)))) {
          parts.push("{} from ");
        }

        parts.push(path.call(print, "source"), semi);
        return concat$6(parts);
      }

    case "Import":
      return "import";

    case "TSModuleBlock":
    case "BlockStatement":
      {
        var naked = path.call(function (bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        }, "body");
        var hasContent = n.body.find(function (node) {
          return node.type !== "EmptyStatement";
        });
        var hasDirectives = n.directives && n.directives.length > 0;

        var _parent4 = path.getParentNode();

        var _parentParent = path.getParentNode(1);

        if (!hasContent && !hasDirectives && !hasDanglingComments$1(n) && (_parent4.type === "ArrowFunctionExpression" || _parent4.type === "FunctionExpression" || _parent4.type === "FunctionDeclaration" || _parent4.type === "ObjectMethod" || _parent4.type === "ClassMethod" || _parent4.type === "ClassPrivateMethod" || _parent4.type === "ForStatement" || _parent4.type === "WhileStatement" || _parent4.type === "DoWhileStatement" || _parent4.type === "DoExpression" || _parent4.type === "CatchClause" && !_parentParent.finalizer || _parent4.type === "TSModuleDeclaration")) {
          return "{}";
        }

        parts.push("{"); // Babel 6

        if (hasDirectives) {
          path.each(function (childPath) {
            parts.push(indent$3(concat$6([hardline$4, print(childPath), semi])));

            if (isNextLineEmpty$2(options.originalText, childPath.getValue(), options)) {
              parts.push(hardline$4);
            }
          }, "directives");
        }

        if (hasContent) {
          parts.push(indent$3(concat$6([hardline$4, naked])));
        }

        parts.push(comments.printDanglingComments(path, options));
        parts.push(hardline$4, "}");
        return concat$6(parts);
      }

    case "ReturnStatement":
      parts.push("return");

      if (n.argument) {
        if (returnArgumentHasLeadingComment$1(options, n.argument)) {
          parts.push(concat$6([" (", indent$3(concat$6([hardline$4, path.call(print, "argument")])), hardline$4, ")"]));
        } else if (n.argument.type === "LogicalExpression" || n.argument.type === "BinaryExpression" || n.argument.type === "SequenceExpression") {
          parts.push(group$2(concat$6([ifBreak$1(" (", " "), indent$3(concat$6([softline$2, path.call(print, "argument")])), softline$2, ifBreak$1(")")])));
        } else {
          parts.push(" ", path.call(print, "argument"));
        }
      }

      if (hasDanglingComments$1(n)) {
        parts.push(" ", comments.printDanglingComments(path, options,
        /* sameIndent */
        true));
      }

      parts.push(semi);
      return concat$6(parts);

    case "NewExpression":
    case "OptionalCallExpression":
    case "CallExpression":
      {
        var isNew = n.type === "NewExpression";
        var optional = printOptionalToken(path);

        if ( // We want to keep CommonJS- and AMD-style require calls, and AMD-style
        // define calls, as a unit.
        // e.g. `define(["some/lib", (lib) => {`
        !isNew && n.callee.type === "Identifier" && (n.callee.name === "require" || n.callee.name === "define") || // Template literals as single arguments
        n.arguments.length === 1 && isTemplateOnItsOwnLine$1(n.arguments[0], options.originalText, options) || // Keep test declarations on a single line
        // e.g. `it('long name', () => {`
        !isNew && isTestCall$1(n, path.getParentNode())) {
          return concat$6([isNew ? "new " : "", path.call(print, "callee"), optional, printFunctionTypeParameters(path, options, print), concat$6(["(", join$4(", ", path.map(print, "arguments")), ")"])]);
        } // Inline Flow annotation comments following Identifiers in Call nodes need to
        // stay with the Identifier. For example:
        //
        // foo /*:: <SomeGeneric> */(bar);
        //
        // Here, we ensure that such comments stay between the Identifier and the Callee.


        var isIdentifierWithFlowAnnotation = n.callee.type === "Identifier" && hasFlowAnnotationComment$1(n.callee.trailingComments);

        if (isIdentifierWithFlowAnnotation) {
          n.callee.trailingComments[0].printed = true;
        } // We detect calls on member lookups and possibly print them in a
        // special chain format. See `printMemberChain` for more info.


        if (!isNew && isMemberish$1(n.callee)) {
          return printMemberChain(path, options, print);
        }

        var contents = concat$6([isNew ? "new " : "", path.call(print, "callee"), optional, isIdentifierWithFlowAnnotation ? `/*:: ${n.callee.trailingComments[0].value.substring(2).trim()} */` : "", printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]); // We group here when the callee is itself a call expression.
        // See `isLongCurriedCallExpression` for more info.

        if (isCallOrOptionalCallExpression$1(n.callee)) {
          return group$2(contents);
        }

        return contents;
      }

    case "TSInterfaceDeclaration":
      if (n.declare) {
        parts.push("declare ");
      }

      parts.push(n.abstract ? "abstract " : "", printTypeScriptModifiers(path, options, print), "interface ", path.call(print, "id"), n.typeParameters ? path.call(print, "typeParameters") : "", " ");

      if (n.extends && n.extends.length) {
        parts.push(group$2(indent$3(concat$6([softline$2, "extends ", (n.extends.length === 1 ? identity$1 : indent$3)(join$4(concat$6([",", line$2]), path.map(print, "extends"))), " "]))));
      }

      parts.push(path.call(print, "body"));
      return concat$6(parts);

    case "ObjectTypeInternalSlot":
      return concat$6([n.static ? "static " : "", "[[", path.call(print, "id"), "]]", printOptionalToken(path), n.method ? "" : ": ", path.call(print, "value")]);

    case "ObjectExpression":
    case "ObjectPattern":
    case "ObjectTypeAnnotation":
    case "TSInterfaceBody":
    case "TSTypeLiteral":
      {
        var propertiesField;

        if (n.type === "TSTypeLiteral") {
          propertiesField = "members";
        } else if (n.type === "TSInterfaceBody") {
          propertiesField = "body";
        } else {
          propertiesField = "properties";
        }

        var isTypeAnnotation = n.type === "ObjectTypeAnnotation";
        var fields = [];

        if (isTypeAnnotation) {
          fields.push("indexers", "callProperties", "internalSlots");
        }

        fields.push(propertiesField);
        var firstProperty = fields.map(function (field) {
          return n[field][0];
        }).sort(function (a, b) {
          return options.locStart(a) - options.locStart(b);
        })[0];

        var _parent5 = path.getParentNode(0);

        var isFlowInterfaceLikeBody = isTypeAnnotation && _parent5 && (_parent5.type === "InterfaceDeclaration" || _parent5.type === "DeclareInterface" || _parent5.type === "DeclareClass") && path.getName() === "body";
        var shouldBreak = n.type === "TSInterfaceBody" || isFlowInterfaceLikeBody || n.type === "ObjectPattern" && _parent5.type !== "FunctionDeclaration" && _parent5.type !== "FunctionExpression" && _parent5.type !== "ArrowFunctionExpression" && _parent5.type !== "ObjectMethod" && _parent5.type !== "ClassMethod" && _parent5.type !== "ClassPrivateMethod" && _parent5.type !== "AssignmentPattern" && _parent5.type !== "CatchClause" && n.properties.some(function (property) {
          return property.value && (property.value.type === "ObjectPattern" || property.value.type === "ArrayPattern");
        }) || n.type !== "ObjectPattern" && firstProperty && hasNewlineInRange$2(options.originalText, options.locStart(n), options.locStart(firstProperty));
        var separator = isFlowInterfaceLikeBody ? ";" : n.type === "TSInterfaceBody" || n.type === "TSTypeLiteral" ? ifBreak$1(semi, ";") : ",";
        var leftBrace = n.exact ? "{|" : "{";
        var rightBrace = n.exact ? "|}" : "}"; // Unfortunately, things are grouped together in the ast can be
        // interleaved in the source code. So we need to reorder them before
        // printing them.

        var propsAndLoc = [];
        fields.forEach(function (field) {
          path.each(function (childPath) {
            var node = childPath.getValue();
            propsAndLoc.push({
              node: node,
              printed: print(childPath),
              loc: options.locStart(node)
            });
          }, field);
        });
        var separatorParts = [];
        var props = propsAndLoc.sort(function (a, b) {
          return a.loc - b.loc;
        }).map(function (prop) {
          var result = concat$6(separatorParts.concat(group$2(prop.printed)));
          separatorParts = [separator, line$2];

          if ((prop.node.type === "TSPropertySignature" || prop.node.type === "TSMethodSignature" || prop.node.type === "TSConstructSignatureDeclaration") && hasNodeIgnoreComment$2(prop.node)) {
            separatorParts.shift();
          }

          if (isNextLineEmpty$2(options.originalText, prop.node, options)) {
            separatorParts.push(hardline$4);
          }

          return result;
        });

        if (n.inexact) {
          props.push(concat$6(separatorParts.concat(group$2("..."))));
        }

        var lastElem = getLast$2(n[propertiesField]);
        var canHaveTrailingSeparator = !(lastElem && (lastElem.type === "RestProperty" || lastElem.type === "RestElement" || hasNodeIgnoreComment$2(lastElem) || n.inexact));
        var content;

        if (props.length === 0) {
          if (!hasDanglingComments$1(n)) {
            return concat$6([leftBrace, rightBrace, printTypeAnnotation(path, options, print)]);
          }

          content = group$2(concat$6([leftBrace, comments.printDanglingComments(path, options), softline$2, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]));
        } else {
          content = concat$6([leftBrace, indent$3(concat$6([options.bracketSpacing ? line$2 : softline$2, concat$6(props)])), ifBreak$1(canHaveTrailingSeparator && (separator !== "," || shouldPrintComma(options)) ? separator : ""), concat$6([options.bracketSpacing ? line$2 : softline$2, rightBrace]), printOptionalToken(path), printTypeAnnotation(path, options, print)]);
        } // If we inline the object as first argument of the parent, we don't want
        // to create another group so that the object breaks before the return
        // type


        var parentParentParent = path.getParentNode(2);

        if (n.type === "ObjectPattern" && _parent5 && shouldHugArguments(_parent5) && !n.decorators && _parent5.params[0] === n || shouldHugType(n) && parentParentParent && shouldHugArguments(parentParentParent) && parentParentParent.params[0].typeAnnotation && parentParentParent.params[0].typeAnnotation.typeAnnotation === n) {
          return content;
        }

        return group$2(content, {
          shouldBreak
        });
      }
    // Babel 6

    case "ObjectProperty": // Non-standard AST node type.

    case "Property":
      if (n.method || n.kind === "get" || n.kind === "set") {
        return printMethod(path, options, print);
      }

      if (n.shorthand) {
        parts.push(path.call(print, "value"));
      } else {
        parts.push(printAssignment(n.key, printPropertyKey(path, options, print), ":", n.value, path.call(print, "value"), options));
      }

      return concat$6(parts);
    // Babel 6

    case "ClassMethod":
    case "ClassPrivateMethod":
    case "MethodDefinition":
    case "TSAbstractMethodDefinition":
      if (n.decorators && n.decorators.length !== 0) {
        parts.push(printDecorators(path, options, print));
      }

      if (n.accessibility) {
        parts.push(n.accessibility + " ");
      }

      if (n.static) {
        parts.push("static ");
      }

      if (n.type === "TSAbstractMethodDefinition") {
        parts.push("abstract ");
      }

      parts.push(printMethod(path, options, print));
      return concat$6(parts);

    case "ObjectMethod":
      return printMethod(path, options, print);

    case "Decorator":
      return concat$6(["@", path.call(print, "expression"), path.call(print, "callee")]);

    case "ArrayExpression":
    case "ArrayPattern":
      if (n.elements.length === 0) {
        if (!hasDanglingComments$1(n)) {
          parts.push("[]");
        } else {
          parts.push(group$2(concat$6(["[", comments.printDanglingComments(path, options), softline$2, "]"])));
        }
      } else {
        var _lastElem = getLast$2(n.elements);

        var canHaveTrailingComma = !(_lastElem && _lastElem.type === "RestElement"); // JavaScript allows you to have empty elements in an array which
        // changes its length based on the number of commas. The algorithm
        // is that if the last argument is null, we need to force insert
        // a comma to ensure JavaScript recognizes it.
        //   [,].length === 1
        //   [1,].length === 1
        //   [1,,].length === 2
        //
        // Note that getLast returns null if the array is empty, but
        // we already check for an empty array just above so we are safe

        var needsForcedTrailingComma = canHaveTrailingComma && _lastElem === null;

        var _shouldBreak = n.elements.length > 1 && n.elements.every(function (element, i, elements) {
          var elementType = element && element.type;

          if (elementType !== "ArrayExpression" && elementType !== "ObjectExpression") {
            return false;
          }

          var nextElement = elements[i + 1];

          if (nextElement && elementType !== nextElement.type) {
            return false;
          }

          var itemsKey = elementType === "ArrayExpression" ? "elements" : "properties";
          return element[itemsKey] && element[itemsKey].length > 1;
        });

        parts.push(group$2(concat$6(["[", indent$3(concat$6([softline$2, printArrayItems(path, options, "elements", print)])), needsForcedTrailingComma ? "," : "", ifBreak$1(canHaveTrailingComma && !needsForcedTrailingComma && shouldPrintComma(options) ? "," : ""), comments.printDanglingComments(path, options,
        /* sameIndent */
        true), softline$2, "]"]), {
          shouldBreak: _shouldBreak
        }));
      }

      parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));
      return concat$6(parts);

    case "SequenceExpression":
      {
        var _parent6 = path.getParentNode(0);

        if (_parent6.type === "ExpressionStatement" || _parent6.type === "ForStatement") {
          // For ExpressionStatements and for-loop heads, which are among
          // the few places a SequenceExpression appears unparenthesized, we want
          // to indent expressions after the first.
          var _parts2 = [];
          path.each(function (p) {
            if (p.getName() === 0) {
              _parts2.push(print(p));
            } else {
              _parts2.push(",", indent$3(concat$6([line$2, print(p)])));
            }
          }, "expressions");
          return group$2(concat$6(_parts2));
        }

        return group$2(concat$6([join$4(concat$6([",", line$2]), path.map(print, "expressions"))]));
      }

    case "ThisExpression":
      return "this";

    case "Super":
      return "super";

    case "NullLiteral":
      // Babel 6 Literal split
      return "null";

    case "RegExpLiteral":
      // Babel 6 Literal split
      return printRegex(n);

    case "NumericLiteral":
      // Babel 6 Literal split
      return printNumber$1(n.extra.raw);

    case "BigIntLiteral":
      // babel: n.extra.raw, typescript: n.raw, flow: n.bigint
      return (n.bigint || (n.extra ? n.extra.raw : n.raw)).toLowerCase();

    case "BooleanLiteral": // Babel 6 Literal split

    case "StringLiteral": // Babel 6 Literal split

    case "Literal":
      {
        if (n.regex) {
          return printRegex(n.regex);
        }

        if (typeof n.value === "number") {
          return printNumber$1(n.raw);
        }

        if (typeof n.value !== "string") {
          return "" + n.value;
        } // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2
        // See corresponding workaround in needs-parens.js


        var grandParent = path.getParentNode(1);
        var isTypeScriptDirective = options.parser === "typescript" && typeof n.value === "string" && grandParent && (grandParent.type === "Program" || grandParent.type === "BlockStatement");
        return nodeStr(n, options, isTypeScriptDirective);
      }

    case "Directive":
      return path.call(print, "value");
    // Babel 6

    case "DirectiveLiteral":
      return nodeStr(n, options);

    case "UnaryExpression":
      parts.push(n.operator);

      if (/[a-z]$/.test(n.operator)) {
        parts.push(" ");
      }

      if (n.argument.comments && n.argument.comments.length > 0) {
        parts.push(group$2(concat$6(["(", indent$3(concat$6([softline$2, path.call(print, "argument")])), softline$2, ")"])));
      } else {
        parts.push(path.call(print, "argument"));
      }

      return concat$6(parts);

    case "UpdateExpression":
      parts.push(path.call(print, "argument"), n.operator);

      if (n.prefix) {
        parts.reverse();
      }

      return concat$6(parts);

    case "ConditionalExpression":
      return printTernaryOperator(path, options, print, {
        beforeParts: function beforeParts() {
          return [path.call(print, "test")];
        },
        afterParts: function afterParts(breakClosingParen) {
          return [breakClosingParen ? softline$2 : ""];
        },
        shouldCheckJsx: true,
        conditionalNodeType: "ConditionalExpression",
        consequentNodePropertyName: "consequent",
        alternateNodePropertyName: "alternate",
        testNodePropertyName: "test",
        breakNested: true
      });

    case "VariableDeclaration":
      {
        var printed = path.map(function (childPath) {
          return print(childPath);
        }, "declarations"); // We generally want to terminate all variable declarations with a
        // semicolon, except when they in the () part of for loops.

        var parentNode = path.getParentNode();
        var isParentForLoop = parentNode.type === "ForStatement" || parentNode.type === "ForInStatement" || parentNode.type === "ForOfStatement" || parentNode.type === "ForAwaitStatement";
        var hasValue = n.declarations.some(function (decl) {
          return decl.init;
        });
        var firstVariable;

        if (printed.length === 1 && !n.declarations[0].comments) {
          firstVariable = printed[0];
        } else if (printed.length > 0) {
          // Indent first var to comply with eslint one-var rule
          firstVariable = indent$3(printed[0]);
        }

        parts = [n.declare ? "declare " : "", n.kind, firstVariable ? concat$6([" ", firstVariable]) : "", indent$3(concat$6(printed.slice(1).map(function (p) {
          return concat$6([",", hasValue && !isParentForLoop ? hardline$4 : line$2, p]);
        })))];

        if (!(isParentForLoop && parentNode.body !== n)) {
          parts.push(semi);
        }

        return group$2(concat$6(parts));
      }

    case "TSTypeAliasDeclaration":
      {
        if (n.declare) {
          parts.push("declare ");
        }

        var _printed = printAssignmentRight(n.id, n.typeAnnotation, n.typeAnnotation && path.call(print, "typeAnnotation"), options);

        parts.push("type ", path.call(print, "id"), path.call(print, "typeParameters"), " =", _printed, semi);
        return group$2(concat$6(parts));
      }

    case "VariableDeclarator":
      return printAssignment(n.id, path.call(print, "id"), " =", n.init, n.init && path.call(print, "init"), options);

    case "WithStatement":
      return group$2(concat$6(["with (", path.call(print, "object"), ")", adjustClause(n.body, path.call(print, "body"))]));

    case "IfStatement":
      {
        var con = adjustClause(n.consequent, path.call(print, "consequent"));
        var opening = group$2(concat$6(["if (", group$2(concat$6([indent$3(concat$6([softline$2, path.call(print, "test")])), softline$2])), ")", con]));
        parts.push(opening);

        if (n.alternate) {
          var commentOnOwnLine = hasTrailingComment$1(n.consequent) && n.consequent.comments.some(function (comment) {
            return comment.trailing && !comments$1.isBlockComment(comment);
          }) || needsHardlineAfterDanglingComment$1(n);
          var elseOnSameLine = n.consequent.type === "BlockStatement" && !commentOnOwnLine;
          parts.push(elseOnSameLine ? " " : hardline$4);

          if (hasDanglingComments$1(n)) {
            parts.push(comments.printDanglingComments(path, options, true), commentOnOwnLine ? hardline$4 : " ");
          }

          parts.push("else", group$2(adjustClause(n.alternate, path.call(print, "alternate"), n.alternate.type === "IfStatement")));
        }

        return concat$6(parts);
      }

    case "ForStatement":
      {
        var _body = adjustClause(n.body, path.call(print, "body")); // We want to keep dangling comments above the loop to stay consistent.
        // Any comment positioned between the for statement and the parentheses
        // is going to be printed before the statement.


        var _dangling = comments.printDanglingComments(path, options,
        /* sameLine */
        true);

        var printedComments = _dangling ? concat$6([_dangling, softline$2]) : "";

        if (!n.init && !n.test && !n.update) {
          return concat$6([printedComments, group$2(concat$6(["for (;;)", _body]))]);
        }

        return concat$6([printedComments, group$2(concat$6(["for (", group$2(concat$6([indent$3(concat$6([softline$2, path.call(print, "init"), ";", line$2, path.call(print, "test"), ";", line$2, path.call(print, "update")])), softline$2])), ")", _body]))]);
      }

    case "WhileStatement":
      return group$2(concat$6(["while (", group$2(concat$6([indent$3(concat$6([softline$2, path.call(print, "test")])), softline$2])), ")", adjustClause(n.body, path.call(print, "body"))]));

    case "ForInStatement":
      // Note: esprima can't actually parse "for each (".
      return group$2(concat$6([n.each ? "for each (" : "for (", path.call(print, "left"), " in ", path.call(print, "right"), ")", adjustClause(n.body, path.call(print, "body"))]));

    case "ForOfStatement":
    case "ForAwaitStatement":
      {
        // Babel 7 removed ForAwaitStatement in favor of ForOfStatement
        // with `"await": true`:
        // https://github.com/estree/estree/pull/138
        var isAwait = n.type === "ForAwaitStatement" || n.await;
        return group$2(concat$6(["for", isAwait ? " await" : "", " (", path.call(print, "left"), " of ", path.call(print, "right"), ")", adjustClause(n.body, path.call(print, "body"))]));
      }

    case "DoWhileStatement":
      {
        var clause = adjustClause(n.body, path.call(print, "body"));
        var doBody = group$2(concat$6(["do", clause]));
        parts = [doBody];

        if (n.body.type === "BlockStatement") {
          parts.push(" ");
        } else {
          parts.push(hardline$4);
        }

        parts.push("while (");
        parts.push(group$2(concat$6([indent$3(concat$6([softline$2, path.call(print, "test")])), softline$2])), ")", semi);
        return concat$6(parts);
      }

    case "DoExpression":
      return concat$6(["do ", path.call(print, "body")]);

    case "BreakStatement":
      parts.push("break");

      if (n.label) {
        parts.push(" ", path.call(print, "label"));
      }

      parts.push(semi);
      return concat$6(parts);

    case "ContinueStatement":
      parts.push("continue");

      if (n.label) {
        parts.push(" ", path.call(print, "label"));
      }

      parts.push(semi);
      return concat$6(parts);

    case "LabeledStatement":
      if (n.body.type === "EmptyStatement") {
        return concat$6([path.call(print, "label"), ":;"]);
      }

      return concat$6([path.call(print, "label"), ": ", path.call(print, "body")]);

    case "TryStatement":
      return concat$6(["try ", path.call(print, "block"), n.handler ? concat$6([" ", path.call(print, "handler")]) : "", n.finalizer ? concat$6([" finally ", path.call(print, "finalizer")]) : ""]);

    case "CatchClause":
      if (n.param) {
        var hasComments = n.param.comments && n.param.comments.some(function (comment) {
          return !comments$1.isBlockComment(comment) || comment.leading && hasNewline$3(options.originalText, options.locEnd(comment)) || comment.trailing && hasNewline$3(options.originalText, options.locStart(comment), {
            backwards: true
          });
        });
        var param = path.call(print, "param");
        return concat$6(["catch ", hasComments ? concat$6(["(", indent$3(concat$6([softline$2, param])), softline$2, ") "]) : concat$6(["(", param, ") "]), path.call(print, "body")]);
      }

      return concat$6(["catch ", path.call(print, "body")]);

    case "ThrowStatement":
      return concat$6(["throw ", path.call(print, "argument"), semi]);
    // Note: ignoring n.lexical because it has no printing consequences.

    case "SwitchStatement":
      return concat$6([group$2(concat$6(["switch (", indent$3(concat$6([softline$2, path.call(print, "discriminant")])), softline$2, ")"])), " {", n.cases.length > 0 ? indent$3(concat$6([hardline$4, join$4(hardline$4, path.map(function (casePath) {
        var caseNode = casePath.getValue();
        return concat$6([casePath.call(print), n.cases.indexOf(caseNode) !== n.cases.length - 1 && isNextLineEmpty$2(options.originalText, caseNode, options) ? hardline$4 : ""]);
      }, "cases"))])) : "", hardline$4, "}"]);

    case "SwitchCase":
      {
        if (n.test) {
          parts.push("case ", path.call(print, "test"), ":");
        } else {
          parts.push("default:");
        }

        var consequent = n.consequent.filter(function (node) {
          return node.type !== "EmptyStatement";
        });

        if (consequent.length > 0) {
          var cons = path.call(function (consequentPath) {
            return printStatementSequence(consequentPath, options, print);
          }, "consequent");
          parts.push(consequent.length === 1 && consequent[0].type === "BlockStatement" ? concat$6([" ", cons]) : indent$3(concat$6([hardline$4, cons])));
        }

        return concat$6(parts);
      }
    // JSX extensions below.

    case "DebuggerStatement":
      return concat$6(["debugger", semi]);

    case "JSXAttribute":
      parts.push(path.call(print, "name"));

      if (n.value) {
        var res;

        if (isStringLiteral$1(n.value)) {
          var raw = rawText$1(n.value); // Unescape all quotes so we get an accurate preferred quote

          var final = raw.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          var quote = getPreferredQuote$1(final, options.jsxSingleQuote ? "'" : '"');

          var _escape = quote === "'" ? "&apos;" : "&quot;";

          final = final.slice(1, -1).replace(new RegExp(quote, "g"), _escape);
          res = concat$6([quote, final, quote]);
        } else {
          res = path.call(print, "value");
        }

        parts.push("=", res);
      }

      return concat$6(parts);

    case "JSXIdentifier":
      return "" + n.name;

    case "JSXNamespacedName":
      return join$4(":", [path.call(print, "namespace"), path.call(print, "name")]);

    case "JSXMemberExpression":
      return join$4(".", [path.call(print, "object"), path.call(print, "property")]);

    case "TSQualifiedName":
      return join$4(".", [path.call(print, "left"), path.call(print, "right")]);

    case "JSXSpreadAttribute":
    case "JSXSpreadChild":
      {
        return concat$6(["{", path.call(function (p) {
          var printed = concat$6(["...", print(p)]);
          var n = p.getValue();

          if (!n.comments || !n.comments.length) {
            return printed;
          }

          return concat$6([indent$3(concat$6([softline$2, comments.printComments(p, function () {
            return printed;
          }, options)])), softline$2]);
        }, n.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"]);
      }

    case "JSXExpressionContainer":
      {
        var _parent7 = path.getParentNode(0);

        var preventInline = _parent7.type === "JSXAttribute" && n.expression.comments && n.expression.comments.length > 0;

        var _shouldInline = !preventInline && (n.expression.type === "ArrayExpression" || n.expression.type === "ObjectExpression" || n.expression.type === "ArrowFunctionExpression" || n.expression.type === "CallExpression" || n.expression.type === "OptionalCallExpression" || n.expression.type === "FunctionExpression" || n.expression.type === "JSXEmptyExpression" || n.expression.type === "TemplateLiteral" || n.expression.type === "TaggedTemplateExpression" || n.expression.type === "DoExpression" || isJSXNode$1(_parent7) && (n.expression.type === "ConditionalExpression" || isBinaryish$1(n.expression)));

        if (_shouldInline) {
          return group$2(concat$6(["{", path.call(print, "expression"), lineSuffixBoundary$1, "}"]));
        }

        return group$2(concat$6(["{", indent$3(concat$6([softline$2, path.call(print, "expression")])), softline$2, lineSuffixBoundary$1, "}"]));
      }

    case "JSXFragment":
    case "JSXElement":
      {
        var elem = comments.printComments(path, function () {
          return printJSXElement(path, options, print);
        }, options);
        return maybeWrapJSXElementInParens(path, elem, options);
      }

    case "JSXOpeningElement":
      {
        var _n = path.getValue();

        var nameHasComments = _n.name && _n.name.comments && _n.name.comments.length > 0 || _n.typeParameters && _n.typeParameters.comments && _n.typeParameters.comments.length > 0; // Don't break self-closing elements with no attributes and no comments

        if (_n.selfClosing && !_n.attributes.length && !nameHasComments) {
          return concat$6(["<", path.call(print, "name"), path.call(print, "typeParameters"), " />"]);
        } // don't break up opening elements with a single long text attribute


        if (_n.attributes && _n.attributes.length === 1 && _n.attributes[0].value && isStringLiteral$1(_n.attributes[0].value) && !_n.attributes[0].value.value.includes("\n") && // We should break for the following cases:
        // <div
        //   // comment
        //   attr="value"
        // >
        // <div
        //   attr="value"
        //   // comment
        // >
        !nameHasComments && (!_n.attributes[0].comments || !_n.attributes[0].comments.length)) {
          return group$2(concat$6(["<", path.call(print, "name"), path.call(print, "typeParameters"), " ", concat$6(path.map(print, "attributes")), _n.selfClosing ? " />" : ">"]));
        }

        var lastAttrHasTrailingComments = _n.attributes.length && hasTrailingComment$1(getLast$2(_n.attributes));
        var bracketSameLine = // Simple tags (no attributes and no comment in tag name) should be
        // kept unbroken regardless of `jsxBracketSameLine`
        !_n.attributes.length && !nameHasComments || options.jsxBracketSameLine && ( // We should print the bracket in a new line for the following cases:
        // <div
        //   // comment
        // >
        // <div
        //   attr // comment
        // >
        !nameHasComments || _n.attributes.length) && !lastAttrHasTrailingComments; // We should print the opening element expanded if any prop value is a
        // string literal with newlines

        var _shouldBreak2 = _n.attributes && _n.attributes.some(function (attr) {
          return attr.value && isStringLiteral$1(attr.value) && attr.value.value.includes("\n");
        });

        return group$2(concat$6(["<", path.call(print, "name"), path.call(print, "typeParameters"), concat$6([indent$3(concat$6(path.map(function (attr) {
          return concat$6([line$2, print(attr)]);
        }, "attributes"))), _n.selfClosing ? line$2 : bracketSameLine ? ">" : softline$2]), _n.selfClosing ? "/>" : bracketSameLine ? "" : ">"]), {
          shouldBreak: _shouldBreak2
        });
      }

    case "JSXClosingElement":
      return concat$6(["</", path.call(print, "name"), ">"]);

    case "JSXOpeningFragment":
    case "JSXClosingFragment":
      {
        var hasComment = n.comments && n.comments.length;
        var hasOwnLineComment = hasComment && !n.comments.every(comments$1.isBlockComment);
        var isOpeningFragment = n.type === "JSXOpeningFragment";
        return concat$6([isOpeningFragment ? "<" : "</", indent$3(concat$6([hasOwnLineComment ? hardline$4 : hasComment && !isOpeningFragment ? " " : "", comments.printDanglingComments(path, options, true)])), hasOwnLineComment ? hardline$4 : "", ">"]);
      }

    case "JSXText":
      /* istanbul ignore next */
      throw new Error("JSXTest should be handled by JSXElement");

    case "JSXEmptyExpression":
      {
        var requiresHardline = n.comments && !n.comments.every(comments$1.isBlockComment);
        return concat$6([comments.printDanglingComments(path, options,
        /* sameIndent */
        !requiresHardline), requiresHardline ? hardline$4 : ""]);
      }

    case "ClassBody":
      if (!n.comments && n.body.length === 0) {
        return "{}";
      }

      return concat$6(["{", n.body.length > 0 ? indent$3(concat$6([hardline$4, path.call(function (bodyPath) {
        return printStatementSequence(bodyPath, options, print);
      }, "body")])) : comments.printDanglingComments(path, options), hardline$4, "}"]);

    case "ClassProperty":
    case "TSAbstractClassProperty":
    case "ClassPrivateProperty":
      {
        if (n.decorators && n.decorators.length !== 0) {
          parts.push(printDecorators(path, options, print));
        }

        if (n.accessibility) {
          parts.push(n.accessibility + " ");
        }

        if (n.declare) {
          parts.push("declare ");
        }

        if (n.static) {
          parts.push("static ");
        }

        if (n.type === "TSAbstractClassProperty") {
          parts.push("abstract ");
        }

        if (n.readonly) {
          parts.push("readonly ");
        }

        var variance = getFlowVariance$1(n);

        if (variance) {
          parts.push(variance);
        }

        parts.push(printPropertyKey(path, options, print), printOptionalToken(path), printTypeAnnotation(path, options, print));

        if (n.value) {
          parts.push(" =", printAssignmentRight(n.key, n.value, path.call(print, "value"), options));
        }

        parts.push(semi);
        return group$2(concat$6(parts));
      }

    case "ClassDeclaration":
    case "ClassExpression":
      if (n.declare) {
        parts.push("declare ");
      }

      parts.push(concat$6(printClass(path, options, print)));
      return concat$6(parts);

    case "TSInterfaceHeritage":
      parts.push(path.call(print, "expression"));

      if (n.typeParameters) {
        parts.push(path.call(print, "typeParameters"));
      }

      return concat$6(parts);

    case "TemplateElement":
      return join$4(literalline$2, n.value.raw.split(/\r?\n/g));

    case "TemplateLiteral":
      {
        var expressions = path.map(print, "expressions");

        var _parentNode = path.getParentNode();

        if (isJestEachTemplateLiteral$1(n, _parentNode)) {
          var _printed2 = printJestEachTemplateLiteral(n, expressions, options);

          if (_printed2) {
            return _printed2;
          }
        }

        var isSimple = isSimpleTemplateLiteral$1(n);

        if (isSimple) {
          expressions = expressions.map(function (doc) {
            return printDocToString$2(doc, Object.assign({}, options, {
              printWidth: Infinity
            })).formatted;
          });
        }

        parts.push(lineSuffixBoundary$1, "`");
        path.each(function (childPath) {
          var i = childPath.getName();
          parts.push(print(childPath));

          if (i < expressions.length) {
            // For a template literal of the following form:
            //   `someQuery {
            //     ${call({
            //       a,
            //       b,
            //     })}
            //   }`
            // the expression is on its own line (there is a \n in the previous
            // quasi literal), therefore we want to indent the JavaScript
            // expression inside at the beginning of ${ instead of the beginning
            // of the `.
            var tabWidth = options.tabWidth;
            var quasi = childPath.getValue();
            var indentSize = getIndentSize$1(quasi.value.raw, tabWidth);
            var _printed3 = expressions[i];

            if (!isSimple) {
              // Breaks at the template element boundaries (${ and }) are preferred to breaking
              // in the middle of a MemberExpression
              if (n.expressions[i].comments && n.expressions[i].comments.length || n.expressions[i].type === "MemberExpression" || n.expressions[i].type === "OptionalMemberExpression" || n.expressions[i].type === "ConditionalExpression") {
                _printed3 = concat$6([indent$3(concat$6([softline$2, _printed3])), softline$2]);
              }
            }

            var aligned = indentSize === 0 && quasi.value.raw.endsWith("\n") ? align$1(-Infinity, _printed3) : addAlignmentToDoc$2(_printed3, indentSize, tabWidth);
            parts.push(group$2(concat$6(["${", aligned, lineSuffixBoundary$1, "}"])));
          }
        }, "quasis");
        parts.push("`");
        return concat$6(parts);
      }
    // These types are unprintable because they serve as abstract
    // supertypes for other (printable) types.

    case "TaggedTemplateExpression":
      return concat$6([path.call(print, "tag"), path.call(print, "typeParameters"), path.call(print, "quasi")]);

    case "Node":
    case "Printable":
    case "SourceLocation":
    case "Position":
    case "Statement":
    case "Function":
    case "Pattern":
    case "Expression":
    case "Declaration":
    case "Specifier":
    case "NamedSpecifier":
    case "Comment":
    case "MemberTypeAnnotation": // Flow

    case "Type":
      /* istanbul ignore next */
      throw new Error("unprintable type: " + JSON.stringify(n.type));
    // Type Annotations for Facebook Flow, typically stripped out or
    // transformed away before printing.

    case "TypeAnnotation":
    case "TSTypeAnnotation":
      if (n.typeAnnotation) {
        return path.call(print, "typeAnnotation");
      }
      /* istanbul ignore next */


      return "";

    case "TSTupleType":
    case "TupleTypeAnnotation":
      {
        var typesField = n.type === "TSTupleType" ? "elementTypes" : "types";
        return group$2(concat$6(["[", indent$3(concat$6([softline$2, printArrayItems(path, options, typesField, print)])), ifBreak$1(shouldPrintComma(options, "all") ? "," : ""), comments.printDanglingComments(path, options,
        /* sameIndent */
        true), softline$2, "]"]));
      }

    case "ExistsTypeAnnotation":
      return "*";

    case "EmptyTypeAnnotation":
      return "empty";

    case "AnyTypeAnnotation":
      return "any";

    case "MixedTypeAnnotation":
      return "mixed";

    case "ArrayTypeAnnotation":
      return concat$6([path.call(print, "elementType"), "[]"]);

    case "BooleanTypeAnnotation":
      return "boolean";

    case "BooleanLiteralTypeAnnotation":
      return "" + n.value;

    case "DeclareClass":
      return printFlowDeclaration(path, printClass(path, options, print));

    case "TSDeclareFunction":
      // For TypeScript the TSDeclareFunction node shares the AST
      // structure with FunctionDeclaration
      return concat$6([n.declare ? "declare " : "", printFunctionDeclaration(path, print, options), semi]);

    case "DeclareFunction":
      return printFlowDeclaration(path, ["function ", path.call(print, "id"), n.predicate ? " " : "", path.call(print, "predicate"), semi]);

    case "DeclareModule":
      return printFlowDeclaration(path, ["module ", path.call(print, "id"), " ", path.call(print, "body")]);

    case "DeclareModuleExports":
      return printFlowDeclaration(path, ["module.exports", ": ", path.call(print, "typeAnnotation"), semi]);

    case "DeclareVariable":
      return printFlowDeclaration(path, ["var ", path.call(print, "id"), semi]);

    case "DeclareExportAllDeclaration":
      return concat$6(["declare export * from ", path.call(print, "source")]);

    case "DeclareExportDeclaration":
      return concat$6(["declare ", printExportDeclaration(path, options, print)]);

    case "DeclareOpaqueType":
    case "OpaqueType":
      {
        parts.push("opaque type ", path.call(print, "id"), path.call(print, "typeParameters"));

        if (n.supertype) {
          parts.push(": ", path.call(print, "supertype"));
        }

        if (n.impltype) {
          parts.push(" = ", path.call(print, "impltype"));
        }

        parts.push(semi);

        if (n.type === "DeclareOpaqueType") {
          return printFlowDeclaration(path, parts);
        }

        return concat$6(parts);
      }

    case "EnumDeclaration":
      return concat$6(["enum ", path.call(print, "id"), " ", path.call(print, "body")]);

    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
      {
        if (n.type === "EnumSymbolBody" || n.explicitType) {
          var type = null;

          switch (n.type) {
            case "EnumBooleanBody":
              type = "boolean";
              break;

            case "EnumNumberBody":
              type = "number";
              break;

            case "EnumStringBody":
              type = "string";
              break;

            case "EnumSymbolBody":
              type = "symbol";
              break;
          }

          parts.push("of ", type, " ");
        }

        if (n.members.length === 0) {
          parts.push(group$2(concat$6(["{", comments.printDanglingComments(path, options), softline$2, "}"])));
        } else {
          parts.push(group$2(concat$6(["{", indent$3(concat$6([hardline$4, printArrayItems(path, options, "members", print), shouldPrintComma(options) ? "," : ""])), comments.printDanglingComments(path, options,
          /* sameIndent */
          true), hardline$4, "}"])));
        }

        return concat$6(parts);
      }

    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
      return concat$6([path.call(print, "id"), " = ", typeof n.init === "object" ? path.call(print, "init") : String(n.init)]);

    case "EnumDefaultedMember":
      return path.call(print, "id");

    case "FunctionTypeAnnotation":
    case "TSFunctionType":
      {
        // FunctionTypeAnnotation is ambiguous:
        // declare function foo(a: B): void; OR
        // var A: (a: B) => void;
        var _parent8 = path.getParentNode(0);

        var _parentParent2 = path.getParentNode(1);

        var _parentParentParent = path.getParentNode(2);

        var isArrowFunctionTypeAnnotation = n.type === "TSFunctionType" || !((_parent8.type === "ObjectTypeProperty" || _parent8.type === "ObjectTypeInternalSlot") && !getFlowVariance$1(_parent8) && !_parent8.optional && options.locStart(_parent8) === options.locStart(n) || _parent8.type === "ObjectTypeCallProperty" || _parentParentParent && _parentParentParent.type === "DeclareFunction");
        var needsColon = isArrowFunctionTypeAnnotation && (_parent8.type === "TypeAnnotation" || _parent8.type === "TSTypeAnnotation"); // Sadly we can't put it inside of FastPath::needsColon because we are
        // printing ":" as part of the expression and it would put parenthesis
        // around :(

        var needsParens = needsColon && isArrowFunctionTypeAnnotation && (_parent8.type === "TypeAnnotation" || _parent8.type === "TSTypeAnnotation") && _parentParent2.type === "ArrowFunctionExpression";

        if (isObjectTypePropertyAFunction$1(_parent8, options)) {
          isArrowFunctionTypeAnnotation = true;
          needsColon = true;
        }

        if (needsParens) {
          parts.push("(");
        }

        parts.push(printFunctionParams(path, print, options,
        /* expandArg */
        false,
        /* printTypeParams */
        true)); // The returnType is not wrapped in a TypeAnnotation, so the colon
        // needs to be added separately.

        if (n.returnType || n.predicate || n.typeAnnotation) {
          parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path.call(print, "returnType"), path.call(print, "predicate"), path.call(print, "typeAnnotation"));
        }

        if (needsParens) {
          parts.push(")");
        }

        return group$2(concat$6(parts));
      }

    case "TSRestType":
      return concat$6(["...", path.call(print, "typeAnnotation")]);

    case "TSOptionalType":
      return concat$6([path.call(print, "typeAnnotation"), "?"]);

    case "FunctionTypeParam":
      return concat$6([path.call(print, "name"), printOptionalToken(path), n.name ? ": " : "", path.call(print, "typeAnnotation")]);

    case "GenericTypeAnnotation":
      return concat$6([path.call(print, "id"), path.call(print, "typeParameters")]);

    case "DeclareInterface":
    case "InterfaceDeclaration":
    case "InterfaceTypeAnnotation":
      {
        if (n.type === "DeclareInterface" || n.declare) {
          parts.push("declare ");
        }

        parts.push("interface");

        if (n.type === "DeclareInterface" || n.type === "InterfaceDeclaration") {
          parts.push(" ", path.call(print, "id"), path.call(print, "typeParameters"));
        }

        if (n["extends"].length > 0) {
          parts.push(group$2(indent$3(concat$6([line$2, "extends ", (n.extends.length === 1 ? identity$1 : indent$3)(join$4(concat$6([",", line$2]), path.map(print, "extends")))]))));
        }

        parts.push(" ", path.call(print, "body"));
        return group$2(concat$6(parts));
      }

    case "ClassImplements":
    case "InterfaceExtends":
      return concat$6([path.call(print, "id"), path.call(print, "typeParameters")]);

    case "TSClassImplements":
      return concat$6([path.call(print, "expression"), path.call(print, "typeParameters")]);

    case "TSIntersectionType":
    case "IntersectionTypeAnnotation":
      {
        var types = path.map(print, "types");
        var result = [];
        var wasIndented = false;

        for (var _i = 0; _i < types.length; ++_i) {
          if (_i === 0) {
            result.push(types[_i]);
          } else if (isObjectType$1(n.types[_i - 1]) && isObjectType$1(n.types[_i])) {
            // If both are objects, don't indent
            result.push(concat$6([" & ", wasIndented ? indent$3(types[_i]) : types[_i]]));
          } else if (!isObjectType$1(n.types[_i - 1]) && !isObjectType$1(n.types[_i])) {
            // If no object is involved, go to the next line if it breaks
            result.push(indent$3(concat$6([" &", line$2, types[_i]])));
          } else {
            // If you go from object to non-object or vis-versa, then inline it
            if (_i > 1) {
              wasIndented = true;
            }

            result.push(" & ", _i > 1 ? indent$3(types[_i]) : types[_i]);
          }
        }

        return group$2(concat$6(result));
      }

    case "TSUnionType":
    case "UnionTypeAnnotation":
      {
        // single-line variation
        // A | B | C
        // multi-line variation
        // | A
        // | B
        // | C
        var _parent9 = path.getParentNode(); // If there's a leading comment, the parent is doing the indentation


        var shouldIndent = _parent9.type !== "TypeParameterInstantiation" && _parent9.type !== "TSTypeParameterInstantiation" && _parent9.type !== "GenericTypeAnnotation" && _parent9.type !== "TSTypeReference" && _parent9.type !== "TSTypeAssertion" && _parent9.type !== "TupleTypeAnnotation" && _parent9.type !== "TSTupleType" && !(_parent9.type === "FunctionTypeParam" && !_parent9.name) && !((_parent9.type === "TypeAlias" || _parent9.type === "VariableDeclarator" || _parent9.type === "TSTypeAliasDeclaration") && hasLeadingOwnLineComment$1(options.originalText, n, options)); // {
        //   a: string
        // } | null | void
        // should be inlined and not be printed in the multi-line variant

        var shouldHug = shouldHugType(n); // We want to align the children but without its comment, so it looks like
        // | child1
        // // comment
        // | child2

        var _printed4 = path.map(function (typePath) {
          var printedType = typePath.call(print);

          if (!shouldHug) {
            printedType = align$1(2, printedType);
          }

          return comments.printComments(typePath, function () {
            return printedType;
          }, options);
        }, "types");

        if (shouldHug) {
          return join$4(" | ", _printed4);
        }

        var shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment$1(options.originalText, n, options);
        var code = concat$6([ifBreak$1(concat$6([shouldAddStartLine ? line$2 : "", "| "])), join$4(concat$6([line$2, "| "]), _printed4)]);

        if (needsParens_1(path, options)) {
          return group$2(concat$6([indent$3(code), softline$2]));
        }

        if (_parent9.type === "TupleTypeAnnotation" && _parent9.types.length > 1 || _parent9.type === "TSTupleType" && _parent9.elementTypes.length > 1) {
          return group$2(concat$6([indent$3(concat$6([ifBreak$1(concat$6(["(", softline$2])), code])), softline$2, ifBreak$1(")")]));
        }

        return group$2(shouldIndent ? indent$3(code) : code);
      }

    case "NullableTypeAnnotation":
      return concat$6(["?", path.call(print, "typeAnnotation")]);

    case "TSNullKeyword":
    case "NullLiteralTypeAnnotation":
      return "null";

    case "ThisTypeAnnotation":
      return "this";

    case "NumberTypeAnnotation":
      return "number";

    case "ObjectTypeCallProperty":
      if (n.static) {
        parts.push("static ");
      }

      parts.push(path.call(print, "value"));
      return concat$6(parts);

    case "ObjectTypeIndexer":
      {
        var _variance = getFlowVariance$1(n);

        return concat$6([_variance || "", "[", path.call(print, "id"), n.id ? ": " : "", path.call(print, "key"), "]: ", path.call(print, "value")]);
      }

    case "ObjectTypeProperty":
      {
        var _variance2 = getFlowVariance$1(n);

        var modifier = "";

        if (n.proto) {
          modifier = "proto ";
        } else if (n.static) {
          modifier = "static ";
        }

        return concat$6([modifier, isGetterOrSetter$1(n) ? n.kind + " " : "", _variance2 || "", printPropertyKey(path, options, print), printOptionalToken(path), isFunctionNotation$1(n, options) ? "" : ": ", path.call(print, "value")]);
      }

    case "QualifiedTypeIdentifier":
      return concat$6([path.call(print, "qualification"), ".", path.call(print, "id")]);

    case "StringLiteralTypeAnnotation":
      return nodeStr(n, options);

    case "NumberLiteralTypeAnnotation":
      assert$1.strictEqual(typeof n.value, "number");

      if (n.extra != null) {
        return printNumber$1(n.extra.raw);
      }

      return printNumber$1(n.raw);

    case "StringTypeAnnotation":
      return "string";

    case "DeclareTypeAlias":
    case "TypeAlias":
      {
        if (n.type === "DeclareTypeAlias" || n.declare) {
          parts.push("declare ");
        }

        var _printed5 = printAssignmentRight(n.id, n.right, path.call(print, "right"), options);

        parts.push("type ", path.call(print, "id"), path.call(print, "typeParameters"), " =", _printed5, semi);
        return group$2(concat$6(parts));
      }

    case "TypeCastExpression":
      {
        var value = path.getValue(); // Flow supports a comment syntax for specifying type annotations: https://flow.org/en/docs/types/comments/.
        // Unfortunately, its parser doesn't differentiate between comment annotations and regular
        // annotations when producing an AST. So to preserve parentheses around type casts that use
        // the comment syntax, we need to hackily read the source itself to see if the code contains
        // a type annotation comment.
        //
        // Note that we're able to use the normal whitespace regex here because the Flow parser has
        // already deemed this AST node to be a type cast. Only the Babel parser needs the
        // non-line-break whitespace regex, which is why hasFlowShorthandAnnotationComment() is
        // implemented differently.

        var commentSyntax = value && value.typeAnnotation && value.typeAnnotation.range && options.originalText.substring(value.typeAnnotation.range[0]).match(/^\/\*\s*:/);
        return concat$6(["(", path.call(print, "expression"), commentSyntax ? " /*" : "", ": ", path.call(print, "typeAnnotation"), commentSyntax ? " */" : "", ")"]);
      }

    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
      {
        var _value = path.getValue();

        var commentStart = _value.range ? options.originalText.substring(0, _value.range[0]).lastIndexOf("/*") : -1; // As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here
        // because we know for sure that this is a type definition.

        var _commentSyntax = commentStart >= 0 && options.originalText.substring(commentStart).match(/^\/\*\s*::/);

        if (_commentSyntax) {
          return concat$6(["/*:: ", printTypeParameters(path, options, print, "params"), " */"]);
        }

        return printTypeParameters(path, options, print, "params");
      }

    case "TSTypeParameterDeclaration":
    case "TSTypeParameterInstantiation":
      return printTypeParameters(path, options, print, "params");

    case "TSTypeParameter":
    case "TypeParameter":
      {
        var _parent10 = path.getParentNode();

        if (_parent10.type === "TSMappedType") {
          parts.push("[", path.call(print, "name"));

          if (n.constraint) {
            parts.push(" in ", path.call(print, "constraint"));
          }

          parts.push("]");
          return concat$6(parts);
        }

        var _variance3 = getFlowVariance$1(n);

        if (_variance3) {
          parts.push(_variance3);
        }

        parts.push(path.call(print, "name"));

        if (n.bound) {
          parts.push(": ");
          parts.push(path.call(print, "bound"));
        }

        if (n.constraint) {
          parts.push(" extends ", path.call(print, "constraint"));
        }

        if (n["default"]) {
          parts.push(" = ", path.call(print, "default"));
        } // Keep comma if the file extension is .tsx and
        // has one type parameter that isn't extend with any types.
        // Because, otherwise formatted result will be invalid as tsx.


        var _grandParent = path.getNode(2);

        if (_parent10.params && _parent10.params.length === 1 && isTSXFile$1(options) && !n.constraint && _grandParent.type === "ArrowFunctionExpression") {
          parts.push(",");
        }

        return concat$6(parts);
      }

    case "TypeofTypeAnnotation":
      return concat$6(["typeof ", path.call(print, "argument")]);

    case "VoidTypeAnnotation":
      return "void";

    case "InferredPredicate":
      return "%checks";
    // Unhandled types below. If encountered, nodes of these types should
    // be either left alone or desugared into AST types that are fully
    // supported by the pretty-printer.

    case "DeclaredPredicate":
      return concat$6(["%checks(", path.call(print, "value"), ")"]);

    case "TSAbstractKeyword":
      return "abstract";

    case "TSAnyKeyword":
      return "any";

    case "TSAsyncKeyword":
      return "async";

    case "TSBooleanKeyword":
      return "boolean";

    case "TSBigIntKeyword":
      return "bigint";

    case "TSConstKeyword":
      return "const";

    case "TSDeclareKeyword":
      return "declare";

    case "TSExportKeyword":
      return "export";

    case "TSNeverKeyword":
      return "never";

    case "TSNumberKeyword":
      return "number";

    case "TSObjectKeyword":
      return "object";

    case "TSProtectedKeyword":
      return "protected";

    case "TSPrivateKeyword":
      return "private";

    case "TSPublicKeyword":
      return "public";

    case "TSReadonlyKeyword":
      return "readonly";

    case "TSSymbolKeyword":
      return "symbol";

    case "TSStaticKeyword":
      return "static";

    case "TSStringKeyword":
      return "string";

    case "TSUndefinedKeyword":
      return "undefined";

    case "TSUnknownKeyword":
      return "unknown";

    case "TSVoidKeyword":
      return "void";

    case "TSAsExpression":
      return concat$6([path.call(print, "expression"), " as ", path.call(print, "typeAnnotation")]);

    case "TSArrayType":
      return concat$6([path.call(print, "elementType"), "[]"]);

    case "TSPropertySignature":
      {
        if (n.export) {
          parts.push("export ");
        }

        if (n.accessibility) {
          parts.push(n.accessibility + " ");
        }

        if (n.static) {
          parts.push("static ");
        }

        if (n.readonly) {
          parts.push("readonly ");
        }

        parts.push(printPropertyKey(path, options, print), printOptionalToken(path));

        if (n.typeAnnotation) {
          parts.push(": ");
          parts.push(path.call(print, "typeAnnotation"));
        } // This isn't valid semantically, but it's in the AST so we can print it.


        if (n.initializer) {
          parts.push(" = ", path.call(print, "initializer"));
        }

        return concat$6(parts);
      }

    case "TSParameterProperty":
      if (n.accessibility) {
        parts.push(n.accessibility + " ");
      }

      if (n.export) {
        parts.push("export ");
      }

      if (n.static) {
        parts.push("static ");
      }

      if (n.readonly) {
        parts.push("readonly ");
      }

      parts.push(path.call(print, "parameter"));
      return concat$6(parts);

    case "TSTypeReference":
      return concat$6([path.call(print, "typeName"), printTypeParameters(path, options, print, "typeParameters")]);

    case "TSTypeQuery":
      return concat$6(["typeof ", path.call(print, "exprName")]);

    case "TSIndexSignature":
      {
        var _parent11 = path.getParentNode();

        return concat$6([n.export ? "export " : "", n.accessibility ? concat$6([n.accessibility, " "]) : "", n.static ? "static " : "", n.readonly ? "readonly " : "", "[", n.parameters ? concat$6(path.map(print, "parameters")) : "", "]: ", path.call(print, "typeAnnotation"), _parent11.type === "ClassBody" ? semi : ""]);
      }

    case "TSTypePredicate":
      return concat$6([n.asserts ? "asserts " : "", path.call(print, "parameterName"), n.typeAnnotation ? concat$6([" is ", path.call(print, "typeAnnotation")]) : ""]);

    case "TSNonNullExpression":
      return concat$6([path.call(print, "expression"), "!"]);

    case "TSThisType":
      return "this";

    case "TSImportType":
      return concat$6([!n.isTypeOf ? "" : "typeof ", "import(", path.call(print, "parameter"), ")", !n.qualifier ? "" : concat$6([".", path.call(print, "qualifier")]), printTypeParameters(path, options, print, "typeParameters")]);

    case "TSLiteralType":
      return path.call(print, "literal");

    case "TSIndexedAccessType":
      return concat$6([path.call(print, "objectType"), "[", path.call(print, "indexType"), "]"]);

    case "TSConstructSignatureDeclaration":
    case "TSCallSignatureDeclaration":
    case "TSConstructorType":
      {
        if (n.type !== "TSCallSignatureDeclaration") {
          parts.push("new ");
        }

        parts.push(group$2(printFunctionParams(path, print, options,
        /* expandArg */
        false,
        /* printTypeParams */
        true)));

        if (n.returnType) {
          var isType = n.type === "TSConstructorType";
          parts.push(isType ? " => " : ": ", path.call(print, "returnType"));
        }

        return concat$6(parts);
      }

    case "TSTypeOperator":
      return concat$6([n.operator, " ", path.call(print, "typeAnnotation")]);

    case "TSMappedType":
      {
        var _shouldBreak3 = hasNewlineInRange$2(options.originalText, options.locStart(n), options.locEnd(n));

        return group$2(concat$6(["{", indent$3(concat$6([options.bracketSpacing ? line$2 : softline$2, n.readonly ? concat$6([getTypeScriptMappedTypeModifier$1(n.readonly, "readonly"), " "]) : "", printTypeScriptModifiers(path, options, print), path.call(print, "typeParameter"), n.optional ? getTypeScriptMappedTypeModifier$1(n.optional, "?") : "", ": ", path.call(print, "typeAnnotation"), ifBreak$1(semi, "")])), comments.printDanglingComments(path, options,
        /* sameIndent */
        true), options.bracketSpacing ? line$2 : softline$2, "}"]), {
          shouldBreak: _shouldBreak3
        });
      }

    case "TSMethodSignature":
      parts.push(n.accessibility ? concat$6([n.accessibility, " "]) : "", n.export ? "export " : "", n.static ? "static " : "", n.readonly ? "readonly " : "", n.computed ? "[" : "", path.call(print, "key"), n.computed ? "]" : "", printOptionalToken(path), printFunctionParams(path, print, options,
      /* expandArg */
      false,
      /* printTypeParams */
      true));

      if (n.returnType) {
        parts.push(": ", path.call(print, "returnType"));
      }

      return group$2(concat$6(parts));

    case "TSNamespaceExportDeclaration":
      parts.push("export as namespace ", path.call(print, "id"));

      if (options.semi) {
        parts.push(";");
      }

      return group$2(concat$6(parts));

    case "TSEnumDeclaration":
      if (n.declare) {
        parts.push("declare ");
      }

      if (n.modifiers) {
        parts.push(printTypeScriptModifiers(path, options, print));
      }

      if (n.const) {
        parts.push("const ");
      }

      parts.push("enum ", path.call(print, "id"), " ");

      if (n.members.length === 0) {
        parts.push(group$2(concat$6(["{", comments.printDanglingComments(path, options), softline$2, "}"])));
      } else {
        parts.push(group$2(concat$6(["{", indent$3(concat$6([hardline$4, printArrayItems(path, options, "members", print), shouldPrintComma(options, "es5") ? "," : ""])), comments.printDanglingComments(path, options,
        /* sameIndent */
        true), hardline$4, "}"])));
      }

      return concat$6(parts);

    case "TSEnumMember":
      parts.push(path.call(print, "id"));

      if (n.initializer) {
        parts.push(" = ", path.call(print, "initializer"));
      }

      return concat$6(parts);

    case "TSImportEqualsDeclaration":
      if (n.isExport) {
        parts.push("export ");
      }

      parts.push("import ", path.call(print, "id"), " = ", path.call(print, "moduleReference"));

      if (options.semi) {
        parts.push(";");
      }

      return group$2(concat$6(parts));

    case "TSExternalModuleReference":
      return concat$6(["require(", path.call(print, "expression"), ")"]);

    case "TSModuleDeclaration":
      {
        var _parent12 = path.getParentNode();

        var isExternalModule = isLiteral$1(n.id);
        var parentIsDeclaration = _parent12.type === "TSModuleDeclaration";
        var bodyIsDeclaration = n.body && n.body.type === "TSModuleDeclaration";

        if (parentIsDeclaration) {
          parts.push(".");
        } else {
          if (n.declare) {
            parts.push("declare ");
          }

          parts.push(printTypeScriptModifiers(path, options, print));
          var textBetweenNodeAndItsId = options.originalText.slice(options.locStart(n), options.locStart(n.id)); // Global declaration looks like this:
          // (declare)? global { ... }

          var isGlobalDeclaration = n.id.type === "Identifier" && n.id.name === "global" && !/namespace|module/.test(textBetweenNodeAndItsId);

          if (!isGlobalDeclaration) {
            parts.push(isExternalModule || /(^|\s)module(\s|$)/.test(textBetweenNodeAndItsId) ? "module " : "namespace ");
          }
        }

        parts.push(path.call(print, "id"));

        if (bodyIsDeclaration) {
          parts.push(path.call(print, "body"));
        } else if (n.body) {
          parts.push(" ", group$2(path.call(print, "body")));
        } else {
          parts.push(semi);
        }

        return concat$6(parts);
      }

    case "PrivateName":
      return concat$6(["#", path.call(print, "id")]);

    case "TSConditionalType":
      return printTernaryOperator(path, options, print, {
        beforeParts: function beforeParts() {
          return [path.call(print, "checkType"), " ", "extends", " ", path.call(print, "extendsType")];
        },
        afterParts: function afterParts() {
          return [];
        },
        shouldCheckJsx: false,
        conditionalNodeType: "TSConditionalType",
        consequentNodePropertyName: "trueType",
        alternateNodePropertyName: "falseType",
        testNodePropertyName: "checkType",
        breakNested: true
      });

    case "TSInferType":
      return concat$6(["infer", " ", path.call(print, "typeParameter")]);

    case "InterpreterDirective":
      parts.push("#!", n.value, hardline$4);

      if (isNextLineEmpty$2(options.originalText, n, options)) {
        parts.push(hardline$4);
      }

      return concat$6(parts);

    case "NGRoot":
      return concat$6([].concat(path.call(print, "node"), !n.node.comments || n.node.comments.length === 0 ? [] : concat$6([" //", n.node.comments[0].value.trimRight()])));

    case "NGChainedExpression":
      return group$2(join$4(concat$6([";", line$2]), path.map(function (childPath) {
        return hasNgSideEffect$1(childPath) ? print(childPath) : concat$6(["(", print(childPath), ")"]);
      }, "expressions")));

    case "NGEmptyExpression":
      return "";

    case "NGQuotedExpression":
      return concat$6([n.prefix, ":", n.value]);

    case "NGMicrosyntax":
      return concat$6(path.map(function (childPath, index) {
        return concat$6([index === 0 ? "" : isNgForOf$1(childPath.getValue(), index, n) ? " " : concat$6([";", line$2]), print(childPath)]);
      }, "body"));

    case "NGMicrosyntaxKey":
      return /^[a-z_$][a-z0-9_$]*(-[a-z_$][a-z0-9_$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);

    case "NGMicrosyntaxExpression":
      return concat$6([path.call(print, "expression"), n.alias === null ? "" : concat$6([" as ", path.call(print, "alias")])]);

    case "NGMicrosyntaxKeyedExpression":
      {
        var index = path.getName();

        var _parentNode2 = path.getParentNode();

        var shouldNotPrintColon = isNgForOf$1(n, index, _parentNode2) || (index === 1 && (n.key.name === "then" || n.key.name === "else") || index === 2 && n.key.name === "else" && _parentNode2.body[index - 1].type === "NGMicrosyntaxKeyedExpression" && _parentNode2.body[index - 1].key.name === "then") && _parentNode2.body[0].type === "NGMicrosyntaxExpression";
        return concat$6([path.call(print, "key"), shouldNotPrintColon ? " " : ": ", path.call(print, "expression")]);
      }

    case "NGMicrosyntaxLet":
      return concat$6(["let ", path.call(print, "key"), n.value === null ? "" : concat$6([" = ", path.call(print, "value")])]);

    case "NGMicrosyntaxAs":
      return concat$6([path.call(print, "key"), " as ", path.call(print, "alias")]);

    case "ArgumentPlaceholder":
      return "?";

    default:
      /* istanbul ignore next */
      throw new Error("unknown type: " + JSON.stringify(n.type));
  }
}

function printStatementSequence(path, options, print) {
  var printed = [];
  var bodyNode = path.getNode();
  var isClass = bodyNode.type === "ClassBody";
  path.map(function (stmtPath, i) {
    var stmt = stmtPath.getValue(); // Just in case the AST has been modified to contain falsy
    // "statements," it's safer simply to skip them.

    /* istanbul ignore if */

    if (!stmt) {
      return;
    } // Skip printing EmptyStatement nodes to avoid leaving stray
    // semicolons lying around.


    if (stmt.type === "EmptyStatement") {
      return;
    }

    var stmtPrinted = print(stmtPath);
    var text = options.originalText;
    var parts = []; // in no-semi mode, prepend statement with semicolon if it might break ASI
    // don't prepend the only JSX element in a program with semicolon

    if (!options.semi && !isClass && !isTheOnlyJSXElementInMarkdown$1(options, stmtPath) && stmtNeedsASIProtection(stmtPath, options)) {
      if (stmt.comments && stmt.comments.some(function (comment) {
        return comment.leading;
      })) {
        parts.push(print(stmtPath, {
          needsSemi: true
        }));
      } else {
        parts.push(";", stmtPrinted);
      }
    } else {
      parts.push(stmtPrinted);
    }

    if (!options.semi && isClass) {
      if (classPropMayCauseASIProblems$1(stmtPath)) {
        parts.push(";");
      } else if (stmt.type === "ClassProperty") {
        var nextChild = bodyNode.body[i + 1];

        if (classChildNeedsASIProtection$1(nextChild)) {
          parts.push(";");
        }
      }
    }

    if (isNextLineEmpty$2(text, stmt, options) && !isLastStatement$1(stmtPath)) {
      parts.push(hardline$4);
    }

    printed.push(concat$6(parts));
  });
  return join$4(hardline$4, printed);
}

function printPropertyKey(path, options, print) {
  var node = path.getNode();

  if (node.computed) {
    return concat$6(["[", path.call(print, "key"), "]"]);
  }

  var parent = path.getParentNode();
  var key = node.key;

  if (options.quoteProps === "consistent" && !needsQuoteProps.has(parent)) {
    var objectHasStringProp = (parent.properties || parent.body || parent.members).some(function (prop) {
      return !prop.computed && prop.key && isStringLiteral$1(prop.key) && !isStringPropSafeToCoerceToIdentifier$1(prop, options);
    });
    needsQuoteProps.set(parent, objectHasStringProp);
  }

  if (key.type === "Identifier" && (options.parser === "json" || options.quoteProps === "consistent" && needsQuoteProps.get(parent))) {
    // a -> "a"
    var prop = printString$1(JSON.stringify(key.name), options);
    return path.call(function (keyPath) {
      return comments.printComments(keyPath, function () {
        return prop;
      }, options);
    }, "key");
  }

  if (isStringPropSafeToCoerceToIdentifier$1(node, options) && (options.quoteProps === "as-needed" || options.quoteProps === "consistent" && !needsQuoteProps.get(parent))) {
    // 'a' -> a
    return path.call(function (keyPath) {
      return comments.printComments(keyPath, function () {
        return key.value;
      }, options);
    }, "key");
  }

  return path.call(print, "key");
}

function printMethod(path, options, print) {
  var node = path.getNode();
  var kind = node.kind;
  var value = node.value || node;
  var parts = [];

  if (!kind || kind === "init" || kind === "method" || kind === "constructor") {
    if (value.async) {
      parts.push("async ");
    }

    if (value.generator) {
      parts.push("*");
    }
  } else {
    assert$1.ok(kind === "get" || kind === "set");
    parts.push(kind, " ");
  }

  parts.push(printPropertyKey(path, options, print), node.optional || node.key.optional ? "?" : "", node === value ? printMethodInternal(path, options, print) : path.call(function (path) {
    return printMethodInternal(path, options, print);
  }, "value"));
  return concat$6(parts);
}

function printMethodInternal(path, options, print) {
  var parts = [printFunctionTypeParameters(path, options, print), group$2(concat$6([printFunctionParams(path, print, options), printReturnType(path, print, options)]))];

  if (path.getNode().body) {
    parts.push(" ", path.call(print, "body"));
  } else {
    parts.push(options.semi ? ";" : "");
  }

  return concat$6(parts);
}

function couldGroupArg(arg) {
  return arg.type === "ObjectExpression" && (arg.properties.length > 0 || arg.comments) || arg.type === "ArrayExpression" && (arg.elements.length > 0 || arg.comments) || arg.type === "TSTypeAssertion" && couldGroupArg(arg.expression) || arg.type === "TSAsExpression" && couldGroupArg(arg.expression) || arg.type === "FunctionExpression" || arg.type === "ArrowFunctionExpression" && ( // we want to avoid breaking inside composite return types but not simple keywords
  // https://github.com/prettier/prettier/issues/4070
  // export class Thing implements OtherThing {
  //   do: (type: Type) => Provider<Prop> = memoize(
  //     (type: ObjectType): Provider<Opts> => {}
  //   );
  // }
  // https://github.com/prettier/prettier/issues/6099
  // app.get("/", (req, res): void => {
  //   res.send("Hello World!");
  // });
  !arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== "TSTypeReference") && (arg.body.type === "BlockStatement" || arg.body.type === "ArrowFunctionExpression" || arg.body.type === "ObjectExpression" || arg.body.type === "ArrayExpression" || arg.body.type === "CallExpression" || arg.body.type === "OptionalCallExpression" || arg.body.type === "ConditionalExpression" || isJSXNode$1(arg.body));
}

function shouldGroupLastArg(args) {
  var lastArg = getLast$2(args);
  var penultimateArg = getPenultimate$1(args);
  return !hasLeadingComment$3(lastArg) && !hasTrailingComment$1(lastArg) && couldGroupArg(lastArg) && ( // If the last two arguments are of the same type,
  // disable last element expansion.
  !penultimateArg || penultimateArg.type !== lastArg.type);
}

function shouldGroupFirstArg(args) {
  if (args.length !== 2) {
    return false;
  }

  var firstArg = args[0];
  var secondArg = args[1];
  return (!firstArg.comments || !firstArg.comments.length) && (firstArg.type === "FunctionExpression" || firstArg.type === "ArrowFunctionExpression" && firstArg.body.type === "BlockStatement") && secondArg.type !== "FunctionExpression" && secondArg.type !== "ArrowFunctionExpression" && secondArg.type !== "ConditionalExpression" && !couldGroupArg(secondArg);
}

function printJestEachTemplateLiteral(node, expressions, options) {
  /**
   * a    | b    | expected
   * ${1} | ${1} | ${2}
   * ${1} | ${2} | ${3}
   * ${2} | ${1} | ${3}
   */
  var headerNames = node.quasis[0].value.raw.trim().split(/\s*\|\s*/);

  if (headerNames.length > 1 || headerNames.some(function (headerName) {
    return headerName.length !== 0;
  })) {
    var parts = [];
    var stringifiedExpressions = expressions.map(function (doc) {
      return "${" + printDocToString$2(doc, Object.assign({}, options, {
        printWidth: Infinity,
        endOfLine: "lf"
      })).formatted + "}";
    });
    var tableBody = [{
      hasLineBreak: false,
      cells: []
    }];

    for (var i = 1; i < node.quasis.length; i++) {
      var row = tableBody[tableBody.length - 1];
      var correspondingExpression = stringifiedExpressions[i - 1];
      row.cells.push(correspondingExpression);

      if (correspondingExpression.indexOf("\n") !== -1) {
        row.hasLineBreak = true;
      }

      if (node.quasis[i].value.raw.indexOf("\n") !== -1) {
        tableBody.push({
          hasLineBreak: false,
          cells: []
        });
      }
    }

    var maxColumnCount = tableBody.reduce(function (maxColumnCount, row) {
      return Math.max(maxColumnCount, row.cells.length);
    }, headerNames.length);
    var maxColumnWidths = Array.from(new Array(maxColumnCount), function () {
      return 0;
    });
    var table = [{
      cells: headerNames
    }].concat(tableBody.filter(function (row) {
      return row.cells.length !== 0;
    }));
    table.filter(function (row) {
      return !row.hasLineBreak;
    }).forEach(function (row) {
      row.cells.forEach(function (cell, index) {
        maxColumnWidths[index] = Math.max(maxColumnWidths[index], getStringWidth$2(cell));
      });
    });
    parts.push(lineSuffixBoundary$1, "`", indent$3(concat$6([hardline$4, join$4(hardline$4, table.map(function (row) {
      return join$4(" | ", row.cells.map(function (cell, index) {
        return row.hasLineBreak ? cell : cell + " ".repeat(maxColumnWidths[index] - getStringWidth$2(cell));
      }));
    }))])), hardline$4, "`");
    return concat$6(parts);
  }
}

function printArgumentsList(path, options, print) {
  var node = path.getValue();
  var args = node.arguments;

  if (args.length === 0) {
    return concat$6(["(", comments.printDanglingComments(path, options,
    /* sameIndent */
    true), ")"]);
  } // useEffect(() => { ... }, [foo, bar, baz])


  if (args.length === 2 && args[0].type === "ArrowFunctionExpression" && args[0].params.length === 0 && args[0].body.type === "BlockStatement" && args[1].type === "ArrayExpression" && !args.find(function (arg) {
    return arg.comments;
  })) {
    return concat$6(["(", path.call(print, "arguments", 0), ", ", path.call(print, "arguments", 1), ")"]);
  } // func(
  //   ({
  //     a,
  //     b
  //   }) => {}
  // );


  function shouldBreakForArrowFunctionInArguments(arg, argPath) {
    if (!arg || arg.type !== "ArrowFunctionExpression" || !arg.body || arg.body.type !== "BlockStatement" || !arg.params || arg.params.length < 1) {
      return false;
    }

    var shouldBreak = false;
    argPath.each(function (paramPath) {
      var printed = concat$6([print(paramPath)]);
      shouldBreak = shouldBreak || willBreak$1(printed);
    }, "params");
    return shouldBreak;
  }

  var anyArgEmptyLine = false;
  var shouldBreakForArrowFunction = false;
  var hasEmptyLineFollowingFirstArg = false;
  var lastArgIndex = args.length - 1;
  var printedArguments = path.map(function (argPath, index) {
    var arg = argPath.getNode();
    var parts = [print(argPath)];

    if (index === lastArgIndex) ; else if (isNextLineEmpty$2(options.originalText, arg, options)) {
      if (index === 0) {
        hasEmptyLineFollowingFirstArg = true;
      }

      anyArgEmptyLine = true;
      parts.push(",", hardline$4, hardline$4);
    } else {
      parts.push(",", line$2);
    }

    shouldBreakForArrowFunction = shouldBreakForArrowFunctionInArguments(arg, argPath);
    return concat$6(parts);
  }, "arguments");
  var maybeTrailingComma = // Dynamic imports cannot have trailing commas
  !(node.callee && node.callee.type === "Import") && shouldPrintComma(options, "all") ? "," : "";

  function allArgsBrokenOut() {
    return group$2(concat$6(["(", indent$3(concat$6([line$2, concat$6(printedArguments)])), maybeTrailingComma, line$2, ")"]), {
      shouldBreak: true
    });
  }

  if (isFunctionCompositionArgs$1(args)) {
    return allArgsBrokenOut();
  }

  var shouldGroupFirst = shouldGroupFirstArg(args);
  var shouldGroupLast = shouldGroupLastArg(args);

  if (shouldGroupFirst || shouldGroupLast) {
    var shouldBreak = (shouldGroupFirst ? printedArguments.slice(1).some(willBreak$1) : printedArguments.slice(0, -1).some(willBreak$1)) || anyArgEmptyLine || shouldBreakForArrowFunction; // We want to print the last argument with a special flag

    var printedExpanded;
    var i = 0;
    path.each(function (argPath) {
      if (shouldGroupFirst && i === 0) {
        printedExpanded = [concat$6([argPath.call(function (p) {
          return print(p, {
            expandFirstArg: true
          });
        }), printedArguments.length > 1 ? "," : "", hasEmptyLineFollowingFirstArg ? hardline$4 : line$2, hasEmptyLineFollowingFirstArg ? hardline$4 : ""])].concat(printedArguments.slice(1));
      }

      if (shouldGroupLast && i === args.length - 1) {
        printedExpanded = printedArguments.slice(0, -1).concat(argPath.call(function (p) {
          return print(p, {
            expandLastArg: true
          });
        }));
      }

      i++;
    }, "arguments");
    var somePrintedArgumentsWillBreak = printedArguments.some(willBreak$1);
    var simpleConcat = concat$6(["(", concat$6(printedExpanded), ")"]);
    return concat$6([somePrintedArgumentsWillBreak ? breakParent$2 : "", conditionalGroup$1([!somePrintedArgumentsWillBreak && !node.typeArguments && !node.typeParameters ? simpleConcat : ifBreak$1(allArgsBrokenOut(), simpleConcat), shouldGroupFirst ? concat$6(["(", group$2(printedExpanded[0], {
      shouldBreak: true
    }), concat$6(printedExpanded.slice(1)), ")"]) : concat$6(["(", concat$6(printedArguments.slice(0, -1)), group$2(getLast$2(printedExpanded), {
      shouldBreak: true
    }), ")"]), allArgsBrokenOut()], {
      shouldBreak
    })]);
  }

  var contents = concat$6(["(", indent$3(concat$6([softline$2, concat$6(printedArguments)])), ifBreak$1(maybeTrailingComma), softline$2, ")"]);

  if (isLongCurriedCallExpression$1(path)) {
    // By not wrapping the arguments in a group, the printer prioritizes
    // breaking up these arguments rather than the args of the parent call.
    return contents;
  }

  return group$2(contents, {
    shouldBreak: printedArguments.some(willBreak$1) || anyArgEmptyLine
  });
}

function printTypeAnnotation(path, options, print) {
  var node = path.getValue();

  if (!node.typeAnnotation) {
    return "";
  }

  var parentNode = path.getParentNode();
  var isDefinite = node.definite || parentNode && parentNode.type === "VariableDeclarator" && parentNode.definite;
  var isFunctionDeclarationIdentifier = parentNode.type === "DeclareFunction" && parentNode.id === node;

  if (isFlowAnnotationComment$1(options.originalText, node.typeAnnotation, options)) {
    return concat$6([" /*: ", path.call(print, "typeAnnotation"), " */"]);
  }

  return concat$6([isFunctionDeclarationIdentifier ? "" : isDefinite ? "!: " : ": ", path.call(print, "typeAnnotation")]);
}

function printFunctionTypeParameters(path, options, print) {
  var fun = path.getValue();

  if (fun.typeArguments) {
    return path.call(print, "typeArguments");
  }

  if (fun.typeParameters) {
    return path.call(print, "typeParameters");
  }

  return "";
}

function printFunctionParams(path, print, options, expandArg, printTypeParams) {
  var fun = path.getValue();
  var parent = path.getParentNode();
  var paramsField = fun.parameters ? "parameters" : "params";
  var isParametersInTestCall = isTestCall$1(parent);
  var shouldHugParameters = shouldHugArguments(fun);
  var shouldExpandParameters = expandArg && !(fun[paramsField] && fun[paramsField].some(function (n) {
    return n.comments;
  }));
  var typeParams = printTypeParams ? printFunctionTypeParameters(path, options, print) : "";
  var printed = [];

  if (fun[paramsField]) {
    var lastArgIndex = fun[paramsField].length - 1;
    printed = path.map(function (childPath, index) {
      var parts = [];
      var param = childPath.getValue();
      parts.push(print(childPath));

      if (index === lastArgIndex) {
        if (fun.rest) {
          parts.push(",", line$2);
        }
      } else if (isParametersInTestCall || shouldHugParameters || shouldExpandParameters) {
        parts.push(", ");
      } else if (isNextLineEmpty$2(options.originalText, param, options)) {
        parts.push(",", hardline$4, hardline$4);
      } else {
        parts.push(",", line$2);
      }

      return concat$6(parts);
    }, paramsField);
  }

  if (fun.rest) {
    printed.push(concat$6(["...", path.call(print, "rest")]));
  }

  if (printed.length === 0) {
    return concat$6([typeParams, "(", comments.printDanglingComments(path, options,
    /* sameIndent */
    true, function (comment) {
      return getNextNonSpaceNonCommentCharacter$1(options.originalText, comment, options.locEnd) === ")";
    }), ")"]);
  }

  var lastParam = getLast$2(fun[paramsField]); // If the parent is a call with the first/last argument expansion and this is the
  // params of the first/last argument, we don't want the arguments to break and instead
  // want the whole expression to be on a new line.
  //
  // Good:                 Bad:
  //   verylongcall(         verylongcall((
  //     (a, b) => {           a,
  //     }                     b,
  //   })                    ) => {
  //                         })

  if (shouldExpandParameters) {
    return group$2(concat$6([removeLines$1(typeParams), "(", concat$6(printed.map(removeLines$1)), ")"]));
  } // Single object destructuring should hug
  //
  // function({
  //   a,
  //   b,
  //   c
  // }) {}


  var hasNotParameterDecorator = fun[paramsField].every(function (param) {
    return !param.decorators;
  });

  if (shouldHugParameters && hasNotParameterDecorator) {
    return concat$6([typeParams, "(", concat$6(printed), ")"]);
  } // don't break in specs, eg; `it("should maintain parens around done even when long", (done) => {})`


  if (isParametersInTestCall) {
    return concat$6([typeParams, "(", concat$6(printed), ")"]);
  }

  var isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction$1(parent, options) || isTypeAnnotationAFunction$1(parent, options) || parent.type === "TypeAlias" || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType" || parent.type === "IntersectionTypeAnnotation" || parent.type === "FunctionTypeAnnotation" && parent.returnType === fun) && fun[paramsField].length === 1 && fun[paramsField][0].name === null && fun[paramsField][0].typeAnnotation && fun.typeParameters === null && isSimpleFlowType$1(fun[paramsField][0].typeAnnotation) && !fun.rest;

  if (isFlowShorthandWithOneArg) {
    if (options.arrowParens === "always") {
      return concat$6(["(", concat$6(printed), ")"]);
    }

    return concat$6(printed);
  }

  var canHaveTrailingComma = !(lastParam && lastParam.type === "RestElement") && !fun.rest;
  return concat$6([typeParams, "(", indent$3(concat$6([softline$2, concat$6(printed)])), ifBreak$1(canHaveTrailingComma && shouldPrintComma(options, "all") ? "," : ""), softline$2, ")"]);
}

function shouldPrintParamsWithoutParens(path, options) {
  if (options.arrowParens === "always") {
    return false;
  }

  if (options.arrowParens === "avoid") {
    var node = path.getValue();
    return canPrintParamsWithoutParens(node);
  } // Fallback default; should be unreachable


  return false;
}

function canPrintParamsWithoutParens(node) {
  return node.params.length === 1 && !node.rest && !node.typeParameters && !hasDanglingComments$1(node) && node.params[0].type === "Identifier" && !node.params[0].typeAnnotation && !node.params[0].comments && !node.params[0].optional && !node.predicate && !node.returnType;
}

function printFunctionDeclaration(path, print, options) {
  var n = path.getValue();
  var parts = [];

  if (n.async) {
    parts.push("async ");
  }

  parts.push("function");

  if (n.generator) {
    parts.push("*");
  }

  if (n.id) {
    parts.push(" ", path.call(print, "id"));
  }

  parts.push(printFunctionTypeParameters(path, options, print), group$2(concat$6([printFunctionParams(path, print, options), printReturnType(path, print, options)])), n.body ? " " : "", path.call(print, "body"));
  return concat$6(parts);
}

function printReturnType(path, print, options) {
  var n = path.getValue();
  var returnType = path.call(print, "returnType");

  if (n.returnType && isFlowAnnotationComment$1(options.originalText, n.returnType, options)) {
    return concat$6([" /*: ", returnType, " */"]);
  }

  var parts = [returnType]; // prepend colon to TypeScript type annotation

  if (n.returnType && n.returnType.typeAnnotation) {
    parts.unshift(": ");
  }

  if (n.predicate) {
    // The return type will already add the colon, but otherwise we
    // need to do it ourselves
    parts.push(n.returnType ? " " : ": ", path.call(print, "predicate"));
  }

  return concat$6(parts);
}

function printExportDeclaration(path, options, print) {
  var decl = path.getValue();
  var semi = options.semi ? ";" : "";
  var parts = ["export "];
  var isDefault = decl["default"] || decl.type === "ExportDefaultDeclaration";

  if (isDefault) {
    parts.push("default ");
  }

  parts.push(comments.printDanglingComments(path, options,
  /* sameIndent */
  true));

  if (needsHardlineAfterDanglingComment$1(decl)) {
    parts.push(hardline$4);
  }

  if (decl.declaration) {
    parts.push(path.call(print, "declaration"));

    if (isDefault && decl.declaration.type !== "ClassDeclaration" && decl.declaration.type !== "FunctionDeclaration" && decl.declaration.type !== "TSInterfaceDeclaration" && decl.declaration.type !== "DeclareClass" && decl.declaration.type !== "DeclareFunction" && decl.declaration.type !== "TSDeclareFunction") {
      parts.push(semi);
    }
  } else {
    if (decl.specifiers && decl.specifiers.length > 0) {
      var specifiers = [];
      var defaultSpecifiers = [];
      var namespaceSpecifiers = [];
      path.each(function (specifierPath) {
        var specifierType = path.getValue().type;

        if (specifierType === "ExportSpecifier") {
          specifiers.push(print(specifierPath));
        } else if (specifierType === "ExportDefaultSpecifier") {
          defaultSpecifiers.push(print(specifierPath));
        } else if (specifierType === "ExportNamespaceSpecifier") {
          namespaceSpecifiers.push(concat$6(["* as ", print(specifierPath)]));
        }
      }, "specifiers");
      var isNamespaceFollowed = namespaceSpecifiers.length !== 0 && specifiers.length !== 0;
      var isDefaultFollowed = defaultSpecifiers.length !== 0 && (namespaceSpecifiers.length !== 0 || specifiers.length !== 0);
      var canBreak = specifiers.length > 1 || defaultSpecifiers.length > 0 || decl.specifiers && decl.specifiers.some(function (node) {
        return node.comments;
      });
      var printed = "";

      if (specifiers.length !== 0) {
        if (canBreak) {
          printed = group$2(concat$6(["{", indent$3(concat$6([options.bracketSpacing ? line$2 : softline$2, join$4(concat$6([",", line$2]), specifiers)])), ifBreak$1(shouldPrintComma(options) ? "," : ""), options.bracketSpacing ? line$2 : softline$2, "}"]));
        } else {
          printed = concat$6(["{", options.bracketSpacing ? " " : "", concat$6(specifiers), options.bracketSpacing ? " " : "", "}"]);
        }
      }

      parts.push(decl.exportKind === "type" ? "type " : "", concat$6(defaultSpecifiers), concat$6([isDefaultFollowed ? ", " : ""]), concat$6(namespaceSpecifiers), concat$6([isNamespaceFollowed ? ", " : ""]), printed);
    } else {
      parts.push("{}");
    }

    if (decl.source) {
      parts.push(" from ", path.call(print, "source"));
    }

    parts.push(semi);
  }

  return concat$6(parts);
}

function printFlowDeclaration(path, parts) {
  var parentExportDecl = getParentExportDeclaration$1(path);

  if (parentExportDecl) {
    assert$1.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
  } else {
    // If the parent node has type DeclareExportDeclaration, then it
    // will be responsible for printing the "declare" token. Otherwise
    // it needs to be printed with this non-exported declaration node.
    parts.unshift("declare ");
  }

  return concat$6(parts);
}

function printTypeScriptModifiers(path, options, print) {
  var n = path.getValue();

  if (!n.modifiers || !n.modifiers.length) {
    return "";
  }

  return concat$6([join$4(" ", path.map(print, "modifiers")), " "]);
}

function printTypeParameters(path, options, print, paramsKey) {
  var n = path.getValue();

  if (!n[paramsKey]) {
    return "";
  } // for TypeParameterDeclaration typeParameters is a single node


  if (!Array.isArray(n[paramsKey])) {
    return path.call(print, paramsKey);
  }

  var grandparent = path.getNode(2);
  var greatGreatGrandParent = path.getNode(4);
  var isParameterInTestCall = grandparent != null && isTestCall$1(grandparent);
  var shouldInline = isParameterInTestCall || n[paramsKey].length === 0 || n[paramsKey].length === 1 && (shouldHugType(n[paramsKey][0]) || n[paramsKey][0].type === "GenericTypeAnnotation" && shouldHugType(n[paramsKey][0].id) || n[paramsKey][0].type === "TSTypeReference" && shouldHugType(n[paramsKey][0].typeName) || n[paramsKey][0].type === "NullableTypeAnnotation" || // See https://github.com/prettier/prettier/pull/6467 for the context.
  greatGreatGrandParent && greatGreatGrandParent.type === "VariableDeclarator" && grandparent && grandparent.type === "TSTypeAnnotation" && n[paramsKey][0].type !== "TSUnionType" && n[paramsKey][0].type !== "UnionTypeAnnotation" && n[paramsKey][0].type !== "TSConditionalType" && n[paramsKey][0].type !== "TSMappedType");

  if (shouldInline) {
    return concat$6(["<", join$4(", ", path.map(print, paramsKey)), ">"]);
  }

  return group$2(concat$6(["<", indent$3(concat$6([softline$2, join$4(concat$6([",", line$2]), path.map(print, paramsKey))])), ifBreak$1(options.parser !== "typescript" && shouldPrintComma(options, "all") ? "," : ""), softline$2, ">"]));
}

function printClass(path, options, print) {
  var n = path.getValue();
  var parts = [];

  if (n.abstract) {
    parts.push("abstract ");
  }

  parts.push("class");

  if (n.id) {
    parts.push(" ", path.call(print, "id"));
  }

  parts.push(path.call(print, "typeParameters"));
  var partsGroup = [];

  if (n.superClass) {
    var printed = concat$6(["extends ", path.call(print, "superClass"), path.call(print, "superTypeParameters")]); // Keep old behaviour of extends in same line
    // If there is only on extends and there are not comments

    if ((!n.implements || n.implements.length === 0) && (!n.superClass.comments || n.superClass.comments.length === 0)) {
      parts.push(concat$6([" ", path.call(function (superClass) {
        return comments.printComments(superClass, function () {
          return printed;
        }, options);
      }, "superClass")]));
    } else {
      partsGroup.push(group$2(concat$6([line$2, path.call(function (superClass) {
        return comments.printComments(superClass, function () {
          return printed;
        }, options);
      }, "superClass")])));
    }
  } else if (n.extends && n.extends.length > 0) {
    parts.push(" extends ", join$4(", ", path.map(print, "extends")));
  }

  if (n["mixins"] && n["mixins"].length > 0) {
    partsGroup.push(line$2, "mixins ", group$2(indent$3(join$4(concat$6([",", line$2]), path.map(print, "mixins")))));
  }

  if (n["implements"] && n["implements"].length > 0) {
    partsGroup.push(line$2, "implements", group$2(indent$3(concat$6([line$2, join$4(concat$6([",", line$2]), path.map(print, "implements"))]))));
  }

  if (partsGroup.length > 0) {
    parts.push(group$2(indent$3(concat$6(partsGroup))));
  }

  if (n.body && n.body.comments && hasLeadingOwnLineComment$1(options.originalText, n.body, options)) {
    parts.push(hardline$4);
  } else {
    parts.push(" ");
  }

  parts.push(path.call(print, "body"));
  return parts;
}

function printOptionalToken(path) {
  var node = path.getValue();

  if (!node.optional || // It's an optional computed method parsed by typescript-estree.
  // "?" is printed in `printMethod`.
  node.type === "Identifier" && node === path.getParentNode().key) {
    return "";
  }

  if (node.type === "OptionalCallExpression" || node.type === "OptionalMemberExpression" && node.computed) {
    return "?.";
  }

  return "?";
}

function printMemberLookup(path, options, print) {
  var property = path.call(print, "property");
  var n = path.getValue();
  var optional = printOptionalToken(path);

  if (!n.computed) {
    return concat$6([optional, ".", property]);
  }

  if (!n.property || isNumericLiteral$1(n.property)) {
    return concat$6([optional, "[", property, "]"]);
  }

  return group$2(concat$6([optional, "[", indent$3(concat$6([softline$2, property])), softline$2, "]"]));
}

function printBindExpressionCallee(path, options, print) {
  return concat$6(["::", path.call(print, "callee")]);
} // We detect calls on member expressions specially to format a
// common pattern better. The pattern we are looking for is this:
//
// arr
//   .map(x => x + 1)
//   .filter(x => x > 10)
//   .some(x => x % 2)
//
// The way it is structured in the AST is via a nested sequence of
// MemberExpression and CallExpression. We need to traverse the AST
// and make groups out of it to print it in the desired way.


function printMemberChain(path, options, print) {
  // The first phase is to linearize the AST by traversing it down.
  //
  //   a().b()
  // has the following AST structure:
  //   CallExpression(MemberExpression(CallExpression(Identifier)))
  // and we transform it into
  //   [Identifier, CallExpression, MemberExpression, CallExpression]
  var printedNodes = []; // Here we try to retain one typed empty line after each call expression or
  // the first group whether it is in parentheses or not

  function shouldInsertEmptyLineAfter(node) {
    var originalText = options.originalText;
    var nextCharIndex = getNextNonSpaceNonCommentCharacterIndex$2(originalText, node, options);
    var nextChar = originalText.charAt(nextCharIndex); // if it is cut off by a parenthesis, we only account for one typed empty
    // line after that parenthesis

    if (nextChar == ")") {
      return isNextLineEmptyAfterIndex$1(originalText, nextCharIndex + 1, options);
    }

    return isNextLineEmpty$2(originalText, node, options);
  }

  function rec(path) {
    var node = path.getValue();

    if ((node.type === "CallExpression" || node.type === "OptionalCallExpression") && (isMemberish$1(node.callee) || node.callee.type === "CallExpression" || node.callee.type === "OptionalCallExpression")) {
      printedNodes.unshift({
        node: node,
        printed: concat$6([comments.printComments(path, function () {
          return concat$6([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);
        }, options), shouldInsertEmptyLineAfter(node) ? hardline$4 : ""])
      });
      path.call(function (callee) {
        return rec(callee);
      }, "callee");
    } else if (isMemberish$1(node)) {
      printedNodes.unshift({
        node: node,
        needsParens: needsParens_1(path, options),
        printed: comments.printComments(path, function () {
          return node.type === "OptionalMemberExpression" || node.type === "MemberExpression" ? printMemberLookup(path, options, print) : printBindExpressionCallee(path, options, print);
        }, options)
      });
      path.call(function (object) {
        return rec(object);
      }, "object");
    } else if (node.type === "TSNonNullExpression") {
      printedNodes.unshift({
        node: node,
        printed: comments.printComments(path, function () {
          return "!";
        }, options)
      });
      path.call(function (expression) {
        return rec(expression);
      }, "expression");
    } else {
      printedNodes.unshift({
        node: node,
        printed: path.call(print)
      });
    }
  } // Note: the comments of the root node have already been printed, so we
  // need to extract this first call without printing them as they would
  // if handled inside of the recursive call.


  var node = path.getValue();
  printedNodes.unshift({
    node,
    printed: concat$6([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)])
  });
  path.call(function (callee) {
    return rec(callee);
  }, "callee"); // Once we have a linear list of printed nodes, we want to create groups out
  // of it.
  //
  //   a().b.c().d().e
  // will be grouped as
  //   [
  //     [Identifier, CallExpression],
  //     [MemberExpression, MemberExpression, CallExpression],
  //     [MemberExpression, CallExpression],
  //     [MemberExpression],
  //   ]
  // so that we can print it as
  //   a()
  //     .b.c()
  //     .d()
  //     .e
  // The first group is the first node followed by
  //   - as many CallExpression as possible
  //       < fn()()() >.something()
  //   - as many array accessors as possible
  //       < fn()[0][1][2] >.something()
  //   - then, as many MemberExpression as possible but the last one
  //       < this.items >.something()

  var groups = [];
  var currentGroup = [printedNodes[0]];
  var i = 1;

  for (; i < printedNodes.length; ++i) {
    if (printedNodes[i].node.type === "TSNonNullExpression" || printedNodes[i].node.type === "OptionalCallExpression" || printedNodes[i].node.type === "CallExpression" || (printedNodes[i].node.type === "MemberExpression" || printedNodes[i].node.type === "OptionalMemberExpression") && printedNodes[i].node.computed && isNumericLiteral$1(printedNodes[i].node.property)) {
      currentGroup.push(printedNodes[i]);
    } else {
      break;
    }
  }

  if (printedNodes[0].node.type !== "CallExpression" && printedNodes[0].node.type !== "OptionalCallExpression") {
    for (; i + 1 < printedNodes.length; ++i) {
      if (isMemberish$1(printedNodes[i].node) && isMemberish$1(printedNodes[i + 1].node)) {
        currentGroup.push(printedNodes[i]);
      } else {
        break;
      }
    }
  }

  groups.push(currentGroup);
  currentGroup = []; // Then, each following group is a sequence of MemberExpression followed by
  // a sequence of CallExpression. To compute it, we keep adding things to the
  // group until we has seen a CallExpression in the past and reach a
  // MemberExpression

  var hasSeenCallExpression = false;

  for (; i < printedNodes.length; ++i) {
    if (hasSeenCallExpression && isMemberish$1(printedNodes[i].node)) {
      // [0] should be appended at the end of the group instead of the
      // beginning of the next one
      if (printedNodes[i].node.computed && isNumericLiteral$1(printedNodes[i].node.property)) {
        currentGroup.push(printedNodes[i]);
        continue;
      }

      groups.push(currentGroup);
      currentGroup = [];
      hasSeenCallExpression = false;
    }

    if (printedNodes[i].node.type === "CallExpression" || printedNodes[i].node.type === "OptionalCallExpression") {
      hasSeenCallExpression = true;
    }

    currentGroup.push(printedNodes[i]);

    if (printedNodes[i].node.comments && printedNodes[i].node.comments.some(function (comment) {
      return comment.trailing;
    })) {
      groups.push(currentGroup);
      currentGroup = [];
      hasSeenCallExpression = false;
    }
  }

  if (currentGroup.length > 0) {
    groups.push(currentGroup);
  } // There are cases like Object.keys(), Observable.of(), _.values() where
  // they are the subject of all the chained calls and therefore should
  // be kept on the same line:
  //
  //   Object.keys(items)
  //     .filter(x => x)
  //     .map(x => x)
  //
  // In order to detect those cases, we use an heuristic: if the first
  // node is an identifier with the name starting with a capital
  // letter or just a sequence of _$.