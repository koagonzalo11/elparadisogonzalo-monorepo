.jsx === 1 /* Preserve */ ? ".jsx" /* Jsx */ : ".js" /* Js */;
                case ".js" /* Js */:
                case ".jsx" /* Jsx */:
                case ".json" /* Json */:
                    return ext;
                default:
                    return undefined;
            }
        }
        moduleSpecifiers_1.tryGetJSExtensionForFile = tryGetJSExtensionForFile;
        function getRelativePathIfInDirectory(path, directoryPath, getCanonicalFileName) {
            var relativePath = ts.getRelativePathToDirectoryOrUrl(directoryPath, path, directoryPath, getCanonicalFileName, /*isAbsolutePathAnUrl*/ false);
            return ts.isRootedDiskPath(relativePath) ? undefined : relativePath;
        }
        function isPathRelativeToParent(path) {
            return ts.startsWith(path, "..");
        }
    })(moduleSpecifiers = ts.moduleSpecifiers || (ts.moduleSpecifiers = {}));
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var sysFormatDiagnosticsHost = ts.sys ? {
        getCurrentDirectory: function () { return ts.sys.getCurrentDirectory(); },
        getNewLine: function () { return ts.sys.newLine; },
        getCanonicalFileName: ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames)
    } : undefined;
    /**
     * Create a function that reports error by writing to the system and handles the formating of the diagnostic
     */
    function createDiagnosticReporter(system, pretty) {
        var host = system === ts.sys && sysFormatDiagnosticsHost ? sysFormatDiagnosticsHost : {
            getCurrentDirectory: function () { return system.getCurrentDirectory(); },
            getNewLine: function () { return system.newLine; },
            getCanonicalFileName: ts.createGetCanonicalFileName(system.useCaseSensitiveFileNames),
        };
        if (!pretty) {
            return function (diagnostic) { return system.write(ts.formatDiagnostic(diagnostic, host)); };
        }
        var diagnostics = new Array(1);
        return function (diagnostic) {
            diagnostics[0] = diagnostic;
            system.write(ts.formatDiagnosticsWithColorAndContext(diagnostics, host) + host.getNewLine());
            diagnostics[0] = undefined; // TODO: GH#18217
        };
    }
    ts.createDiagnosticReporter = createDiagnosticReporter;
    /**
     * @returns Whether the screen was cleared.
     */
    function clearScreenIfNotWatchingForFileChanges(system, diagnostic, options) {
        if (system.clearScreen &&
            !options.preserveWatchOutput &&
            !options.extendedDiagnostics &&
            !options.diagnostics &&
            ts.contains(ts.screenStartingMessageCodes, diagnostic.code)) {
            system.clearScreen();
            return true;
        }
        return false;
    }
    ts.screenStartingMessageCodes = [
        ts.Diagnostics.Starting_compilation_in_watch_mode.code,
        ts.Diagnostics.File_change_detected_Starting_incremental_compilation.code,
    ];
    function getPlainDiagnosticFollowingNewLines(diagnostic, newLine) {
        return ts.contains(ts.screenStartingMessageCodes, diagnostic.code)
            ? newLine + newLine
            : newLine;
    }
    /**
     * Get locale specific time based on whether we are in test mode
     */
    function getLocaleTimeString(system) {
        return !system.now ?
            new Date().toLocaleTimeString() :
            system.now().toLocaleTimeString("en-US", { timeZone: "UTC" });
    }
    ts.getLocaleTimeString = getLocaleTimeString;
    /**
     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic
     */
    function createWatchStatusReporter(system, pretty) {
        return pretty ?
            function (diagnostic, newLine, options) {
                clearScreenIfNotWatchingForFileChanges(system, diagnostic, options);
                var output = "[" + ts.formatColorAndReset(getLocaleTimeString(system), ts.ForegroundColorEscapeSequences.Grey) + "] ";
                output += "" + ts.flattenDiagnosticMessageText(diagnostic.messageText, system.newLine) + (newLine + newLine);
                system.write(output);
            } :
            function (diagnostic, newLine, options) {
                var output = "";
                if (!clearScreenIfNotWatchingForFileChanges(system, diagnostic, options)) {
                    output += newLine;
                }
                output += getLocaleTimeString(system) + " - ";
                output += "" + ts.flattenDiagnosticMessageText(diagnostic.messageText, system.newLine) + getPlainDiagnosticFollowingNewLines(diagnostic, newLine);
                system.write(output);
            };
    }
    ts.createWatchStatusReporter = createWatchStatusReporter;
    /** Parses config file using System interface */
    function parseConfigFileWithSystem(configFileName, optionsToExtend, extendedConfigCache, watchOptionsToExtend, system, reportDiagnostic) {
        var host = system;
        host.onUnRecoverableConfigFileDiagnostic = function (diagnostic) { return reportUnrecoverableDiagnostic(system, reportDiagnostic, diagnostic); };
        var result = ts.getParsedCommandLineOfConfigFile(configFileName, optionsToExtend, host, extendedConfigCache, watchOptionsToExtend);
        host.onUnRecoverableConfigFileDiagnostic = undefined; // TODO: GH#18217
        return result;
    }
    ts.parseConfigFileWithSystem = parseConfigFileWithSystem;
    function getErrorCountForSummary(diagnostics) {
        return ts.countWhere(diagnostics, function (diagnostic) { return diagnostic.category === ts.DiagnosticCategory.Error; });
    }
    ts.getErrorCountForSummary = getErrorCountForSummary;
    function getWatchErrorSummaryDiagnosticMessage(errorCount) {
        return errorCount === 1 ?
            ts.Diagnostics.Found_1_error_Watching_for_file_changes :
            ts.Diagnostics.Found_0_errors_Watching_for_file_changes;
    }
    ts.getWatchErrorSummaryDiagnosticMessage = getWatchErrorSummaryDiagnosticMessage;
    function getErrorSummaryText(errorCount, newLine) {
        if (errorCount === 0)
            return "";
        var d = ts.createCompilerDiagnostic(errorCount === 1 ? ts.Diagnostics.Found_1_error : ts.Diagnostics.Found_0_errors, errorCount);
        return "" + newLine + ts.flattenDiagnosticMessageText(d.messageText, newLine) + newLine + newLine;
    }
    ts.getErrorSummaryText = getErrorSummaryText;
    function isBuilderProgram(program) {
        return !!program.getState;
    }
    ts.isBuilderProgram = isBuilderProgram;
    function listFiles(program, write) {
        var options = program.getCompilerOptions();
        if (options.explainFiles) {
            explainFiles(isBuilderProgram(program) ? program.getProgram() : program, write);
        }
        else if (options.listFiles || options.listFilesOnly) {
            ts.forEach(program.getSourceFiles(), function (file) {
                write(file.fileName);
            });
        }
    }
    ts.listFiles = listFiles;
    function explainFiles(program, write) {
        var _a, _b;
        var reasons = program.getFileIncludeReasons();
        var getCanonicalFileName = ts.createGetCanonicalFileName(program.useCaseSensitiveFileNames());
        var relativeFileName = function (fileName) { return ts.convertToRelativePath(fileName, program.getCurrentDirectory(), getCanonicalFileName); };
        for (var _i = 0, _c = program.getSourceFiles(); _i < _c.length; _i++) {
            var file = _c[_i];
            write("" + toFileName(file, relativeFileName));
            (_a = reasons.get(file.path)) === null || _a === void 0 ? void 0 : _a.forEach(function (reason) { return write("  " + fileIncludeReasonToDiagnostics(program, reason, relativeFileName).messageText); });
            (_b = explainIfFileIsRedirect(file, relativeFileName)) === null || _b === void 0 ? void 0 : _b.forEach(function (d) { return write("  " + d.messageText); });
        }
    }
    ts.explainFiles = explainFiles;
    function explainIfFileIsRedirect(file, fileNameConvertor) {
        var result;
        if (file.path !== file.resolvedPath) {
            (result || (result = [])).push(ts.chainDiagnosticMessages(
            /*details*/ undefined, ts.Diagnostics.File_is_output_of_project_reference_source_0, toFileName(file.originalFileName, fileNameConvertor)));
        }
        if (file.redirectInfo) {
            (result || (result = [])).push(ts.chainDiagnosticMessages(
            /*details*/ undefined, ts.Diagnostics.File_redirects_to_file_0, toFileName(file.redirectInfo.redirectTarget, fileNameConvertor)));
        }
        return result;
    }
    ts.explainIfFileIsRedirect = explainIfFileIsRedirect;
    function getMatchedFileSpec(program, fileName) {
        var _a;
        var configFile = program.getCompilerOptions().configFile;
        if (!((_a = configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) === null || _a === void 0 ? void 0 : _a.validatedFilesSpec))
            return undefined;
        var getCanonicalFileName = ts.createGetCanonicalFileName(program.useCaseSensitiveFileNames());
        var filePath = getCanonicalFileName(fileName);
        var basePath = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(configFile.fileName, program.getCurrentDirectory()));
        return ts.find(configFile.configFileSpecs.validatedFilesSpec, function (fileSpec) { return getCanonicalFileName(ts.getNormalizedAbsolutePath(fileSpec, basePath)) === filePath; });
    }
    ts.getMatchedFileSpec = getMatchedFileSpec;
    function getMatchedIncludeSpec(program, fileName) {
        var _a, _b;
        var configFile = program.getCompilerOptions().configFile;
        if (!((_a = configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) === null || _a === void 0 ? void 0 : _a.validatedIncludeSpecs))
            return undefined;
        var isJsonFile = ts.fileExtensionIs(fileName, ".json" /* Json */);
        var basePath = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(configFile.fileName, program.getCurrentDirectory()));
        var useCaseSensitiveFileNames = program.useCaseSensitiveFileNames();
        return ts.find((_b = configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) === null || _b === void 0 ? void 0 : _b.validatedIncludeSpecs, function (includeSpec) {
            if (isJsonFile && !ts.endsWith(includeSpec, ".json" /* Json */))
                return false;
            var pattern = ts.getPatternFromSpec(includeSpec, basePath, "files");
            return !!pattern && ts.getRegexFromPattern("(" + pattern + ")$", useCaseSensitiveFileNames).test(fileName);
        });
    }
    ts.getMatchedIncludeSpec = getMatchedIncludeSpec;
    function fileIncludeReasonToDiagnostics(program, reason, fileNameConvertor) {
        var _a, _b;
        var options = program.getCompilerOptions();
        if (ts.isReferencedFile(reason)) {
            var referenceLocation = ts.getReferencedFileLocation(function (path) { return program.getSourceFileByPath(path); }, reason);
            var referenceText = ts.isReferenceFileLocation(referenceLocation) ? referenceLocation.file.text.substring(referenceLocation.pos, referenceLocation.end) : "\"" + referenceLocation.text + "\"";
            var message = void 0;
            ts.Debug.assert(ts.isReferenceFileLocation(referenceLocation) || reason.kind === ts.FileIncludeKind.Import, "Only synthetic references are imports");
            switch (reason.kind) {
                case ts.FileIncludeKind.Import:
                    if (ts.isReferenceFileLocation(referenceLocation)) {
                        message = referenceLocation.packageId ?
                            ts.Diagnostics.Imported_via_0_from_file_1_with_packageId_2 :
                            ts.Diagnostics.Imported_via_0_from_file_1;
                    }
                    else if (referenceLocation.text === ts.externalHelpersModuleNameText) {
                        message = referenceLocation.packageId ?
                            ts.Diagnostics.Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions :
                            ts.Diagnostics.Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions;
                    }
                    else {
                        message = referenceLocation.packageId ?
                            ts.Diagnostics.Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions :
                            ts.Diagnostics.Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions;
                    }
                    break;
                case ts.FileIncludeKind.ReferenceFile:
                    ts.Debug.assert(!referenceLocation.packageId);
                    message = ts.Diagnostics.Referenced_via_0_from_file_1;
                    break;
                case ts.FileIncludeKind.TypeReferenceDirective:
                    message = referenceLocation.packageId ?
                        ts.Diagnostics.Type_library_referenced_via_0_from_file_1_with_packageId_2 :
                        ts.Diagnostics.Type_library_referenced_via_0_from_file_1;
                    break;
                case ts.FileIncludeKind.LibReferenceDirective:
                    ts.Debug.assert(!referenceLocation.packageId);
                    message = ts.Diagnostics.Library_referenced_via_0_from_file_1;
                    break;
                default:
                    ts.Debug.assertNever(reason);
            }
            return ts.chainDiagnosticMessages(
            /*details*/ undefined, message, referenceText, toFileName(referenceLocation.file, fileNameConvertor), referenceLocation.packageId && ts.packageIdToString(referenceLocation.packageId));
        }
        switch (reason.kind) {
            case ts.FileIncludeKind.RootFile:
                if (!((_a = options.configFile) === null || _a === void 0 ? void 0 : _a.configFileSpecs))
                    return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Root_file_specified_for_compilation);
                var fileName = ts.getNormalizedAbsolutePath(program.getRootFileNames()[reason.index], program.getCurrentDirectory());
                var matchedByFiles = getMatchedFileSpec(program, fileName);
                if (matchedByFiles)
                    return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Part_of_files_list_in_tsconfig_json);
                var matchedByInclude = getMatchedIncludeSpec(program, fileName);
                return matchedByInclude ?
                    ts.chainDiagnosticMessages(
                    /*details*/ undefined, ts.Diagnostics.Matched_by_include_pattern_0_in_1, matchedByInclude, toFileName(options.configFile, fileNameConvertor)) :
                    // Could be additional files specified as roots
                    ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Root_file_specified_for_compilation);
            case ts.FileIncludeKind.SourceFromProjectReference:
            case ts.FileIncludeKind.OutputFromProjectReference:
                var isOutput = reason.kind === ts.FileIncludeKind.OutputFromProjectReference;
                var referencedResolvedRef = ts.Debug.checkDefined((_b = program.getResolvedProjectReferences()) === null || _b === void 0 ? void 0 : _b[reason.index]);
                return ts.chainDiagnosticMessages(
                /*details*/ undefined, ts.outFile(options) ?
                    isOutput ?
                        ts.Diagnostics.Output_from_referenced_project_0_included_because_1_specified :
                        ts.Diagnostics.Source_from_referenced_project_0_included_because_1_specified :
                    isOutput ?
                        ts.Diagnostics.Output_from_referenced_project_0_included_because_module_is_specified_as_none :
                        ts.Diagnostics.Source_from_referenced_project_0_included_because_module_is_specified_as_none, toFileName(referencedResolvedRef.sourceFile.fileName, fileNameConvertor), options.outFile ? "--outFile" : "--out");
            case ts.FileIncludeKind.AutomaticTypeDirectiveFile:
                return ts.chainDiagnosticMessages(
                /*details*/ undefined, options.types ?
                    reason.packageId ?
                        ts.Diagnostics.Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1 :
                        ts.Diagnostics.Entry_point_of_type_library_0_specified_in_compilerOptions :
                    reason.packageId ?
                        ts.Diagnostics.Entry_point_for_implicit_type_library_0_with_packageId_1 :
                        ts.Diagnostics.Entry_point_for_implicit_type_library_0, reason.typeReference, reason.packageId && ts.packageIdToString(reason.packageId));
            case ts.FileIncludeKind.LibFile:
                if (reason.index !== undefined)
                    return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Library_0_specified_in_compilerOptions, options.lib[reason.index]);
                var target = ts.forEachEntry(ts.targetOptionDeclaration.type, function (value, key) { return value === options.target ? key : undefined; });
                return ts.chainDiagnosticMessages(
                /*details*/ undefined, target ?
                    ts.Diagnostics.Default_library_for_target_0 :
                    ts.Diagnostics.Default_library, target);
            default:
                ts.Debug.assertNever(reason);
        }
    }
    ts.fileIncludeReasonToDiagnostics = fileIncludeReasonToDiagnostics;
    function toFileName(file, fileNameConvertor) {
        var fileName = ts.isString(file) ? file : file.fileName;
        return fileNameConvertor ? fileNameConvertor(fileName) : fileName;
    }
    /**
     * Helper that emit files, report diagnostics and lists emitted and/or source files depending on compiler options
     */
    function emitFilesAndReportErrors(program, reportDiagnostic, write, reportSummary, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
        var isListFilesOnly = !!program.getCompilerOptions().listFilesOnly;
        // First get and report any syntactic errors.
        var allDiagnostics = program.getConfigFileParsingDiagnostics().slice();
        var configFileParsingDiagnosticsLength = allDiagnostics.length;
        ts.addRange(allDiagnostics, program.getSyntacticDiagnostics(/*sourceFile*/ undefined, cancellationToken));
        // If we didn't have any syntactic errors, then also try getting the global and
        // semantic errors.
        if (allDiagnostics.length === configFileParsingDiagnosticsLength) {
            ts.addRange(allDiagnostics, program.getOptionsDiagnostics(cancellationToken));
            if (!isListFilesOnly) {
                ts.addRange(allDiagnostics, program.getGlobalDiagnostics(cancellationToken));
                if (allDiagnostics.length === configFileParsingDiagnosticsLength) {
                    ts.addRange(allDiagnostics, program.getSemanticDiagnostics(/*sourceFile*/ undefined, cancellationToken));
                }
            }
        }
        // Emit and report any errors we ran into.
        var emitResult = isListFilesOnly
            ? { emitSkipped: true, diagnostics: ts.emptyArray }
            : program.emit(/*targetSourceFile*/ undefined, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);
        var emittedFiles = emitResult.emittedFiles, emitDiagnostics = emitResult.diagnostics;
        ts.addRange(allDiagnostics, emitDiagnostics);
        var diagnostics = ts.sortAndDeduplicateDiagnostics(allDiagnostics);
        diagnostics.forEach(reportDiagnostic);
        if (write) {
            var currentDir_1 = program.getCurrentDirectory();
            ts.forEach(emittedFiles, function (file) {
                var filepath = ts.getNormalizedAbsolutePath(file, currentDir_1);
                write("TSFILE: " + filepath);
            });
            listFiles(program, write);
        }
        if (reportSummary) {
            reportSummary(getErrorCountForSummary(diagnostics));
        }
        return {
            emitResult: emitResult,
            diagnostics: diagnostics,
        };
    }
    ts.emitFilesAndReportErrors = emitFilesAndReportErrors;
    function emitFilesAndReportErrorsAndGetExitStatus(program, reportDiagnostic, write, reportSummary, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
        var _a = emitFilesAndReportErrors(program, reportDiagnostic, write, reportSummary, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers), emitResult = _a.emitResult, diagnostics = _a.diagnostics;
        if (emitResult.emitSkipped && diagnostics.length > 0) {
            // If the emitter didn't emit anything, then pass that value along.
            return ts.ExitStatus.DiagnosticsPresent_OutputsSkipped;
        }
        else if (diagnostics.length > 0) {
            // The emitter emitted something, inform the caller if that happened in the presence
            // of diagnostics or not.
            return ts.ExitStatus.DiagnosticsPresent_OutputsGenerated;
        }
        return ts.ExitStatus.Success;
    }
    ts.emitFilesAndReportErrorsAndGetExitStatus = emitFilesAndReportErrorsAndGetExitStatus;
    ts.noopFileWatcher = { close: ts.noop };
    ts.returnNoopFileWatcher = function () { return ts.noopFileWatcher; };
    function createWatchHost(system, reportWatchStatus) {
        if (system === void 0) { system = ts.sys; }
        var onWatchStatusChange = reportWatchStatus || createWatchStatusReporter(system);
        return {
            onWatchStatusChange: onWatchStatusChange,
            watchFile: ts.maybeBind(system, system.watchFile) || ts.returnNoopFileWatcher,
            watchDirectory: ts.maybeBind(system, system.watchDirectory) || ts.returnNoopFileWatcher,
            setTimeout: ts.maybeBind(system, system.setTimeout) || ts.noop,
            clearTimeout: ts.maybeBind(system, system.clearTimeout) || ts.noop
        };
    }
    ts.createWatchHost = createWatchHost;
    ts.WatchType = {
        ConfigFile: "Config file",
        ExtendedConfigFile: "Extended config file",
        SourceFile: "Source file",
        MissingFile: "Missing file",
        WildcardDirectory: "Wild card directory",
        FailedLookupLocations: "Failed Lookup Locations",
        TypeRoots: "Type roots",
        ConfigFileOfReferencedProject: "Config file of referened project",
        ExtendedConfigOfReferencedProject: "Extended config file of referenced project",
        WildcardDirectoryOfReferencedProject: "Wild card directory of referenced project",
        PackageJson: "package.json file",
    };
    function createWatchFactory(host, options) {
        var watchLogLevel = host.trace ? options.extendedDiagnostics ? ts.WatchLogLevel.Verbose : options.diagnostics ? ts.WatchLogLevel.TriggerOnly : ts.WatchLogLevel.None : ts.WatchLogLevel.None;
        var writeLog = watchLogLevel !== ts.WatchLogLevel.None ? (function (s) { return host.trace(s); }) : ts.noop;
        var result = ts.getWatchFactory(host, watchLogLevel, writeLog);
        result.writeLog = writeLog;
        return result;
    }
    ts.createWatchFactory = createWatchFactory;
    function createCompilerHostFromProgramHost(host, getCompilerOptions, directoryStructureHost) {
        if (directoryStructureHost === void 0) { directoryStructureHost = host; }
        var useCaseSensitiveFileNames = host.useCaseSensitiveFileNames();
        var hostGetNewLine = ts.memoize(function () { return host.getNewLine(); });
        return {
            getSourceFile: function (fileName, languageVersion, onError) {
                var text;
                try {
                    ts.performance.mark("beforeIORead");
                    text = host.readFile(fileName, getCompilerOptions().charset);
                    ts.performance.mark("afterIORead");
                    ts.performance.measure("I/O Read", "beforeIORead", "afterIORead");
                }
                catch (e) {
                    if (onError) {
                        onError(e.message);
                    }
                    text = "";
                }
                return text !== undefined ? ts.createSourceFile(fileName, text, languageVersion) : undefined;
            },
            getDefaultLibLocation: ts.maybeBind(host, host.getDefaultLibLocation),
            getDefaultLibFileName: function (options) { return host.getDefaultLibFileName(options); },
            writeFile: writeFile,
            getCurrentDirectory: ts.memoize(function () { return host.getCurrentDirectory(); }),
            useCaseSensitiveFileNames: function () { return useCaseSensitiveFileNames; },
            getCanonicalFileName: ts.createGetCanonicalFileName(useCaseSensitiveFileNames),
            getNewLine: function () { return ts.getNewLineCharacter(getCompilerOptions(), hostGetNewLine); },
            fileExists: function (f) { return host.fileExists(f); },
            readFile: function (f) { return host.readFile(f); },
            trace: ts.maybeBind(host, host.trace),
            directoryExists: ts.maybeBind(directoryStructureHost, directoryStructureHost.directoryExists),
            getDirectories: ts.maybeBind(directoryStructureHost, directoryStructureHost.getDirectories),
            realpath: ts.maybeBind(host, host.realpath),
            getEnvironmentVariable: ts.maybeBind(host, host.getEnvironmentVariable) || (function () { return ""; }),
            createHash: ts.maybeBind(host, host.createHash),
            readDirectory: ts.maybeBind(host, host.readDirectory),
            disableUseFileVersionAsSignature: host.disableUseFileVersionAsSignature,
        };
        function writeFile(fileName, text, writeByteOrderMark, onError) {
            try {
                ts.performance.mark("beforeIOWrite");
                // NOTE: If patchWriteFileEnsuringDirectory has been called,
                // the host.writeFile will do its own directory creation and
                // the ensureDirectoriesExist call will always be redundant.
                ts.writeFileEnsuringDirectories(fileName, text, writeByteOrderMark, function (path, data, writeByteOrderMark) { return host.writeFile(path, data, writeByteOrderMark); }, function (path) { return host.createDirectory(path); }, function (path) { return host.directoryExists(path); });
                ts.performance.mark("afterIOWrite");
                ts.performance.measure("I/O Write", "beforeIOWrite", "afterIOWrite");
            }
            catch (e) {
                if (onError) {
                    onError(e.message);
                }
            }
        }
    }
    ts.createCompilerHostFromProgramHost = createCompilerHostFromProgramHost;
    function setGetSourceFileAsHashVersioned(compilerHost, host) {
        var originalGetSourceFile = compilerHost.getSourceFile;
        var computeHash = ts.maybeBind(host, host.createHash) || ts.generateDjb2Hash;
        compilerHost.getSourceFile = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var result = originalGetSourceFile.call.apply(originalGetSourceFile, __spreadArray([compilerHost], args, false));
            if (result) {
                result.version = computeHash(result.text);
            }
            return result;
        };
    }
    ts.setGetSourceFileAsHashVersioned = setGetSourceFileAsHashVersioned;
    /**
     * Creates the watch compiler host that can be extended with config file or root file names and options host
     */
    function createProgramHost(system, createProgram) {
        var getDefaultLibLocation = ts.memoize(function () { return ts.getDirectoryPath(ts.normalizePath(system.getExecutingFilePath())); });
        return {
            useCaseSensitiveFileNames: function () { return system.useCaseSensitiveFileNames; },
            getNewLine: function () { return system.newLine; },
            getCurrentDirectory: ts.memoize(function () { return system.getCurrentDirectory(); }),
            getDefaultLibLocation: getDefaultLibLocation,
            getDefaultLibFileName: function (options) { return ts.combinePaths(getDefaultLibLocation(), ts.getDefaultLibFileName(options)); },
            fileExists: function (path) { return system.fileExists(path); },
            readFile: function (path, encoding) { return system.readFile(path, encoding); },
            directoryExists: function (path) { return system.directoryExists(path); },
            getDirectories: function (path) { return system.getDirectories(path); },
            readDirectory: function (path, extensions, exclude, include, depth) { return system.readDirectory(path, extensions, exclude, include, depth); },
            realpath: ts.maybeBind(system, system.realpath),
            getEnvironmentVariable: ts.maybeBind(system, system.getEnvironmentVariable),
            trace: function (s) { return system.write(s + system.newLine); },
            createDirectory: function (path) { return system.createDirectory(path); },
            writeFile: function (path, data, writeByteOrderMark) { return system.writeFile(path, data, writeByteOrderMark); },
            createHash: ts.maybeBind(system, system.createHash),
            createProgram: createProgram || ts.createEmitAndSemanticDiagnosticsBuilderProgram,
            disableUseFileVersionAsSignature: system.disableUseFileVersionAsSignature,
        };
    }
    ts.createProgramHost = createProgramHost;
    /**
     * Creates the watch compiler host that can be extended with config file or root file names and options host
     */
    function createWatchCompilerHost(system, createProgram, reportDiagnostic, reportWatchStatus) {
        if (system === void 0) { system = ts.sys; }
        var write = function (s) { return system.write(s + system.newLine); };
        var result = createProgramHost(system, createProgram);
        ts.copyProperties(result, createWatchHost(system, reportWatchStatus));
        result.afterProgramCreate = function (builderProgram) {
            var compilerOptions = builderProgram.getCompilerOptions();
            var newLine = ts.getNewLineCharacter(compilerOptions, function () { return system.newLine; });
            emitFilesAndReportErrors(builderProgram, reportDiagnostic, write, function (errorCount) { return result.onWatchStatusChange(ts.createCompilerDiagnostic(getWatchErrorSummaryDiagnosticMessage(errorCount), errorCount), newLine, compilerOptions, errorCount); });
        };
        return result;
    }
    /**
     * Report error and exit
     */
    function reportUnrecoverableDiagnostic(system, reportDiagnostic, diagnostic) {
        reportDiagnostic(diagnostic);
        system.exit(ts.ExitStatus.DiagnosticsPresent_OutputsSkipped);
    }
    /**
     * Creates the watch compiler host from system for config file in watch mode
     */
    function createWatchCompilerHostOfConfigFile(_a) {
        var configFileName = _a.configFileName, optionsToExtend = _a.optionsToExtend, watchOptionsToExtend = _a.watchOptionsToExtend, extraFileExtensions = _a.extraFileExtensions, system = _a.system, createProgram = _a.createProgram, reportDiagnostic = _a.reportDiagnostic, reportWatchStatus = _a.reportWatchStatus;
        var diagnosticReporter = reportDiagnostic || createDiagnosticReporter(system);
        var host = createWatchCompilerHost(system, createProgram, diagnosticReporter, reportWatchStatus);
        host.onUnRecoverableConfigFileDiagnostic = function (diagnostic) { return reportUnrecoverableDiagnostic(system, diagnosticReporter, diagnostic); };
        host.configFileName = configFileName;
        host.optionsToExtend = optionsToExtend;
        host.watchOptionsToExtend = watchOptionsToExtend;
        host.extraFileExtensions = extraFileExtensions;
        return host;
    }
    ts.createWatchCompilerHostOfConfigFile = createWatchCompilerHostOfConfigFile;
    /**
     * Creates the watch compiler host from system for compiling root files and options in watch mode
     */
    function createWatchCompilerHostOfFilesAndCompilerOptions(_a) {
        var rootFiles = _a.rootFiles, options = _a.options, watchOptions = _a.watchOptions, projectReferences = _a.projectReferences, system = _a.system, createProgram = _a.createProgram, reportDiagnostic = _a.reportDiagnostic, reportWatchStatus = _a.reportWatchStatus;
        var host = createWatchCompilerHost(system, createProgram, reportDiagnostic || createDiagnosticReporter(system), reportWatchStatus);
        host.rootFiles = rootFiles;
        host.options = options;
        host.watchOptions = watchOptions;
        host.projectReferences = projectReferences;
        return host;
    }
    ts.createWatchCompilerHostOfFilesAndCompilerOptions = createWatchCompilerHostOfFilesAndCompilerOptions;
    function performIncrementalCompilation(input) {
        var system = input.system || ts.sys;
        var host = input.host || (input.host = ts.createIncrementalCompilerHost(input.options, system));
        var builderProgram = ts.createIncrementalProgram(input);
        var exitStatus = emitFilesAndReportErrorsAndGetExitStatus(builderProgram, input.reportDiagnostic || createDiagnosticReporter(system), function (s) { return host.trace && host.trace(s); }, input.reportErrorSummary || input.options.pretty ? function (errorCount) { return system.write(getErrorSummaryText(errorCount, system.newLine)); } : undefined);
        if (input.afterProgramEmitAndDiagnostics)
            input.afterProgramEmitAndDiagnostics(builderProgram);
        return exitStatus;
    }
    ts.performIncrementalCompilation = performIncrementalCompilation;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function readBuilderProgram(compilerOptions, host) {
        if (ts.outFile(compilerOptions))
            return undefined;
        var buildInfoPath = ts.getTsBuildInfoEmitOutputFilePath(compilerOptions);
        if (!buildInfoPath)
            return undefined;
        var content = host.readFile(buildInfoPath);
        if (!content)
            return undefined;
        var buildInfo = ts.getBuildInfo(content);
        if (buildInfo.version !== ts.version)
            return undefined;
        if (!buildInfo.program)
            return undefined;
        return ts.createBuildProgramUsingProgramBuildInfo(buildInfo.program, buildInfoPath, host);
    }
    ts.readBuilderProgram = readBuilderProgram;
    function createIncrementalCompilerHost(options, system) {
        if (system === void 0) { system = ts.sys; }
        var host = ts.createCompilerHostWorker(options, /*setParentNodes*/ undefined, system);
        host.createHash = ts.maybeBind(system, system.createHash);
        host.disableUseFileVersionAsSignature = system.disableUseFileVersionAsSignature;
        ts.setGetSourceFileAsHashVersioned(host, system);
        ts.changeCompilerHostLikeToUseCache(host, function (fileName) { return ts.toPath(fileName, host.getCurrentDirectory(), host.getCanonicalFileName); });
        return host;
    }
    ts.createIncrementalCompilerHost = createIncrementalCompilerHost;
    function createIncrementalProgram(_a) {
        var rootNames = _a.rootNames, options = _a.options, configFileParsingDiagnostics = _a.configFileParsingDiagnostics, projectReferences = _a.projectReferences, host = _a.host, createProgram = _a.createProgram;
        host = host || createIncrementalCompilerHost(options);
        createProgram = createProgram || ts.createEmitAndSemanticDiagnosticsBuilderProgram;
        var oldProgram = readBuilderProgram(options, host);
        return createProgram(rootNames, options, host, oldProgram, configFileParsingDiagnostics, projectReferences);
    }
    ts.createIncrementalProgram = createIncrementalProgram;
    function createWatchCompilerHost(rootFilesOrConfigFileName, options, system, createProgram, reportDiagnostic, reportWatchStatus, projectReferencesOrWatchOptionsToExtend, watchOptionsOrExtraFileExtensions) {
        if (ts.isArray(rootFilesOrConfigFileName)) {
            return ts.createWatchCompilerHostOfFilesAndCompilerOptions({
                rootFiles: rootFilesOrConfigFileName,
                options: options,
                watchOptions: watchOptionsOrExtraFileExtensions,
                projectReferences: projectReferencesOrWatchOptionsToExtend,
                system: system,
                createProgram: createProgram,
                reportDiagnostic: reportDiagnostic,
                reportWatchStatus: reportWatchStatus,
            });
        }
        else {
            return ts.createWatchCompilerHostOfConfigFile({
                configFileName: rootFilesOrConfigFileName,
                optionsToExtend: options,
                watchOptionsToExtend: projectReferencesOrWatchOptionsToExtend,
                extraFileExtensions: watchOptionsOrExtraFileExtensions,
                system: system,
                createProgram: createProgram,
                reportDiagnostic: reportDiagnostic,
                reportWatchStatus: reportWatchStatus,
            });
        }
    }
    ts.createWatchCompilerHost = createWatchCompilerHost;
    function createWatchProgram(host) {
        var builderProgram;
        var reloadLevel; // level to indicate if the program needs to be reloaded from config file/just filenames etc
        var missingFilesMap; // Map of file watchers for the missing files
        var packageJsonMap; // map of watchers for package json files used in module resolution
        var watchedWildcardDirectories; // map of watchers for the wild card directories in the config file
        var timerToUpdateProgram; // timer callback to recompile the program
        var timerToInvalidateFailedLookupResolutions; // timer callback to invalidate resolutions for changes in failed lookup locations
        var parsedConfigs; // Parsed commandline and watching cached for referenced projects
        var sharedExtendedConfigFileWatchers; // Map of file watchers for extended files, shared between different referenced projects
        var extendedConfigCache = host.extendedConfigCache; // Cache for extended config evaluation
        var changesAffectResolution = false; // Flag for indicating non-config changes affect module resolution
        var sourceFilesCache = new ts.Map(); // Cache that stores the source file and version info
        var missingFilePathsRequestedForRelease; // These paths are held temporarily so that we can remove the entry from source file cache if the file is not tracked by missing files
        var hasChangedCompilerOptions = false; // True if the compiler options have changed between compilations
        var useCaseSensitiveFileNames = host.useCaseSensitiveFileNames();
        var currentDirectory = host.getCurrentDirectory();
        var configFileName = host.configFileName, _a = host.optionsToExtend, optionsToExtendForConfigFile = _a === void 0 ? {} : _a, watchOptionsToExtend = host.watchOptionsToExtend, extraFileExtensions = host.extraFileExtensions, createProgram = host.createProgram;
        var rootFileNames = host.rootFiles, compilerOptions = host.options, watchOptions = host.watchOptions, projectReferences = host.projectReferences;
        var wildcardDirectories;
        var configFileParsingDiagnostics;
        var canConfigFileJsonReportNoInputFiles = false;
        var hasChangedConfigFileParsingErrors = false;
        var cachedDirectoryStructureHost = configFileName === undefined ? undefined : ts.createCachedDirectoryStructureHost(host, currentDirectory, useCaseSensitiveFileNames);
        var directoryStructureHost = cachedDirectoryStructureHost || host;
        var parseConfigFileHost = ts.parseConfigHostFromCompilerHostLike(host, directoryStructureHost);
        // From tsc we want to get already parsed result and hence check for rootFileNames
        var newLine = updateNewLine();
        if (configFileName && host.configFileParsingResult) {
            setConfigFileParsingResult(host.configFileParsingResult);
            newLine = updateNewLine();
        }
        reportWatchDiagnostic(ts.Diagnostics.Starting_compilation_in_watch_mode);
        if (configFileName && !host.configFileParsingResult) {
            newLine = ts.getNewLineCharacter(optionsToExtendForConfigFile, function () { return host.getNewLine(); });
            ts.Debug.assert(!rootFileNames);
            parseConfigFile();
            newLine = updateNewLine();
        }
        var _b = ts.createWatchFactory(host, compilerOptions), watchFile = _b.watchFile, watchDirectory = _b.watchDirectory, writeLog = _b.writeLog;
        var getCanonicalFileName = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        writeLog("Current directory: " + currentDirectory + " CaseSensitiveFileNames: " + useCaseSensitiveFileNames);
        var configFileWatcher;
        if (configFileName) {
            configFileWatcher = watchFile(configFileName, scheduleProgramReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
        }
        var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return compilerOptions; }, directoryStructureHost);
        ts.setGetSourceFileAsHashVersioned(compilerHost, host);
        // Members for CompilerHost
        var getNewSourceFile = compilerHost.getSourceFile;
        compilerHost.getSourceFile = function (fileName) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return getVersionedSourceFileByPath.apply(void 0, __spreadArray([fileName, toPath(fileName)], args, false));
        };
        compilerHost.getSourceFileByPath = getVersionedSourceFileByPath;
        compilerHost.getNewLine = function () { return newLine; };
        compilerHost.fileExists = fileExists;
        compilerHost.onReleaseOldSourceFile = onReleaseOldSourceFile;
        compilerHost.onReleaseParsedCommandLine = onReleaseParsedCommandLine;
        // Members for ResolutionCacheHost
        compilerHost.toPath = toPath;
        compilerHost.getCompilationSettings = function () { return compilerOptions; };
        compilerHost.useSourceOfProjectReferenceRedirect = ts.maybeBind(host, host.useSourceOfProjectReferenceRedirect);
        compilerHost.watchDirectoryOfFailedLookupLocation = function (dir, cb, flags) { return watchDirectory(dir, cb, flags, watchOptions, ts.WatchType.FailedLookupLocations); };
        compilerHost.watchTypeRootsDirectory = function (dir, cb, flags) { return watchDirectory(dir, cb, flags, watchOptions, ts.WatchType.TypeRoots); };
        compilerHost.getCachedDirectoryStructureHost = function () { return cachedDirectoryStructureHost; };
        compilerHost.scheduleInvalidateResolutionsOfFailedLookupLocations = scheduleInvalidateResolutionsOfFailedLookupLocations;
        compilerHost.onInvalidatedResolution = scheduleProgramUpdate;
        compilerHost.onChangedAutomaticTypeDirectiveNames = scheduleProgramUpdate;
        compilerHost.fileIsOpen = ts.returnFalse;
        compilerHost.getCurrentProgram = getCurrentProgram;
        compilerHost.writeLog = writeLog;
        compilerHost.getParsedCommandLine = getParsedCommandLine;
        // Cache for the module resolution
        var resolutionCache = ts.createResolutionCache(compilerHost, configFileName ?
            ts.getDirectoryPath(ts.getNormalizedAbsolutePath(configFileName, currentDirectory)) :
            currentDirectory, 
        /*logChangesWhenResolvingModule*/ false);
        // Resolve module using host module resolution strategy if provided otherwise use resolution cache to resolve module names
        compilerHost.resolveModuleNames = host.resolveModuleNames ?
            (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return host.resolveModuleNames.apply(host, args);
            }) :
            (function (moduleNames, containingFile, reusedNames, redirectedReference) { return resolutionCache.resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference); });
        compilerHost.resolveTypeReferenceDirectives = host.resolveTypeReferenceDirectives ?
            (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return host.resolveTypeReferenceDirectives.apply(host, args);
            }) :
            (function (typeDirectiveNames, containingFile, redirectedReference) { return resolutionCache.resolveTypeReferenceDirectives(typeDirectiveNames, containingFile, redirectedReference); });
        var userProvidedResolution = !!host.resolveModuleNames || !!host.resolveTypeReferenceDirectives;
        builderProgram = readBuilderProgram(compilerOptions, compilerHost);
        synchronizeProgram();
        // Update the wild card directory watch
        watchConfigFileWildCardDirectories();
        // Update extended config file watch
        if (configFileName)
            updateExtendedConfigFilesWatches(toPath(configFileName), compilerOptions, watchOptions, ts.WatchType.ExtendedConfigFile);
        return configFileName ?
            { getCurrentProgram: getCurrentBuilderProgram, getProgram: updateProgram, close: close } :
            { getCurrentProgram: getCurrentBuilderProgram, getProgram: updateProgram, updateRootFileNames: updateRootFileNames, close: close };
        function close() {
            clearInvalidateResolutionsOfFailedLookupLocations();
            resolutionCache.clear();
            ts.clearMap(sourceFilesCache, function (value) {
                if (value && value.fileWatcher) {
                    value.fileWatcher.close();
                    value.fileWatcher = undefined;
                }
            });
            if (configFileWatcher) {
                configFileWatcher.close();
                configFileWatcher = undefined;
            }
            extendedConfigCache === null || extendedConfigCache === void 0 ? void 0 : extendedConfigCache.clear();
            extendedConfigCache = undefined;
            if (sharedExtendedConfigFileWatchers) {
                ts.clearMap(sharedExtendedConfigFileWatchers, ts.closeFileWatcherOf);
                sharedExtendedConfigFileWatchers = undefined;
            }
            if (watchedWildcardDirectories) {
                ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcherOf);
                watchedWildcardDirectories = undefined;
            }
            if (missingFilesMap) {
                ts.clearMap(missingFilesMap, ts.closeFileWatcher);
                missingFilesMap = undefined;
            }
            if (parsedConfigs) {
                ts.clearMap(parsedConfigs, function (config) {
                    var _a;
                    (_a = config.watcher) === null || _a === void 0 ? void 0 : _a.close();
                    config.watcher = undefined;
                    if (config.watchedDirectories)
                        ts.clearMap(config.watchedDirectories, ts.closeFileWatcherOf);
                    config.watchedDirectories = undefined;
                });
                parsedConfigs = undefined;
            }
            if (packageJsonMap) {
                ts.clearMap(packageJsonMap, ts.closeFileWatcher);
                packageJsonMap = undefined;
            }
        }
        function getCurrentBuilderProgram() {
            return builderProgram;
        }
        function getCurrentProgram() {
            return builderProgram && builderProgram.getProgramOrUndefined();
        }
        function synchronizeProgram() {
            writeLog("Synchronizing program");
            clearInvalidateResolutionsOfFailedLookupLocations();
            var program = getCurrentBuilderProgram();
            if (hasChangedCompilerOptions) {
                newLine = updateNewLine();
                if (program && (changesAffectResolution || ts.changesAffectModuleResolution(program.getCompilerOptions(), compilerOptions))) {
                    resolutionCache.clear();
                }
            }
            // All resolutions are invalid if user provided resolutions
            var hasInvalidatedResolution = resolutionCache.createHasInvalidatedResolution(userProvidedResolution || changesAffectResolution);
            if (ts.isProgramUptoDate(getCurrentProgram(), rootFileNames, compilerOptions, getSourceVersion, fileExists, hasInvalidatedResolution, hasChangedAutomaticTypeDirectiveNames, getParsedCommandLine, projectReferences)) {
                if (hasChangedConfigFileParsingErrors) {
                    builderProgram = createProgram(/*rootNames*/ undefined, /*options*/ undefined, compilerHost, builderProgram, configFileParsingDiagnostics, projectReferences);
                    hasChangedConfigFileParsingErrors = false;
                }
            }
            else {
                createNewProgram(hasInvalidatedResolution);
            }
            changesAffectResolution = false; // reset for next sync
            if (host.afterProgramCreate && program !== builderProgram) {
                host.afterProgramCreate(builderProgram);
            }
            return builderProgram;
        }
        function createNewProgram(hasInvalidatedResolution) {
            // Compile the program
            writeLog("CreatingProgramWith::");
            writeLog("  roots: " + JSON.stringify(rootFileNames));
            writeLog("  options: " + JSON.stringify(compilerOptions));
            if (projectReferences)
                writeLog("  projectReferences: " + JSON.stringify(projectReferences));
            var needsUpdateInTypeRootWatch = hasChangedCompilerOptions || !getCurrentProgram();
            hasChangedCompilerOptions = false;
            hasChangedConfigFileParsingErrors = false;
            resolutionCache.startCachingPerDirectoryResolution();
            compilerHost.hasInvalidatedResolution = hasInvalidatedResolution;
            compilerHost.hasChangedAutomaticTypeDirectiveNames = hasChangedAutomaticTypeDirectiveNames;
            builderProgram = createProgram(rootFileNames, compilerOptions, compilerHost, builderProgram, configFileParsingDiagnostics, projectReferences);
            // map package json cache entries to their realpaths so we don't try to watch across symlinks
            var packageCacheEntries = ts.map(resolutionCache.getModuleResolutionCache().getPackageJsonInfoCache().entries(), function (_a) {
                var path = _a[0], data = _a[1];
                return [compilerHost.realpath ? toPath(compilerHost.realpath(path)) : path, data];
            });
            resolutionCache.finishCachingPerDirectoryResolution();
            // Update watches
            ts.updateMissingFilePathsWatch(builderProgram.getProgram(), missingFilesMap || (missingFilesMap = new ts.Map()), watchMissingFilePath);
            ts.updatePackageJsonWatch(packageCacheEntries, packageJsonMap || (packageJsonMap = new ts.Map()), watchPackageJsonLookupPath);
            if (needsUpdateInTypeRootWatch) {
                resolutionCache.updateTypeRootsWatch();
            }
            if (missingFilePathsRequestedForRelease) {
                // These are the paths that program creater told us as not in use any more but were missing on the disk.
                // We didnt remove the entry for them from sourceFiles cache so that we dont have to do File IO,
                // if there is already watcher for it (for missing files)
                // At this point our watches were updated, hence now we know that these paths are not tracked and need to be removed
                // so that at later time we have correct result of their presence
                for (var _i = 0, missingFilePathsRequestedForRelease_1 = missingFilePathsRequestedForRelease; _i < missingFilePathsRequestedForRelease_1.length; _i++) {
                    var missingFilePath = missingFilePathsRequestedForRelease_1[_i];
                    if (!missingFilesMap.has(missingFilePath)) {
                        sourceFilesCache.delete(missingFilePath);
                    }
                }
                missingFilePathsRequestedForRelease = undefined;
            }
        }
        function updateRootFileNames(files) {
            ts.Debug.assert(!configFileName, "Cannot update root file names with config file watch mode");
            rootFileNames = files;
            scheduleProgramUpdate();
        }
        function updateNewLine() {
            return ts.getNewLineCharacter(compilerOptions || optionsToExtendForConfigFile, function () { return host.getNewLine(); });
        }
        function toPath(fileName) {
            return ts.toPath(fileName, currentDirectory, getCanonicalFileName);
        }
        function isFileMissingOnHost(hostSourceFile) {
            return typeof hostSourceFile === "boolean";
        }
        function isFilePresenceUnknownOnHost(hostSourceFile) {
            return typeof hostSourceFile.version === "boolean";
        }
        function fileExists(fileName) {
            var path = toPath(fileName);
            // If file is missing on host from cache, we can definitely say file doesnt exist
            // otherwise we need to ensure from the disk
            if (isFileMissingOnHost(sourceFilesCache.get(path))) {
                return false;
            }
            return directoryStructureHost.fileExists(fileName);
        }
        function getVersionedSourceFileByPath(fileName, path, languageVersion, onError, shouldCreateNewSourceFile) {
            var hostSourceFile = sourceFilesCache.get(path);
            // No source file on the host
            if (isFileMissingOnHost(hostSourceFile)) {
                return undefined;
            }
            // Create new source file if requested or the versions dont match
            if (hostSourceFile === undefined || shouldCreateNewSourceFile || isFilePresenceUnknownOnHost(hostSourceFile)) {
                var sourceFile = getNewSourceFile(fileName, languageVersion, onError);
                if (hostSourceFile) {
                    if (sourceFile) {
                        // Set the source file and create file watcher now that file was present on the disk
                        hostSourceFile.sourceFile = sourceFile;
                        hostSourceFile.version = sourceFile.version;
                        if (!hostSourceFile.fileWatcher) {
                            hostSourceFile.fileWatcher = watchFilePath(path, fileName, onSourceFileChange, ts.PollingInterval.Low, watchOptions, ts.WatchType.SourceFile);
                        }
                    }
                    else {
                        // There is no source file on host any more, close the watch, missing file paths will track it
                        if (hostSourceFile.fileWatcher) {
                            hostSourceFile.fileWatcher.close();
                        }
                        sourceFilesCache.set(path, false);
                    }
                }
                else {
                    if (sourceFile) {
                        var fileWatcher = watchFilePath(path, fileName, onSourceFileChange, ts.PollingInterval.Low, watchOptions, ts.WatchType.SourceFile);
                        sourceFilesCache.set(path, { sourceFile: sourceFile, version: sourceFile.version, fileWatcher: fileWatcher });
                    }
                    else {
                        sourceFilesCache.set(path, false);
                    }
                }
                return sourceFile;
            }
            return hostSourceFile.sourceFile;
        }
        function nextSourceFileVersion(path) {
            var hostSourceFile = sourceFilesCache.get(path);
            if (hostSourceFile !== undefined) {
                if (isFileMissingOnHost(hostSourceFile)) {
                    // The next version, lets set it as presence unknown file
                    sourceFilesCache.set(path, { version: false });
                }
                else {
                    hostSourceFile.version = false;
                }
            }
        }
        function getSourceVersion(path) {
            var hostSourceFile = sourceFilesCache.get(path);
            return !hostSourceFile || !hostSourceFile.version ? undefined : hostSourceFile.version;
        }
        function onReleaseOldSourceFile(oldSourceFile, _oldOptions, hasSourceFileByPath) {
            var hostSourceFileInfo = sourceFilesCache.get(oldSourceFile.resolvedPath);
            // If this is the source file thats in the cache and new program doesnt need it,
            // remove the cached entry.
            // Note we arent deleting entry if file became missing in new program or
            // there was version update and new source file was created.
            if (hostSourceFileInfo !== undefined) {
                // record the missing file paths so they can be removed later if watchers arent tracking them
                if (isFileMissingOnHost(hostSourceFileInfo)) {
                    (missingFilePathsRequestedForRelease || (missingFilePathsRequestedForRelease = [])).push(oldSourceFile.path);
                }
                else if (hostSourceFileInfo.sourceFile === oldSourceFile) {
                    if (hostSourceFileInfo.fileWatcher) {
                        hostSourceFileInfo.fileWatcher.close();
                    }
                    sourceFilesCache.delete(oldSourceFile.resolvedPath);
                    if (!hasSourceFileByPath) {
                        resolutionCache.removeResolutionsOfFile(oldSourceFile.path);
                    }
                }
            }
        }
        function reportWatchDiagnostic(message) {
            if (host.onWatchStatusChange) {
                host.onWatchStatusChange(ts.createCompilerDiagnostic(message), newLine, compilerOptions || optionsToExtendForConfigFile);
            }
        }
        function hasChangedAutomaticTypeDirectiveNames() {
            return resolutionCache.hasChangedAutomaticTypeDirectiveNames();
        }
        function clearInvalidateResolutionsOfFailedLookupLocations() {
            if (!timerToInvalidateFailedLookupResolutions)
                return false;
            host.clearTimeout(timerToInvalidateFailedLookupResolutions);
            timerToInvalidateFailedLookupResolutions = undefined;
            return true;
        }
        function scheduleInvalidateResolutionsOfFailedLookupLocations() {
            if (!host.setTimeout || !host.clearTimeout) {
                return resolutionCache.invalidateResolutionsOfFailedLookupLocations();
            }
            var pending = clearInvalidateResolutionsOfFailedLookupLocations();
            writeLog("Scheduling invalidateFailedLookup" + (pending ? ", Cancelled earlier one" : ""));
            timerToInvalidateFailedLookupResolutions = host.setTimeout(invalidateResolutionsOfFailedLookup, 250);
        }
        function invalidateResolutionsOfFailedLookup() {
            timerToInvalidateFailedLookupResolutions = undefined;
            if (resolutionCache.invalidateResolutionsOfFailedLookupLocations()) {
                scheduleProgramUpdate();
            }
        }
        // Upon detecting a file change, wait for 250ms and then perform a recompilation. This gives batch
        // operations (such as saving all modified files in an editor) a chance to complete before we kick
        // off a new compilation.
        function scheduleProgramUpdate() {
            if (!host.setTimeout || !host.clearTimeout) {
                return;
            }
            if (timerToUpdateProgram) {
                host.clearTimeout(timerToUpdateProgram);
            }
            writeLog("Scheduling update");
            timerToUpdateProgram = host.setTimeout(updateProgramWithWatchStatus, 250);
        }
        function scheduleProgramReload() {
            ts.Debug.assert(!!configFileName);
            reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
            scheduleProgramUpdate();
        }
        function updateProgramWithWatchStatus() {
            timerToUpdateProgram = undefined;
            reportWatchDiagnostic(ts.Diagnostics.File_change_detected_Starting_incremental_compilation);
            updateProgram();
        }
        function updateProgram() {
            switch (reloadLevel) {
                case ts.ConfigFileProgramReloadLevel.Partial:
                    ts.perfLogger.logStartUpdateProgram("PartialConfigReload");
                    reloadFileNamesFromConfigFile();
                    break;
                case ts.ConfigFileProgramReloadLevel.Full:
                    ts.perfLogger.logStartUpdateProgram("FullConfigReload");
                    reloadConfigFile();
                    break;
                default:
                    ts.perfLogger.logStartUpdateProgram("SynchronizeProgram");
                    synchronizeProgram();
                    break;
            }
            ts.perfLogger.logStopUpdateProgram("Done");
            return getCurrentBuilderProgram();
        }
        function reloadFileNamesFromConfigFile() {
            writeLog("Reloading new file names and options");
            rootFileNames = ts.getFileNamesFromConfigSpecs(compilerOptions.configFile.configFileSpecs, ts.getNormalizedAbsolutePath(ts.getDirectoryPath(configFileName), currentDirectory), compilerOptions, parseConfigFileHost, extraFileExtensions);
            if (ts.updateErrorForNoInputFiles(rootFileNames, ts.getNormalizedAbsolutePath(configFileName, currentDirectory), compilerOptions.configFile.configFileSpecs, configFileParsingDiagnostics, canConfigFileJsonReportNoInputFiles)) {
                hasChangedConfigFileParsingErrors = true;
            }
            // Update the program
            synchronizeProgram();
        }
        function reloadConfigFile() {
            writeLog("Reloading config file: " + configFileName);
            reloadLevel = ts.ConfigFileProgramReloadLevel.None;
            if (cachedDirectoryStructureHost) {
                cachedDirectoryStructureHost.clearCache();
            }
            parseConfigFile();
            hasChangedCompilerOptions = true;
            synchronizeProgram();
            // Update the wild card directory watch
            watchConfigFileWildCardDirectories();
            // Update extended config file watch
            updateExtendedConfigFilesWatches(toPath(configFileName), compilerOptions, watchOptions, ts.WatchType.ExtendedConfigFile);
        }
        function parseConfigFile() {
            setConfigFileParsingResult(ts.getParsedCommandLineOfConfigFile(configFileName, optionsToExtendForConfigFile, parseConfigFileHost, extendedConfigCache || (extendedConfigCache = new ts.Map()), watchOptionsToExtend, extraFileExtensions)); // TODO: GH#18217
        }
        function setConfigFileParsingResult(configFileParseResult) {
            rootFileNames = configFileParseResult.fileNames;
            compilerOptions = configFileParseResult.options;
            watchOptions = configFileParseResult.watchOptions;
            projectReferences = configFileParseResult.projectReferences;
            wildcardDirectories = configFileParseResult.wildcardDirectories;
            configFileParsingDiagnostics = ts.getConfigFileParsingDiagnostics(configFileParseResult).slice();
            canConfigFileJsonReportNoInputFiles = ts.canJsonReportNoInputFiles(configFileParseResult.raw);
            hasChangedConfigFileParsingErrors = true;
        }
        function getParsedCommandLine(configFileName) {
            var configPath = toPath(configFileName);
            var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(configPath);
            if (config) {
                if (!config.reloadLevel)
                    return config.parsedCommandLine;
                // With host implementing getParsedCommandLine we cant just update file names
                if (config.parsedCommandLine && config.reloadLevel === ts.ConfigFileProgramReloadLevel.Partial && !host.getParsedCommandLine) {
                    writeLog("Reloading new file names and options");
                    var fileNames = ts.getFileNamesFromConfigSpecs(config.parsedCommandLine.options.configFile.configFileSpecs, ts.getNormalizedAbsolutePath(ts.getDirectoryPath(configFileName), currentDirectory), compilerOptions, parseConfigFileHost);
                    config.parsedCommandLine = __assign(__assign({}, config.parsedCommandLine), { fileNames: fileNames });
                    config.reloadLevel = undefined;
                    return config.parsedCommandLine;
                }
            }
            writeLog("Loading config file: " + configFileName);
            var parsedCommandLine = host.getParsedCommandLine ?
                host.getParsedCommandLine(configFileName) :
                getParsedCommandLineFromConfigFileHost(configFileName);
            if (config) {
                config.parsedCommandLine = parsedCommandLine;
                config.reloadLevel = undefined;
            }
            else {
                (parsedConfigs || (parsedConfigs = new ts.Map())).set(configPath, config = { parsedCommandLine: parsedCommandLine });
            }
            watchReferencedProject(configFileName, configPath, config);
            return parsedCommandLine;
        }
        function getParsedCommandLineFromConfigFileHost(configFileName) {
            // Ignore the file absent errors
            var onUnRecoverableConfigFileDiagnostic = parseConfigFileHost.onUnRecoverableConfigFileDiagnostic;
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = ts.noop;
            var parsedCommandLine = ts.getParsedCommandLineOfConfigFile(configFileName, 
            /*optionsToExtend*/ undefined, parseConfigFileHost, extendedConfigCache || (extendedConfigCache = new ts.Map()), watchOptionsToExtend);
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = onUnRecoverableConfigFileDiagnostic;
            return parsedCommandLine;
        }
        function onReleaseParsedCommandLine(fileName) {
            var _a;
            var path = toPath(fileName);
            var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(path);
            if (!config)
                return;
            parsedConfigs.delete(path);
            if (config.watchedDirectories)
                ts.clearMap(config.watchedDirectories, ts.closeFileWatcherOf);
            (_a = config.watcher) === null || _a === void 0 ? void 0 : _a.close();
            ts.clearSharedExtendedConfigFileWatcher(path, sharedExtendedConfigFileWatchers);
        }
        function watchFilePath(path, file, callback, pollingInterval, options, watchType) {
            return watchFile(file, function (fileName, eventKind) { return callback(fileName, eventKind, path); }, pollingInterval, options, watchType);
        }
        function onSourceFileChange(fileName, eventKind, path) {
            updateCachedSystemWithFile(fileName, path, eventKind);
            // Update the source file cache
            if (eventKind === ts.FileWatcherEventKind.Deleted && sourceFilesCache.has(path)) {
                resolutionCache.invalidateResolutionOfFile(path);
            }
            nextSourceFileVersion(path);
            // Update the program
            scheduleProgramUpdate();
        }
        function updateCachedSystemWithFile(fileName, path, eventKind) {
            if (cachedDirectoryStructureHost) {
                cachedDirectoryStructureHost.addOrDeleteFile(fileName, path, eventKind);
            }
        }
        function watchMissingFilePath(missingFilePath) {
            // If watching missing referenced config file, we are already watching it so no need for separate watcher
            return (parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.has(missingFilePath)) ?
                ts.noopFileWatcher :
                watchFilePath(missingFilePath, missingFilePath, onMissingFileChange, ts.PollingInterval.Medium, watchOptions, ts.WatchType.MissingFile);
        }
        function watchPackageJsonLookupPath(packageJsonPath) {
            // If the package.json is pulled into the compilation itself (eg, via json imports), don't add a second watcher here
            return sourceFilesCache.has(packageJsonPath) ?
                ts.noopFileWatcher :
                watchFilePath(packageJsonPath, packageJsonPath, onPackageJsonChange, ts.PollingInterval.High, watchOptions, ts.WatchType.PackageJson);
        }
        function onPackageJsonChange(fileName, eventKind, path) {
            updateCachedSystemWithFile(fileName, path, eventKind);
            // package.json changes invalidate module resolution and can change the set of loaded files
            // so if we witness a change to one, we have to do a full reload
            reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
            changesAffectResolution = true;
            // Update the program
            scheduleProgramUpdate();
        }
        function onMissingFileChange(fileName, eventKind, missingFilePath) {
            updateCachedSystemWithFile(fileName, missingFilePath, eventKind);
            if (eventKind === ts.FileWatcherEventKind.Created && missingFilesMap.has(missingFilePath)) {
                missingFilesMap.get(missingFilePath).close();
                missingFilesMap.delete(missingFilePath);
                // Delete the entry in the source files cache so that new source file is created
                nextSourceFileVersion(missingFilePath);
                // When a missing file is created, we should update the graph.
                scheduleProgramUpdate();
            }
        }
        function watchConfigFileWildCardDirectories() {
            if (wildcardDirectories) {
                ts.updateWatchingWildcardDirectories(watchedWildcardDirectories || (watchedWildcardDirectories = new ts.Map()), new ts.Map(ts.getEntries(wildcardDirectories)), watchWildcardDirectory);
            }
            else if (watchedWildcardDirectories) {
                ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcherOf);
            }
        }
        function watchWildcardDirectory(directory, flags) {
            return watchDirectory(directory, function (fileOrDirectory) {
                ts.Debug.assert(!!configFileName);
                var fileOrDirectoryPath = toPath(fileOrDirectory);
                // Since the file existence changed, update the sourceFiles cache
                if (cachedDirectoryStructureHost) {
                    cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                }
                nextSourceFileVersion(fileOrDirectoryPath);
                if (ts.isIgnoredFileFromWildCardWatching({
                    watchedDirPath: toPath(directory),
                    fileOrDirectory: fileOrDirectory,
                    fileOrDirectoryPath: fileOrDirectoryPath,
                    configFileName: configFileName,
                    extraFileExtensions: extraFileExtensions,
                    options: compilerOptions,
                    program: getCurrentBuilderProgram() || rootFileNames,
                    currentDirectory: currentDirectory,
                    useCaseSensitiveFileNames: useCaseSensitiveFileNames,
                    writeLog: writeLog,
                    toPath: toPath,
                }))
                    return;
                // Reload is pending, do the reload
                if (reloadLevel !== ts.ConfigFileProgramReloadLevel.Full) {
                    reloadLevel = ts.ConfigFileProgramReloadLevel.Partial;
                    // Schedule Update the program
                    scheduleProgramUpdate();
                }
            }, flags, watchOptions, ts.WatchType.WildcardDirectory);
        }
        function updateExtendedConfigFilesWatches(forProjectPath, options, watchOptions, watchType) {
            ts.updateSharedExtendedConfigFileWatcher(forProjectPath, options, sharedExtendedConfigFileWatchers || (sharedExtendedConfigFileWatchers = new ts.Map()), function (extendedConfigFileName, extendedConfigFilePath) { return watchFile(extendedConfigFileName, function (_fileName, eventKind) {
                var _a;
                updateCachedSystemWithFile(extendedConfigFileName, extendedConfigFilePath, eventKind);
                // Update extended config cache
                if (extendedConfigCache)
                    ts.cleanExtendedConfigCache(extendedConfigCache, extendedConfigFilePath, toPath);
                // Update projects
                var projects = (_a = sharedExtendedConfigFileWatchers.get(extendedConfigFilePath)) === null || _a === void 0 ? void 0 : _a.projects;
                // If there are no referenced projects this extended config file watcher depend on ignore
                if (!(projects === null || projects === void 0 ? void 0 : projects.size))
                    return;
                projects.forEach(function (projectPath) {
                    if (toPath(configFileName) === projectPath) {
                        // If this is the config file of the project, reload completely
                        reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
                    }
                    else {
                        // Reload config for the referenced projects and remove the resolutions from referenced projects since the config file changed
                        var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(projectPath);
                        if (config)
                            config.reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
                        resolutionCache.removeResolutionsFromProjectReferenceRedirects(projectPath);
                    }
                    scheduleProgramUpdate();
                });
            }, ts.PollingInterval.High, watchOptions, watchType); }, toPath);
        }
        function watchReferencedProject(configFileName, configPath, commandLine) {
            var _a, _b, _c, _d, _e;
            // Watch file
            commandLine.watcher || (commandLine.watcher = watchFile(configFileName, function (_fileName, eventKind) {
                updateCachedSystemWithFile(configFileName, configPath, eventKind);
                var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(configPath);
                if (config)
                    config.reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
                resolutionCache.removeResolutionsFromProjectReferenceRedirects(configPath);
                scheduleProgramUpdate();
            }, ts.PollingInterval.High, ((_a = commandLine.parsedCommandLine) === null || _a === void 0 ? void 0 : _a.watchOptions) || watchOptions, ts.WatchType.ConfigFileOfReferencedProject));
            // Watch Wild card
            if ((_b = commandLine.parsedCommandLine) === null || _b === void 0 ? void 0 : _b.wildcardDirectories) {
                ts.updateWatchingWildcardDirectories(commandLine.watchedDirectories || (commandLine.watchedDirectories = new ts.Map()), new ts.Map(ts.getEntries((_c = commandLine.parsedCommandLine) === null || _c === void 0 ? void 0 : _c.wildcardDirectories)), function (directory, flags) {
                    var _a;
                    return watchDirectory(directory, function (fileOrDirectory) {
                        var fileOrDirectoryPath = toPath(fileOrDirectory);
                        // Since the file existence changed, update the sourceFiles cache
                        if (cachedDirectoryStructureHost) {
                            cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                        }
                        nextSourceFileVersion(fileOrDirectoryPath);
                        var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(configPath);
                        if (!(config === null || config === void 0 ? void 0 : config.parsedCommandLine))
                            return;
                        if (ts.isIgnoredFileFromWildCardWatching({
                            watchedDirPath: toPath(directory),
                            fileOrDirectory: fileOrDirectory,
                            fileOrDirectoryPath: fileOrDirectoryPath,
                            configFileName: configFileName,
                            options: config.parsedCommandLine.options,
                            program: config.parsedCommandLine.fileNames,
                            currentDirectory: currentDirectory,
                            useCaseSensitiveFileNames: useCaseSensitiveFileNames,
                            writeLog: writeLog,
                            toPath: toPath,
                        }))
                            return;
                        // Reload is pending, do the reload
                        if (config.reloadLevel !== ts.ConfigFileProgramReloadLevel.Full) {
                            config.reloadLevel = ts.ConfigFileProgramReloadLevel.Partial;
                            // Schedule Update the program
                            scheduleProgramUpdate();
                        }
                    }, flags, ((_a = commandLine.parsedCommandLine) === null || _a === void 0 ? void 0 : _a.watchOptions) || watchOptions, ts.WatchType.WildcardDirectoryOfReferencedProject);
                });
            }
            else if (commandLine.watchedDirectories) {
                ts.clearMap(commandLine.watchedDirectories, ts.closeFileWatcherOf);
                commandLine.watchedDirectories = undefined;
            }
            // Watch extended config files
            updateExtendedConfigFilesWatches(configPath, (_d = commandLine.parsedCommandLine) === null || _d === void 0 ? void 0 : _d.options, ((_e = commandLine.parsedCommandLine) === null || _e === void 0 ? void 0 : _e.watchOptions) || watchOptions, ts.WatchType.ExtendedConfigOfReferencedProject);
        }
    }
    ts.createWatchProgram = createWatchProgram;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var UpToDateStatusType;
    (function (UpToDateStatusType) {
        UpToDateStatusType[UpToDateStatusType["Unbuildable"] = 0] = "Unbuildable";
        UpToDateStatusType[UpToDateStatusType["UpToDate"] = 1] = "UpToDate";
        /**
         * The project appears out of date because its upstream inputs are newer than its outputs,
         * but all of its outputs are actually newer than the previous identical outputs of its (.d.ts) inputs.
         * This means we can Pseudo-build (just touch timestamps), as if we had actually built this project.
         */
        UpToDateStatusType[UpToDateStatusType["UpToDateWithUpstreamTypes"] = 2] = "UpToDateWithUpstreamTypes";
        /**
         * The project appears out of date because its upstream inputs are newer than its outputs,
         * but all of its outputs are actually newer than the previous identical outputs of its (.d.ts) inputs.
         * This means we can Pseudo-build (just manipulate outputs), as if we had actually built this project.
         */
        UpToDateStatusType[UpToDateStatusType["OutOfDateWithPrepend"] = 3] = "OutOfDateWithPrepend";
        UpToDateStatusType[UpToDateStatusType["OutputMissing"] = 4] = "OutputMissing";
        UpToDateStatusType[UpToDateStatusType["OutOfDateWithSelf"] = 5] = "OutOfDateWithSelf";
        UpToDateStatusType[UpToDateStatusType["OutOfDateWithUpstream"] = 6] = "OutOfDateWithUpstream";
        UpToDateStatusType[UpToDateStatusType["UpstreamOutOfDate"] = 7] = "UpstreamOutOfDate";
        UpToDateStatusType[UpToDateStatusType["UpstreamBlocked"] = 8] = "UpstreamBlocked";
        UpToDateStatusType[UpToDateStatusType["ComputingUpstream"] = 9] = "ComputingUpstream";
        UpToDateStatusType[UpToDateStatusType["TsVersionOutputOfDate"] = 10] = "TsVersionOutputOfDate";
        /**
         * Projects with no outputs (i.e. "solution" files)
         */
        UpToDateStatusType[UpToDateStatusType["ContainerOnly"] = 11] = "ContainerOnly";
    })(UpToDateStatusType = ts.UpToDateStatusType || (ts.UpToDateStatusType = {}));
    function resolveConfigFileProjectName(project) {
        if (ts.fileExtensionIs(project, ".json" /* Json */)) {
            return project;
        }
        return ts.combinePaths(project, "tsconfig.json");
    }
    ts.resolveConfigFileProjectName = resolveConfigFileProjectName;
})(ts || (ts = {}));
var ts;
(function (ts) {
    var minimumDate = new Date(-8640000000000000);
    var maximumDate = new Date(8640000000000000);
    var BuildResultFlags;
    (function (BuildResultFlags) {
        BuildResultFlags[BuildResultFlags["None"] = 0] = "None";
        /**
         * No errors of any kind occurred during build
         */
        BuildResultFlags[BuildResultFlags["Success"] = 1] = "Success";
        /**
         * None of the .d.ts files emitted by this build were
         * different from the existing files on disk
         */
        BuildResultFlags[BuildResultFlags["DeclarationOutputUnchanged"] = 2] = "DeclarationOutputUnchanged";
        BuildResultFlags[BuildResultFlags["ConfigFileErrors"] = 4] = "ConfigFileErrors";
        BuildResultFlags[BuildResultFlags["SyntaxErrors"] = 8] = "SyntaxErrors";
        BuildResultFlags[BuildResultFlags["TypeErrors"] = 16] = "TypeErrors";
        BuildResultFlags[BuildResultFlags["DeclarationEmitErrors"] = 32] = "DeclarationEmitErrors";
        BuildResultFlags[BuildResultFlags["EmitErrors"] = 64] = "EmitErrors";
        BuildResultFlags[BuildResultFlags["AnyErrors"] = 124] = "AnyErrors";
    })(BuildResultFlags || (BuildResultFlags = {}));
    function getOrCreateValueFromConfigFileMap(configFileMap, resolved, createT) {
        var existingValue = configFileMap.get(resolved);
        var newValue;
        if (!existingValue) {
            newValue = createT();
            configFileMap.set(resolved, newValue);
        }
        return existingValue || newValue;
    }
    function getOrCreateValueMapFromConfigFileMap(configFileMap, resolved) {
        return getOrCreateValueFromConfigFileMap(configFileMap, resolved, function () { return new ts.Map(); });
    }
    function newer(date1, date2) {
        return date2 > date1 ? date2 : date1;
    }
    function isDeclarationFile(fileName) {
        return ts.fileExtensionIs(fileName, ".d.ts" /* Dts */);
    }
    /*@internal*/
    function isCircularBuildOrder(buildOrder) {
        return !!buildOrder && !!buildOrder.buildOrder;
    }
    ts.isCircularBuildOrder = isCircularBuildOrder;
    /*@internal*/
    function getBuildOrderFromAnyBuildOrder(anyBuildOrder) {
        return isCircularBuildOrder(anyBuildOrder) ? anyBuildOrder.buildOrder : anyBuildOrder;
    }
    ts.getBuildOrderFromAnyBuildOrder = getBuildOrderFromAnyBuildOrder;
    /**
     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic
     */
    function createBuilderStatusReporter(system, pretty) {
        return function (diagnostic) {
            var output = pretty ? "[" + ts.formatColorAndReset(ts.getLocaleTimeString(system), ts.ForegroundColorEscapeSequences.Grey) + "] " : ts.getLocaleTimeString(system) + " - ";
            output += "" + ts.flattenDiagnosticMessageText(diagnostic.messageText, system.newLine) + (system.newLine + system.newLine);
            system.write(output);
        };
    }
    ts.createBuilderStatusReporter = createBuilderStatusReporter;
    function createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus) {
        var host = ts.createProgramHost(system, createProgram);
        host.getModifiedTime = system.getModifiedTime ? function (path) { return system.getModifiedTime(path); } : ts.returnUndefined;
        host.setModifiedTime = system.setModifiedTime ? function (path, date) { return system.setModifiedTime(path, date); } : ts.noop;
        host.deleteFile = system.deleteFile ? function (path) { return system.deleteFile(path); } : ts.noop;
        host.reportDiagnostic = reportDiagnostic || ts.createDiagnosticReporter(system);
        host.reportSolutionBuilderStatus = reportSolutionBuilderStatus || createBuilderStatusReporter(system);
        host.now = ts.maybeBind(system, system.now); // For testing
        return host;
    }
    function createSolutionBuilderHost(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus, reportErrorSummary) {
        if (system === void 0) { system = ts.sys; }
        var host = createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus);
        host.reportErrorSummary = reportErrorSummary;
        return host;
    }
    ts.createSolutionBuilderHost = createSolutionBuilderHost;
    function createSolutionBuilderWithWatchHost(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus, reportWatchStatus) {
        if (system === void 0) { system = ts.sys; }
        var host = createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus);
        var watchHost = ts.createWatchHost(system, reportWatchStatus);
        ts.copyProperties(host, watchHost);
        return host;
    }
    ts.createSolutionBuilderWithWatchHost = createSolutionBuilderWithWatchHost;
    function getCompilerOptionsOfBuildOptions(buildOptions) {
        var result = {};
        ts.commonOptionsWithBuild.forEach(function (option) {
            if (ts.hasProperty(buildOptions, option.name))
                result[option.name] = buildOptions[option.name];
        });
        return result;
    }
    function createSolutionBuilder(host, rootNames, defaultOptions) {
        return createSolutionBuilderWorker(/*watch*/ false, host, rootNames, defaultOptions);
    }
    ts.createSolutionBuilder = createSolutionBuilder;
    function createSolutionBuilderWithWatch(host, rootNames, defaultOptions, baseWatchOptions) {
        return createSolutionBuilderWorker(/*watch*/ true, host, rootNames, defaultOptions, baseWatchOptions);
    }
    ts.createSolutionBuilderWithWatch = createSolutionBuilderWithWatch;
    function createSolutionBuilderState(watch, hostOrHostWithWatch, rootNames, options, baseWatchOptions) {
        var host = hostOrHostWithWatch;
        var hostWithWatch = hostOrHostWithWatch;
        var currentDirectory = host.getCurrentDirectory();
        var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames());
        // State of the solution
        var baseCompilerOptions = getCompilerOptionsOfBuildOptions(options);
        var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return state.projectCompilerOptions; });
        ts.setGetSourceFileAsHashVersioned(compilerHost, host);
        compilerHost.getParsedCommandLine = function (fileName) { return parseConfigFile(state, fileName, toResolvedConfigFilePath(state, fileName)); };
        compilerHost.resolveModuleNames = ts.maybeBind(host, host.resolveModuleNames);
        compilerHost.resolveTypeReferenceDirectives = ts.maybeBind(host, host.resolveTypeReferenceDirectives);
        var moduleResolutionCache = !compilerHost.resolveModuleNames ? ts.createModuleResolutionCache(currentDirectory, getCanonicalFileName) : undefined;
        var typeReferenceDirectiveResolutionCache = !compilerHost.resolveTypeReferenceDirectives ? ts.createTypeReferenceDirectiveResolutionCache(currentDirectory, getCanonicalFileName, /*options*/ undefined, moduleResolutionCache === null || moduleResolutionCache === void 0 ? void 0 : moduleResolutionCache.getPackageJsonInfoCache()) : undefined;
        if (!compilerHost.resolveModuleNames) {
            var loader_3 = function (moduleName, containingFile, redirectedReference) { return ts.resolveModuleName(moduleName, containingFile, state.projectCompilerOptions, compilerHost, moduleResolutionCache, redirectedReference).resolvedModule; };
            compilerHost.resolveModuleNames = function (moduleNames, containingFile, _reusedNames, redirectedReference) {
                return ts.loadWithLocalCache(ts.Debug.checkEachDefined(moduleNames), containingFile, redirectedReference, loader_3);
            };
        }
        if (!compilerHost.resolveTypeReferenceDirectives) {
            var loader_4 = function (moduleName, containingFile, redirectedReference) { return ts.resolveTypeReferenceDirective(moduleName, containingFile, state.projectCompilerOptions, compilerHost, redirectedReference, state.typeReferenceDirectiveResolutionCache).resolvedTypeReferenceDirective; };
            compilerHost.resolveTypeReferenceDirectives = function (typeReferenceDirectiveNames, containingFile, redirectedReference) {
                return ts.loadWithLocalCache(ts.Debug.checkEachDefined(typeReferenceDirectiveNames), containingFile, redirectedReference, loader_4);
            };
        }
        var _a = ts.createWatchFactory(hostWithWatch, options), watchFile = _a.watchFile, watchDirectory = _a.watchDirectory, writeLog = _a.writeLog;
        var state = {
            host: host,
            hostWithWatch: hostWithWatch,
            currentDirectory: currentDirectory,
            getCanonicalFileName: getCanonicalFileName,
            parseConfigFileHost: ts.parseConfigHostFromCompilerHostLike(host),
            write: ts.maybeBind(host, host.trace),
            // State of solution
            options: options,
            baseCompilerOptions: baseCompilerOptions,
            rootNames: rootNames,
            baseWatchOptions: baseWatchOptions,
            resolvedConfigFilePaths: new ts.Map(),
            configFileCache: new ts.Map(),
            projectStatus: new ts.Map(),
            buildInfoChecked: new ts.Map(),
            extendedConfigCache: new ts.Map(),
            builderPrograms: new ts.Map(),
            diagnostics: new ts.Map(),
            projectPendingBuild: new ts.Map(),
            projectErrorsReported: new ts.Map(),
            compilerHost: compilerHost,
            moduleResolutionCache: moduleResolutionCache,
            typeReferenceDirectiveResolutionCache: typeReferenceDirectiveResolutionCache,
            // Mutable state
            buildOrder: undefined,
            readFileWithCache: function (f) { return host.readFile(f); },
            projectCompilerOptions: baseCompilerOptions,
            cache: undefined,
            allProjectBuildPending: true,
            needsSummary: true,
            watchAllProjectsPending: watch,
            currentInvalidatedProject: undefined,
            // Watch state
            watch: watch,
            allWatchedWildcardDirectories: new ts.Map(),
            allWatchedInputFiles: new ts.Map(),
            allWatchedConfigFiles: new ts.Map(),
            allWatchedExtendedConfigFiles: new ts.Map(),
            allWatchedPackageJsonFiles: new ts.Map(),
            lastCachedPackageJsonLookups: new ts.Map(),
            timerToBuildInvalidatedProject: undefined,
            reportFileChangeDetected: false,
            watchFile: watchFile,
            watchDirectory: watchDirectory,
            writeLog: writeLog,
        };
        return state;
    }
    function toPath(state, fileName) {
        return ts.toPath(fileName, state.currentDirectory, state.getCanonicalFileName);
    }
    function toResolvedConfigFilePath(state, fileName) {
        var resolvedConfigFilePaths = state.resolvedConfigFilePaths;
        var path = resolvedConfigFilePaths.get(fileName);
        if (path !== undefined)
            return path;
        var resolvedPath = toPath(state, fileName);
        resolvedConfigFilePaths.set(fileName, resolvedPath);
        return resolvedPath;
    }
    function isParsedCommandLine(entry) {
        return !!entry.options;
    }
    function getCachedParsedConfigFile(state, configFilePath) {
        var value = state.configFileCache.get(configFilePath);
        return value && isParsedCommandLine(value) ? value : undefined;
    }
    function parseConfigFile(state, configFileName, configFilePath) {
        var configFileCache = state.configFileCache;
        var value = configFileCache.get(configFilePath);
        if (value) {
            return isParsedCommandLine(value) ? value : undefined;
        }
        var diagnostic;
        var parseConfigFileHost = state.parseConfigFileHost, baseCompilerOptions = state.baseCompilerOptions, baseWatchOptions = state.baseWatchOptions, extendedConfigCache = state.extendedConfigCache, host = state.host;
        var parsed;
        if (host.getParsedCommandLine) {
            parsed = host.getParsedCommandLine(configFileName);
            if (!parsed)
                diagnostic = ts.createCompilerDiagnostic(ts.Diagnostics.File_0_not_found, configFileName);
        }
        else {
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = function (d) { return diagnostic = d; };
            parsed = ts.getParsedCommandLineOfConfigFile(configFileName, baseCompilerOptions, parseConfigFileHost, extendedConfigCache, baseWatchOptions);
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = ts.noop;
        }
        configFileCache.set(configFilePath, parsed || diagnostic);
        return parsed;
    }
    function resolveProjectName(state, name) {
        return ts.resolveConfigFileProjectName(ts.resolvePath(state.currentDirectory, name));
    }
    function createBuildOrder(state, roots) {
        var temporaryMarks = new ts.Map();
        var permanentMarks = new ts.Map();
        var circularityReportStack = [];
        var buildOrder;
        var circularDiagnostics;
        for (var _i = 0, roots_1 = roots; _i < roots_1.length; _i++) {
            var root = roots_1[_i];
            visit(root);
        }
        return circularDiagnostics ?
            { buildOrder: buildOrder || ts.emptyArray, circularDiagnostics: circularDiagnostics } :
            buildOrder || ts.emptyArray;
        function visit(configFileName, inCircularContext) {
            var projPath = toResolvedConfigFilePath(state, configFileName);
            // Already visited
            if (permanentMarks.has(projPath))
                return;
            // Circular
            if (temporaryMarks.has(projPath)) {
                if (!inCircularContext) {
                    (circularDiagnostics || (circularDiagnostics = [])).push(ts.createCompilerDiagnostic(ts.Diagnostics.Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0, circularityReportStack.join("\r\n")));
                }
                return;
            }
            temporaryMarks.set(projPath, true);
            circularityReportStack.push(configFileName);
            var parsed = parseConfigFile(state, configFileName, projPath);
            if (parsed && parsed.projectReferences) {
                for (var _i = 0, _a = parsed.projectReferences; _i < _a.length; _i++) {
                    var ref = _a[_i];
                    var resolvedRefPath = resolveProjectName(state, ref.path);
                    visit(resolvedRefPath, inCircularContext || ref.circular);
                }
            }
            circularityReportStack.pop();
            permanentMarks.set(projPath, true);
            (buildOrder || (buildOrder = [])).push(configFileName);
        }
    }
    function getBuildOrder(state) {
        return state.buildOrder || createStateBuildOrder(state);
    }
    function createStateBuildOrder(state) {
        var buildOrder = createBuildOrder(state, state.rootNames.map(function (f) { return resolveProjectName(state, f); }));
        // Clear all to ResolvedConfigFilePaths cache to start fresh
        state.resolvedConfigFilePaths.clear();
        // TODO(rbuckton): Should be a `Set`, but that requires changing the code below that uses `mutateMapSkippingNewValues`
        var currentProjects = new ts.Map(getBuildOrderFromAnyBuildOrder(buildOrder).map(function (resolved) { return [toResolvedConfigFilePath(state, resolved), true]; }));
        var noopOnDelete = { onDeleteValue: ts.noop };
        // Config file cache
        ts.mutateMapSkippingNewValues(state.configFileCache, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.projectStatus, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.buildInfoChecked, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.builderPrograms, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.diagnostics, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.projectPendingBuild, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.projectErrorsReported, currentProjects, noopOnDelete);
        // Remove watches for the program no longer in the solution
        if (state.watch) {
            ts.mutateMapSkippingNewValues(state.allWatchedConfigFiles, currentProjects, { onDeleteValue: ts.closeFileWatcher });
            state.allWatchedExtendedConfigFiles.forEach(function (watcher) {
                watcher.projects.forEach(function (project) {
                    if (!currentProjects.has(project)) {
                        watcher.projects.delete(project);
                    }
                });
                watcher.close();
            });
            ts.mutateMapSkippingNewValues(state.allWatchedWildcardDirectories, currentProjects, { onDeleteValue: function (existingMap) { return existingMap.forEach(ts.closeFileWatcherOf); } });
            ts.mutateMapSkippingNewValues(state.allWatchedInputFiles, currentProjects, { onDeleteValue: function (existingMap) { return existingMap.forEach(ts.closeFileWatcher); } });
            ts.mutateMapSkippingNewValues(state.allWatchedPackageJsonFiles, currentProjects, { onDeleteValue: function (existingMap) { return existingMap.forEach(ts.closeFileWatcher); } });
        }
        return state.buildOrder = buildOrder;
    }
    function getBuildOrderFor(state, project, onlyReferences) {
        var resolvedProject = project && resolveProjectName(state, project);
        var buildOrderFromState = getBuildOrder(state);
        if (isCircularBuildOrder(buildOrderFromState))
            return buildOrderFromState;
        if (resolvedProject) {
            var projectPath_1 = toResolvedConfigFilePath(state, resolvedProject);
            var projectIndex = ts.findIndex(buildOrderFromState, function (configFileName) { return toResolvedConfigFilePath(state, configFileName) === projectPath_1; });
            if (projectIndex === -1)
                return undefined;
        }
        var buildOrder = resolvedProject ? createBuildOrder(state, [resolvedProject]) : buildOrderFromState;
        ts.Debug.assert(!isCircularBuildOrder(buildOrder));
        ts.Debug.assert(!onlyReferences || resolvedProject !== undefined);
        ts.Debug.assert(!onlyReferences || buildOrder[buildOrder.length - 1] === resolvedProject);
        return onlyReferences ? buildOrder.slice(0, buildOrder.length - 1) : buildOrder;
    }
    function enableCache(state) {
        if (state.cache) {
            disableCache(state);
        }
        var compilerHost = state.compilerHost, host = state.host;
        var originalReadFileWithCache = state.readFileWithCache;
        var originalGetSourceFile = compilerHost.getSourceFile;
        var _a = ts.changeCompilerHostLikeToUseCache(host, function (fileName) { return toPath(state, fileName); }, function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return originalGetSourceFile.call.apply(originalGetSourceFile, __spreadArray([compilerHost], args, false));
        }), originalReadFile = _a.originalReadFile, originalFileExists = _a.originalFileExists, originalDirectoryExists = _a.originalDirectoryExists, originalCreateDirectory = _a.originalCreateDirectory, originalWriteFile = _a.originalWriteFile, getSourceFileWithCache = _a.getSourceFileWithCache, readFileWithCache = _a.readFileWithCache;
        state.readFileWithCache = readFileWithCache;
        compilerHost.getSourceFile = getSourceFileWithCache;
        state.cache = {
            originalReadFile: originalReadFile,
            originalFileExists: originalFileExists,
            originalDirectoryExists: originalDirectoryExists,
            originalCreateDirectory: originalCreateDirectory,
            originalWriteFile: originalWriteFile,
            originalReadFileWithCache: originalReadFileWithCache,
            originalGetSourceFile: originalGetSourceFile,
        };
    }
    function disableCache(state) {
        if (!state.cache)
            return;
        var cache = state.cache, host = state.host, compilerHost = state.compilerHost, extendedConfigCache = state.extendedConfigCache, moduleResolutionCache = state.moduleResolutionCache, typeReferenceDirectiveResolutionCache = state.typeReferenceDirectiveResolutionCache;
        host.readFile = cache.originalReadFile;
        host.fileExists = cache.originalFileExists;
        host.directoryExists = cache.originalDirectoryExists;
        host.createDirectory = cache.originalCreateDirectory;
        host.writeFile = cache.originalWriteFile;
        compilerHost.getSourceFile = cache.originalGetSourceFile;
        state.readFileWithCache = cache.originalReadFileWithCache;
        extendedConfigCache.clear();
        moduleResolutionCache === null || moduleResolutionCache === void 0 ? void 0 : moduleResolutionCache.clear();
        typeReferenceDirectiveResolutionCache === null || typeReferenceDirectiveResolutionCache === void 0 ? void 0 : typeReferenceDirectiveResolutionCache.clear();
        state.cache = undefined;
    }
    function clearProjectStatus(state, resolved) {
        state.projectStatus.delete(resolved);
        state.diagnostics.delete(resolved);
    }
    function addProjToQueue(_a, proj, reloadLevel) {
        var projectPendingBuild = _a.projectPendingBuild;
        var value = projectPendingBuild.get(proj);
        if (value === undefined) {
            projectPendingBuild.set(proj, reloadLevel);
        }
        else if (value < reloadLevel) {
            projectPendingBuild.set(proj, reloadLevel);
        }
    }
    function setupInitialBuild(state, cancellationToken) {
        // Set initial build if not already built
        if (!state.allProjectBuildPending)
            return;
        state.allProjectBuildPending = false;
        if (state.options.watch) {
            reportWatchStatus(state, ts.Diagnostics.Starting_compilation_in_watch_mode);
        }
        enableCache(state);
        var buildOrder = getBuildOrderFromAnyBuildOrder(getBuildOrder(state));
        buildOrder.forEach(function (configFileName) {
            return state.projectPendingBuild.set(toResolvedConfigFilePath(state, configFileName), ts.ConfigFileProgramReloadLevel.None);
        });
        if (cancellationToken) {
            cancellationToken.throwIfCancellationRequested();
        }
    }
    var InvalidatedProjectKind;
    (function (InvalidatedProjectKind) {
        InvalidatedProjectKind[InvalidatedProjectKind["Build"] = 0] = "Build";
        InvalidatedProjectKind[InvalidatedProjectKind["UpdateBundle"] = 1] = "UpdateBundle";
        InvalidatedProjectKind[InvalidatedProjectKind["UpdateOutputFileStamps"] = 2] = "UpdateOutputFileStamps";
    })(InvalidatedProjectKind = ts.InvalidatedProjectKind || (ts.InvalidatedProjectKind = {}));
    function doneInvalidatedProject(state, projectPath) {
        state.projectPendingBuild.delete(projectPath);
        state.currentInvalidatedProject = undefined;
        return state.diagnostics.has(projectPath) ?
            ts.ExitStatus.DiagnosticsPresent_OutputsSkipped :
            ts.ExitStatus.Success;
    }
    function createUpdateOutputFileStampsProject(state, project, projectPath, config, buildOrder) {
        var updateOutputFileStampsPending = true;
        return {
            kind: InvalidatedProjectKind.UpdateOutputFileStamps,
            project: project,
            projectPath: projectPath,
            buildOrder: buildOrder,
            getCompilerOptions: function () { return config.options; },
            getCurrentDirectory: function () { return state.currentDirectory; },
            updateOutputFileStatmps: function () {
                updateOutputTimestamps(state, config, projectPath);
                updateOutputFileStampsPending = false;
            },
            done: function () {
                if (updateOutputFileStampsPending) {
                    updateOutputTimestamps(state, config, projectPath);
                }
                return doneInvalidatedProject(state, projectPath);
            }
        };
    }
    var BuildStep;
    (function (BuildStep) {
        BuildStep[BuildStep["CreateProgram"] = 0] = "CreateProgram";
        BuildStep[BuildStep["SyntaxDiagnostics"] = 1] = "SyntaxDiagnostics";
        BuildStep[BuildStep["SemanticDiagnostics"] = 2] = "SemanticDiagnostics";
        BuildStep[BuildStep["Emit"] = 3] = "Emit";
        BuildStep[BuildStep["EmitBundle"] = 4] = "EmitBundle";
        BuildStep[BuildStep["EmitBuildInfo"] = 5] = "EmitBuildInfo";
        BuildStep[BuildStep["BuildInvalidatedProjectOfBundle"] = 6] = "BuildInvalidatedProjectOfBundle";
        BuildStep[BuildStep["QueueReferencingProjects"] = 7] = "QueueReferencingProjects";
        BuildStep[BuildStep["Done"] = 8] = "Done";
    })(BuildStep || (BuildStep = {}));
    function createBuildOrUpdateInvalidedProject(kind, state, project, projectPath, projectIndex, config, buildOrder) {
        var step = kind === InvalidatedProjectKind.Build ? BuildStep.CreateProgram : BuildStep.EmitBundle;
        var program;
        var buildResult;
        var invalidatedProjectOfBundle;
        return kind === InvalidatedProjectKind.Build ?
            {
                kind: kind,
                project: project,
                projectPath: projectPath,
                buildOrder: buildOrder,
                getCompilerOptions: function () { return config.options; },
                getCurrentDirectory: function () { return state.currentDirectory; },
                getBuilderProgram: function () { return withProgramOrUndefined(ts.identity); },
                getProgram: function () {
                    return withProgramOrUndefined(function (program) { return program.getProgramOrUndefined(); });
                },
                getSourceFile: function (fileName) {
                    return withProgramOrUndefined(function (program) { return program.getSourceFile(fileName); });
                },
                getSourceFiles: function () {
                    return withProgramOrEmptyArray(function (program) { return program.getSourceFiles(); });
                },
                getOptionsDiagnostics: function (cancellationToken) {
                    return withProgramOrEmptyArray(function (program) { return program.getOptionsDiagnostics(cancellationToken); });
                },
                getGlobalDiagnostics: function (cancellationToken) {
                    return withProgramOrEmptyArray(function (program) { return program.getGlobalDiagnostics(cancellationToken); });
                },
                getConfigFileParsingDiagnostics: function () {
                    return withProgramOrEmptyArray(function (program) { return program.getConfigFileParsingDiagnostics(); });
                },
                getSyntacticDiagnostics: function (sourceFile, cancellationToken) {
                    return withProgramOrEmptyArray(function (program) { return program.getSyntacticDiagnostics(sourceFile, cancellationToken); });
                },
                getAllDependencies: function (sourceFile) {
                    return withProgramOrEmptyArray(function (program) { return program.getAllDependencies(sourceFile); });
                },
                getSemanticDiagnostics: function (sourceFile, cancellationToken) {
                    return withProgramOrEmptyArray(function (program) { return program.getSemanticDiagnostics(sourceFile, cancellationToken); });
                },
                getSemanticDiagnosticsOfNextAffectedFile: function (cancellationToken, ignoreSourceFile) {
                    return withProgramOrUndefined(function (program) {
                        return (program.getSemanticDiagnosticsOfNextAffectedFile) &&
                            program.getSemanticDiagnosticsOfNextAffectedFile(cancellationToken, ignoreSourceFile);
                    });
                },
                emit: function (targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
                    if (targetSourceFile || emitOnlyDtsFiles) {
                        return withProgramOrUndefined(function (program) { var _a, _b; return program.emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers || ((_b = (_a = state.host).getCustomTransformers) === null || _b === void 0 ? void 0 : _b.call(_a, project))); });
                    }
                    executeSteps(BuildStep.SemanticDiagnostics, cancellationToken);
                    if (step === BuildStep.EmitBuildInfo) {
                        return emitBuildInfo(writeFile, cancellationToken);
                    }
                    if (step !== BuildStep.Emit)
                        return undefined;
                    return emit(writeFile, cancellationToken, customTransformers);
                },
                done: done
            } :
            {
                kind: kind,
                project: project,
                projectPath: projectPath,
                buildOrder: buildOrder,
                getCompilerOptions: function () { return config.options; },
                getCurrentDirectory: function () { return state.currentDirectory; },
                emit: function (writeFile, customTransformers) {
                    if (step !== BuildStep.EmitBundle)
                        return invalidatedProjectOfBundle;
                    return emitBundle(writeFile, customTransformers);
                },
                done: done,
            };
        function done(cancellationToken, writeFile, customTransformers) {
            executeSteps(BuildStep.Done, cancellationToken, writeFile, customTransformers);
            return doneInvalidatedProject(state, projectPath);
        }
        function withProgramOrUndefined(action) {
            executeSteps(BuildStep.CreateProgram);
            return program && action(program);
        }
        function withProgramOrEmptyArray(action) {
            return withProgramOrUndefined(action) || ts.emptyArray;
        }
        function createProgram() {
            var _a, _b;
            ts.Debug.assert(program === undefined);
            if (state.options.dry) {
                reportStatus(state, ts.Diagnostics.A_non_dry_build_would_build_project_0, project);
                buildResult = BuildResultFlags.Success;
                step = BuildStep.QueueReferencingProjects;
                return;
            }
            if (state.options.verbose)
                reportStatus(state, ts.Diagnostics.Building_project_0, project);
            if (config.fileNames.length === 0) {
                reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                // Nothing to build - must be a solution file, basically
                buildResult = BuildResultFlags.None;
                step = BuildStep.QueueReferencingProjects;
                return;
            }
            var host = state.host, compilerHost = state.compilerHost;
            state.projectCompilerOptions = config.options;
            // Update module resolution cache if needed
            (_a = state.moduleResolutionCache) === null || _a === void 0 ? void 0 : _a.update(config.options);
            (_b = state.typeReferenceDirectiveResolutionCache) === null || _b === void 0 ? void 0 : _b.update(config.options);
            // Create program
            program = host.createProgram(config.fileNames, config.options, compilerHost, getOldProgram(state, projectPath, config), ts.getConfigFileParsingDiagnostics(config), config.projectReferences);
            if (state.watch) {
                state.lastCachedPackageJsonLookups.set(projectPath, state.moduleResolutionCache && ts.map(state.moduleResolutionCache.getPackageJsonInfoCache().entries(), function (_a) {
                    var path = _a[0], data = _a[1];
                    return [state.host.realpath && data ? toPath(state, state.host.realpath(path)) : path, data];
                }));
                state.builderPrograms.set(projectPath, program);
            }
            step++;
        }
        function handleDiagnostics(diagnostics, errorFlags, errorType) {
            var _a;
            if (diagnostics.length) {
                (_a = buildErrors(state, projectPath, program, config, diagnostics, errorFlags, errorType), buildResult = _a.buildResult, step = _a.step);
            }
            else {
                step++;
            }
        }
        function getSyntaxDiagnostics(cancellationToken) {
            ts.Debug.assertIsDefined(program);
            handleDiagnostics(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], program.getConfigFileParsingDiagnostics(), true), program.getOptionsDiagnostics(cancellationToken), true), program.getGlobalDiagnostics(cancellationToken), true), program.getSyntacticDiagnostics(/*sourceFile*/ undefined, cancellationToken), true), BuildResultFlags.SyntaxErrors, "Syntactic");
        }
        function getSemanticDiagnostics(cancellationToken) {
            handleDiagnostics(ts.Debug.checkDefined(program).getSemanticDiagnostics(/*sourceFile*/ undefined, cancellationToken), BuildResultFlags.TypeErrors, "Semantic");
        }
        function emit(writeFileCallback, cancellationToken, customTransformers) {
            var _a;
            var _b, _c;
            ts.Debug.assertIsDefined(program);
            ts.Debug.assert(step === BuildStep.Emit);
            // Before emitting lets backup state, so we can revert it back if there are declaration errors to handle emit and declaration errors correctly
            program.backupState();
            var declDiagnostics;
            var reportDeclarationDiagnostics = function (d) { return (declDiagnostics || (declDiagnostics = [])).push(d); };
            var outputFiles = [];
            var emitResult = ts.emitFilesAndReportErrors(program, reportDeclarationDiagnostics, 
            /*write*/ undefined, 
            /*reportSummary*/ undefined, function (name, text, writeByteOrderMark) { return outputFiles.push({ name: name, text: text, writeByteOrderMark: writeByteOrderMark }); }, cancellationToken, 
            /*emitOnlyDts*/ false, customTransformers || ((_c = (_b = state.host).getCustomTransformers) === null || _c === void 0 ? void 0 : _c.call(_b, project))).emitResult;
            // Don't emit .d.ts if there are decl file errors
            if (declDiagnostics) {
                program.restoreState();
                (_a = buildErrors(state, projectPath, program, config, declDiagnostics, BuildResultFlags.DeclarationEmitErrors, "Declaration file"), buildResult = _a.buildResult, step = _a.step);
                return {
                    emitSkipped: true,
                    diagnostics: emitResult.diagnostics
                };
            }
            // Actual Emit
            var host = state.host, compilerHost = state.compilerHost;
            var resultFlags = BuildResultFlags.DeclarationOutputUnchanged;
            var newestDeclarationFileContentChangedTime = minimumDate;
            var anyDtsChanged = false;
            var emitterDiagnostics = ts.createDiagnosticCollection();
            var emittedOutputs = new ts.Map();
            outputFiles.forEach(function (_a) {
                var name = _a.name, text = _a.text, writeByteOrderMark = _a.writeByteOrderMark;
                var priorChangeTime;
                if (!anyDtsChanged && isDeclarationFile(name)) {
                    // Check for unchanged .d.ts files
                    if (host.fileExists(name) && state.readFileWithCache(name) === text) {
                        priorChangeTime = host.getModifiedTime(name);
                    }
                    else {
                        resultFlags &= ~BuildResultFlags.DeclarationOutputUnchanged;
                        anyDtsChanged = true;
                    }
                }
                emittedOutputs.set(toPath(state, name), name);
                ts.writeFile(writeFileCallback ? { writeFile: writeFileCallback } : compilerHost, emitterDiagnostics, name, text, writeByteOrderMark);
                if (priorChangeTime !== undefined) {
                    newestDeclarationFileContentChangedTime = newer(priorChangeTime, newestDeclarationFileContentChangedTime);
                }
            });
            finishEmit(emitterDiagnostics, emittedOutputs, newestDeclarationFileContentChangedTime, 
            /*newestDeclarationFileContentChangedTimeIsMaximumDate*/ anyDtsChanged, outputFiles.length ? outputFiles[0].name : ts.getFirstProjectOutput(config, !host.useCaseSensitiveFileNames()), resultFlags);
            return emitResult;
        }
        function emitBuildInfo(writeFileCallback, cancellationToken) {
            ts.Debug.assertIsDefined(program);
            ts.Debug.assert(step === BuildStep.EmitBuildInfo);
            var emitResult = program.emitBuildInfo(writeFileCallback, cancellationToken);
            if (emitResult.diagnostics.length) {
                reportErrors(state, emitResult.diagnostics);
                state.diagnostics.set(projectPath, __spreadArray(__spreadArray([], state.diagnostics.get(projectPath), true), emitResult.diagnostics, true));
                buildResult = BuildResultFlags.EmitErrors & buildResult;
            }
            if (emitResult.emittedFiles && state.write) {
                emitResult.emittedFiles.forEach(function (name) { return listEmittedFile(state, config, name); });
            }
            afterProgramDone(state, program, config);
            step = BuildStep.QueueReferencingProjects;
            return emitResult;
        }
        function finishEmit(emitterDiagnostics, emittedOutputs, priorNewestUpdateTime, newestDeclarationFileContentChangedTimeIsMaximumDate, oldestOutputFileName, resultFlags) {
            var _a;
            var emitDiagnostics = emitterDiagnostics.getDiagnostics();
            if (emitDiagnostics.length) {
                (_a = buildErrors(state, projectPath, program, config, emitDiagnostics, BuildResultFlags.EmitErrors, "Emit"), buildResult = _a.buildResult, step = _a.step);
                return emitDiagnostics;
            }
            if (state.write) {
                emittedOutputs.forEach(function (name) { return listEmittedFile(state, config, name); });
            }
            // Update time stamps for rest of the outputs
            var newestDeclarationFileContentChangedTime = updateOutputTimestampsWorker(state, config, priorNewestUpdateTime, ts.Diagnostics.Updating_unchanged_output_timestamps_of_project_0, emittedOutputs);
            state.diagnostics.delete(projectPath);
            state.projectStatus.set(projectPath, {
                type: ts.UpToDateStatusType.UpToDate,
                newestDeclarationFileContentChangedTime: newestDeclarationFileContentChangedTimeIsMaximumDate ?
                    maximumDate :
                    newestDeclarationFileContentChangedTime,
                oldestOutputFileName: oldestOutputFileName
            });
            afterProgramDone(state, program, config);
            step = BuildStep.QueueReferencingProjects;
            buildResult = resultFlags;
            return emitDiagnostics;
        }
        function emitBundle(writeFileCallback, customTransformers) {
            var _a, _b;
            ts.Debug.assert(kind === InvalidatedProjectKind.UpdateBundle);
            if (state.options.dry) {
                reportStatus(state, ts.Diagnostics.A_non_dry_build_would_update_output_of_project_0, project);
                buildResult = BuildResultFlags.Success;
                step = BuildStep.QueueReferencingProjects;
                return undefined;
            }
            if (state.options.verbose)
                reportStatus(state, ts.Diagnostics.Updating_output_of_project_0, project);
            // Update js, and source map
            var compilerHost = state.compilerHost;
            state.projectCompilerOptions = config.options;
            var outputFiles = ts.emitUsingBuildInfo(config, compilerHost, function (ref) {
                var refName = resolveProjectName(state, ref.path);
                return parseConfigFile(state, refName, toResolvedConfigFilePath(state, refName));
            }, customTransformers || ((_b = (_a = state.host).getCustomTransformers) === null || _b === void 0 ? void 0 : _b.call(_a, project)));
            if (ts.isString(outputFiles)) {
                reportStatus(state, ts.Diagnostics.Cannot_update_output_of_project_0_because_there_was_error_reading_file_1, project, relName(state, outputFiles));
                step = BuildStep.BuildInvalidatedProjectOfBundle;
                return invalidatedProjectOfBundle = createBuildOrUpdateInvalidedProject(InvalidatedProjectKind.Build, state, project, projectPath, projectIndex, config, buildOrder);
            }
            // Actual Emit
            ts.Debug.assert(!!outputFiles.length);
            var emitterDiagnostics = ts.createDiagnosticCollection();
            var emittedOutputs = new ts.Map();
            outputFiles.forEach(function (_a) {
                var name = _a.name, text = _a.text, writeByteOrderMark = _a.writeByteOrderMark;
                emittedOutputs.set(toPath(state, name), name);
                ts.writeFile(writeFileCallback ? { writeFile: writeFileCallback } : compilerHost, emitterDiagnostics, name, text, writeByteOrderMark);
            });
            var emitDiagnostics = finishEmit(emitterDiagnostics, emittedOutputs, minimumDate, 
            /*newestDeclarationFileContentChangedTimeIsMaximumDate*/ false, outputFiles[0].name, BuildResultFlags.DeclarationOutputUnchanged);
            return { emitSkipped: false, diagnostics: emitDiagnostics };
        }
        function executeSteps(till, cancellationToken, writeFile, customTransformers) {
            while (step <= till && step < BuildStep.Done) {
                var currentStep = step;
                switch (step) {
                    case BuildStep.CreateProgram:
                        createProgram();
                        break;
                    case BuildStep.SyntaxDiagnostics:
                        getSyntaxDiagnostics(cancellationToken);
                        break;
                    case BuildStep.SemanticDiagnostics:
                        getSemanticDiagnostics(cancellationToken);
                        break;
                    case BuildStep.Emit:
                        emit(writeFile, cancellationToken, customTransformers);
                        break;
                    case BuildStep.EmitBuildInfo:
                        emitBuildInfo(writeFile, cancellationToken);
                        break;
                    case BuildStep.EmitBundle:
                        emitBundle(writeFile, customTransformers);
                        break;
                    case BuildStep.BuildInvalidatedProjectOfBundle:
                        ts.Debug.checkDefined(invalidatedProjectOfBundle).done(cancellationToken, writeFile, customTransformers);
                        step = BuildStep.Done;
                        break;
                    case BuildStep.QueueReferencingProjects:
                        queueReferencingProjects(state, project, projectPath, projectIndex, config, buildOrder, ts.Debug.checkDefined(buildResult));
                        step++;
                        break;
                    // Should never be done
                    case BuildStep.Done:
                    default:
                        ts.assertType(step);
                }
                ts.Debug.assert(step > currentStep);
            }
        }
    }
    function needsBuild(_a, status, config) {
        var options = _a.options;
        if (status.type !== ts.UpToDateStatusType.OutOfDateWithPrepend || options.force)
            return true;
        return config.fileNames.length === 0 ||
            !!ts.getConfigFileParsingDiagnostics(config).length ||
            !ts.isIncrementalCompilation(config.options);
    }
    function getNextInvalidatedProject(state, buildOrder, reportQueue) {
        if (!state.projectPendingBuild.size)
            return undefined;
        if (isCircularBuildOrder(buildOrder))
            return undefined;
        if (state.currentInvalidatedProject) {
            // Only if same buildOrder the currentInvalidated project can be sent again
            return ts.arrayIsEqualTo(state.currentInvalidatedProject.buildOrder, buildOrder) ?
                state.currentInvalidatedProject :
                undefined;
        }
        var options = state.options, projectPendingBuild = state.projectPendingBuild;
        for (var projectIndex = 0; projectIndex < buildOrder.length; projectIndex++) {
            var project = buildOrder[projectIndex];
            var projectPath = toResolvedConfigFilePath(state, project);
            var reloadLevel = state.projectPendingBuild.get(projectPath);
            if (reloadLevel === undefined)
                continue;
            if (reportQueue) {
                reportQueue = false;
                reportBuildQueue(state, buildOrder);
            }
            var config = parseConfigFile(state, project, projectPath);
            if (!config) {
                reportParseConfigFileDiagnostic(state, projectPath);
                projectPendingBuild.delete(projectPath);
                continue;
            }
            if (reloadLevel === ts.ConfigFileProgramReloadLevel.Full) {
                watchConfigFile(state, project, projectPath, config);
                watchExtendedConfigFiles(state, projectPath, config);
                watchWildCardDirectories(state, project, projectPath, config);
                watchInputFiles(state, project, projectPath, config);
                watchPackageJsonFiles(state, project, projectPath, config);
            }
            else if (reloadLevel === ts.ConfigFileProgramReloadLevel.Partial) {
                // Update file names
                config.fileNames = ts.getFileNamesFromConfigSpecs(config.options.configFile.configFileSpecs, ts.getDirectoryPath(project), config.options, state.parseConfigFileHost);
                ts.updateErrorForNoInputFiles(config.fileNames, project, config.options.configFile.configFileSpecs, config.errors, ts.canJsonReportNoInputFiles(config.raw));
                watchInputFiles(state, project, projectPath, config);
                watchPackageJsonFiles(state, project, projectPath, config);
            }
            var status = getUpToDateStatus(state, config, projectPath);
            verboseReportProjectStatus(state, project, status);
            if (!options.force) {
                if (status.type === ts.UpToDateStatusType.UpToDate) {
                    reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                    projectPendingBuild.delete(projectPath);
                    // Up to date, skip
                    if (options.dry) {
                        // In a dry build, inform the user of this fact
                        reportStatus(state, ts.Diagnostics.Project_0_is_up_to_date, project);
                    }
                    continue;
                }
                if (status.type === ts.UpToDateStatusType.UpToDateWithUpstreamTypes) {
                    reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                    return createUpdateOutputFileStampsProject(state, project, projectPath, config, buildOrder);
                }
            }
            if (status.type === ts.UpToDateStatusType.UpstreamBlocked) {
                reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                projectPendingBuild.delete(projectPath);
                if (options.verbose) {
                    reportStatus(state, status.upstreamProjectBlocked ?
                        ts.Diagnostics.Skipping_build_of_project_0_because_its_dependency_1_was_not_built :
                        ts.Diagnostics.Skipping_build_of_project_0_because_its_dependency_1_has_errors, project, status.upstreamProjectName);
                }
                continue;
            }
            if (status.type === ts.UpToDateStatusType.ContainerOnly) {
                reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                projectPendingBuild.delete(projectPath);
                // Do nothing
                continue;
            }
            return createBuildOrUpdateInvalidedProject(needsBuild(state, status, config) ?
                InvalidatedProjectKind.Build :
                InvalidatedProjectKind.UpdateBundle, state, project, projectPath, projectIndex, config, buildOrder);
        }
        return undefined;
    }
    function listEmittedFile(_a, proj, file) {
        var write = _a.write;
        if (write && proj.options.listEmittedFiles) {
            write("TSFILE: " + file);
        }
    }
    function getOldProgram(_a, proj, parsed) {
        var options = _a.options, builderPrograms = _a.builderPrograms, compilerHost = _a.compilerHost;
        if (options.force)
            return undefined;
        var value = builderPrograms.get(proj);
        if (value)
            return value;
        return ts.readBuilderProgram(parsed.options, compilerHost);
    }
    function afterProgramDone(state, program, config) {
        if (program) {
            if (program && state.write)
                ts.listFiles(program, state.write);
            if (state.host.afterProgramEmitAndDiagnostics) {
                state.host.afterProgramEmitAndDiagnostics(program);
            }
            program.releaseProgram();
        }
        else if (state.host.afterEmitBundle) {
            state.host.afterEmitBundle(config);
        }
        state.projectCompilerOptions = state.baseCompilerOptions;
    }
    function buildErrors(state, resolvedPath, program, config, diagnostics, buildResult, errorType) {
        var canEmitBuildInfo = !(buildResult & BuildResultFlags.SyntaxErrors) && program && !ts.outFile(program.getCompilerOptions());
        reportAndStoreErrors(state, resolvedPath, diagnostics);
        state.projectStatus.set(resolvedPath, { type: ts.UpToDateStatusType.Unbuildable, reason: errorType + " errors" });
        if (canEmitBuildInfo)
            return { buildResult: buildResult, step: BuildStep.EmitBuildInfo };
        afterProgramDone(state, program, config);
        return { buildResult: buildResult, step: BuildStep.QueueReferencingProjects };
    }
    function checkConfigFileUpToDateStatus(state, configFile, oldestOutputFileTime, oldestOutputFileName) {
        // Check tsconfig time
        var tsconfigTime = ts.getModifiedTime(state.host, configFile);
        if (oldestOutputFileTime < tsconfigTime) {
            return {
                type: ts.UpToDateStatusType.OutOfDateWithSelf,
                outOfDateOutputFileName: oldestOutputFileName,
                newerInputFileName: configFile
            };
        }
    }
    function getUpToDateStatusWorker(state, project, resolvedPath) {
        var force = !!state.options.force;
        var newestInputFileName = undefined;
        var newestInputFileTime = minimumDate;
        var host = state.host;
        // Get timestamps of input files
        for (var _i = 0, _a = project.fileNames; _i < _a.length; _i++) {
            var inputFile = _a[_i];
            if (!host.fileExists(inputFile)) {
                return {
                    type: ts.UpToDateStatusType.Unbuildable,
                    reason: inputFile + " does not exist"
                };
            }
            if (!force) {
                var inputTime = ts.getModifiedTime(host, inputFile);
                host.getModifiedTime(inputFile);
                if (inputTime > newestInputFileTime) {
                    newestInputFileName = inputFile;
                    newestInputFileTime = inputTime;
                }
            }
        }
        // Container if no files are specified in the project
        if (!project.fileNames.length && !ts.canJsonReportNoInputFiles(project.raw)) {
            return {
                type: ts.UpToDateStatusType.ContainerOnly
            };
        }
        // Collect the expected outputs of this project
        var outputs = ts.getAllProjectOutputs(project, !host.useCaseSensitiveFileNames());
        // Now see if all outputs are newer than the newest input
        var oldestOutputFileName = "(none)";
        var oldestOutputFileTime = maximumDate;
        var newestOutputFileName = "(none)";
        var newestOutputFileTime = minimumDate;
        var missingOutputFileName;
        var newestDeclarationFileContentChangedTime = minimumDate;
        var isOutOfDateWithInputs = false;
        if (!force) {
            for (var _b = 0, outputs_1 = outputs; _b < outputs_1.length; _b++) {
                var output = outputs_1[_b];
                // Output is missing; can stop checking
                // Don't immediately return because we can still be upstream-blocked, which is a higher-priority status
                if (!host.fileExists(output)) {
                    missingOutputFileName = output;
                    break;
                }
                var outputTime = ts.getModifiedTime(host, output);
                if (outputTime < oldestOutputFileTime) {
                    oldestOutputFileTime = outputTime;
                    oldestOutputFileName = output;
                }
                // If an output is older than the newest input, we can stop checking
                // Don't immediately return because we can still be upstream-blocked, which is a higher-priority status
                if (outputTime < newestInputFileTime) {
                    isOutOfDateWithInputs = true;
                    break;
                }
                if (outputTime > newestOutputFileTime) {
                    newestOutputFileTime = outputTime;
                    newestOutputFileName = output;
                }
                // Keep track of when the most recent time a .d.ts file was changed.
                // In addition to file timestamps, we also keep track of when a .d.ts file
                // had its file touched but not had its contents changed - this allows us
                // to skip a downstream typecheck
                if (isDeclarationFile(output)) {
                    var outputModifiedTime = ts.getModifiedTime(host, output);
                    newestDeclarationFileContentChangedTime = newer(newestDeclarationFileContentChangedTime, outputModifiedTime);
                }
            }
        }
        var pseudoUpToDate = false;
        var usesPrepend = false;
        var upstreamChangedProject;
        if (project.projectReferences) {
            state.projectStatus.set(resolvedPath, { type: ts.UpToDateStatusType.ComputingUpstream });
            for (var _c = 0, _d = project.projectReferences; _c < _d.length; _c++) {
                var ref = _d[_c];
                usesPrepend = usesPrepend || !!(ref.prepend);
                var resolvedRef = ts.resolveProjectReferencePath(ref);
                var resolvedRefPath = toResolvedConfigFilePath(state, resolvedRef);
                var refStatus = getUpToDateStatus(state, parseConfigFile(state, resolvedRef, resolvedRefPath), resolvedRefPath);
                // Its a circular reference ignore the status of this project
                if (refStatus.type === ts.UpToDateStatusType.ComputingUpstream ||
                    refStatus.type === ts.UpToDateStatusType.ContainerOnly) { // Container only ignore this project
                    continue;
                }
                // An upstream project is blocked
                if (refStatus.type === ts.UpToDateStatusType.Unbuildable ||
                    refStatus.type === ts.UpToDateStatusType.UpstreamBlocked) {
                    return {
                        type: ts.UpToDateStatusType.UpstreamBlocked,
                        upstreamProjectName: ref.path,
                        upstreamProjectBlocked: refStatus.type === ts.UpToDateStatusType.UpstreamBlocked
                    };
                }
                // If the upstream project is out of date, then so are we (someone shouldn't have asked, though?)
                if (refStatus.type !== ts.UpToDateStatusType.UpToDate) {
                    return {
                        type: ts.UpToDateStatusType.UpstreamOutOfDate,
                        upstreamProjectName: ref.path
                    };
                }
                // Check oldest output file name only if there is no missing output file name
                // (a check we will have skipped if this is a forced build)
                if (!force && !missingOutputFileName) {
                    // If the upstream project's newest file is older than our oldest output, we
                    // can't be out of date because of it
                    if (refStatus.newestInputFileTime && refStatus.newestInputFileTime <= oldestOutputFileTime) {
                        continue;
                    }
                    // If the upstream project has only change .d.ts files, and we've built
                    // *after* those files, then we're "psuedo up to date" and eligible for a fast rebuild
                    if (refStatus.newestDeclarationFileContentChangedTime && refStatus.newestDeclarationFileContentChangedTime <= oldestOutputFileTime) {
                        pseudoUpToDate = true;
                        upstreamChangedProject = ref.path;
                        continue;
                    }
                    // We have an output older than an upstream output - we are out of date
                    ts.Debug.assert(oldestOutputFileName !== undefined, "Should have an oldest output filename here");
                    return {
                        type: ts.UpToDateStatusType.OutOfDateWithUpstream,
                        outOfDateOutputFileName: oldestOutputFileName,
                        newerProjectName: ref.path
                    };
                }
            }
        }
        if (missingOutputFileName !== undefined) {
            return {
                type: ts.UpToDateStatusType.OutputMissing,
                missingOutputFileName: missingOutputFileName
            };
        }
        if (isOutOfDateWithInputs) {
            return {
                type: ts.UpToDateStatusType.OutOfDateWithSelf,
                outOfDateOutputFileName: oldestOutputFileName,
                newerInputFileName: newestInputFileName
            };
        }
        else {
            // Check tsconfig time
            var configStatus = checkConfigFileUpToDateStatus(state, project.options.configFilePath, oldestOutputFileTime, oldestOutputFileName);
            if (configStatus)
                return configStatus;
            // Check extended config time
            var extendedConfigStatus = ts.forEach(project.options.configFile.extendedSourceFiles || ts.emptyArray, function (configFile) { return checkConfigFileUpToDateStatus(state, configFile, oldestOutputFileTime, oldestOutputFileName); });
            if (extendedConfigStatus)
                return extendedConfigStatus;
            // Check package file time
            var dependentPackageFileStatus = ts.forEach(state.lastCachedPackageJsonLookups.get(resolvedPath) || ts.emptyArray, function (_a) {
                var path = _a[0];
                return checkConfigFileUpToDateStatus(state, path, oldestOutputFileTime, oldestOutputFileName);
            });
            if (dependentPackageFileStatus)
                return dependentPackageFileStatus;
        }
        if (!force && !state.buildInfoChecked.has(resolvedPath)) {
            state.buildInfoChecked.set(resolvedPath, true);
            var buildInfoPath = ts.getTsBuildInfoEmitOutputFilePath(project.options);
            if (buildInfoPath) {
                var value = state.readFileWithCache(buildInfoPath);
                var buildInfo = value && ts.getBuildInfo(value);
                if (buildInfo && (buildInfo.bundle || buildInfo.program) && buildInfo.version !== ts.version) {
                    return {
                        type: ts.UpToDateStatusType.TsVersionOutputOfDate,
                        version: buildInfo.version
                    };
                }
            }
        }
        if (usesPrepend && pseudoUpToDate) {
            return {
                type: ts.UpToDateStatusType.OutOfDateWithPrepend,
                outOfDateOutputFileName: oldestOutputFileName,
                newerProjectName: upstreamChangedProject
            };
        }
        // Up to date
        return {
            type: pseudoUpToDate ? ts.UpToDateStatusType.UpToDateWithUpstreamTypes : ts.UpToDateStatusType.UpToDate,
            newestDeclarationFileContentChangedTime: newestDeclarationFileContentChangedTime,
            newestInputFileTime: newestInputFileTime,
            newestOutputFileTime: newestOutputFileTime,
            newestInputFileName: newestInputFileName,
            newestOutputFileName: newestOutputFileName,
            oldestOutputFileName: oldestOutputFileName
        };
    }
    function getUpToDateStatus(state, project, resolvedPath) {
        if (project === undefined) {
            return { type: ts.UpToDateStatusType.Unbuildable, reason: "File deleted mid-build" };
        }
        var prior = state.projectStatus.get(resolvedPath);
        if (prior !== undefined) {
            return prior;
        }
        var actual = getUpToDateStatusWorker(state, project, resolvedPath);
        state.projectStatus.set(resolvedPath, actual);
        return actual;
    }
    function updateOutputTimestampsWorker(state, proj, priorNewestUpdateTime, verboseMessage, skipOutputs) {
        if (proj.options.noEmit)
            return priorNewestUpdateTime;
        var host = state.host;
        var outputs = ts.getAllProjectOutputs(proj, !host.useCaseSensitiveFileNames());
        if (!skipOutputs || outputs.length !== skipOutputs.size) {
            var reportVerbose = !!state.options.verbose;
            var now = host.now ? host.now() : new Date();
            for (var _i = 0, outputs_2 = outputs; _i < outputs_2.length; _i++) {
                var file = outputs_2[_i];
                if (skipOutputs && skipOutputs.has(toPath(state, file))) {
                    continue;
                }
                if (reportVerbose) {
                    reportVerbose = false;
                    reportStatus(state, verboseMessage, proj.options.configFilePath);
                }
                if (isDeclarationFile(file)) {
                    priorNewestUpdateTime = newer(priorNewestUpdateTime, ts.getModifiedTime(host, file));
                }
                host.setModifiedTime(file, now);
            }
        }
        return priorNewestUpdateTime;
    }
    function updateOutputTimestamps(state, proj, resolvedPath) {
        if (state.options.dry) {
            return reportStatus(state, ts.Diagnostics.A_non_dry_build_would_update_timestamps_for_output_of_project_0, proj.options.configFilePath);
        }
        var priorNewestUpdateTime = updateOutputTimestampsWorker(state, proj, minimumDate, ts.Diagnostics.Updating_output_timestamps_of_project_0);
        state.projectStatus.set(resolvedPath, {
            type: ts.UpToDateStatusType.UpToDate,
            newestDeclarationFileContentChangedTime: priorNewestUpdateTime,
            oldestOutputFileName: ts.getFirstProjectOutput(proj, !state.host.useCaseSensitiveFileNames())
        });
    }
    function queueReferencingProjects(state, project, projectPath, projectIndex, config, buildOrder, buildResult) {
        // Queue only if there are no errors
        if (buildResult & BuildResultFlags.AnyErrors)
            return;
        // Only composite projects can be referenced by other projects
        if (!config.options.composite)
            return;
        // Always use build order to queue projects
        for (var index = projectIndex + 1; index < buildOrder.length; index++) {
            var nextProject = buildOrder[index];
            var nextProjectPath = toResolvedConfigFilePath(state, nextProject);
            if (state.projectPendingBuild.has(nextProjectPath))
                continue;
            var nextProjectConfig = parseConfigFile(state, nextProject, nextProjectPath);
            if (!nextProjectConfig || !nextProjectConfig.projectReferences)
                continue;
            for (var _i = 0, _a = nextProjectConfig.projectReferences; _i < _a.length; _i++) {
                var ref = _a[_i];
                var resolvedRefPath = resolveProjectName(state, ref.path);
                if (toResolvedConfigFilePath(state, resolvedRefPath) !== projectPath)
                    continue;
                // If the project is referenced with prepend, always build downstream projects,
                // If declaration output is changed, build the project
                // otherwise mark the project UpToDateWithUpstreamTypes so it updates output time stamps
                var status = state.projectStatus.get(nextProjectPath);
                if (status) {
                    switch (status.type) {
                        case ts.UpToDateStatusType.UpToDate:
                            if (buildResult & BuildResultFlags.DeclarationOutputUnchanged) {
                                if (ref.prepend) {
                                    state.projectStatus.set(nextProjectPath, {
                                        type: ts.UpToDateStatusType.OutOfDateWithPrepend,
                                        outOfDateOutputFileName: status.oldestOutputFileName,
                                        newerProjectName: project
                                    });
                                }
                                else {
                                    status.type = ts.UpToDateStatusType.UpToDateWithUpstreamTypes;
                                }
                                break;
                            }
                        // falls through
                        case ts.UpToDateStatusType.UpToDateWithUpstreamTypes:
                        case ts.UpToDateStatusType.OutOfDateWithPrepend:
                            if (!(buildResult & BuildResultFlags.DeclarationOutputUnchanged)) {
                                state.projectStatus.set(nextProjectPath, {
                                    type: ts.UpToDateStatusType.OutOfDateWithUpstream,
                                    outOfDateOutputFileName: status.type === ts.UpToDateStatusType.OutOfDateWithPrepend ? status.outOfDateOutputFileName : status.oldestOutputFileName,
                                    newerProjectName: project
                                });
                            }
                            break;
                        case ts.UpToDateStatusType.UpstreamBlocked:
                            if (toResolvedConfigFilePath(state, resolveProjectName(state, status.upstreamProjectName)) === projectPath) {
                                clearProjectStatus(state, nextProjectPath);
                            }
                            break;
                    }
                }
                addProjToQueue(state, nextProjectPath, ts.ConfigFileProgramReloadLevel.None);
                break;
            }
        }
    }
    function build(state, project, cancellationToken, writeFile, getCustomTransformers, onlyReferences) {
        var buildOrder = getBuildOrderFor(state, project, onlyReferences);
        if (!buildOrder)
            return ts.ExitStatus.InvalidProject_OutputsSkipped;
        setupInitialBuild(state, cancellationToken);
        var reportQueue = true;
        var successfulProjects = 0;
        while (true) {
            var invalidatedProject = getNextInvalidatedProject(state, buildOrder, reportQueue);
            if (!invalidatedProject)
                break;
            reportQueue = false;
            invalidatedProject.done(cancellationToken, writeFile, getCustomTransformers === null || getCustomTransformers === void 0 ? void 0 : getCustomTransformers(invalidatedProject.project));
            if (!state.diagnostics.has(invalidatedProject.projectPath))
                successfulProjects++;
        }
        disableCache(state);
        reportErrorSummary(state, buildOrder);
        startWatching(state, buildOrder);
        return isCircularBuildOrder(buildOrder)
            ? ts.ExitStatus.ProjectReferenceCycle_OutputsSkipped
            : !buildOrder.some(function (p) { return state.diagnostics.has(toResolvedConfigFilePath(state, p)); })
                ? ts.ExitStatus.Success
                : successfulProjects
                    ? ts.ExitStatus.DiagnosticsPresent_OutputsGenerated
                    : ts.ExitStatus.DiagnosticsPresent_OutputsSkipped;
    }
    function clean(state, project, onlyReferences) {
        var buildOrder = getBuildOrderFor(state, project, onlyReferences);
        if (!buildOrder)
            return ts.ExitStatus.InvalidProject_OutputsSkipped;
        if (isCircularBuildOrder(buildOrder)) {
            reportErrors(state, buildOrder.circularDiagnostics);
            return ts.ExitStatus.ProjectReferenceCycle_OutputsSkipped;
        }
        var options = state.options, host = state.host;
        var filesToDelete = options.dry ? [] : undefined;
        for (var _i = 0, buildOrder_1 = buildOrder; _i < buildOrder_1.length; _i++) {
            var proj = buildOrder_1[_i];
            var resolvedPath = toResolvedConfigFilePath(state, proj);
            var parsed = parseConfigFile(state, proj, resolvedPath);
            if (parsed === undefined) {
                // File has gone missing; fine to ignore here
                reportParseConfigFileDiagnostic(state, resolvedPath);
                continue;
            }
            var outputs = ts.getAllProjectOutputs(parsed, !host.useCaseSensitiveFileNames());
            if (!outputs.length)
                continue;
            var inputFileNames = new ts.Set(parsed.fileNames.map(function (f) { return toPath(state, f); }));
            for (var _a = 0, outputs_3 = outputs; _a < outputs_3.length; _a++) {
                var output = outputs_3[_a];
                // If output name is same as input file name, do not delete and ignore the error
                if (inputFileNames.has(toPath(state, output)))
                    continue;
                if (host.fileExists(output)) {
                    if (filesToDelete) {
                        filesToDelete.push(output);
                    }
                    else {
                        host.deleteFile(output);
                        invalidateProject(state, resolvedPath, ts.ConfigFileProgramReloadLevel.None);
                    }
                }
            }
        }
        if (filesToDelete) {
            reportStatus(state, ts.Diagnostics.A_non_dry_build_would_delete_the_following_files_Colon_0, filesToDelete.map(function (f) { return "\r\n * " + f; }).join(""));
        }
        return ts.ExitStatus.Success;
    }
    function invalidateProject(state, resolved, reloadLevel) {
        // If host implements getParsedCommandLine, we cant get list of files from parseConfigFileHost
        if (state.host.getParsedCommandLine && reloadLevel === ts.ConfigFileProgramReloadLevel.Partial) {
            reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
        }
        if (reloadLevel === ts.ConfigFileProgramReloadLevel.Full) {
            state.configFileCache.delete(resolved);
            state.buildOrder = undefined;
        }
        state.needsSummary = true;
        clearProjectStatus(state, resolved);
        addProjToQueue(state, resolved, reloadLevel);
        enableCache(state);
    }
    function invalidateProjectAndScheduleBuilds(state, resolvedPath, reloadLevel) {
        state.reportFileChangeDetected = true;
        invalidateProject(state, resolvedPath, reloadLevel);
        scheduleBuildInvalidatedProject(state);
    }
    function scheduleBuildInvalidatedProject(state) {
        var hostWithWatch = state.hostWithWatch;
        if (!hostWithWatch.setTimeout || !hostWithWatch.clearTimeout) {
            return;
        }
        if (state.timerToBuildInvalidatedProject) {
            hostWithWatch.clearTimeout(state.timerToBuildInvalidatedProject);
        }
        state.timerToBuildInvalidatedProject = hostWithWatch.setTimeout(buildNextInvalidatedProject, 250, state);
    }
    function buildNextInvalidatedProject(state) {
        state.timerToBuildInvalidatedProject = undefined;
        if (state.reportFileChangeDetected) {
            state.reportFileChangeDetected = false;
            state.projectErrorsReported.clear();
            reportWatchStatus(state, ts.Diagnostics.File_change_detected_Starting_incremental_compilation);
        }
        var buildOrder = getBuildOrder(state);
        var invalidatedProject = getNextInvalidatedProject(state, buildOrder, /*reportQueue*/ false);
        if (invalidatedProject) {
            invalidatedProject.done();
            if (state.projectPendingBuild.size) {
                // Schedule next project for build
                if (state.watch && !state.timerToBuildInvalidatedProject) {
                    scheduleBuildInvalidatedProject(state);
                }
                return;
            }
        }
        disableCache(state);
        reportErrorSummary(state, buildOrder);
    }
    function watchConfigFile(state, resolved, resolvedPath, parsed) {
        if (!state.watch || state.allWatchedConfigFiles.has(resolvedPath))
            return;
        state.allWatchedConfigFiles.set(resolvedPath, state.watchFile(resolved, function () {
            invalidateProjectAndScheduleBuilds(state, resolvedPath, ts.ConfigFileProgramReloadLevel.Full);
        }, ts.PollingInterval.High, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.ConfigFile, resolved));
    }
    function watchExtendedConfigFiles(state, resolvedPath, parsed) {
        ts.updateSharedExtendedConfigFileWatcher(resolvedPath, parsed === null || parsed === void 0 ? void 0 : parsed.options, state.allWatchedExtendedConfigFiles, function (extendedConfigFileName, extendedConfigFilePath) { return state.watchFile(extendedConfigFileName, function () {
            var _a;
            return (_a = state.allWatchedExtendedConfigFiles.get(extendedConfigFilePath)) === null || _a === void 0 ? void 0 : _a.projects.forEach(function (projectConfigFilePath) {
                return invalidateProjectAndScheduleBuilds(state, projectConfigFilePath, ts.ConfigFileProgramReloadLevel.Full);
            });
        }, ts.PollingInterval.High, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.ExtendedConfigFile); }, function (fileName) { return toPath(state, fileName); });
    }
    function watchWildCardDirectories(state, resolved, resolvedPath, parsed) {
        if (!state.watch)
            return;
        ts.updateWatchingWildcardDirectories(getOrCreateValueMapFromConfigFileMap(state.allWatchedWildcardDirectories, resolvedPath), new ts.Map(ts.getEntries(parsed.wildcardDirectories)), function (dir, flags) { return state.watchDirectory(dir, function (fileOrDirectory) {
            var _a;
            if (ts.isIgnoredFileFromWildCardWatching({
                watchedDirPath: toPath(state, dir),
                fileOrDirectory: fileOrDirectory,
                fileOrDirectoryPath: toPath(state, fileOrDirectory),
                configFileName: resolved,
                currentDirectory: state.currentDirectory,
                options: parsed.options,
                program: state.builderPrograms.get(resolvedPath) || ((_a = getCachedParsedConfigFile(state, resolvedPath)) === null || _a === void 0 ? void 0 : _a.fileNames),
                useCaseSensitiveFileNames: state.parseConfigFileHost.useCaseSensitiveFileNames,
                writeLog: function (s) { return state.writeLog(s); },
                toPath: function (fileName) { return toPath(state, fileName); }
            }))
                return;
            invalidateProjectAndScheduleBuilds(state, resolvedPath, ts.ConfigFileProgramReloadLevel.Partial);
        }, flags, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.WildcardDirectory, resolved); });
    }
    function watchInputFiles(state, resolved, resolvedPath, parsed) {
        if (!state.watch)
            return;
        ts.mutateMap(getOrCreateValueMapFromConfigFileMap(state.allWatchedInputFiles, resolvedPath), ts.arrayToMap(parsed.fileNames, function (fileName) { return toPath(state, fileName); }), {
            createNewValue: function (_path, input) { return state.watchFile(input, function () { return invalidateProjectAndScheduleBuilds(state, resolvedPath, ts.ConfigFileProgramReloadLevel.None); }, ts.PollingInterval.Low, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.SourceFile, resolved); },
            onDeleteValue: ts.closeFileWatcher,
        });
    }
    function watchPackageJsonFiles(state, resolved, resolvedPath, parsed) {
        if (!state.watch || !state.lastCachedPackageJsonLookups)
            return;
        ts.mutateMap(getOrCreateValueMapFromConfigFileMap(state.allWatchedPackageJsonFiles, resolvedPath), new ts.Map(state.lastCachedPackageJsonLookups.get(resolvedPath)), {
            createNewValue: function (path, _input) { return state.watchFile(path, function () { return invalidateProjectAndScheduleBuilds(state, resolvedPath, ts.ConfigFileProgramReloadLevel.Full); }, ts.PollingInterval.High, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.PackageJson, resolved); },
            onDeleteValue: ts.closeFileWatcher,
        });
    }
    function startWatching(state, buildOrder) {
        if (!state.watchAllProjectsPending)
            return;
        state.watchAllProjectsPending = false;
        for (var _i = 0, _a = getBuildOrderFromAnyBuildOrder(buildOrder); _i < _a.length; _i++) {
            var resolved = _a[_i];
            var resolvedPath = toResolvedConfigFilePath(state, resolved);
            var cfg = parseConfigFile(state, resolved, resolvedPath);
            // Watch this file
            watchConfigFile(state, resolved, resolvedPath, cfg);
            watchExtendedConfigFiles(state, resolvedPath, cfg);
            if (cfg) {
                // Update watchers for wildcard directories
                watchWildCardDirectories(state, resolved, resolvedPath, cfg);
                // Watch input files
                watchInputFiles(state, resolved, resolvedPath, cfg);
                // Watch package json files
                watchPackageJsonFiles(state, resolved, resolvedPath, cfg);
            }
        }
    }
    function stopWatching(state) {
        ts.clearMap(state.allWatchedConfigFiles, ts.closeFileWatcher);
        ts.clearMap(state.allWatchedExtendedConfigFiles, ts.closeFileWatcherOf);
        ts.clearMap(state.allWatchedWildcardDirectories, function (watchedWildcardDirectories) { return ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcherOf); });
        ts.clearMap(state.allWatchedInputFiles, function (watchedWildcardDirectories) { return ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcher); });
        ts.clearMap(state.allWatchedPackageJsonFiles, function (watchedPacageJsonFiles) { return ts.clearMap(watchedPacageJsonFiles, ts.closeFileWatcher); });
    }
    function createSolutionBuilderWorker(watch, hostOrHostWithWatch, rootNames, options, baseWatchOptions) {
        var state = createSolutionBuilderState(watch, hostOrHostWithWatch, rootNames, options, baseWatchOptions);
        return {
            build: function (project, cancellationToken, writeFile, getCustomTransformers) { return build(state, project, cancellationToken, writeFile, getCustomTransformers); },
            clean: function (project) { return clean(state, project); },
            buildReferences: function (project, cancellationToken, writeFile, getCustomTransformers) { return build(state, project, cancellationToken, writeFile, getCustomTransformers, /*onlyReferences*/ true); },
            cleanReferences: function (project) { return clean(state, project, /*onlyReferences*/ true); },
            getNextInvalidatedProject: function (cancellationToken) {
                setupInitialBuild(state, cancellationToken);
                return getNextInvalidatedProject(state, getBuildOrder(state), /*reportQueue*/ false);
            },
            getBuildOrder: function () { return getBuildOrder(state); },
            getUpToDateStatusOfProject: function (project) {
                var configFileName = resolveProjectName(state, project);
                var configFilePath = toResolvedConfigFilePath(state, configFileName);
                return getUpToDateStatus(state, parseConfigFile(state, configFileName, configFilePath), configFilePath);
            },
            invalidateProject: function (configFilePath, reloadLevel) { return invalidateProject(state, configFilePath, reloadLevel || ts.ConfigFileProgramReloadLevel.None); },
            buildNextInvalidatedProject: function () { return buildNextInvalidatedProject(state); },
            getAllParsedConfigs: function () { return ts.arrayFrom(ts.mapDefinedIterator(state.configFileCache.values(), function (config) { return isParsedCommandLine(config) ? config : undefined; })); },
            close: function () { return stopWatching(state); },
        };
    }
    function relName(state, path) {
        return ts.convertToRelativePath(path, state.currentDirectory, function (f) { return state.getCanonicalFileName(f); });
    }
    function reportStatus(state, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        state.host.reportSolutionBuilderStatus(ts.createCompilerDiagnostic.apply(void 0, __spreadArray([message], args, false)));
    }
    function reportWatchStatus(state, message) {
        var _a, _b;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        (_b = (_a = state.hostWithWatch).onWatchStatusChange) === null || _b === void 0 ? void 0 : _b.call(_a, ts.createCompilerDiagnostic.apply(void 0, __spreadArray([message], args, false)), state.host.getNewLine(), state.baseCompilerOptions);
    }
    function reportErrors(_a, errors) {
        var host = _a.host;
        errors.forEach(function (err) { return host.reportDiagnostic(err); });
    }
    function reportAndStoreErrors(state, proj, errors) {
        reportErrors(state, errors);
        state.projectErrorsReported.set(proj, true);
        if (errors.length) {
            state.diagnostics.set(proj, errors);
        }
    }
    function reportParseConfigFileDiagnostic(state, proj) {
        reportAndStoreErrors(state, proj, [state.configFileCache.get(proj)]);
    }
    function reportErrorSummary(state, buildOrder) {
        if (!state.needsSummary)
            return;
        state.needsSummary = false;
        var canReportSummary = state.watch || !!state.host.reportErrorSummary;
        var diagnostics = state.diagnostics;
        var totalErrors = 0;
        if (isCircularBuildOrder(buildOrder)) {
            reportBuildQueue(state, buildOrder.buildOrder);
            reportErrors(state, buildOrder.circularDiagnostics);
            if (canReportSummary)
                totalErrors += ts.getErrorCountForSummary(buildOrder.circularDiagnostics);
        }
        else {
            // Report errors from the other projects
            buildOrder.forEach(function (project) {
                var projectPath = toResolvedConfigFilePath(state, project);
                if (!state.projectErrorsReported.has(projectPath)) {
                    reportErrors(state, diagnostics.get(projectPath) || ts.emptyArray);
                }
            });
            if (canReportSummary)
                diagnostics.forEach(function (singleProjectErrors) { return totalErrors += ts.getErrorCountForSummary(singleProjectErrors); });
        }
        if (state.watch) {
            reportWatchStatus(state, ts.getWatchErrorSummaryDiagnosticMessage(totalErrors), totalErrors);
        }
        else if (state.host.reportErrorSummary) {
            state.host.reportErrorSummary(totalErrors);
        }
    }
    /**
     * Report the build ordering inferred from the current project graph if we're in verbose mode
     */
    function reportBuildQueue(state, buildQueue) {
        if (state.options.verbose) {
            reportStatus(state, ts.Diagnostics.Projects_in_this_build_Colon_0, buildQueue.map(function (s) { return "\r\n    * " + relName(state, s); }).join(""));
        }
    }
    function reportUpToDateStatus(state, configFileName, status) {
        if (state.options.force && (status.type === ts.UpToDateStatusType.UpToDate || status.type === ts.UpToDateStatusType.UpToDateWithUpstreamTypes)) {
            return reportStatus(state, ts.Diagnostics.Project_0_is_being_forcibly_rebuilt, relName(state, configFileName));
        }
        switch (status.type) {
            case ts.UpToDateStatusType.OutOfDateWithSelf:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_oldest_output_1_is_older_than_newest_input_2, relName(state, configFileName), relName(state, status.outOfDateOutputFileName), relName(state, status.newerInputFileName));
            case ts.UpToDateStatusType.OutOfDateWithUpstream:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_oldest_output_1_is_older_than_newest_input_2, relName(state, configFileName), relName(state, status.outOfDateOutputFileName), relName(state, status.newerProjectName));
            case ts.UpToDateStatusType.OutputMissing:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_output_file_1_does_not_exist, relName(state, configFileName), relName(state, status.missingOutputFileName));
            case ts.UpToDateStatusType.UpToDate:
                if (status.newestInputFileTime !== undefined) {
                    return reportStatus(state, ts.Diagnostics.Project_0_is_up_to_date_because_newest_input_1_is_older_than_oldest_output_2, relName(state, configFileName), relName(state, status.newestInputFileName || ""), relName(state, status.oldestOutputFileName || ""));
                }
                // Don't report anything for "up to date because it was already built" -- too verbose
                break;
            case ts.UpToDateStatusType.OutOfDateWithPrepend:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed, relName(state, configFileName), relName(state, status.newerProjectName));
            case ts.UpToDateStatusType.UpToDateWithUpstreamTypes:
                return reportStatus(state, ts.Diagnostics.Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies, relName(state, configFileName));
            case ts.UpToDateStatusType.UpstreamOutOfDate:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date, relName(state, configFileName), relName(state, status.upstreamProjectName));
            case ts.UpToDateStatusType.UpstreamBlocked:
                return reportStatus(state, status.upstreamProjectBlocked ?
                    ts.Diagnostics.Project_0_can_t_be_built_because_its_dependency_1_was_not_built :
                    ts.Diagnostics.Project_0_can_t_be_built_because_its_dependency_1_has_errors, relName(state, configFileName), relName(state, status.upstreamProjectName));
            case ts.UpToDateStatusType.Unbuildable:
                return reportStatus(state, ts.Diagnostics.Failed_to_parse_file_0_Colon_1, relName(state, configFileName), status.reason);
            case ts.UpToDateStatusType.TsVersionOutputOfDate:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_current_version_2, relName(state, configFileName), status.version, ts.version);
            case ts.UpToDateStatusType.ContainerOnly:
            // Don't report status on "solution" projects
            // falls through
            case ts.UpToDateStatusType.ComputingUpstream:
                // Should never leak from getUptoDateStatusWorker
                break;
            default:
                ts.assertType(status);
        }
    }
    /**
     * Report the up-to-date status of a project if we're in verbose mode
     */
    function verboseReportProjectStatus(state, configFileName, status) {
        if (state.options.verbose) {
            reportUpToDateStatus(state, configFileName, status);
        }
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    var server;
    (function (server) {
        /* @internal */
        server.ActionSet = "action::set";
        /* @internal */
        server.ActionInvalidate = "action::invalidate";
        /* @internal */
        server.ActionPackageInstalled = "action::packageInstalled";
        /* @internal */
        server.EventTypesRegistry = "event::typesRegistry";
        /* @internal */
        server.EventBeginInstallTypes = "event::beginInstallTypes";
        /* @internal */
        server.EventEndInstallTypes = "event::endInstallTypes";
        /* @internal */
        server.EventInitializationFailed = "event::initializationFailed";
        /* @internal */
        var Arguments;
        (function (Arguments) {
            Arguments.GlobalCacheLocation = "--globalTypingsCacheLocation";
            Arguments.LogFile = "--logFile";
            Arguments.EnableTelemetry = "--enableTelemetry";
            Arguments.TypingSafeListLocation = "--typingSafeListLocation";
            Arguments.TypesMapLocation = "--typesMapLocation";
            /**
             * This argument specifies the location of the NPM executable.
             * typingsInstaller will run the command with `${npmLocation} install ...`.
             */
            Arguments.NpmLocation = "--npmLocation";
            /**
             * Flag indicating that the typings installer should try to validate the default npm location.
             * If the default npm is not found when this flag is enabled, fallback to `npm install`
             */
            Arguments.ValidateDefaultNpmLocation = "--validateDefaultNpmLocation";
        })(Arguments = server.Arguments || (server.Arguments = {}));
        /* @internal */
        function hasArgument(argumentName) {
            return ts.sys.args.indexOf(argumentName) >= 0;
        }
        server.hasArgument = hasArgument;
        /* @internal */
        function findArgument(argumentName) {
            var index = ts.sys.args.indexOf(argumentName);
            return index >= 0 && index < ts.sys.args.length - 1
                ? ts.sys.args[index + 1]
                : undefined;
        }
        server.findArgument = findArgument;
        /* @internal */
        function nowString() {
            // E.g. "12:34:56.789"
            var d = new Date();
            return ts.padLeft(d.getHours().toString(), 2, "0") + ":" + ts.padLeft(d.getMinutes().toString(), 2, "0") + ":" + ts.padLeft(d.getSeconds().toString(), 2, "0") + "." + ts.padLeft(d.getMilliseconds().toString(), 3, "0");
        }
        server.nowString = nowString;
    })(server = ts.server || (ts.server = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var JsTyping;
    (function (JsTyping) {
        function isTypingUpToDate(cachedTyping, availableTypingVersions) {
            var availableVersion = new ts.Version(ts.getProperty(availableTypingVersions, "ts" + ts.versionMajorMinor) || ts.getProperty(availableTypingVersions, "latest"));
            return availableVersion.compareTo(cachedTyping.version) <= 0;
        }
        JsTyping.isTypingUpToDate = isTypingUpToDate;
        var unprefixedNodeCoreModuleList = [
            "assert",
            "assert/strict",
            "async_hooks",
            "buffer",
            "child_process",
            "cluster",
            "console",
            "constants",
            "crypto",
            "dgram",
            "diagnostics_channel",
            "dns",
            "dns/promises",
            "domain",
            "events",
            "fs",
            "fs/promises",
            "http",
            "https",
            "http2",
            "inspector",
            "module",
            "net",
            "os",
            "path",
            "perf_hooks",
            "process",
            "punycode",
            "querystring",
            "readline",
            "repl",
            "stream",
            "stream/promises",
            "string_decoder",
            "timers",
            "timers/promises",
            "tls",
            "trace_events",
            "tty",
            "url",
            "util",
            "util/types",
            "v8",
            "vm",
            "wasi",
            "worker_threads",
            "zlib"
        ];
        JsTyping.prefixedNodeCoreModuleList = unprefixedNodeCoreModuleList.map(function (name) { return "node:" + name; });
        JsTyping.nodeCoreModuleList = __spreadArray(__spreadArray([], unprefixedNodeCoreModuleList, true), JsTyping.prefixedNodeCoreModuleList, true);
        JsTyping.nodeCoreModules = new ts.Set(JsTyping.nodeCoreModuleList);
        function nonRelativeModuleNameForTypingCache(moduleName) {
            return JsTyping.nodeCoreModules.has(moduleName) ? "node" : moduleName;
        }
        JsTyping.nonRelativeModuleNameForTypingCache = nonRelativeModuleNameForTypingCache;
        function loadSafeList(host, safeListPath) {
            var result = ts.readConfigFile(safeListPath, function (path) { return host.readFile(path); });
            return new ts.Map(ts.getEntries(result.config));
        }
        JsTyping.loadSafeList = loadSafeList;
        function loadTypesMap(host, typesMapPath) {
            var result = ts.readConfigFile(typesMapPath, function (path) { return host.readFile(path); });
            if (result.config) {
                return new ts.Map(ts.getEntries(result.config.simpleMap));
            }
            return undefined;
        }
        JsTyping.loadTypesMap = loadTypesMap;
        /**
         * @param host is the object providing I/O related operations.
         * @param fileNames are the file names that belong to the same project
         * @param projectRootPath is the path to the project root directory
         * @param safeListPath is the path used to retrieve the safe list
         * @param packageNameToTypingLocation is the map of package names to their cached typing locations and installed versions
         * @param typeAcquisition is used to customize the typing acquisition process
         * @param compilerOptions are used as a source for typing inference
         */
        function discoverTypings(host, log, fileNames, projectRootPath, safeList, packageNameToTypingLocation, typeAcquisition, unresolvedImports, typesRegistry) {
            if (!typeAcquisition || !typeAcquisition.enable) {
                return { cachedTypingPaths: [], newTypingNames: [], filesToWatch: [] };
            }
            // A typing name to typing file path mapping
            var inferredTypings = new ts.Map();
            // Only infer typings for .js and .jsx files
            fileNames = ts.mapDefined(fileNames, function (fileName) {
                var path = ts.normalizePath(fileName);
                if (ts.hasJSFileExtension(path)) {
                    return path;
                }
            });
            var filesToWatch = [];
            if (typeAcquisition.include)
                addInferredTypings(typeAcquisition.include, "Explicitly included types");
            var exclude = typeAcquisition.exclude || [];
            // Directories to search for package.json, bower.json and other typing information
            var possibleSearchDirs = new ts.Set(fileNames.map(ts.getDirectoryPath));
            possibleSearchDirs.add(projectRootPath);
            possibleSearchDirs.forEach(function (searchDir) {
                var packageJsonPath = ts.combinePaths(searchDir, "package.json");
                getTypingNamesFromJson(packageJsonPath, filesToWatch);
                var bowerJsonPath = ts.combinePaths(searchDir, "bower.json");
                getTypingNamesFromJson(bowerJsonPath, filesToWatch);
                var bowerComponentsPath = ts.combinePaths(searchDir, "bower_components");
                getTypingNamesFromPackagesFolder(bowerComponentsPath, filesToWatch);
                var nodeModulesPath = ts.combinePaths(searchDir, "node_modules");
                getTypingNamesFromPackagesFolder(nodeModulesPath, filesToWatch);
            });
            if (!typeAcquisition.disableFilenameBasedTypeAcquisition) {
                getTypingNamesFromSourceFileNames(fileNames);
            }
            // add typings for unresolved imports
            if (unresolvedImports) {
                var module_1 = ts.deduplicate(unresolvedImports.map(nonRelativeModuleNameForTypingCache), ts.equateStringsCaseSensitive, ts.compareStringsCaseSensitive);
                addInferredTypings(module_1, "Inferred typings from unresolved imports");
            }
            // Add the cached typing locations for inferred typings that are already installed
            packageNameToTypingLocation.forEach(function (typing, name) {
                var registryEntry = typesRegistry.get(name);
                if (inferredTypings.has(name) && inferredTypings.get(name) === undefined && registryEntry !== undefined && isTypingUpToDate(typing, registryEntry)) {
                    inferredTypings.set(name, typing.typingLocation);
                }
            });
            // Remove typings that the user has added to the exclude list
            for (var _i = 0, exclude_1 = exclude; _i < exclude_1.length; _i++) {
                var excludeTypingName = exclude_1[_i];
                var didDelete = inferredTypings.delete(excludeTypingName);
                if (didDelete && log)
                    log("Typing for " + excludeTypingName + " is in exclude list, will be ignored.");
            }
            var newTypingNames = [];
            var cachedTypingPaths = [];
            inferredTypings.forEach(function (inferred, typing) {
                if (inferred !== undefined) {
                    cachedTypingPaths.push(inferred);
                }
                else {
                    newTypingNames.push(typing);
                }
            });
            var result = { cachedTypingPaths: cachedTypingPaths, newTypingNames: newTypingNames, filesToWatch: filesToWatch };
            if (log)
                log("Result: " + JSON.stringify(result));
            return result;
            function addInferredTyping(typingName) {
                if (!inferredTypings.has(typingName)) {
                    inferredTypings.set(typingName, undefined); // TODO: GH#18217
                }
            }
            function addInferredTypings(typingNames, message) {
                if (log)
                    log(message + ": " + JSON.stringify(typingNames));
                ts.forEach(typingNames, addInferredTyping);
            }
            /**
             * Get the typing info from common package manager json files like package.json or bower.json
             */
            function getTypingNamesFromJson(jsonPath, filesToWatch) {
                if (!host.fileExists(jsonPath)) {
                    return;
                }
                filesToWatch.push(jsonPath);
                var jsonConfig = ts.readConfigFile(jsonPath, function (path) { return host.readFile(path); }).config;
                var jsonTypingNames = ts.flatMap([jsonConfig.dependencies, jsonConfig.devDependencies, jsonConfig.optionalDependencies, jsonConfig.peerDependencies], ts.getOwnKeys);
                addInferredTypings(jsonTypingNames, "Typing names in '" + jsonPath + "' dependencies");
            }
            /**
             * Infer typing names from given file names. For example, the file name "jquery-min.2.3.4.js"
             * should be inferred to the 'jquery' typing name; and "angular-route.1.2.3.js" should be inferred
             * to the 'angular-route' typing name.
             * @param fileNames are the names for source files in the project
             */
            function getTypingNamesFromSourceFileNames(fileNames) {
                var fromFileNames = ts.mapDefined(fileNames, function (j) {
                    if (!ts.hasJSFileExtension(j))
                        return undefined;
                    var inferredTypingName = ts.removeFileExtension(ts.getBaseFileName(j.toLowerCase()));
                    var cleanedTypingName = ts.removeMinAndVersionNumbers(inferredTypingName);
                    return safeList.get(cleanedTypingName);
                });
                if (fromFileNames.length) {
                    addInferredTypings(fromFileNames, "Inferred typings from file names");
                }
                var hasJsxFile = ts.some(fileNames, function (f) { return ts.fileExtensionIs(f, ".jsx" /* Jsx */); });
                if (hasJsxFile) {
                    if (log)
                        log("Inferred 'react' typings due to presence of '.jsx' extension");
                    addInferredTyping("react");
                }
            }
            /**
             * Infer typing names from packages folder (ex: node_module, bower_components)
             * @param packagesFolderPath is the path to the packages folder
             */
            function getTypingNamesFromPackagesFolder(packagesFolderPath, filesToWatch) {
                filesToWatch.push(packagesFolderPath);
                // Todo: add support for ModuleResolutionHost too
                if (!host.directoryExists(packagesFolderPath)) {
                    return;
                }
                // depth of 2, so we access `node_modules/foo` but not `node_modules/foo/bar`
                var fileNames = host.readDirectory(packagesFolderPath, [".json" /* Json */], /*excludes*/ undefined, /*includes*/ undefined, /*depth*/ 2);
                if (log)
                    log("Searching for typing names in " + packagesFolderPath + "; all files: " + JSON.stringify(fileNames));
                var packageNames = [];
                for (var _i = 0, fileNames_1 = fileNames; _i < fileNames_1.length; _i++) {
                    var fileName = fileNames_1[_i];
                    var normalizedFileName = ts.normalizePath(fileName);
                    var baseFileName = ts.getBaseFileName(normalizedFileName);
                    if (baseFileName !== "package.json" && baseFileName !== "bower.json") {
                        continue;
                    }
                    var result_1 = ts.readConfigFile(normalizedFileName, function (path) { return host.readFile(path); });
                    var packageJson = result_1.config;
                    // npm 3's package.json contains a "_requiredBy" field
                    // we should include all the top level module names for npm 2, and only module names whose
                    // "_requiredBy" field starts with "#" or equals "/" for npm 3.
                    if (baseFileName === "package.json" && packageJson._requiredBy &&
                        ts.filter(packageJson._requiredBy, function (r) { return r[0] === "#" || r === "/"; }).length === 0) {
                        continue;
                    }
                    // If the package has its own d.ts typings, those will take precedence. Otherwise the package name will be used
                    // to download d.ts files from DefinitelyTyped
                    if (!packageJson.name) {
                        continue;
                    }
                    var ownTypes = packageJson.types || packageJson.typings;
                    if (ownTypes) {
                        var absolutePath = ts.getNormalizedAbsolutePath(ownTypes, ts.getDirectoryPath(normalizedFileName));
                        if (log)
                            log("    Package '" + packageJson.name + "' provides its own types.");
                        inferredTypings.set(packageJson.name, absolutePath);
                    }
                    else {
                        packageNames.push(packageJson.name);
                    }
                }
                addInferredTypings(packageNames, "    Found package names");
            }
        }
        JsTyping.discoverTypings = discoverTypings;
        var NameValidationResult;
        (function (NameValidationResult) {
            NameValidationResult[NameValidationResult["Ok"] = 0] = "Ok";
            NameValidationResult[NameValidationResult["EmptyName"] = 1] = "EmptyName";
            NameValidationResult[NameValidationResult["NameTooLong"] = 2] = "NameTooLong";
            NameValidationResult[NameValidationResult["NameStartsWithDot"] = 3] = "NameStartsWithDot";
            NameValidationResult[NameValidationResult["NameStartsWithUnderscore"] = 4] = "NameStartsWithUnderscore";
            NameValidationResult[NameValidationResult["NameContainsNonURISafeCharacters"] = 5] = "NameContainsNonURISafeCharacters";
        })(NameValidationResult = JsTyping.NameValidationResult || (JsTyping.NameValidationResult = {}));
        var maxPackageNameLength = 214;
        /**
         * Validates package name using rules defined at https://docs.npmjs.com/files/package.json
         */
        function validatePackageName(packageName) {
            return validatePackageNameWorker(packageName, /*supportScopedPackage*/ true);
        }
        JsTyping.validatePackageName = validatePackageName;
        function validatePackageNameWorker(packageName, supportScopedPackage) {
            if (!packageName) {
                return 1 /* EmptyName */;
            }
            if (packageName.length > maxPackageNameLength) {
                return 2 /* NameTooLong */;
            }
            if (packageName.charCodeAt(0) === 46 /* dot */) {
                return 3 /* NameStartsWithDot */;
            }
            if (packageName.charCodeAt(0) === 95 /* _ */) {
                return 4 /* NameStartsWithUnderscore */;
            }
            // check if name is scope package like: starts with @ and has one '/' in the middle
            // scoped packages are not currently supported
            if (supportScopedPackage) {
                var matches = /^@([^/]+)\/([^/]+)$/.exec(packageName);
                if (matches) {
                    var scopeResult = validatePackageNameWorker(matches[1], /*supportScopedPackage*/ false);
                    if (scopeResult !== 0 /* Ok */) {
                        return { name: matches[1], isScopeName: true, result: scopeResult };
                    }
                    var packageResult = validatePackageNameWorker(matches[2], /*supportScopedPackage*/ false);
                    if (packageResult !== 0 /* Ok */) {
                        return { name: matches[2], isScopeName: false, result: packageResult };
                    }
                    return 0 /* Ok */;
                }
            }
            if (encodeURIComponent(packageName) !== packageName) {
                return 5 /* NameContainsNonURISafeCharacters */;
            }
            return 0 /* Ok */;
        }
        function renderPackageNameValidationFailure(result, typing) {
            return typeof result === "object" ?
                renderPackageNameValidationFailureWorker(typing, result.result, result.name, result.isScopeName) :
                renderPackageNameValidationFailureWorker(typing, result, typing, /*isScopeName*/ false);
        }
        JsTyping.renderPackageNameValidationFailure = renderPackageNameValidationFailure;
        function renderPackageNameValidationFailureWorker(typing, result, name, isScopeName) {
            var kind = isScopeName ? "Scope" : "Package";
            switch (result) {
                case 1 /* EmptyName */:
                    return "'" + typing + "':: " + kind + " name '" + name + "' cannot be empty";
                case 2 /* NameTooLong */:
                    return "'" + typing + "':: " + kind + " name '" + name + "' should be less than " + maxPackageNameLength + " characters";
                case 3 /* NameStartsWithDot */:
                    return "'" + typing + "':: " + kind + " name '" + name + "' cannot start with '.'";
                case 4 /* NameStartsWithUnderscore */:
                    return "'" + typing + "':: " + kind + " name '" + name + "' cannot start with '_'";
                case 5 /* NameContainsNonURISafeCharacters */:
                    return "'" + typing + "':: " + kind + " name '" + name + "' contains non URI safe characters";
                case 0 /* Ok */:
                    return ts.Debug.fail(); // Shouldn't have called this.
                default:
                    throw ts.Debug.assertNever(result);
            }
        }
    })(JsTyping = ts.JsTyping || (ts.JsTyping = {}));
})(ts || (ts = {}));
var ts;
(function (ts) {
    var server;
    (function (server) {
        var typingsInstaller;
        (function (typingsInstaller) {
            var nullLog = {
                isEnabled: function () { return false; },
                writeLine: ts.noop
            };
            function typingToFileName(cachePath, packageName, installTypingHost, log) {
                try {
                    var result = ts.resolveModuleName(packageName, ts.combinePaths(cachePath, "index.d.ts"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, installTypingHost);
                    return result.resolvedModule && result.resolvedModule.resolvedFileName;
                }
                catch (e) {
                    if (log.isEnabled()) {
                        log.writeLine("Failed to resolve " + packageName + " in folder '" + cachePath + "': " + e.message);
                    }
                    return undefined;
                }
            }
            /*@internal*/
            function installNpmPackages(npmPath, tsVersion, packageNames, install) {
                var hasError = false;
                for (var remaining = packageNames.length; remaining > 0;) {
                    var result = getNpmCommandForInstallation(npmPath, tsVersion, packageNames, remaining);
                    remaining = result.remaining;
                    hasError = install(result.command) || hasError;
                }
                return hasError;
            }
            typingsInstaller.installNpmPackages = installNpmPackages;
            /*@internal*/
            function getNpmCommandForInstallation(npmPath, tsVersion, packageNames, remaining) {
                var sliceStart = packageNames.length - remaining;
                var command, toSlice = remaining;
                while (true) {
                    command = npmPath + " install --ignore-scripts " + (toSlice === packageNames.length ? packageNames : packageNames.slice(sliceStart, sliceStart + toSlice)).join(" ") + " --save-dev --user-agent=\"typesInstaller/" + tsVersion + "\"";
                    if (command.length < 8000) {
                        break;
                    }
                    toSlice = toSlice - Math.floor(toSlice / 2);
                }
                return { command: command, remaining: remaining - toSlice };
            }
            typingsInstaller.getNpmCommandForInstallation = getNpmCommandForInstallation;
            function endsWith(str, suffix, caseSensitive) {
                var expectedPos = str.length - suffix.length;
                return expectedPos >= 0 &&
                    (str.indexOf(suffix, expectedPos) === expectedPos ||
                        (!caseSensitive && ts.compareStringsCaseInsensitive(str.substr(expectedPos), suffix) === 0 /* EqualTo */));
            }
            function isPackageOrBowerJson(fileName, caseSensitive) {
                return endsWith(fileName, "/package.json", caseSensitive) || endsWith(fileName, "/bower.json", caseSensitive);
            }
            function sameFiles(a, b, caseSensitive) {
                return a === b || (!caseSensitive && ts.compareStringsCaseInsensitive(a, b) === 0 /* EqualTo */);
            }
            var ProjectWatcherType;
            (function (ProjectWatcherType) {
                ProjectWatcherType["FileWatcher"] = "FileWatcher";
                ProjectWatcherType["DirectoryWatcher"] = "DirectoryWatcher";
            })(ProjectWatcherType || (ProjectWatcherType = {}));
            function getDetailWatchInfo(projectName, watchers) {
                return "Project: " + projectName + " watcher already invoked: " + watchers.isInvoked;
            }
            var TypingsInstaller = /** @class */ (function () {
                function TypingsInstaller(installTypingHost, globalCachePath, safeListPath, typesMapLocation, throttleLimit, log) {
                    var _this = this;
                    if (log === void 0) { log = nullLog; }
                    this.installTypingHost = installTypingHost;
                    this.globalCachePath = globalCachePath;
                    this.safeListPath = safeListPath;
                    this.typesMapLocation = typesMapLocation;
                    this.throttleLimit = throttleLimit;
                    this.log = log;
                    this.packageNameToTypingLocation = new ts.Map();
                    this.missingTypingsSet = new ts.Set();
                    this.knownCachesSet = new ts.Set();
                    this.projectWatchers = new ts.Map();
                    this.pendingRunRequests = [];
                    this.installRunCount = 1;
                    this.inFlightRequestCount = 0;
                    this.latestDistTag = "latest";
                    this.toCanonicalFileName = ts.createGetCanonicalFileName(installTypingHost.useCaseSensitiveFileNames);
                    this.globalCachePackageJsonPath = ts.combinePaths(globalCachePath, "package.json");
                    var isLoggingEnabled = this.log.isEnabled();
                    if (isLoggingEnabled) {
                        this.log.writeLine("Global cache location '" + globalCachePath + "', safe file path '" + safeListPath + "', types map path " + typesMapLocation);
                    }
                    this.watchFactory = ts.getWatchFactory(this.installTypingHost, isLoggingEnabled ? ts.WatchLogLevel.Verbose : ts.WatchLogLevel.None, function (s) { return _this.log.writeLine(s); }, getDetailWatchInfo);
                    this.processCacheLocation(this.globalCachePath);
                }
                TypingsInstaller.prototype.closeProject = function (req) {
                    this.closeWatchers(req.projectName);
                };
                TypingsInstaller.prototype.closeWatchers = function (projectName) {
                    if (this.log.isEnabled()) {
                        this.log.writeLine("Closing file watchers for project '" + projectName + "'");
                    }
                    var watchers = this.projectWatchers.get(projectName);
                    if (!watchers) {
                        if (this.log.isEnabled()) {
                            this.log.writeLine("No watchers are registered for project '" + projectName + "'");
                        }
                        return;
                    }
                    ts.clearMap(watchers, ts.closeFileWatcher);
                    this.projectWatchers.delete(projectName);
                    if (this.log.isEnabled()) {
                        this.log.writeLine("Closing file watchers for project '" + projectName + "' - done.");
                    }
                };
                TypingsInstaller.prototype.install = function (req) {
                    var _this = this;
                    if (this.log.isEnabled()) {
                        this.log.writeLine("Got install request " + JSON.stringify(req));
                    }
                    // load existing typing information from the cache
                    if (req.cachePath) {
                        if (this.log.isEnabled()) {
                            this.log.writeLine("Request specifies cache path '" + req.cachePath + "', loading cached information...");
                        }
                        this.processCacheLocation(req.cachePath);
                    }
                    if (this.safeList === undefined) {
                        this.initializeSafeList();
                    }
                    var discoverTypingsResult = ts.JsTyping.discoverTypings(this.installTypingHost, this.log.isEnabled() ? (function (s) { return _this.log.writeLine(s); }) : undefined, req.fileNames, req.projectRootPath, this.safeList, this.packageNameToTypingLocation, req.typeAcquisition, req.unresolvedImports, this.typesRegistry);
                    if (this.log.isEnabled()) {
                        this.log.writeLine("Finished typings discovery: " + JSON.stringify(discoverTypingsResult));
                    }
                    // start watching files
                    this.watchFiles(req.projectName, discoverTypingsResult.filesToWatch, req.projectRootPath, req.watchOptions);
                    // install typings
                    if (discoverTypingsResult.newTypingNames.length) {
                        this.installTypings(req, req.cachePath || this.globalCachePath, discoverTypingsResult.cachedTypingPaths, discoverTypingsResult.newTypingNames);
                    }
                    else {
                        this.sendResponse(this.createSetTypings(req, discoverTypingsResult.cachedTypingPaths));
                        if (this.log.isEnabled()) {
                            this.log.writeLine("No new typings were requested as a result of typings discovery");
                        }
                    }
                };
                TypingsInstaller.prototype.initializeSafeList = function () {
                    // Prefer the safe list from the types map if it exists
                    if (this.typesMapLocation) {
                        var safeListFromMap = ts.JsTyping.loadTypesMap(this.installTypingHost, this.typesMapLocation);
                        if (safeListFromMap) {
                            this.log.writeLine("Loaded safelist from types map file '" + this.typesMapLocation + "'");
                            this.safeList = safeListFromMap;
                            return;
                        }
                        this.log.writeLine("Failed to load safelist from types map file '" + this.typesMapLocation + "'");
                    }
                    this.safeList = ts.JsTyping.loadSafeList(this.installTypingHost, this.safeListPath);
                };
                TypingsInstaller.prototype.processCacheLocation = function (cacheLocation) {
                    if (this.log.isEnabled()) {
                        this.log.writeLine("Processing cache location '" + cacheLocation + "'");
                    }
                    if (this.knownCachesSet.has(cacheLocation)) {
                        if (this.log.isEnabled()) {
                            this.log.writeLine("Cache location was already processed...");
                        }
                        return;
                    }
                    var packageJson = ts.combinePaths(cacheLocation, "package.json");
                    var packageLockJson = ts.combinePaths(cacheLocation, "package-lock.json");
                    if (this.log.isEnabled()) {
                        this.log.writeLine("Trying to find '" + packageJson + "'...");
                    }
                    if (this.installTypingHost.fileExists(packageJson) && this.installTypingHost.fileExists(packageLockJson)) {
                        var npmConfig = JSON.parse(this.installTypingHost.readFile(packageJson)); // TODO: GH#18217
                        var npmLock = JSON.parse(this.installTypingHost.readFile(packageLockJson)); // TODO: GH#18217
                        if (this.log.isEnabled()) {
                            this.log.writeLine("Loaded content of '" + packageJson + "': " + JSON.stringify(npmConfig));
                            this.log.writeLine("Loaded content of '" + packageLockJson + "'");
                        }
                        if (npmConfig.devDependencies && npmLock.dependencies) {
                            for (var key in npmConfig.devDependencies) {
                                if (!ts.hasProperty(npmLock.dependencies, key)) {
                                    // if package in package.json but not package-lock.json, skip adding to cache so it is reinstalled on next use
                                    continue;
                                }
                                // key is @types/<package name>
                                var packageName = ts.getBaseFileName(key);
                                if (!packageName) {
                                    continue;
                                }
                                var typingFile = typingToFileName(cacheLocation, packageName, this.installTypingHost, this.log);
                                if (!typingFile) {
                                    this.missingTypingsSet.add(packageName);
                                    continue;
                                }
                                var existingTypingFile = this.packageNameToTypingLocation.get(packageName);
                                if (existingTypingFile) {
                                    if (existingTypingFile.typingLocation === typingFile) {
                                        continue;
                                    }
                                    if (this.log.isEnabled()) {
                                        this.log.writeLine("New typing for package " + packageName + " from '" + typingFile + "' conflicts with existing typing file '" + existingTypingFile + "'");
                                    }
                                }
                                if (this.log.isEnabled()) {
                                    this.log.writeLine("Adding entry into typings cache: '" + packageName + "' => '" + typingFile + "'");
                                }
                                var info = ts.getProperty(npmLock.dependencies, key);
                                var version_1 = info && info.version;
                                if (!version_1) {
                                    continue;
                                }
                                var newTyping = { typingLocation: typingFile, version: new ts.Version(version_1) };
                                this.packageNameToTypingLocation.set(packageName, newTyping);
                            }
                        }
                    }
                    if (this.log.isEnabled()) {
                        this.log.writeLine("Finished processing cache location '" + cacheLocation + "'");
                    }
                    this.knownCachesSet.add(cacheLocation);
                };
                TypingsInstaller.prototype.filterTypings = function (typingsToInstall) {
                    var _this = this;
                    return ts.mapDefined(typingsToInstall, function (typing) {
                        var typingKey = ts.mangleScopedPackageName(typing);
                        if (_this.missingTypingsSet.has(typingKey)) {
                            if (_this.log.isEnabled())
                                _this.log.writeLine("'" + typing + "':: '" + typingKey + "' is in missingTypingsSet - skipping...");
                            return undefined;
                        }
                        var validationResult = ts.JsTyping.validatePackageName(typing);
                        if (validationResult !== 0 /* Ok */) {
                            // add typing name to missing set so we won't process it again
                            _this.missingTypingsSet.add(typingKey);
                            if (_this.log.isEnabled())
                                _this.log.writeLine(ts.JsTyping.renderPackageNameValidationFailure(validationResult, typing));
                            return undefined;
                        }
                        if (!_this.typesRegistry.has(typingKey)) {
                            if (_this.log.isEnabled())
                                _this.log.writeLine("'" + typing + "':: Entry for package '" + typingKey + "' does not exist in local types registry - skipping...");
                            return undefined;
                        }
                        if (_this.packageNameToTypingLocation.get(typingKey) && ts.JsTyping.isTypingUpToDate(_this.packageNameToTypingLocation.get(typingKey), _this.typesRegistry.get(typingKey))) {
                            if (_this.log.isEnabled())
                                _this.log.writeLine("'" + typing + "':: '" + typingKey + "' already has an up-to-date typing - skipping...");
                            return undefined;
                        }
                        return typingKey;
                    });
                };
                TypingsInstaller.prototype.ensurePackageDirectoryExists = function (directory) {
                    var npmConfigPath = ts.combinePaths(directory, "package.json");
                    if (this.log.isEnabled()) {
                        this.log.writeLine("Npm config file: " + npmConfigPath);
                    }
                    if (!this.installTypingHost.fileExists(npmConfigPath)) {
                        if (this.log.isEnabled()) {
                            this.log.writeLine("Npm config file: '" + npmConfigPath + "' is missing, creating new one...");
                        }
                        this.ensureDirectoryExists(directory, this.installTypingHost);
                        this.installTypingHost.writeFile(npmConfigPath, '{ "private": true }');
                    }
                };
                TypingsInstaller.prototype.installTypings = function (req, cachePath, currentlyCachedTypings, typingsToInstall) {
                    var _this = this;
                    if (this.log.isEnabled()) {
                        this.log.writeLine("Installing typings " + JSON.stringify(typingsToInstall));
                    }
                    var filteredTypings = this.filterTypings(typingsToInstall);
                    if (filteredTypings.length === 0) {
                        if (this.log.isEnabled()) {
                            this.log.writeLine("All typings are known to be missing or invalid - no need to install more typings");
                        }
                        this.sendResponse(this.createSetTypings(req, currentlyCachedTypings));
                        return;
                    }
                    this.ensurePackageDirectoryExists(cachePath);
                    var requestId = this.installRunCount;
                    this.installRunCount++;
                    // send progress event
                    this.sendResponse({
                        kind: server.EventBeginInstallTypes,
                        eventId: requestId,
                        // qualified explicitly to prevent occasional shadowing
                        // eslint-disable-next-line @typescript-eslint/no-unnecessary-qualifier
                        typingsInstallerVersion: ts.version,
                        projectName: req.projectName
                    });
                    var scopedTypings = filteredTypings.map(typingsName);
                    this.installTypingsAsync(requestId, scopedTypings, cachePath, function (ok) {
                        try {
                            if (!ok) {
                                if (_this.log.isEnabled()) {
                                    _this.log.writeLine("install request failed, marking packages as missing to prevent repeated requests: " + JSON.stringify(filteredTypings));
                                }
                                for (var _i = 0, filteredTypings_1 = filteredTypings; _i < filteredTypings_1.length; _i++) {
                                    var typing = filteredTypings_1[_i];
                                    _this.missingTypingsSet.add(typing);
                                }
                                return;
                            }
                            // TODO: watch project directory
                            if (_this.log.isEnabled()) {
                                _this.log.writeLine("Installed typings " + JSON.stringify(scopedTypings));
                            }
                            var installedTypingFiles = [];
                            for (var _a = 0, filteredTypings_2 = filteredTypings; _a < filteredTypings_2.length; _a++) {
                                var packageName = filteredTypings_2[_a];
                                var typingFile = typingToFileName(cachePath, packageName, _this.installTypingHost, _this.log);
                                if (!typingFile) {
                                    _this.missingTypingsSet.add(packageName);
                                    continue;
                                }
                                // packageName is guaranteed to exist in typesRegistry by filterTypings
                                var distTags = _this.typesRegistry.get(packageName);
                                var newVersion = new ts.Version(distTags["ts" + ts.versionMajorMinor] || distTags[_this.latestDistTag]);
                                var newTyping = { typingLocation: typingFile, version: newVersion };
                                _this.packageNameToTypingLocation.set(packageName, newTyping);
                                installedTypingFiles.push(typingFile);
                            }
                            if (_this.log.isEnabled()) {
                                _this.log.writeLine("Installed typing files " + JSON.stringify(installedTypingFiles));
                            }
                            _this.sendResponse(_this.createSetTypings(req, currentlyCachedTypings.concat(installedTypingFiles)));
                        }
                        finally {
                            var response = {
                                kind: server.EventEndInstallTypes,
                                eventId: requestId,
                                projectName: req.projectName,
                                packagesToInstall: scopedTypings,
                                installSuccess: ok,
                                // qualified explicitly to prevent occasional shadowing
                                // eslint-disable-next-line @typescript-eslint/no-unnecessary-qualifier
                                typingsInstallerVersion: ts.version
                            };
                            _this.sendResponse(response);
                        }
                    });
                };
                TypingsInstaller.prototype.ensureDirectoryExists = function (directory, host) {
                    var directoryName = ts.getDirectoryPath(directory);
                    if (!host.directoryExists(directoryName)) {
                        this.ensureDirectoryExists(directoryName, host);
                    }
                    if (!host.directoryExists(directory)) {
                        host.createDirectory(directory);
                    }
                };
                TypingsInstaller.prototype.watchFiles = function (projectName, files, projectRootPath, options) {
                    var _this = this;
                    if (!files.length) {
                        // shut down existing watchers
                        this.closeWatchers(projectName);
                        return;
                    }
                    var watchers = this.projectWatchers.get(projectName);
                    var toRemove = new ts.Map();
                    if (!watchers) {
                        watchers = new ts.Map();
                        this.projectWatchers.set(projectName, watchers);
                    }
                    else {
                        ts.copyEntries(watchers, toRemove);
                    }
                    // handler should be invoked once for the entire set of files since it will trigger full rediscovery of typings
                    watchers.isInvoked = false;
                    var isLoggingEnabled = this.log.isEnabled();
                    var createProjectWatcher = function (path, projectWatcherType) {
                        var canonicalPath = _this.toCanonicalFileName(path);
                        toRemove.delete(canonicalPath);
                        if (watchers.has(canonicalPath)) {
                            return;
                        }
                        if (isLoggingEnabled) {
                            _this.log.writeLine(projectWatcherType + ":: Added:: WatchInfo: " + path);
                        }
                        var watcher = projectWatcherType === "FileWatcher" /* FileWatcher */ ?
                            _this.watchFactory.watchFile(path, function () {
                                if (!watchers.isInvoked) {
                                    watchers.isInvoked = true;
                                    _this.sendResponse({ projectName: projectName, kind: server.ActionInvalidate });
                                }
                            }, ts.PollingInterval.High, options, projectName, watchers) :
                            _this.watchFactory.watchDirectory(path, function (f) {
                                if (watchers.isInvoked || !ts.fileExtensionIs(f, ".json" /* Json */)) {
                                    return;
                                }
                                if (isPackageOrBowerJson(f, _this.installTypingHost.useCaseSensitiveFileNames) &&
                                    !sameFiles(f, _this.globalCachePackageJsonPath, _this.installTypingHost.useCaseSensitiveFileNames)) {
                                    watchers.isInvoked = true;
                                    _this.sendResponse({ projectName: projectName, kind: server.ActionInvalidate });
                                }
                            }, 1 /* Recursive */, options, projectName, watchers);
                        watchers.set(canonicalPath, isLoggingEnabled ? {
                            close: function () {
                                _this.log.writeLine(projectWatcherType + ":: Closed:: WatchInfo: " + path);
                                watcher.close();
                            }
                        } : watcher);
                    };
                    // Create watches from list of files
                    for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                        var file = files_1[_i];
                        if (file.endsWith("/package.json") || file.endsWith("/bower.json")) {
                            // package.json or bower.json exists, watch the file to detect changes and update typings
                            createProjectWatcher(file, "FileWatcher" /* FileWatcher */);
                            continue;
                        }
                        // path in projectRoot, watch project root
                        if (ts.containsPath(projectRootPath, file, projectRootPath, !this.installTypingHost.useCaseSensitiveFileNames)) {
                            var subDirectory = file.indexOf(ts.directorySeparator, projectRootPath.length + 1);
                            if (subDirectory !== -1) {
                                // Watch subDirectory
                                createProjectWatcher(file.substr(0, subDirectory), "DirectoryWatcher" /* DirectoryWatcher */);
                            }
                            else {
                                // Watch the directory itself
                                createProjectWatcher(file, "DirectoryWatcher" /* DirectoryWatcher */);
                            }
                            continue;
                        }
                        // path in global cache, watch global cache
                        if (ts.containsPath(this.globalCachePath, file, projectRootPath, !this.installTypingHost.useCaseSensitiveFileNames)) {
                            createProjectWatcher(this.globalCachePath, "DirectoryWatcher" /* DirectoryWatcher */);
                            continue;
                        }
                        // watch node_modules or bower_components
                        createProjectWatcher(file, "DirectoryWatcher" /* DirectoryWatcher */);
                    }
                    // Remove unused watches
                    toRemove.forEach(function (watch, path) {
                        watch.close();
                        watchers.delete(path);
                    });
                };
                TypingsInstaller.prototype.createSetTypings = function (request, typings) {
                    return {
                        projectName: request.projectName,
                        typeAcquisition: request.typeAcquisition,
                        compilerOptions: request.compilerOptions,
                        typings: typings,
                        unresolvedImports: request.unresolvedImports,
                        kind: server.ActionSet
                    };
                };
                TypingsInstaller.prototype.installTypingsAsync = function (requestId, packageNames, cwd, onRequestCompleted) {
                    this.pendingRunRequests.unshift({ requestId: requestId, packageNames: packageNames, cwd: cwd, onRequestCompleted: onRequestCompleted });
                    this.executeWithThrottling();
                };
                TypingsInstaller.prototype.executeWithThrottling = function () {
                    var _this = this;
                    var _loop_1 = function () {
                        this_1.inFlightRequestCount++;
                        var request = this_1.pendingRunRequests.pop();
                        this_1.installWorker(request.requestId, request.packageNames, request.cwd, function (ok) {
                            _this.inFlightRequestCount--;
                            request.onRequestCompleted(ok);
                            _this.executeWithThrottling();
                        });
                    };
                    var this_1 = this;
                    while (this.inFlightRequestCount < this.throttleLimit && this.pendingRunRequests.length) {
                        _loop_1();
                    }
                };
                return TypingsInstaller;
            }());
            typingsInstaller.TypingsInstaller = TypingsInstaller;
            /* @internal */
            function typingsName(packageName) {
                return "@types/" + packageName + "@ts" + ts.versionMajorMinor;
            }
            typingsInstaller.typingsName = typingsName;
        })(typingsInstaller = server.typingsInstaller || (server.typingsInstaller = {}));
    })(server = ts.server || (ts.server = {}));
})(ts || (ts = {}));
var ts;
(function (ts) {
    var server;
    (function (server) {
        var typingsInstaller;
        (function (typingsInstaller) {
            var fs = require("fs");
            var path = require("path");
            var FileLog = (function () {
                function FileLog(logFile) {
                    var _this = this;
                    this.logFile = logFile;
                    this.isEnabled = function () {
                        return typeof _this.logFile === "string";
                    };
                    this.writeLine = function (text) {
                        if (typeof _this.logFile !== "string")
                            return;
                        try {
                            fs.appendFileSync(_this.logFile, "[" + server.nowString() + "] " + text + ts.sys.newLine);
                        }
                        catch (e) {
                            _this.logFile = undefined;
                        }
                    };
                }
                return FileLog;
            }());
            function getDefaultNPMLocation(processName, validateDefaultNpmLocation, host) {
                if (path.basename(processName).indexOf("node") === 0) {
                    var npmPath = path.join(path.dirname(process.argv[0]), "npm");
                    if (!validateDefaultNpmLocation) {
                        return npmPath;
                    }
                    if (host.fileExists(npmPath)) {
                        return "\"" + npmPath + "\"";
                    }
                }
                return "npm";
            }
            function loadTypesRegistryFile(typesRegistryFilePath, host, log) {
                if (!host.fileExists(typesRegistryFilePath)) {
                    if (log.isEnabled()) {
                        log.writeLine("Types registry file '" + typesRegistryFilePath + "' does not exist");
                    }
                    return new ts.Map();
                }
                try {
                    var content = JSON.parse(host.readFile(typesRegistryFilePath));
                    return new ts.Map(ts.getEntries(content.entries));
                }
                catch (e) {
                    if (log.isEnabled()) {
                        log.writeLine("Error when loading types registry file '" + typesRegistryFilePath + "': " + e.message + ", " + e.stack);
                    }
                    return new ts.Map();
                }
            }
            var typesRegistryPackageName = "types-registry";
            function getTypesRegistryFileLocation(globalTypingsCacheLocation) {
                return ts.combinePaths(ts.normalizeSlashes(globalTypingsCacheLocation), "node_modules/" + typesRegistryPackageName + "/index.json");
            }
            var NodeTypingsInstaller = (function (_super) {
                __extends(NodeTypingsInstaller, _super);
                function NodeTypingsInstaller(globalTypingsCacheLocation, typingSafeListLocation, typesMapLocation, npmLocation, validateDefaultNpmLocation, throttleLimit, log) {
                    var _this = _super.call(this, ts.sys, globalTypingsCacheLocation, typingSafeListLocation ? ts.toPath(typingSafeListLocation, "", ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames)) : ts.toPath("typingSafeList.json", __dirname, ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames)), typesMapLocation ? ts.toPath(typesMapLocation, "", ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames)) : ts.toPath("typesMap.json", __dirname, ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames)), throttleLimit, log) || this;
                    _this.npmPath = npmLocation !== undefined ? npmLocation : getDefaultNPMLocation(process.argv[0], validateDefaultNpmLocation, _this.installTypingHost);
                    if (ts.stringContains(_this.npmPath, " ") && _this.npmPath[0] !== "\"") {
                        _this.npmPath = "\"" + _this.npmPath + "\"";
                    }
                    if (_this.log.isEnabled()) {
                        _this.log.writeLine("Process id: " + process.pid);
                        _this.log.writeLine("NPM location: " + _this.npmPath + " (explicit '" + server.Arguments.NpmLocation + "' " + (npmLocation === undefined ? "not " : "") + " provided)");
                        _this.log.writeLine("validateDefaultNpmLocation: " + validateDefaultNpmLocation);
                    }
                    (_this.nodeExecSync = require("child_process").execSync);
                    _this.ensurePackageDirectoryExists(globalTypingsCacheLocation);
                    try {
                        if (_this.log.isEnabled()) {
                            _this.log.writeLine("Updating " + typesRegistryPackageName + " npm package...");
                        }
                        _this.execSyncAndLog(_this.npmPath + " install --ignore-scripts " + typesRegistryPackageName + "@" + _this.latestDistTag, { cwd: globalTypingsCacheLocation });
                        if (_this.log.isEnabled()) {
                            _this.log.writeLine("Updated " + typesRegistryPackageName + " npm package");
                        }
                    }
                    catch (e) {
                        if (_this.log.isEnabled()) {
                            _this.log.writeLine("Error updating " + typesRegistryPackageName + " package: " + e.message);
                        }
                        _this.delayedInitializationError = {
                            kind: "event::initializationFailed",
                            message: e.message,
                            stack: e.stack,
                        };
                    }
                    _this.typesRegistry = loadTypesRegistryFile(getTypesRegistryFileLocation(globalTypingsCacheLocation), _this.installTypingHost, _this.log);
                    return _this;
                }
                NodeTypingsInstaller.prototype.listen = function () {
                    var _this = this;
                    process.on("message", function (req) {
                        if (_this.delayedInitializationError) {
                            _this.sendResponse(_this.delayedInitializationError);
                            _this.delayedInitializationError = undefined;
                        }
                        switch (req.kind) {
                            case "discover":
                                _this.install(req);
                                break;
                            case "closeProject":
                                _this.closeProject(req);
                                break;
                            case "typesRegistry": {
                                var typesRegistry_1 = {};
                                _this.typesRegistry.forEach(function (value, key) {
                                    typesRegistry_1[key] = value;
                                });
                                var response = { kind: server.EventTypesRegistry, typesRegistry: typesRegistry_1 };
                                _this.sendResponse(response);
                                break;
                            }
                            case "installPackage": {
                                var fileName = req.fileName, packageName_1 = req.packageName, projectName_1 = req.projectName, projectRootPath = req.projectRootPath;
                                var cwd = getDirectoryOfPackageJson(fileName, _this.installTypingHost) || projectRootPath;
                                if (cwd) {
                                    _this.installWorker(-1, [packageName_1], cwd, function (success) {
                                        var message = success ? "Package " + packageName_1 + " installed." : "There was an error installing " + packageName_1 + ".";
                                        var response = { kind: server.ActionPackageInstalled, projectName: projectName_1, success: success, message: message };
                                        _this.sendResponse(response);
                                    });
                                }
                                else {
                                    var response = { kind: server.ActionPackageInstalled, projectName: projectName_1, success: false, message: "Could not determine a project root path." };
                                    _this.sendResponse(response);
                                }
                                break;
                            }
                            default:
                                ts.Debug.assertNever(req);
                        }
                    });
                };
                NodeTypingsInstaller.prototype.sendResponse = function (response) {
                    if (this.log.isEnabled()) {
                        this.log.writeLine("Sending response:\n    " + JSON.stringify(response));
                    }
                    process.send(response);
                    if (this.log.isEnabled()) {
                        this.log.writeLine("Response has been sent.");
                    }
                };
                NodeTypingsInstaller.prototype.installWorker = function (requestId, packageNames, cwd, onRequestCompleted) {
                    var _this = this;
                    if (this.log.isEnabled()) {
                        this.log.writeLine("#" + requestId + " with arguments'" + JSON.stringify(packageNames) + "'.");
                    }
                    var start = Date.now();
                    var hasError = typingsInstaller.installNpmPackages(this.npmPath, ts.version, packageNames, function (command) { return _this.execSyncAndLog(command, { cwd: cwd }); });
                    if (this.log.isEnabled()) {
                        this.log.writeLine("npm install #" + requestId + " took: " + (Date.now() - start) + " ms");
                    }
                    onRequestCompleted(!hasError);
                };
                NodeTypingsInstaller.prototype.execSyncAndLog = function (command, options) {
                    if (this.log.isEnabled()) {
                        this.log.writeLine("Exec: " + command);
                    }
                    try {
                        var stdout = this.nodeExecSync(command, __assign(__assign({}, options), { encoding: "utf-8" }));
                        if (this.log.isEnabled()) {
                            this.log.writeLine("    Succeeded. stdout:" + indent(ts.sys.newLine, stdout));
                        }
                        return false;
                    }
                    catch (error) {
                        var stdout = error.stdout, stderr = error.stderr;
                        this.log.writeLine("    Failed. stdout:" + indent(ts.sys.newLine, stdout) + ts.sys.newLine + "    stderr:" + indent(ts.sys.newLine, stderr));
                        return true;
                    }
                };
                return NodeTypingsInstaller;
            }(typingsInstaller.TypingsInstaller));
            typingsInstaller.NodeTypingsInstaller = NodeTypingsInstaller;
            function getDirectoryOfPackageJson(fileName, host) {
                return ts.forEachAncestorDirectory(ts.getDirectoryPath(fileName), function (directory) {
                    if (host.fileExists(ts.combinePaths(directory, "package.json"))) {
                        return directory;
                    }
                });
            }
            var logFilePath = server.findArgument(server.Arguments.LogFile);
            var globalTypingsCacheLocation = server.findArgument(server.Arguments.GlobalCacheLocation);
            var typingSafeListLocation = server.findArgument(server.Arguments.TypingSafeListLocation);
            var typesMapLocation = server.findArgument(server.Arguments.TypesMapLocation);
            var npmLocation = server.findArgument(server.Arguments.NpmLocation);
            var validateDefaultNpmLocation = server.hasArgument(server.Arguments.ValidateDefaultNpmLocation);
            var log = new FileLog(logFilePath);
            if (log.isEnabled()) {
                process.on("uncaughtException", function (e) {
                    log.writeLine("Unhandled exception: " + e + " at " + e.stack);
                });
            }
            process.on("disconnect", function () {
                if (log.isEnabled()) {
                    log.writeLine("Parent process has exited, shutting down...");
                }
                process.exit(0);
            });
            var installer = new NodeTypingsInstaller(globalTypingsCacheLocation, typingSafeListLocation, typesMapLocation, npmLocation, validateDefaultNpmLocation, 5, log);
            installer.listen();
            function indent(newline, str) {
                return str && str.length
                    ? newline + "    " + str.replace(/\r?\n/, newline + "    ")
                    : "";
            }
        })(typingsInstaller = server.typingsInstaller || (server.typingsInstaller = {}));
    })(server = ts.server || (ts.server = {}));
})(ts || (ts = {}));
//# sourceMappingURL=typingsInstaller.js.map