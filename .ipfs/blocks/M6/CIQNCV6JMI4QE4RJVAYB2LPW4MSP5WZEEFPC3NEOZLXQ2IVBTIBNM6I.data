arameter), 1 | 32 | 384 | 1536));
            ts.startOnNewLine(statement);
            ts.setTextRange(statement, parameter);
            ts.setEmitFlags(statement, 384 | 32 | 1048576 | 1536);
            ts.insertStatementAfterCustomPrologue(statements, statement);
        }
        function shouldAddRestParameter(node, inConstructorWithSynthesizedSuper) {
            return !!(node && node.dotDotDotToken && !inConstructorWithSynthesizedSuper);
        }
        function addRestParameterIfNeeded(statements, node, inConstructorWithSynthesizedSuper) {
            var prologueStatements = [];
            var parameter = ts.lastOrUndefined(node.parameters);
            if (!shouldAddRestParameter(parameter, inConstructorWithSynthesizedSuper)) {
                return false;
            }
            var declarationName = parameter.name.kind === 79 ? ts.setParent(ts.setTextRange(factory.cloneNode(parameter.name), parameter.name), parameter.name.parent) : factory.createTempVariable(undefined);
            ts.setEmitFlags(declarationName, 48);
            var expressionName = parameter.name.kind === 79 ? factory.cloneNode(parameter.name) : declarationName;
            var restIndex = node.parameters.length - 1;
            var temp = factory.createLoopVariable();
            prologueStatements.push(ts.setEmitFlags(ts.setTextRange(factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                factory.createVariableDeclaration(declarationName, undefined, undefined, factory.createArrayLiteralExpression([]))
            ])), parameter), 1048576));
            var forStatement = factory.createForStatement(ts.setTextRange(factory.createVariableDeclarationList([
                factory.createVariableDeclaration(temp, undefined, undefined, factory.createNumericLiteral(restIndex))
            ]), parameter), ts.setTextRange(factory.createLessThan(temp, factory.createPropertyAccessExpression(factory.createIdentifier("arguments"), "length")), parameter), ts.setTextRange(factory.createPostfixIncrement(temp), parameter), factory.createBlock([
                ts.startOnNewLine(ts.setTextRange(factory.createExpressionStatement(factory.createAssignment(factory.createElementAccessExpression(expressionName, restIndex === 0
                    ? temp
                    : factory.createSubtract(temp, factory.createNumericLiteral(restIndex))), factory.createElementAccessExpression(factory.createIdentifier("arguments"), temp))), parameter))
            ]));
            ts.setEmitFlags(forStatement, 1048576);
            ts.startOnNewLine(forStatement);
            prologueStatements.push(forStatement);
            if (parameter.name.kind !== 79) {
                prologueStatements.push(ts.setEmitFlags(ts.setTextRange(factory.createVariableStatement(undefined, factory.createVariableDeclarationList(ts.flattenDestructuringBinding(parameter, visitor, context, 0, expressionName))), parameter), 1048576));
            }
            ts.insertStatementsAfterCustomPrologue(statements, prologueStatements);
            return true;
        }
        function insertCaptureThisForNodeIfNeeded(statements, node) {
            if (hierarchyFacts & 65536 && node.kind !== 212) {
                insertCaptureThisForNode(statements, node, factory.createThis());
                return true;
            }
            return false;
        }
        function insertCaptureThisForNode(statements, node, initializer) {
            enableSubstitutionsForCapturedThis();
            var captureThisStatement = factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                factory.createVariableDeclaration(factory.createUniqueName("_this", 16 | 32), undefined, undefined, initializer)
            ]));
            ts.setEmitFlags(captureThisStatement, 1536 | 1048576);
            ts.setSourceMapRange(captureThisStatement, node);
            ts.insertStatementAfterCustomPrologue(statements, captureThisStatement);
        }
        function insertCaptureNewTargetIfNeeded(statements, node, copyOnWrite) {
            if (hierarchyFacts & 32768) {
                var newTarget = void 0;
                switch (node.kind) {
                    case 212:
                        return statements;
                    case 167:
                    case 170:
                    case 171:
                        newTarget = factory.createVoidZero();
                        break;
                    case 169:
                        newTarget = factory.createPropertyAccessExpression(ts.setEmitFlags(factory.createThis(), 4), "constructor");
                        break;
                    case 254:
                    case 211:
                        newTarget = factory.createConditionalExpression(factory.createLogicalAnd(ts.setEmitFlags(factory.createThis(), 4), factory.createBinaryExpression(ts.setEmitFlags(factory.createThis(), 4), 102, factory.getLocalName(node))), undefined, factory.createPropertyAccessExpression(ts.setEmitFlags(factory.createThis(), 4), "constructor"), undefined, factory.createVoidZero());
                        break;
                    default:
                        return ts.Debug.failBadSyntaxKind(node);
                }
                var captureNewTargetStatement = factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                    factory.createVariableDeclaration(factory.createUniqueName("_newTarget", 16 | 32), undefined, undefined, newTarget)
                ]));
                ts.setEmitFlags(captureNewTargetStatement, 1536 | 1048576);
                if (copyOnWrite) {
                    statements = statements.slice();
                }
                ts.insertStatementAfterCustomPrologue(statements, captureNewTargetStatement);
            }
            return statements;
        }
        function addClassMembers(statements, node) {
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                switch (member.kind) {
                    case 232:
                        statements.push(transformSemicolonClassElementToStatement(member));
                        break;
                    case 167:
                        statements.push(transformClassMethodDeclarationToStatement(getClassMemberPrefix(node, member), member, node));
                        break;
                    case 170:
                    case 171:
                        var accessors = ts.getAllAccessorDeclarations(node.members, member);
                        if (member === accessors.firstAccessor) {
                            statements.push(transformAccessorsToStatement(getClassMemberPrefix(node, member), accessors, node));
                        }
                        break;
                    case 169:
                    case 168:
                        break;
                    default:
                        ts.Debug.failBadSyntaxKind(member, currentSourceFile && currentSourceFile.fileName);
                        break;
                }
            }
        }
        function transformSemicolonClassElementToStatement(member) {
            return ts.setTextRange(factory.createEmptyStatement(), member);
        }
        function transformClassMethodDeclarationToStatement(receiver, member, container) {
            var commentRange = ts.getCommentRange(member);
            var sourceMapRange = ts.getSourceMapRange(member);
            var memberFunction = transformFunctionLikeToExpression(member, member, undefined, container);
            var propertyName = ts.visitNode(member.name, visitor, ts.isPropertyName);
            var e;
            if (!ts.isPrivateIdentifier(propertyName) && ts.getUseDefineForClassFields(context.getCompilerOptions())) {
                var name = ts.isComputedPropertyName(propertyName) ? propertyName.expression
                    : ts.isIdentifier(propertyName) ? factory.createStringLiteral(ts.unescapeLeadingUnderscores(propertyName.escapedText))
                        : propertyName;
                e = factory.createObjectDefinePropertyCall(receiver, name, factory.createPropertyDescriptor({ value: memberFunction, enumerable: false, writable: true, configurable: true }));
            }
            else {
                var memberName = ts.createMemberAccessForPropertyName(factory, receiver, propertyName, member.name);
                e = factory.createAssignment(memberName, memberFunction);
            }
            ts.setEmitFlags(memberFunction, 1536);
            ts.setSourceMapRange(memberFunction, sourceMapRange);
            var statement = ts.setTextRange(factory.createExpressionStatement(e), member);
            ts.setOriginalNode(statement, member);
            ts.setCommentRange(statement, commentRange);
            ts.setEmitFlags(statement, 48);
            return statement;
        }
        function transformAccessorsToStatement(receiver, accessors, container) {
            var statement = factory.createExpressionStatement(transformAccessorsToExpression(receiver, accessors, container, false));
            ts.setEmitFlags(statement, 1536);
            ts.setSourceMapRange(statement, ts.getSourceMapRange(accessors.firstAccessor));
            return statement;
        }
        function transformAccessorsToExpression(receiver, _a, container, startsOnNewLine) {
            var firstAccessor = _a.firstAccessor, getAccessor = _a.getAccessor, setAccessor = _a.setAccessor;
            var target = ts.setParent(ts.setTextRange(factory.cloneNode(receiver), receiver), receiver.parent);
            ts.setEmitFlags(target, 1536 | 32);
            ts.setSourceMapRange(target, firstAccessor.name);
            var visitedAccessorName = ts.visitNode(firstAccessor.name, visitor, ts.isPropertyName);
            if (ts.isPrivateIdentifier(visitedAccessorName)) {
                return ts.Debug.failBadSyntaxKind(visitedAccessorName, "Encountered unhandled private identifier while transforming ES2015.");
            }
            var propertyName = ts.createExpressionForPropertyName(factory, visitedAccessorName);
            ts.setEmitFlags(propertyName, 1536 | 16);
            ts.setSourceMapRange(propertyName, firstAccessor.name);
            var properties = [];
            if (getAccessor) {
                var getterFunction = transformFunctionLikeToExpression(getAccessor, undefined, undefined, container);
                ts.setSourceMapRange(getterFunction, ts.getSourceMapRange(getAccessor));
                ts.setEmitFlags(getterFunction, 512);
                var getter = factory.createPropertyAssignment("get", getterFunction);
                ts.setCommentRange(getter, ts.getCommentRange(getAccessor));
                properties.push(getter);
            }
            if (setAccessor) {
                var setterFunction = transformFunctionLikeToExpression(setAccessor, undefined, undefined, container);
                ts.setSourceMapRange(setterFunction, ts.getSourceMapRange(setAccessor));
                ts.setEmitFlags(setterFunction, 512);
                var setter = factory.createPropertyAssignment("set", setterFunction);
                ts.setCommentRange(setter, ts.getCommentRange(setAccessor));
                properties.push(setter);
            }
            properties.push(factory.createPropertyAssignment("enumerable", getAccessor || setAccessor ? factory.createFalse() : factory.createTrue()), factory.createPropertyAssignment("configurable", factory.createTrue()));
            var call = factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "defineProperty"), undefined, [
                target,
                propertyName,
                factory.createObjectLiteralExpression(properties, true)
            ]);
            if (startsOnNewLine) {
                ts.startOnNewLine(call);
            }
            return call;
        }
        function visitArrowFunction(node) {
            if (node.transformFlags & 8192 && !(hierarchyFacts & 16384)) {
                hierarchyFacts |= 65536;
            }
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = enterSubtree(15232, 66);
            var func = factory.createFunctionExpression(undefined, undefined, undefined, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, transformFunctionBody(node));
            ts.setTextRange(func, node);
            ts.setOriginalNode(func, node);
            ts.setEmitFlags(func, 8);
            exitSubtree(ancestorFacts, 0, 0);
            convertedLoopState = savedConvertedLoopState;
            return func;
        }
        function visitFunctionExpression(node) {
            var ancestorFacts = ts.getEmitFlags(node) & 262144
                ? enterSubtree(32662, 69)
                : enterSubtree(32670, 65);
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var parameters = ts.visitParameterList(node.parameters, visitor, context);
            var body = transformFunctionBody(node);
            var name = hierarchyFacts & 32768
                ? factory.getLocalName(node)
                : node.name;
            exitSubtree(ancestorFacts, 98304, 0);
            convertedLoopState = savedConvertedLoopState;
            return factory.updateFunctionExpression(node, undefined, node.asteriskToken, name, undefined, parameters, undefined, body);
        }
        function visitFunctionDeclaration(node) {
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = enterSubtree(32670, 65);
            var parameters = ts.visitParameterList(node.parameters, visitor, context);
            var body = transformFunctionBody(node);
            var name = hierarchyFacts & 32768
                ? factory.getLocalName(node)
                : node.name;
            exitSubtree(ancestorFacts, 98304, 0);
            convertedLoopState = savedConvertedLoopState;
            return factory.updateFunctionDeclaration(node, undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, name, undefined, parameters, undefined, body);
        }
        function transformFunctionLikeToExpression(node, location, name, container) {
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = container && ts.isClassLike(container) && !ts.isStatic(node)
                ? enterSubtree(32670, 65 | 8)
                : enterSubtree(32670, 65);
            var parameters = ts.visitParameterList(node.parameters, visitor, context);
            var body = transformFunctionBody(node);
            if (hierarchyFacts & 32768 && !name && (node.kind === 254 || node.kind === 211)) {
                name = factory.getGeneratedNameForNode(node);
            }
            exitSubtree(ancestorFacts, 98304, 0);
            convertedLoopState = savedConvertedLoopState;
            return ts.setOriginalNode(ts.setTextRange(factory.createFunctionExpression(undefined, node.asteriskToken, name, undefined, parameters, undefined, body), location), node);
        }
        function transformFunctionBody(node) {
            var multiLine = false;
            var singleLine = false;
            var statementsLocation;
            var closeBraceLocation;
            var prologue = [];
            var statements = [];
            var body = node.body;
            var statementOffset;
            resumeLexicalEnvironment();
            if (ts.isBlock(body)) {
                statementOffset = factory.copyStandardPrologue(body.statements, prologue, false);
                statementOffset = factory.copyCustomPrologue(body.statements, statements, statementOffset, visitor, ts.isHoistedFunction);
                statementOffset = factory.copyCustomPrologue(body.statements, statements, statementOffset, visitor, ts.isHoistedVariableStatement);
            }
            multiLine = addDefaultValueAssignmentsIfNeeded(statements, node) || multiLine;
            multiLine = addRestParameterIfNeeded(statements, node, false) || multiLine;
            if (ts.isBlock(body)) {
                statementOffset = factory.copyCustomPrologue(body.statements, statements, statementOffset, visitor);
                statementsLocation = body.statements;
                ts.addRange(statements, ts.visitNodes(body.statements, visitor, ts.isStatement, statementOffset));
                if (!multiLine && body.multiLine) {
                    multiLine = true;
                }
            }
            else {
                ts.Debug.assert(node.kind === 212);
                statementsLocation = ts.moveRangeEnd(body, -1);
                var equalsGreaterThanToken = node.equalsGreaterThanToken;
                if (!ts.nodeIsSynthesized(equalsGreaterThanToken) && !ts.nodeIsSynthesized(body)) {
                    if (ts.rangeEndIsOnSameLineAsRangeStart(equalsGreaterThanToken, body, currentSourceFile)) {
                        singleLine = true;
                    }
                    else {
                        multiLine = true;
                    }
                }
                var expression = ts.visitNode(body, visitor, ts.isExpression);
                var returnStatement = factory.createReturnStatement(expression);
                ts.setTextRange(returnStatement, body);
                ts.moveSyntheticComments(returnStatement, body);
                ts.setEmitFlags(returnStatement, 384 | 32 | 1024);
                statements.push(returnStatement);
                closeBraceLocation = body;
            }
            factory.mergeLexicalEnvironment(prologue, endLexicalEnvironment());
            insertCaptureNewTargetIfNeeded(prologue, node, false);
            insertCaptureThisForNodeIfNeeded(prologue, node);
            if (ts.some(prologue)) {
                multiLine = true;
            }
            statements.unshift.apply(statements, prologue);
            if (ts.isBlock(body) && ts.arrayIsEqualTo(statements, body.statements)) {
                return body;
            }
            var block = factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), statementsLocation), multiLine);
            ts.setTextRange(block, node.body);
            if (!multiLine && singleLine) {
                ts.setEmitFlags(block, 1);
            }
            if (closeBraceLocation) {
                ts.setTokenSourceMapRange(block, 19, closeBraceLocation);
            }
            ts.setOriginalNode(block, node.body);
            return block;
        }
        function visitBlock(node, isFunctionBody) {
            if (isFunctionBody) {
                return ts.visitEachChild(node, visitor, context);
            }
            var ancestorFacts = hierarchyFacts & 256
                ? enterSubtree(7104, 512)
                : enterSubtree(6976, 128);
            var updated = ts.visitEachChild(node, visitor, context);
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function visitExpressionStatement(node) {
            return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
        }
        function visitParenthesizedExpression(node, expressionResultIsUnused) {
            return ts.visitEachChild(node, expressionResultIsUnused ? visitorWithUnusedExpressionResult : visitor, context);
        }
        function visitBinaryExpression(node, expressionResultIsUnused) {
            if (ts.isDestructuringAssignment(node)) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 0, !expressionResultIsUnused);
            }
            if (node.operatorToken.kind === 27) {
                return factory.updateBinaryExpression(node, ts.visitNode(node.left, visitorWithUnusedExpressionResult, ts.isExpression), node.operatorToken, ts.visitNode(node.right, expressionResultIsUnused ? visitorWithUnusedExpressionResult : visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCommaListExpression(node, expressionResultIsUnused) {
            if (expressionResultIsUnused) {
                return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
            }
            var result;
            for (var i = 0; i < node.elements.length; i++) {
                var element = node.elements[i];
                var visited = ts.visitNode(element, i < node.elements.length - 1 ? visitorWithUnusedExpressionResult : visitor, ts.isExpression);
                if (result || visited !== element) {
                    result || (result = node.elements.slice(0, i));
                    result.push(visited);
                }
            }
            var elements = result ? ts.setTextRange(factory.createNodeArray(result), node.elements) : node.elements;
            return factory.updateCommaListExpression(node, elements);
        }
        function isVariableStatementOfTypeScriptClassWrapper(node) {
            return node.declarationList.declarations.length === 1
                && !!node.declarationList.declarations[0].initializer
                && !!(ts.getEmitFlags(node.declarationList.declarations[0].initializer) & 33554432);
        }
        function visitVariableStatement(node) {
            var ancestorFacts = enterSubtree(0, ts.hasSyntacticModifier(node, 1) ? 32 : 0);
            var updated;
            if (convertedLoopState && (node.declarationList.flags & 3) === 0 && !isVariableStatementOfTypeScriptClassWrapper(node)) {
                var assignments = void 0;
                for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    hoistVariableDeclarationDeclaredInConvertedLoop(convertedLoopState, decl);
                    if (decl.initializer) {
                        var assignment = void 0;
                        if (ts.isBindingPattern(decl.name)) {
                            assignment = ts.flattenDestructuringAssignment(decl, visitor, context, 0);
                        }
                        else {
                            assignment = factory.createBinaryExpression(decl.name, 63, ts.visitNode(decl.initializer, visitor, ts.isExpression));
                            ts.setTextRange(assignment, decl);
                        }
                        assignments = ts.append(assignments, assignment);
                    }
                }
                if (assignments) {
                    updated = ts.setTextRange(factory.createExpressionStatement(factory.inlineExpressions(assignments)), node);
                }
                else {
                    updated = undefined;
                }
            }
            else {
                updated = ts.visitEachChild(node, visitor, context);
            }
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function visitVariableDeclarationList(node) {
            if (node.flags & 3 || node.transformFlags & 262144) {
                if (node.flags & 3) {
                    enableSubstitutionsForBlockScopedBindings();
                }
                var declarations = ts.flatMap(node.declarations, node.flags & 1
                    ? visitVariableDeclarationInLetDeclarationList
                    : visitVariableDeclaration);
                var declarationList = factory.createVariableDeclarationList(declarations);
                ts.setOriginalNode(declarationList, node);
                ts.setTextRange(declarationList, node);
                ts.setCommentRange(declarationList, node);
                if (node.transformFlags & 262144
                    && (ts.isBindingPattern(node.declarations[0].name) || ts.isBindingPattern(ts.last(node.declarations).name))) {
                    ts.setSourceMapRange(declarationList, getRangeUnion(declarations));
                }
                return declarationList;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function getRangeUnion(declarations) {
            var pos = -1, end = -1;
            for (var _i = 0, declarations_9 = declarations; _i < declarations_9.length; _i++) {
                var node = declarations_9[_i];
                pos = pos === -1 ? node.pos : node.pos === -1 ? pos : Math.min(pos, node.pos);
                end = Math.max(end, node.end);
            }
            return ts.createRange(pos, end);
        }
        function shouldEmitExplicitInitializerForLetDeclaration(node) {
            var flags = resolver.getNodeCheckFlags(node);
            var isCapturedInFunction = flags & 262144;
            var isDeclaredInLoop = flags & 524288;
            var emittedAsTopLevel = (hierarchyFacts & 64) !== 0
                || (isCapturedInFunction
                    && isDeclaredInLoop
                    && (hierarchyFacts & 512) !== 0);
            var emitExplicitInitializer = !emittedAsTopLevel
                && (hierarchyFacts & 4096) === 0
                && (!resolver.isDeclarationWithCollidingName(node)
                    || (isDeclaredInLoop
                        && !isCapturedInFunction
                        && (hierarchyFacts & (2048 | 4096)) === 0));
            return emitExplicitInitializer;
        }
        function visitVariableDeclarationInLetDeclarationList(node) {
            var name = node.name;
            if (ts.isBindingPattern(name)) {
                return visitVariableDeclaration(node);
            }
            if (!node.initializer && shouldEmitExplicitInitializerForLetDeclaration(node)) {
                return factory.updateVariableDeclaration(node, node.name, undefined, undefined, factory.createVoidZero());
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitVariableDeclaration(node) {
            var ancestorFacts = enterSubtree(32, 0);
            var updated;
            if (ts.isBindingPattern(node.name)) {
                updated = ts.flattenDestructuringBinding(node, visitor, context, 0, undefined, (ancestorFacts & 32) !== 0);
            }
            else {
                updated = ts.visitEachChild(node, visitor, context);
            }
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function recordLabel(node) {
            convertedLoopState.labels.set(ts.idText(node.label), true);
        }
        function resetLabel(node) {
            convertedLoopState.labels.set(ts.idText(node.label), false);
        }
        function visitLabeledStatement(node) {
            if (convertedLoopState && !convertedLoopState.labels) {
                convertedLoopState.labels = new ts.Map();
            }
            var statement = ts.unwrapInnermostStatementOfLabel(node, convertedLoopState && recordLabel);
            return ts.isIterationStatement(statement, false)
                ? visitIterationStatement(statement, node)
                : factory.restoreEnclosingLabel(ts.visitNode(statement, visitor, ts.isStatement, factory.liftToBlock), node, convertedLoopState && resetLabel);
        }
        function visitIterationStatement(node, outermostLabeledStatement) {
            switch (node.kind) {
                case 238:
                case 239:
                    return visitDoOrWhileStatement(node, outermostLabeledStatement);
                case 240:
                    return visitForStatement(node, outermostLabeledStatement);
                case 241:
                    return visitForInStatement(node, outermostLabeledStatement);
                case 242:
                    return visitForOfStatement(node, outermostLabeledStatement);
            }
        }
        function visitIterationStatementWithFacts(excludeFacts, includeFacts, node, outermostLabeledStatement, convert) {
            var ancestorFacts = enterSubtree(excludeFacts, includeFacts);
            var updated = convertIterationStatementBodyIfNecessary(node, outermostLabeledStatement, ancestorFacts, convert);
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function visitDoOrWhileStatement(node, outermostLabeledStatement) {
            return visitIterationStatementWithFacts(0, 1280, node, outermostLabeledStatement);
        }
        function visitForStatement(node, outermostLabeledStatement) {
            return visitIterationStatementWithFacts(5056, 3328, node, outermostLabeledStatement);
        }
        function visitEachChildOfForStatement(node) {
            return factory.updateForStatement(node, ts.visitNode(node.initializer, visitorWithUnusedExpressionResult, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitorWithUnusedExpressionResult, ts.isExpression), ts.visitNode(node.statement, visitor, ts.isStatement, factory.liftToBlock));
        }
        function visitForInStatement(node, outermostLabeledStatement) {
            return visitIterationStatementWithFacts(3008, 5376, node, outermostLabeledStatement);
        }
        function visitForOfStatement(node, outermostLabeledStatement) {
            return visitIterationStatementWithFacts(3008, 5376, node, outermostLabeledStatement, compilerOptions.downlevelIteration ? convertForOfStatementForIterable : convertForOfStatementForArray);
        }
        function convertForOfStatementHead(node, boundValue, convertedLoopBodyStatements) {
            var statements = [];
            var initializer = node.initializer;
            if (ts.isVariableDeclarationList(initializer)) {
                if (node.initializer.flags & 3) {
                    enableSubstitutionsForBlockScopedBindings();
                }
                var firstOriginalDeclaration = ts.firstOrUndefined(initializer.declarations);
                if (firstOriginalDeclaration && ts.isBindingPattern(firstOriginalDeclaration.name)) {
                    var declarations = ts.flattenDestructuringBinding(firstOriginalDeclaration, visitor, context, 0, boundValue);
                    var declarationList = ts.setTextRange(factory.createVariableDeclarationList(declarations), node.initializer);
                    ts.setOriginalNode(declarationList, node.initializer);
                    ts.setSourceMapRange(declarationList, ts.createRange(declarations[0].pos, ts.last(declarations).end));
                    statements.push(factory.createVariableStatement(undefined, declarationList));
                }
                else {
                    statements.push(ts.setTextRange(factory.createVariableStatement(undefined, ts.setOriginalNode(ts.setTextRange(factory.createVariableDeclarationList([
                        factory.createVariableDeclaration(firstOriginalDeclaration ? firstOriginalDeclaration.name : factory.createTempVariable(undefined), undefined, undefined, boundValue)
                    ]), ts.moveRangePos(initializer, -1)), initializer)), ts.moveRangeEnd(initializer, -1)));
                }
            }
            else {
                var assignment = factory.createAssignment(initializer, boundValue);
                if (ts.isDestructuringAssignment(assignment)) {
                    statements.push(factory.createExpressionStatement(visitBinaryExpression(assignment, true)));
                }
                else {
                    ts.setTextRangeEnd(assignment, initializer.end);
                    statements.push(ts.setTextRange(factory.createExpressionStatement(ts.visitNode(assignment, visitor, ts.isExpression)), ts.moveRangeEnd(initializer, -1)));
                }
            }
            if (convertedLoopBodyStatements) {
                return createSyntheticBlockForConvertedStatements(ts.addRange(statements, convertedLoopBodyStatements));
            }
            else {
                var statement = ts.visitNode(node.statement, visitor, ts.isStatement, factory.liftToBlock);
                if (ts.isBlock(statement)) {
                    return factory.updateBlock(statement, ts.setTextRange(factory.createNodeArray(ts.concatenate(statements, statement.statements)), statement.statements));
                }
                else {
                    statements.push(statement);
                    return createSyntheticBlockForConvertedStatements(statements);
                }
            }
        }
        function createSyntheticBlockForConvertedStatements(statements) {
            return ts.setEmitFlags(factory.createBlock(factory.createNodeArray(statements), true), 48 | 384);
        }
        function convertForOfStatementForArray(node, outermostLabeledStatement, convertedLoopBodyStatements) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var counter = factory.createLoopVariable();
            var rhsReference = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(expression) : factory.createTempVariable(undefined);
            ts.setEmitFlags(expression, 48 | ts.getEmitFlags(expression));
            var forStatement = ts.setTextRange(factory.createForStatement(ts.setEmitFlags(ts.setTextRange(factory.createVariableDeclarationList([
                ts.setTextRange(factory.createVariableDeclaration(counter, undefined, undefined, factory.createNumericLiteral(0)), ts.moveRangePos(node.expression, -1)),
                ts.setTextRange(factory.createVariableDeclaration(rhsReference, undefined, undefined, expression), node.expression)
            ]), node.expression), 2097152), ts.setTextRange(factory.createLessThan(counter, factory.createPropertyAccessExpression(rhsReference, "length")), node.expression), ts.setTextRange(factory.createPostfixIncrement(counter), node.expression), convertForOfStatementHead(node, factory.createElementAccessExpression(rhsReference, counter), convertedLoopBodyStatements)), node);
            ts.setEmitFlags(forStatement, 256);
            ts.setTextRange(forStatement, node);
            return factory.restoreEnclosingLabel(forStatement, outermostLabeledStatement, convertedLoopState && resetLabel);
        }
        function convertForOfStatementForIterable(node, outermostLabeledStatement, convertedLoopBodyStatements, ancestorFacts) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var iterator = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(expression) : factory.createTempVariable(undefined);
            var result = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(iterator) : factory.createTempVariable(undefined);
            var errorRecord = factory.createUniqueName("e");
            var catchVariable = factory.getGeneratedNameForNode(errorRecord);
            var returnMethod = factory.createTempVariable(undefined);
            var values = ts.setTextRange(emitHelpers().createValuesHelper(expression), node.expression);
            var next = factory.createCallExpression(factory.createPropertyAccessExpression(iterator, "next"), undefined, []);
            hoistVariableDeclaration(errorRecord);
            hoistVariableDeclaration(returnMethod);
            var initializer = ancestorFacts & 1024
                ? factory.inlineExpressions([factory.createAssignment(errorRecord, factory.createVoidZero()), values])
                : values;
            var forStatement = ts.setEmitFlags(ts.setTextRange(factory.createForStatement(ts.setEmitFlags(ts.setTextRange(factory.createVariableDeclarationList([
                ts.setTextRange(factory.createVariableDeclaration(iterator, undefined, undefined, initializer), node.expression),
                factory.createVariableDeclaration(result, undefined, undefined, next)
            ]), node.expression), 2097152), factory.createLogicalNot(factory.createPropertyAccessExpression(result, "done")), factory.createAssignment(result, next), convertForOfStatementHead(node, factory.createPropertyAccessExpression(result, "value"), convertedLoopBodyStatements)), node), 256);
            return factory.createTryStatement(factory.createBlock([
                factory.restoreEnclosingLabel(forStatement, outermostLabeledStatement, convertedLoopState && resetLabel)
            ]), factory.createCatchClause(factory.createVariableDeclaration(catchVariable), ts.setEmitFlags(factory.createBlock([
                factory.createExpressionStatement(factory.createAssignment(errorRecord, factory.createObjectLiteralExpression([
                    factory.createPropertyAssignment("error", catchVariable)
                ])))
            ]), 1)), factory.createBlock([
                factory.createTryStatement(factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(factory.createLogicalAnd(factory.createLogicalAnd(result, factory.createLogicalNot(factory.createPropertyAccessExpression(result, "done"))), factory.createAssignment(returnMethod, factory.createPropertyAccessExpression(iterator, "return"))), factory.createExpressionStatement(factory.createFunctionCallCall(returnMethod, iterator, []))), 1),
                ]), undefined, ts.setEmitFlags(factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(errorRecord, factory.createThrowStatement(factory.createPropertyAccessExpression(errorRecord, "error"))), 1)
                ]), 1))
            ]));
        }
        function visitObjectLiteralExpression(node) {
            var properties = node.properties;
            var numInitialProperties = -1, hasComputed = false;
            for (var i = 0; i < properties.length; i++) {
                var property = properties[i];
                if ((property.transformFlags & 524288 &&
                    hierarchyFacts & 4)
                    || (hasComputed = ts.Debug.checkDefined(property.name).kind === 160)) {
                    numInitialProperties = i;
                    break;
                }
            }
            if (numInitialProperties < 0) {
                return ts.visitEachChild(node, visitor, context);
            }
            var temp = factory.createTempVariable(hoistVariableDeclaration);
            var expressions = [];
            var assignment = factory.createAssignment(temp, ts.setEmitFlags(factory.createObjectLiteralExpression(ts.visitNodes(properties, visitor, ts.isObjectLiteralElementLike, 0, numInitialProperties), node.multiLine), hasComputed ? 65536 : 0));
            if (node.multiLine) {
                ts.startOnNewLine(assignment);
            }
            expressions.push(assignment);
            addObjectLiteralMembers(expressions, node, temp, numInitialProperties);
            expressions.push(node.multiLine ? ts.startOnNewLine(ts.setParent(ts.setTextRange(factory.cloneNode(temp), temp), temp.parent)) : temp);
            return factory.inlineExpressions(expressions);
        }
        function shouldConvertPartOfIterationStatement(node) {
            return (resolver.getNodeCheckFlags(node) & 131072) !== 0;
        }
        function shouldConvertInitializerOfForStatement(node) {
            return ts.isForStatement(node) && !!node.initializer && shouldConvertPartOfIterationStatement(node.initializer);
        }
        function shouldConvertConditionOfForStatement(node) {
            return ts.isForStatement(node) && !!node.condition && shouldConvertPartOfIterationStatement(node.condition);
        }
        function shouldConvertIncrementorOfForStatement(node) {
            return ts.isForStatement(node) && !!node.incrementor && shouldConvertPartOfIterationStatement(node.incrementor);
        }
        function shouldConvertIterationStatement(node) {
            return shouldConvertBodyOfIterationStatement(node)
                || shouldConvertInitializerOfForStatement(node);
        }
        function shouldConvertBodyOfIterationStatement(node) {
            return (resolver.getNodeCheckFlags(node) & 65536) !== 0;
        }
        function hoistVariableDeclarationDeclaredInConvertedLoop(state, node) {
            if (!state.hoistedLocalVariables) {
                state.hoistedLocalVariables = [];
            }
            visit(node.name);
            function visit(node) {
                if (node.kind === 79) {
                    state.hoistedLocalVariables.push(node);
                }
                else {
                    for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                        var element = _a[_i];
                        if (!ts.isOmittedExpression(element)) {
                            visit(element.name);
                        }
                    }
                }
            }
        }
        function convertIterationStatementBodyIfNecessary(node, outermostLabeledStatement, ancestorFacts, convert) {
            if (!shouldConvertIterationStatement(node)) {
                var saveAllowedNonLabeledJumps = void 0;
                if (convertedLoopState) {
                    saveAllowedNonLabeledJumps = convertedLoopState.allowedNonLabeledJumps;
                    convertedLoopState.allowedNonLabeledJumps = 2 | 4;
                }
                var result = convert
                    ? convert(node, outermostLabeledStatement, undefined, ancestorFacts)
                    : factory.restoreEnclosingLabel(ts.isForStatement(node) ? visitEachChildOfForStatement(node) : ts.visitEachChild(node, visitor, context), outermostLabeledStatement, convertedLoopState && resetLabel);
                if (convertedLoopState) {
                    convertedLoopState.allowedNonLabeledJumps = saveAllowedNonLabeledJumps;
                }
                return result;
            }
            var currentState = createConvertedLoopState(node);
            var statements = [];
            var outerConvertedLoopState = convertedLoopState;
            convertedLoopState = currentState;
            var initializerFunction = shouldConvertInitializerOfForStatement(node) ? createFunctionForInitializerOfForStatement(node, currentState) : undefined;
            var bodyFunction = shouldConvertBodyOfIterationStatement(node) ? createFunctionForBodyOfIterationStatement(node, currentState, outerConvertedLoopState) : undefined;
            convertedLoopState = outerConvertedLoopState;
            if (initializerFunction)
                statements.push(initializerFunction.functionDeclaration);
            if (bodyFunction)
                statements.push(bodyFunction.functionDeclaration);
            addExtraDeclarationsForConvertedLoop(statements, currentState, outerConvertedLoopState);
            if (initializerFunction) {
                statements.push(generateCallToConvertedLoopInitializer(initializerFunction.functionName, initializerFunction.containsYield));
            }
            var loop;
            if (bodyFunction) {
                if (convert) {
                    loop = convert(node, outermostLabeledStatement, bodyFunction.part, ancestorFacts);
                }
                else {
                    var clone_4 = convertIterationStatementCore(node, initializerFunction, factory.createBlock(bodyFunction.part, true));
                    loop = factory.restoreEnclosingLabel(clone_4, outermostLabeledStatement, convertedLoopState && resetLabel);
                }
            }
            else {
                var clone_5 = convertIterationStatementCore(node, initializerFunction, ts.visitNode(node.statement, visitor, ts.isStatement, factory.liftToBlock));
                loop = factory.restoreEnclosingLabel(clone_5, outermostLabeledStatement, convertedLoopState && resetLabel);
            }
            statements.push(loop);
            return statements;
        }
        function convertIterationStatementCore(node, initializerFunction, convertedLoopBody) {
            switch (node.kind) {
                case 240: return convertForStatement(node, initializerFunction, convertedLoopBody);
                case 241: return convertForInStatement(node, convertedLoopBody);
                case 242: return convertForOfStatement(node, convertedLoopBody);
                case 238: return convertDoStatement(node, convertedLoopBody);
                case 239: return convertWhileStatement(node, convertedLoopBody);
                default: return ts.Debug.failBadSyntaxKind(node, "IterationStatement expected");
            }
        }
        function convertForStatement(node, initializerFunction, convertedLoopBody) {
            var shouldConvertCondition = node.condition && shouldConvertPartOfIterationStatement(node.condition);
            var shouldConvertIncrementor = shouldConvertCondition || node.incrementor && shouldConvertPartOfIterationStatement(node.incrementor);
            return factory.updateForStatement(node, ts.visitNode(initializerFunction ? initializerFunction.part : node.initializer, visitorWithUnusedExpressionResult, ts.isForInitializer), ts.visitNode(shouldConvertCondition ? undefined : node.condition, visitor, ts.isExpression), ts.visitNode(shouldConvertIncrementor ? undefined : node.incrementor, visitorWithUnusedExpressionResult, ts.isExpression), convertedLoopBody);
        }
        function convertForOfStatement(node, convertedLoopBody) {
            return factory.updateForOfStatement(node, undefined, ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.expression, visitor, ts.isExpression), convertedLoopBody);
        }
        function convertForInStatement(node, convertedLoopBody) {
            return factory.updateForInStatement(node, ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.expression, visitor, ts.isExpression), convertedLoopBody);
        }
        function convertDoStatement(node, convertedLoopBody) {
            return factory.updateDoStatement(node, convertedLoopBody, ts.visitNode(node.expression, visitor, ts.isExpression));
        }
        function convertWhileStatement(node, convertedLoopBody) {
            return factory.updateWhileStatement(node, ts.visitNode(node.expression, visitor, ts.isExpression), convertedLoopBody);
        }
        function createConvertedLoopState(node) {
            var loopInitializer;
            switch (node.kind) {
                case 240:
                case 241:
                case 242:
                    var initializer = node.initializer;
                    if (initializer && initializer.kind === 253) {
                        loopInitializer = initializer;
                    }
                    break;
            }
            var loopParameters = [];
            var loopOutParameters = [];
            if (loopInitializer && (ts.getCombinedNodeFlags(loopInitializer) & 3)) {
                var hasCapturedBindingsInForInitializer = shouldConvertInitializerOfForStatement(node);
                for (var _i = 0, _a = loopInitializer.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    processLoopVariableDeclaration(node, decl, loopParameters, loopOutParameters, hasCapturedBindingsInForInitializer);
                }
            }
            var currentState = { loopParameters: loopParameters, loopOutParameters: loopOutParameters };
            if (convertedLoopState) {
                if (convertedLoopState.argumentsName) {
                    currentState.argumentsName = convertedLoopState.argumentsName;
                }
                if (convertedLoopState.thisName) {
                    currentState.thisName = convertedLoopState.thisName;
                }
                if (convertedLoopState.hoistedLocalVariables) {
                    currentState.hoistedLocalVariables = convertedLoopState.hoistedLocalVariables;
                }
            }
            return currentState;
        }
        function addExtraDeclarationsForConvertedLoop(statements, state, outerState) {
            var extraVariableDeclarations;
            if (state.argumentsName) {
                if (outerState) {
                    outerState.argumentsName = state.argumentsName;
                }
                else {
                    (extraVariableDeclarations || (extraVariableDeclarations = [])).push(factory.createVariableDeclaration(state.argumentsName, undefined, undefined, factory.createIdentifier("arguments")));
                }
            }
            if (state.thisName) {
                if (outerState) {
                    outerState.thisName = state.thisName;
                }
                else {
                    (extraVariableDeclarations || (extraVariableDeclarations = [])).push(factory.createVariableDeclaration(state.thisName, undefined, undefined, factory.createIdentifier("this")));
                }
            }
            if (state.hoistedLocalVariables) {
                if (outerState) {
                    outerState.hoistedLocalVariables = state.hoistedLocalVariables;
                }
                else {
                    if (!extraVariableDeclarations) {
                        extraVariableDeclarations = [];
                    }
                    for (var _i = 0, _a = state.hoistedLocalVariables; _i < _a.length; _i++) {
                        var identifier = _a[_i];
                        extraVariableDeclarations.push(factory.createVariableDeclaration(identifier));
                    }
                }
            }
            if (state.loopOutParameters.length) {
                if (!extraVariableDeclarations) {
                    extraVariableDeclarations = [];
                }
                for (var _b = 0, _c = state.loopOutParameters; _b < _c.length; _b++) {
                    var outParam = _c[_b];
                    extraVariableDeclarations.push(factory.createVariableDeclaration(outParam.outParamName));
                }
            }
            if (state.conditionVariable) {
                if (!extraVariableDeclarations) {
                    extraVariableDeclarations = [];
                }
                extraVariableDeclarations.push(factory.createVariableDeclaration(state.conditionVariable, undefined, undefined, factory.createFalse()));
            }
            if (extraVariableDeclarations) {
                statements.push(factory.createVariableStatement(undefined, factory.createVariableDeclarationList(extraVariableDeclarations)));
            }
        }
        function createOutVariable(p) {
            return factory.createVariableDeclaration(p.originalName, undefined, undefined, p.outParamName);
        }
        function createFunctionForInitializerOfForStatement(node, currentState) {
            var functionName = factory.createUniqueName("_loop_init");
            var containsYield = (node.initializer.transformFlags & 524288) !== 0;
            var emitFlags = 0;
            if (currentState.containsLexicalThis)
                emitFlags |= 8;
            if (containsYield && hierarchyFacts & 4)
                emitFlags |= 262144;
            var statements = [];
            statements.push(factory.createVariableStatement(undefined, node.initializer));
            copyOutParameters(currentState.loopOutParameters, 2, 1, statements);
            var functionDeclaration = factory.createVariableStatement(undefined, ts.setEmitFlags(factory.createVariableDeclarationList([
                factory.createVariableDeclaration(functionName, undefined, undefined, ts.setEmitFlags(factory.createFunctionExpression(undefined, containsYield ? factory.createToken(41) : undefined, undefined, undefined, undefined, undefined, ts.visitNode(factory.createBlock(statements, true), visitor, ts.isBlock)), emitFlags))
            ]), 2097152));
            var part = factory.createVariableDeclarationList(ts.map(currentState.loopOutParameters, createOutVariable));
            return { functionName: functionName, containsYield: containsYield, functionDeclaration: functionDeclaration, part: part };
        }
        function createFunctionForBodyOfIterationStatement(node, currentState, outerState) {
            var functionName = factory.createUniqueName("_loop");
            startLexicalEnvironment();
            var statement = ts.visitNode(node.statement, visitor, ts.isStatement, factory.liftToBlock);
            var lexicalEnvironment = endLexicalEnvironment();
            var statements = [];
            if (shouldConvertConditionOfForStatement(node) || shouldConvertIncrementorOfForStatement(node)) {
                currentState.conditionVariable = factory.createUniqueName("inc");
                if (node.incrementor) {
                    statements.push(factory.createIfStatement(currentState.conditionVariable, factory.createExpressionStatement(ts.visitNode(node.incrementor, visitor, ts.isExpression)), factory.createExpressionStatement(factory.createAssignment(currentState.conditionVariable, factory.createTrue()))));
                }
                else {
                    statements.push(factory.createIfStatement(factory.createLogicalNot(currentState.conditionVariable), factory.createExpressionStatement(factory.createAssignment(currentState.conditionVariable, factory.createTrue()))));
                }
                if (shouldConvertConditionOfForStatement(node)) {
                    statements.push(factory.createIfStatement(factory.createPrefixUnaryExpression(53, ts.visitNode(node.condition, visitor, ts.isExpression)), ts.visitNode(factory.createBreakStatement(), visitor, ts.isStatement)));
                }
            }
            if (ts.isBlock(statement)) {
                ts.addRange(statements, statement.statements);
            }
            else {
                statements.push(statement);
            }
            copyOutParameters(currentState.loopOutParameters, 1, 1, statements);
            ts.insertStatementsAfterStandardPrologue(statements, lexicalEnvironment);
            var loopBody = factory.createBlock(statements, true);
            if (ts.isBlock(statement))
                ts.setOriginalNode(loopBody, statement);
            var containsYield = (node.statement.transformFlags & 524288) !== 0;
            var emitFlags = 524288;
            if (currentState.containsLexicalThis)
                emitFlags |= 8;
            if (containsYield && (hierarchyFacts & 4) !== 0)
                emitFlags |= 262144;
            var functionDeclaration = factory.createVariableStatement(undefined, ts.setEmitFlags(factory.createVariableDeclarationList([
                factory.createVariableDeclaration(functionName, undefined, undefined, ts.setEmitFlags(factory.createFunctionExpression(undefined, containsYield ? factory.createToken(41) : undefined, undefined, undefined, currentState.loopParameters, undefined, loopBody), emitFlags))
            ]), 2097152));
            var part = generateCallToConvertedLoop(functionName, currentState, outerState, containsYield);
            return { functionName: functionName, containsYield: containsYield, functionDeclaration: functionDeclaration, part: part };
        }
        function copyOutParameter(outParam, copyDirection) {
            var source = copyDirection === 0 ? outParam.outParamName : outParam.originalName;
            var target = copyDirection === 0 ? outParam.originalName : outParam.outParamName;
            return factory.createBinaryExpression(target, 63, source);
        }
        function copyOutParameters(outParams, partFlags, copyDirection, statements) {
            for (var _i = 0, outParams_1 = outParams; _i < outParams_1.length; _i++) {
                var outParam = outParams_1[_i];
                if (outParam.flags & partFlags) {
                    statements.push(factory.createExpressionStatement(copyOutParameter(outParam, copyDirection)));
                }
            }
        }
        function generateCallToConvertedLoopInitializer(initFunctionExpressionName, containsYield) {
            var call = factory.createCallExpression(initFunctionExpressionName, undefined, []);
            var callResult = containsYield
                ? factory.createYieldExpression(factory.createToken(41), ts.setEmitFlags(call, 8388608))
                : call;
            return factory.createExpressionStatement(callResult);
        }
        function generateCallToConvertedLoop(loopFunctionExpressionName, state, outerState, containsYield) {
            var statements = [];
            var isSimpleLoop = !(state.nonLocalJumps & ~4) &&
                !state.labeledNonLocalBreaks &&
                !state.labeledNonLocalContinues;
            var call = factory.createCallExpression(loopFunctionExpressionName, undefined, ts.map(state.loopParameters, function (p) { return p.name; }));
            var callResult = containsYield
                ? factory.createYieldExpression(factory.createToken(41), ts.setEmitFlags(call, 8388608))
                : call;
            if (isSimpleLoop) {
                statements.push(factory.createExpressionStatement(callResult));
                copyOutParameters(state.loopOutParameters, 1, 0, statements);
            }
            else {
                var loopResultName = factory.createUniqueName("state");
                var stateVariable = factory.createVariableStatement(undefined, factory.createVariableDeclarationList([factory.createVariableDeclaration(loopResultName, undefined, undefined, callResult)]));
                statements.push(stateVariable);
                copyOutParameters(state.loopOutParameters, 1, 0, statements);
                if (state.nonLocalJumps & 8) {
                    var returnStatement = void 0;
                    if (outerState) {
                        outerState.nonLocalJumps |= 8;
                        returnStatement = factory.createReturnStatement(loopResultName);
                    }
                    else {
                        returnStatement = factory.createReturnStatement(factory.createPropertyAccessExpression(loopResultName, "value"));
                    }
                    statements.push(factory.createIfStatement(factory.createTypeCheck(loopResultName, "object"), returnStatement));
                }
                if (state.nonLocalJumps & 2) {
                    statements.push(factory.createIfStatement(factory.createStrictEquality(loopResultName, factory.createStringLiteral("break")), factory.createBreakStatement()));
                }
                if (state.labeledNonLocalBreaks || state.labeledNonLocalContinues) {
                    var caseClauses = [];
                    processLabeledJumps(state.labeledNonLocalBreaks, true, loopResultName, outerState, caseClauses);
                    processLabeledJumps(state.labeledNonLocalContinues, false, loopResultName, outerState, caseClauses);
                    statements.push(factory.createSwitchStatement(loopResultName, factory.createCaseBlock(caseClauses)));
                }
            }
            return statements;
        }
        function setLabeledJump(state, isBreak, labelText, labelMarker) {
            if (isBreak) {
                if (!state.labeledNonLocalBreaks) {
                    state.labeledNonLocalBreaks = new ts.Map();
                }
                state.labeledNonLocalBreaks.set(labelText, labelMarker);
            }
            else {
                if (!state.labeledNonLocalContinues) {
                    state.labeledNonLocalContinues = new ts.Map();
                }
                state.labeledNonLocalContinues.set(labelText, labelMarker);
            }
        }
        function processLabeledJumps(table, isBreak, loopResultName, outerLoop, caseClauses) {
            if (!table) {
                return;
            }
            table.forEach(function (labelMarker, labelText) {
                var statements = [];
                if (!outerLoop || (outerLoop.labels && outerLoop.labels.get(labelText))) {
                    var label = factory.createIdentifier(labelText);
                    statements.push(isBreak ? factory.createBreakStatement(label) : factory.createContinueStatement(label));
                }
                else {
                    setLabeledJump(outerLoop, isBreak, labelText, labelMarker);
                    statements.push(factory.createReturnStatement(loopResultName));
                }
                caseClauses.push(factory.createCaseClause(factory.createStringLiteral(labelMarker), statements));
            });
        }
        function processLoopVariableDeclaration(container, decl, loopParameters, loopOutParameters, hasCapturedBindingsInForInitializer) {
            var name = decl.name;
            if (ts.isBindingPattern(name)) {
                for (var _i = 0, _a = name.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (!ts.isOmittedExpression(element)) {
                        processLoopVariableDeclaration(container, element, loopParameters, loopOutParameters, hasCapturedBindingsInForInitializer);
                    }
                }
            }
            else {
                loopParameters.push(factory.createParameterDeclaration(undefined, undefined, undefined, name));
                var checkFlags = resolver.getNodeCheckFlags(decl);
                if (checkFlags & 4194304 || hasCapturedBindingsInForInitializer) {
                    var outParamName = factory.createUniqueName("out_" + ts.idText(name));
                    var flags = 0;
                    if (checkFlags & 4194304) {
                        flags |= 1;
                    }
                    if (ts.isForStatement(container) && container.initializer && resolver.isBindingCapturedByNode(container.initializer, decl)) {
                        flags |= 2;
                    }
                    loopOutParameters.push({ flags: flags, originalName: name, outParamName: outParamName });
                }
            }
        }
        function addObjectLiteralMembers(expressions, node, receiver, start) {
            var properties = node.properties;
            var numProperties = properties.length;
            for (var i = start; i < numProperties; i++) {
                var property = properties[i];
                switch (property.kind) {
                    case 170:
                    case 171:
                        var accessors = ts.getAllAccessorDeclarations(node.properties, property);
                        if (property === accessors.firstAccessor) {
                            expressions.push(transformAccessorsToExpression(receiver, accessors, node, !!node.multiLine));
                        }
                        break;
                    case 167:
                        expressions.push(transformObjectLiteralMethodDeclarationToExpression(property, receiver, node, node.multiLine));
                        break;
                    case 291:
                        expressions.push(transformPropertyAssignmentToExpression(property, receiver, node.multiLine));
                        break;
                    case 292:
                        expressions.push(transformShorthandPropertyAssignmentToExpression(property, receiver, node.multiLine));
                        break;
                    default:
                        ts.Debug.failBadSyntaxKind(node);
                        break;
                }
            }
        }
        function transformPropertyAssignmentToExpression(property, receiver, startsOnNewLine) {
            var expression = factory.createAssignment(ts.createMemberAccessForPropertyName(factory, receiver, ts.visitNode(property.name, visitor, ts.isPropertyName)), ts.visitNode(property.initializer, visitor, ts.isExpression));
            ts.setTextRange(expression, property);
            if (startsOnNewLine) {
                ts.startOnNewLine(expression);
            }
            return expression;
        }
        function transformShorthandPropertyAssignmentToExpression(property, receiver, startsOnNewLine) {
            var expression = factory.createAssignment(ts.createMemberAccessForPropertyName(factory, receiver, ts.visitNode(property.name, visitor, ts.isPropertyName)), factory.cloneNode(property.name));
            ts.setTextRange(expression, property);
            if (startsOnNewLine) {
                ts.startOnNewLine(expression);
            }
            return expression;
        }
        function transformObjectLiteralMethodDeclarationToExpression(method, receiver, container, startsOnNewLine) {
            var expression = factory.createAssignment(ts.createMemberAccessForPropertyName(factory, receiver, ts.visitNode(method.name, visitor, ts.isPropertyName)), transformFunctionLikeToExpression(method, method, undefined, container));
            ts.setTextRange(expression, method);
            if (startsOnNewLine) {
                ts.startOnNewLine(expression);
            }
            return expression;
        }
        function visitCatchClause(node) {
            var ancestorFacts = enterSubtree(7104, 0);
            var updated;
            ts.Debug.assert(!!node.variableDeclaration, "Catch clause variable should always be present when downleveling ES2015.");
            if (ts.isBindingPattern(node.variableDeclaration.name)) {
                var temp = factory.createTempVariable(undefined);
                var newVariableDeclaration = factory.createVariableDeclaration(temp);
                ts.setTextRange(newVariableDeclaration, node.variableDeclaration);
                var vars = ts.flattenDestructuringBinding(node.variableDeclaration, visitor, context, 0, temp);
                var list = factory.createVariableDeclarationList(vars);
                ts.setTextRange(list, node.variableDeclaration);
                var destructure = factory.createVariableStatement(undefined, list);
                updated = factory.updateCatchClause(node, newVariableDeclaration, addStatementToStartOfBlock(node.block, destructure));
            }
            else {
                updated = ts.visitEachChild(node, visitor, context);
            }
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function addStatementToStartOfBlock(block, statement) {
            var transformedStatements = ts.visitNodes(block.statements, visitor, ts.isStatement);
            return factory.updateBlock(block, __spreadArray([statement], transformedStatements, true));
        }
        function visitMethodDeclaration(node) {
            ts.Debug.assert(!ts.isComputedPropertyName(node.name));
            var functionExpression = transformFunctionLikeToExpression(node, ts.moveRangePos(node, -1), undefined, undefined);
            ts.setEmitFlags(functionExpression, 512 | ts.getEmitFlags(functionExpression));
            return ts.setTextRange(factory.createPropertyAssignment(node.name, functionExpression), node);
        }
        function visitAccessorDeclaration(node) {
            ts.Debug.assert(!ts.isComputedPropertyName(node.name));
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = enterSubtree(32670, 65);
            var updated;
            var parameters = ts.visitParameterList(node.parameters, visitor, context);
            var body = transformFunctionBody(node);
            if (node.kind === 170) {
                updated = factory.updateGetAccessorDeclaration(node, node.decorators, node.modifiers, node.name, parameters, node.type, body);
            }
            else {
                updated = factory.updateSetAccessorDeclaration(node, node.decorators, node.modifiers, node.name, parameters, body);
            }
            exitSubtree(ancestorFacts, 98304, 0);
            convertedLoopState = savedConvertedLoopState;
            return updated;
        }
        function visitShorthandPropertyAssignment(node) {
            return ts.setTextRange(factory.createPropertyAssignment(node.name, visitIdentifier(factory.cloneNode(node.name))), node);
        }
        function visitComputedPropertyName(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        function visitYieldExpression(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        function visitArrayLiteralExpression(node) {
            if (ts.some(node.elements, ts.isSpreadElement)) {
                return transformAndSpreadElements(node.elements, false, !!node.multiLine, !!node.elements.hasTrailingComma);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCallExpression(node) {
            if (ts.getEmitFlags(node) & 33554432) {
                return visitTypeScriptClassWrapper(node);
            }
            var expression = ts.skipOuterExpressions(node.expression);
            if (expression.kind === 106 ||
                ts.isSuperProperty(expression) ||
                ts.some(node.arguments, ts.isSpreadElement)) {
                return visitCallExpressionWithPotentialCapturedThisAssignment(node, true);
            }
            return factory.updateCallExpression(node, ts.visitNode(node.expression, callExpressionVisitor, ts.isExpression), undefined, ts.visitNodes(node.arguments, visitor, ts.isExpression));
        }
        function visitTypeScriptClassWrapper(node) {
            var body = ts.cast(ts.cast(ts.skipOuterExpressions(node.expression), ts.isArrowFunction).body, ts.isBlock);
            var isVariableStatementWithInitializer = function (stmt) { return ts.isVariableStatement(stmt) && !!ts.first(stmt.declarationList.declarations).initializer; };
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var bodyStatements = ts.visitNodes(body.statements, classWrapperStatementVisitor, ts.isStatement);
            convertedLoopState = savedConvertedLoopState;
            var classStatements = ts.filter(bodyStatements, isVariableStatementWithInitializer);
            var remainingStatements = ts.filter(bodyStatements, function (stmt) { return !isVariableStatementWithInitializer(stmt); });
            var varStatement = ts.cast(ts.first(classStatements), ts.isVariableStatement);
            var variable = varStatement.declarationList.declarations[0];
            var initializer = ts.skipOuterExpressions(variable.initializer);
            var aliasAssignment = ts.tryCast(initializer, ts.isAssignmentExpression);
            if (!aliasAssignment && ts.isBinaryExpression(initializer) && initializer.operatorToken.kind === 27) {
                aliasAssignment = ts.tryCast(initializer.left, ts.isAssignmentExpression);
            }
            var call = ts.cast(aliasAssignment ? ts.skipOuterExpressions(aliasAssignment.right) : initializer, ts.isCallExpression);
            var func = ts.cast(ts.skipOuterExpressions(call.expression), ts.isFunctionExpression);
            var funcStatements = func.body.statements;
            var classBodyStart = 0;
            var classBodyEnd = -1;
            var statements = [];
            if (aliasAssignment) {
                var extendsCall = ts.tryCast(funcStatements[classBodyStart], ts.isExpressionStatement);
                if (extendsCall) {
                    statements.push(extendsCall);
                    classBodyStart++;
                }
                statements.push(funcStatements[classBodyStart]);
                classBodyStart++;
                statements.push(factory.createExpressionStatement(factory.createAssignment(aliasAssignment.left, ts.cast(variable.name, ts.isIdentifier))));
            }
            while (!ts.isReturnStatement(ts.elementAt(funcStatements, classBodyEnd))) {
                classBodyEnd--;
            }
            ts.addRange(statements, funcStatements, classBodyStart, classBodyEnd);
            if (classBodyEnd < -1) {
                ts.addRange(statements, funcStatements, classBodyEnd + 1);
            }
            ts.addRange(statements, remainingStatements);
            ts.addRange(statements, classStatements, 1);
            return factory.restoreOuterExpressions(node.expression, factory.restoreOuterExpressions(variable.initializer, factory.restoreOuterExpressions(aliasAssignment && aliasAssignment.right, factory.updateCallExpression(call, factory.restoreOuterExpressions(call.expression, factory.updateFunctionExpression(func, undefined, undefined, undefined, undefined, func.parameters, undefined, factory.updateBlock(func.body, statements))), undefined, call.arguments))));
        }
        function visitImmediateSuperCallInBody(node) {
            return visitCallExpressionWithPotentialCapturedThisAssignment(node, false);
        }
        function visitCallExpressionWithPotentialCapturedThisAssignment(node, assignToCapturedThis) {
            if (node.transformFlags & 16384 ||
                node.expression.kind === 106 ||
                ts.isSuperProperty(ts.skipOuterExpressions(node.expression))) {
                var _a = factory.createCallBinding(node.expression, hoistVariableDeclaration), target = _a.target, thisArg = _a.thisArg;
                if (node.expression.kind === 106) {
                    ts.setEmitFlags(thisArg, 4);
                }
                var resultingCall = void 0;
                if (node.transformFlags & 16384) {
                    resultingCall = factory.createFunctionApplyCall(ts.visitNode(target, callExpressionVisitor, ts.isExpression), node.expression.kind === 106 ? thisArg : ts.visitNode(thisArg, visitor, ts.isExpression), transformAndSpreadElements(node.arguments, true, false, false));
                }
                else {
                    resultingCall = ts.setTextRange(factory.createFunctionCallCall(ts.visitNode(target, callExpressionVisitor, ts.isExpression), node.expression.kind === 106 ? thisArg : ts.visitNode(thisArg, visitor, ts.isExpression), ts.visitNodes(node.arguments, visitor, ts.isExpression)), node);
                }
                if (node.expression.kind === 106) {
                    var initializer = factory.createLogicalOr(resultingCall, createActualThis());
                    resultingCall = assignToCapturedThis
                        ? factory.createAssignment(factory.createUniqueName("_this", 16 | 32), initializer)
                        : initializer;
                }
                return ts.setOriginalNode(resultingCall, node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitNewExpression(node) {
            if (ts.some(node.arguments, ts.isSpreadElement)) {
                var _a = factory.createCallBinding(factory.createPropertyAccessExpression(node.expression, "bind"), hoistVariableDeclaration), target = _a.target, thisArg = _a.thisArg;
                return factory.createNewExpression(factory.createFunctionApplyCall(ts.visitNode(target, visitor, ts.isExpression), thisArg, transformAndSpreadElements(factory.createNodeArray(__spreadArray([factory.createVoidZero()], node.arguments, true)), true, false, false)), undefined, []);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformAndSpreadElements(elements, isArgumentList, multiLine, hasTrailingComma) {
            var numElements = elements.length;
            var segments = ts.flatten(ts.spanMap(elements, partitionSpread, function (partition, visitPartition, _start, end) {
                return visitPartition(partition, multiLine, hasTrailingComma && end === numElements);
            }));
            if (segments.length === 1) {
                var firstSegment = segments[0];
                if (isArgumentList && !compilerOptions.downlevelIteration
                    || ts.isPackedArrayLiteral(firstSegment.expression)
                    || ts.isCallToHelper(firstSegment.expression, "___spreadArray")) {
                    return firstSegment.expression;
                }
            }
            var helpers = emitHelpers();
            var startsWithSpread = segments[0].kind !== 0;
            var expression = startsWithSpread ? factory.createArrayLiteralExpression() :
                segments[0].expression;
            for (var i = startsWithSpread ? 0 : 1; i < segments.length; i++) {
                var segment = segments[i];
                expression = helpers.createSpreadArrayHelper(expression, segment.expression, segment.kind === 1 && !isArgumentList);
            }
            return expression;
        }
        function partitionSpread(node) {
            return ts.isSpreadElement(node)
                ? visitSpanOfSpreads
                : visitSpanOfNonSpreads;
        }
        function visitSpanOfSpreads(chunk) {
            return ts.map(chunk, visitExpressionOfSpread);
        }
        function visitExpressionOfSpread(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var isCallToReadHelper = ts.isCallToHelper(expression, "___read");
            var kind = isCallToReadHelper || ts.isPackedArrayLiteral(expression) ? 2 : 1;
            if (compilerOptions.downlevelIteration && kind === 1 && !ts.isArrayLiteralExpression(expression) && !isCallToReadHelper) {
                expression = emitHelpers().createReadHelper(expression, undefined);
                kind = 2;
            }
            return createSpreadSegment(kind, expression);
        }
        function visitSpanOfNonSpreads(chunk, multiLine, hasTrailingComma) {
            var expression = factory.createArrayLiteralExpression(ts.visitNodes(factory.createNodeArray(chunk, hasTrailingComma), visitor, ts.isExpression), multiLine);
            return createSpreadSegment(0, expression);
        }
        function visitSpreadElement(node) {
            return ts.visitNode(node.expression, visitor, ts.isExpression);
        }
        function visitTemplateLiteral(node) {
            return ts.setTextRange(factory.createStringLiteral(node.text), node);
        }
        function visitStringLiteral(node) {
            if (node.hasExtendedUnicodeEscape) {
                return ts.setTextRange(factory.createStringLiteral(node.text), node);
            }
            return node;
        }
        function visitNumericLiteral(node) {
            if (node.numericLiteralFlags & 384) {
                return ts.setTextRange(factory.createNumericLiteral(node.text), node);
            }
            return node;
        }
        function visitTaggedTemplateExpression(node) {
            return ts.processTaggedTemplateExpression(context, node, visitor, currentSourceFile, recordTaggedTemplateString, ts.ProcessLevel.All);
        }
        function visitTemplateExpression(node) {
            var expressions = [];
            addTemplateHead(expressions, node);
            addTemplateSpans(expressions, node);
            var expression = ts.reduceLeft(expressions, factory.createAdd);
            if (ts.nodeIsSynthesized(expression)) {
                ts.setTextRange(expression, node);
            }
            return expression;
        }
        function shouldAddTemplateHead(node) {
            ts.Debug.assert(node.templateSpans.length !== 0);
            return node.head.text.length !== 0 || node.templateSpans[0].literal.text.length === 0;
        }
        function addTemplateHead(expressions, node) {
            if (!shouldAddTemplateHead(node)) {
                return;
            }
            expressions.push(factory.createStringLiteral(node.head.text));
        }
        function addTemplateSpans(expressions, node) {
            for (var _i = 0, _a = node.templateSpans; _i < _a.length; _i++) {
                var span = _a[_i];
                expressions.push(ts.visitNode(span.expression, visitor, ts.isExpression));
                if (span.literal.text.length !== 0) {
                    expressions.push(factory.createStringLiteral(span.literal.text));
                }
            }
        }
        function visitSuperKeyword(isExpressionOfCall) {
            return hierarchyFacts & 8
                && !isExpressionOfCall
                ? factory.createPropertyAccessExpression(factory.createUniqueName("_super", 16 | 32), "prototype")
                : factory.createUniqueName("_super", 16 | 32);
        }
        function visitMetaProperty(node) {
            if (node.keywordToken === 103 && node.name.escapedText === "target") {
                hierarchyFacts |= 32768;
                return factory.createUniqueName("_newTarget", 16 | 32);
            }
            return node;
        }
        function onEmitNode(hint, node, emitCallback) {
            if (enabledSubstitutions & 1 && ts.isFunctionLike(node)) {
                var ancestorFacts = enterSubtree(32670, ts.getEmitFlags(node) & 8
                    ? 65 | 16
                    : 65);
                previousOnEmitNode(hint, node, emitCallback);
                exitSubtree(ancestorFacts, 0, 0);
                return;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        function enableSubstitutionsForBlockScopedBindings() {
            if ((enabledSubstitutions & 2) === 0) {
                enabledSubstitutions |= 2;
                context.enableSubstitution(79);
            }
        }
        function enableSubstitutionsForCapturedThis() {
            if ((enabledSubstitutions & 1) === 0) {
                enabledSubstitutions |= 1;
                context.enableSubstitution(108);
                context.enableEmitNotification(169);
                context.enableEmitNotification(167);
                context.enableEmitNotification(170);
                context.enableEmitNotification(171);
                context.enableEmitNotification(212);
                context.enableEmitNotification(211);
                context.enableEmitNotification(254);
            }
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1) {
                return substituteExpression(node);
            }
            if (ts.isIdentifier(node)) {
                return substituteIdentifier(node);
            }
            return node;
        }
        function substituteIdentifier(node) {
            if (enabledSubstitutions & 2 && !ts.isInternalName(node)) {
                var original = ts.getParseTreeNode(node, ts.isIdentifier);
                if (original && isNameOfDeclarationWithCollidingName(original)) {
                    return ts.setTextRange(factory.getGeneratedNameForNode(original), node);
                }
            }
            return node;
        }
        function isNameOfDeclarationWithCollidingName(node) {
            switch (node.parent.kind) {
                case 201:
                case 255:
                case 258:
                case 252:
                    return node.parent.name === node
                        && resolver.isDeclarationWithCollidingName(node.parent);
            }
            return false;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79:
                    return substituteExpressionIdentifier(node);
                case 108:
                    return substituteThisKeyword(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            if (enabledSubstitutions & 2 && !ts.isInternalName(node)) {
                var declaration = resolver.getReferencedDeclarationWithCollidingName(node);
                if (declaration && !(ts.isClassLike(declaration) && isPartOfClassBody(declaration, node))) {
                    return ts.setTextRange(factory.getGeneratedNameForNode(ts.getNameOfDeclaration(declaration)), node);
                }
            }
            return node;
        }
        function isPartOfClassBody(declaration, node) {
            var currentNode = ts.getParseTreeNode(node);
            if (!currentNode || currentNode === declaration || currentNode.end <= declaration.pos || currentNode.pos >= declaration.end) {
                return false;
            }
            var blockScope = ts.getEnclosingBlockScopeContainer(declaration);
            while (currentNode) {
                if (currentNode === blockScope || currentNode === declaration) {
                    return false;
                }
                if (ts.isClassElement(currentNode) && currentNode.parent === declaration) {
                    return true;
                }
                currentNode = currentNode.parent;
            }
            return false;
        }
        function substituteThisKeyword(node) {
            if (enabledSubstitutions & 1
                && hierarchyFacts & 16) {
                return ts.setTextRange(factory.createUniqueName("_this", 16 | 32), node);
            }
            return node;
        }
        function getClassMemberPrefix(node, member) {
            return ts.isStatic(member)
                ? factory.getInternalName(node)
                : factory.createPropertyAccessExpression(factory.getInternalName(node), "prototype");
        }
        function hasSynthesizedDefaultSuperCall(constructor, hasExtendsClause) {
            if (!constructor || !hasExtendsClause) {
                return false;
            }
            if (ts.some(constructor.parameters)) {
                return false;
            }
            var statement = ts.firstOrUndefined(constructor.body.statements);
            if (!statement || !ts.nodeIsSynthesized(statement) || statement.kind !== 236) {
                return false;
            }
            var statementExpression = statement.expression;
            if (!ts.nodeIsSynthesized(statementExpression) || statementExpression.kind !== 206) {
                return false;
            }
            var callTarget = statementExpression.expression;
            if (!ts.nodeIsSynthesized(callTarget) || callTarget.kind !== 106) {
                return false;
            }
            var callArgument = ts.singleOrUndefined(statementExpression.arguments);
            if (!callArgument || !ts.nodeIsSynthesized(callArgument) || callArgument.kind !== 223) {
                return false;
            }
            var expression = callArgument.expression;
            return ts.isIdentifier(expression) && expression.escapedText === "arguments";
        }
    }
    ts.transformES2015 = transformES2015;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformES5(context) {
        var factory = context.factory;
        var compilerOptions = context.getCompilerOptions();
        var previousOnEmitNode;
        var noSubstitution;
        if (compilerOptions.jsx === 1 || compilerOptions.jsx === 3) {
            previousOnEmitNode = context.onEmitNode;
            context.onEmitNode = onEmitNode;
            context.enableEmitNotification(278);
            context.enableEmitNotification(279);
            context.enableEmitNotification(277);
            noSubstitution = [];
        }
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        context.enableSubstitution(204);
        context.enableSubstitution(291);
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            return node;
        }
        function onEmitNode(hint, node, emitCallback) {
            switch (node.kind) {
                case 278:
                case 279:
                case 277:
                    var tagName = node.tagName;
                    noSubstitution[ts.getOriginalNodeId(tagName)] = true;
                    break;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        function onSubstituteNode(hint, node) {
            if (node.id && noSubstitution && noSubstitution[node.id]) {
                return previousOnSubstituteNode(hint, node);
            }
            node = previousOnSubstituteNode(hint, node);
            if (ts.isPropertyAccessExpression(node)) {
                return substitutePropertyAccessExpression(node);
            }
            else if (ts.isPropertyAssignment(node)) {
                return substitutePropertyAssignment(node);
            }
            return node;
        }
        function substitutePropertyAccessExpression(node) {
            if (ts.isPrivateIdentifier(node.name)) {
                return node;
            }
            var literalName = trySubstituteReservedName(node.name);
            if (literalName) {
                return ts.setTextRange(factory.createElementAccessExpression(node.expression, literalName), node);
            }
            return node;
        }
        function substitutePropertyAssignment(node) {
            var literalName = ts.isIdentifier(node.name) && trySubstituteReservedName(node.name);
            if (literalName) {
                return factory.updatePropertyAssignment(node, literalName, node.initializer);
            }
            return node;
        }
        function trySubstituteReservedName(name) {
            var token = name.originalKeywordKind || (ts.nodeIsSynthesized(name) ? ts.stringToToken(ts.idText(name)) : undefined);
            if (token !== undefined && token >= 81 && token <= 116) {
                return ts.setTextRange(factory.createStringLiteralFromNode(name), name);
            }
            return undefined;
        }
    }
    ts.transformES5 = transformES5;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function getInstructionName(instruction) {
        switch (instruction) {
            case 2: return "return";
            case 3: return "break";
            case 4: return "yield";
            case 5: return "yield*";
            case 7: return "endfinally";
            default: return undefined;
        }
    }
    function transformGenerators(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistFunctionDeclaration = context.hoistFunctionDeclaration, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var resolver = context.getEmitResolver();
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var renamedCatchVariables;
        var renamedCatchVariableDeclarations;
        var inGeneratorFunctionBody;
        var inStatementContainingYield;
        var blocks;
        var blockOffsets;
        var blockActions;
        var blockStack;
        var labelOffsets;
        var labelExpressions;
        var nextLabelId = 1;
        var operations;
        var operationArguments;
        var operationLocations;
        var state;
        var blockIndex = 0;
        var labelNumber = 0;
        var labelNumbers;
        var lastOperationWasAbrupt;
        var lastOperationWasCompletion;
        var clauses;
        var statements;
        var exceptionBlockStack;
        var currentExceptionBlock;
        var withBlockStack;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile || (node.transformFlags & 1024) === 0) {
                return node;
            }
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function visitor(node) {
            var transformFlags = node.transformFlags;
            if (inStatementContainingYield) {
                return visitJavaScriptInStatementContainingYield(node);
            }
            else if (inGeneratorFunctionBody) {
                return visitJavaScriptInGeneratorFunctionBody(node);
            }
            else if (ts.isFunctionLikeDeclaration(node) && node.asteriskToken) {
                return visitGenerator(node);
            }
            else if (transformFlags & 1024) {
                return ts.visitEachChild(node, visitor, context);
            }
            else {
                return node;
            }
        }
        function visitJavaScriptInStatementContainingYield(node) {
            switch (node.kind) {
                case 238:
                    return visitDoStatement(node);
                case 239:
                    return visitWhileStatement(node);
                case 247:
                    return visitSwitchStatement(node);
                case 248:
                    return visitLabeledStatement(node);
                default:
                    return visitJavaScriptInGeneratorFunctionBody(node);
            }
        }
        function visitJavaScriptInGeneratorFunctionBody(node) {
            switch (node.kind) {
                case 254:
                    return visitFunctionDeclaration(node);
                case 211:
                    return visitFunctionExpression(node);
                case 170:
                case 171:
                    return visitAccessorDeclaration(node);
                case 235:
                    return visitVariableStatement(node);
                case 240:
                    return visitForStatement(node);
                case 241:
                    return visitForInStatement(node);
                case 244:
                    return visitBreakStatement(node);
                case 243:
                    return visitContinueStatement(node);
                case 245:
                    return visitReturnStatement(node);
                default:
                    if (node.transformFlags & 524288) {
                        return visitJavaScriptContainingYield(node);
                    }
                    else if (node.transformFlags & (1024 | 2097152)) {
                        return ts.visitEachChild(node, visitor, context);
                    }
                    else {
                        return node;
                    }
            }
        }
        function visitJavaScriptContainingYield(node) {
            switch (node.kind) {
                case 219:
                    return visitBinaryExpression(node);
                case 346:
                    return visitCommaListExpression(node);
                case 220:
                    return visitConditionalExpression(node);
                case 222:
                    return visitYieldExpression(node);
                case 202:
                    return visitArrayLiteralExpression(node);
                case 203:
                    return visitObjectLiteralExpression(node);
                case 205:
                    return visitElementAccessExpression(node);
                case 206:
                    return visitCallExpression(node);
                case 207:
                    return visitNewExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitGenerator(node) {
            switch (node.kind) {
                case 254:
                    return visitFunctionDeclaration(node);
                case 211:
                    return visitFunctionExpression(node);
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
        }
        function visitFunctionDeclaration(node) {
            if (node.asteriskToken) {
                node = ts.setOriginalNode(ts.setTextRange(factory.createFunctionDeclaration(undefined, node.modifiers, undefined, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, transformGeneratorFunctionBody(node.body)), node), node);
            }
            else {
                var savedInGeneratorFunctionBody = inGeneratorFunctionBody;
                var savedInStatementContainingYield = inStatementContainingYield;
                inGeneratorFunctionBody = false;
                inStatementContainingYield = false;
                node = ts.visitEachChild(node, visitor, context);
                inGeneratorFunctionBody = savedInGeneratorFunctionBody;
                inStatementContainingYield = savedInStatementContainingYield;
            }
            if (inGeneratorFunctionBody) {
                hoistFunctionDeclaration(node);
                return undefined;
            }
            else {
                return node;
            }
        }
        function visitFunctionExpression(node) {
            if (node.asteriskToken) {
                node = ts.setOriginalNode(ts.setTextRange(factory.createFunctionExpression(undefined, undefined, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, transformGeneratorFunctionBody(node.body)), node), node);
            }
            else {
                var savedInGeneratorFunctionBody = inGeneratorFunctionBody;
                var savedInStatementContainingYield = inStatementContainingYield;
                inGeneratorFunctionBody = false;
                inStatementContainingYield = false;
                node = ts.visitEachChild(node, visitor, context);
                inGeneratorFunctionBody = savedInGeneratorFunctionBody;
                inStatementContainingYield = savedInStatementContainingYield;
            }
            return node;
        }
        function visitAccessorDeclaration(node) {
            var savedInGeneratorFunctionBody = inGeneratorFunctionBody;
            var savedInStatementContainingYield = inStatementContainingYield;
            inGeneratorFunctionBody = false;
            inStatementContainingYield = false;
            node = ts.visitEachChild(node, visitor, context);
            inGeneratorFunctionBody = savedInGeneratorFunctionBody;
            inStatementContainingYield = savedInStatementContainingYield;
            return node;
        }
        function transformGeneratorFunctionBody(body) {
            var statements = [];
            var savedInGeneratorFunctionBody = inGeneratorFunctionBody;
            var savedInStatementContainingYield = inStatementContainingYield;
            var savedBlocks = blocks;
            var savedBlockOffsets = blockOffsets;
            var savedBlockActions = blockActions;
            var savedBlockStack = blockStack;
            var savedLabelOffsets = labelOffsets;
            var savedLabelExpressions = labelExpressions;
            var savedNextLabelId = nextLabelId;
            var savedOperations = operations;
            var savedOperationArguments = operationArguments;
            var savedOperationLocations = operationLocations;
            var savedState = state;
            inGeneratorFunctionBody = true;
            inStatementContainingYield = false;
            blocks = undefined;
            blockOffsets = undefined;
            blockActions = undefined;
            blockStack = undefined;
            labelOffsets = undefined;
            labelExpressions = undefined;
            nextLabelId = 1;
            operations = undefined;
            operationArguments = undefined;
            operationLocations = undefined;
            state = factory.createTempVariable(undefined);
            resumeLexicalEnvironment();
            var statementOffset = factory.copyPrologue(body.statements, statements, false, visitor);
            transformAndEmitStatements(body.statements, statementOffset);
            var buildResult = build();
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            statements.push(factory.createReturnStatement(buildResult));
            inGeneratorFunctionBody = savedInGeneratorFunctionBody;
            inStatementContainingYield = savedInStatementContainingYield;
            blocks = savedBlocks;
            blockOffsets = savedBlockOffsets;
            blockActions = savedBlockActions;
            blockStack = savedBlockStack;
            labelOffsets = savedLabelOffsets;
            labelExpressions = savedLabelExpressions;
            nextLabelId = savedNextLabelId;
            operations = savedOperations;
            operationArguments = savedOperationArguments;
            operationLocations = savedOperationLocations;
            state = savedState;
            return ts.setTextRange(factory.createBlock(statements, body.multiLine), body);
        }
        function visitVariableStatement(node) {
            if (node.transformFlags & 524288) {
                transformAndEmitVariableDeclarationList(node.declarationList);
                return undefined;
            }
            else {
                if (ts.getEmitFlags(node) & 1048576) {
                    return node;
                }
                for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    hoistVariableDeclaration(variable.name);
                }
                var variables = ts.getInitializedVariables(node.declarationList);
                if (variables.length === 0) {
                    return undefined;
                }
                return ts.setSourceMapRange(factory.createExpressionStatement(factory.inlineExpressions(ts.map(variables, transformInitializedVariable))), node);
            }
        }
        function visitBinaryExpression(node) {
            var assoc = ts.getExpressionAssociativity(node);
            switch (assoc) {
                case 0:
                    return visitLeftAssociativeBinaryExpression(node);
                case 1:
                    return visitRightAssociativeBinaryExpression(node);
                default:
                    return ts.Debug.assertNever(assoc);
            }
        }
        function visitRightAssociativeBinaryExpression(node) {
            var left = node.left, right = node.right;
            if (containsYield(right)) {
                var target = void 0;
                switch (left.kind) {
                    case 204:
                        target = factory.updatePropertyAccessExpression(left, cacheExpression(ts.visitNode(left.expression, visitor, ts.isLeftHandSideExpression)), left.name);
                        break;
                    case 205:
                        target = factory.updateElementAccessExpression(left, cacheExpression(ts.visitNode(left.expression, visitor, ts.isLeftHandSideExpression)), cacheExpression(ts.visitNode(left.argumentExpression, visitor, ts.isExpression)));
                        break;
                    default:
                        target = ts.visitNode(left, visitor, ts.isExpression);
                        break;
                }
                var operator = node.operatorToken.kind;
                if (ts.isCompoundAssignment(operator)) {
                    return ts.setTextRange(factory.createAssignment(target, ts.setTextRange(factory.createBinaryExpression(cacheExpression(target), ts.getNonAssignmentOperatorForCompoundAssignment(operator), ts.visitNode(right, visitor, ts.isExpression)), node)), node);
                }
                else {
                    return factory.updateBinaryExpression(node, target, node.operatorToken, ts.visitNode(right, visitor, ts.isExpression));
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitLeftAssociativeBinaryExpression(node) {
            if (containsYield(node.right)) {
                if (ts.isLogicalOperator(node.operatorToken.kind)) {
                    return visitLogicalBinaryExpression(node);
                }
                else if (node.operatorToken.kind === 27) {
                    return visitCommaExpression(node);
                }
                return factory.updateBinaryExpression(node, cacheExpression(ts.visitNode(node.left, visitor, ts.isExpression)), node.operatorToken, ts.visitNode(node.right, visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCommaExpression(node) {
            var pendingExpressions = [];
            visit(node.left);
            visit(node.right);
            return factory.inlineExpressions(pendingExpressions);
            function visit(node) {
                if (ts.isBinaryExpression(node) && node.operatorToken.kind === 27) {
                    visit(node.left);
                    visit(node.right);
                }
                else {
                    if (containsYield(node) && pendingExpressions.length > 0) {
                        emitWorker(1, [factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions))]);
                        pendingExpressions = [];
                    }
                    pendingExpressions.push(ts.visitNode(node, visitor, ts.isExpression));
                }
            }
        }
        function visitCommaListExpression(node) {
            var pendingExpressions = [];
            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                var elem = _a[_i];
                if (ts.isBinaryExpression(elem) && elem.operatorToken.kind === 27) {
                    pendingExpressions.push(visitCommaExpression(elem));
                }
                else {
                    if (containsYield(elem) && pendingExpressions.length > 0) {
                        emitWorker(1, [factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions))]);
                        pendingExpressions = [];
                    }
                    pendingExpressions.push(ts.visitNode(elem, visitor, ts.isExpression));
                }
            }
            return factory.inlineExpressions(pendingExpressions);
        }
        function visitLogicalBinaryExpression(node) {
            var resultLabel = defineLabel();
            var resultLocal = declareLocal();
            emitAssignment(resultLocal, ts.visitNode(node.left, visitor, ts.isExpression), node.left);
            if (node.operatorToken.kind === 55) {
                emitBreakWhenFalse(resultLabel, resultLocal, node.left);
            }
            else {
                emitBreakWhenTrue(resultLabel, resultLocal, node.left);
            }
            emitAssignment(resultLocal, ts.visitNode(node.right, visitor, ts.isExpression), node.right);
            markLabel(resultLabel);
            return resultLocal;
        }
        function visitConditionalExpression(node) {
            if (containsYield(node.whenTrue) || containsYield(node.whenFalse)) {
                var whenFalseLabel = defineLabel();
                var resultLabel = defineLabel();
                var resultLocal = declareLocal();
                emitBreakWhenFalse(whenFalseLabel, ts.visitNode(node.condition, visitor, ts.isExpression), node.condition);
                emitAssignment(resultLocal, ts.visitNode(node.whenTrue, visitor, ts.isExpression), node.whenTrue);
                emitBreak(resultLabel);
                markLabel(whenFalseLabel);
                emitAssignment(resultLocal, ts.visitNode(node.whenFalse, visitor, ts.isExpression), node.whenFalse);
                markLabel(resultLabel);
                return resultLocal;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitYieldExpression(node) {
            var resumeLabel = defineLabel();
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            if (node.asteriskToken) {
                var iterator = (ts.getEmitFlags(node.expression) & 8388608) === 0
                    ? ts.setTextRange(emitHelpers().createValuesHelper(expression), node)
                    : expression;
                emitYieldStar(iterator, node);
            }
            else {
                emitYield(expression, node);
            }
            markLabel(resumeLabel);
            return createGeneratorResume(node);
        }
        function visitArrayLiteralExpression(node) {
            return visitElements(node.elements, undefined, undefined, node.multiLine);
        }
        function visitElements(elements, leadingElement, location, multiLine) {
            var numInitialElements = countInitialNodesWithoutYield(elements);
            var temp;
            if (numInitialElements > 0) {
                temp = declareLocal();
                var initialElements = ts.visitNodes(elements, visitor, ts.isExpression, 0, numInitialElements);
                emitAssignment(temp, factory.createArrayLiteralExpression(leadingElement
                    ? __spreadArray([leadingElement], initialElements, true) : initialElements));
                leadingElement = undefined;
            }
            var expressions = ts.reduceLeft(elements, reduceElement, [], numInitialElements);
            return temp
                ? factory.createArrayConcatCall(temp, [factory.createArrayLiteralExpression(expressions, multiLine)])
                : ts.setTextRange(factory.createArrayLiteralExpression(leadingElement ? __spreadArray([leadingElement], expressions, true) : expressions, multiLine), location);
            function reduceElement(expressions, element) {
                if (containsYield(element) && expressions.length > 0) {
                    var hasAssignedTemp = temp !== undefined;
                    if (!temp) {
                        temp = declareLocal();
                    }
                    emitAssignment(temp, hasAssignedTemp
                        ? factory.createArrayConcatCall(temp, [factory.createArrayLiteralExpression(expressions, multiLine)])
                        : factory.createArrayLiteralExpression(leadingElement ? __spreadArray([leadingElement], expressions, true) : expressions, multiLine));
                    leadingElement = undefined;
                    expressions = [];
                }
                expressions.push(ts.visitNode(element, visitor, ts.isExpression));
                return expressions;
            }
        }
        function visitObjectLiteralExpression(node) {
            var properties = node.properties;
            var multiLine = node.multiLine;
            var numInitialProperties = countInitialNodesWithoutYield(properties);
            var temp = declareLocal();
            emitAssignment(temp, factory.createObjectLiteralExpression(ts.visitNodes(properties, visitor, ts.isObjectLiteralElementLike, 0, numInitialProperties), multiLine));
            var expressions = ts.reduceLeft(properties, reduceProperty, [], numInitialProperties);
            expressions.push(multiLine ? ts.startOnNewLine(ts.setParent(ts.setTextRange(factory.cloneNode(temp), temp), temp.parent)) : temp);
            return factory.inlineExpressions(expressions);
            function reduceProperty(expressions, property) {
                if (containsYield(property) && expressions.length > 0) {
                    emitStatement(factory.createExpressionStatement(factory.inlineExpressions(expressions)));
                    expressions = [];
                }
                var expression = ts.createExpressionForObjectLiteralElementLike(factory, node, property, temp);
                var visited = ts.visitNode(expression, visitor, ts.isExpression);
                if (visited) {
                    if (multiLine) {
                        ts.startOnNewLine(visited);
                    }
                    expressions.push(visited);
                }
                return expressions;
            }
        }
        function visitElementAccessExpression(node) {
            if (containsYield(node.argumentExpression)) {
                return factory.updateElementAccessExpression(node, cacheExpression(ts.visitNode(node.expression, visitor, ts.isLeftHandSideExpression)), ts.visitNode(node.argumentExpression, visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCallExpression(node) {
            if (!ts.isImportCall(node) && ts.forEach(node.arguments, containsYield)) {
                var _a = factory.createCallBinding(node.expression, hoistVariableDeclaration, languageVersion, true), target = _a.target, thisArg = _a.thisArg;
                return ts.setOriginalNode(ts.setTextRange(factory.createFunctionApplyCall(cacheExpression(ts.visitNode(target, visitor, ts.isLeftHandSideExpression)), thisArg, visitElements(node.arguments)), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitNewExpression(node) {
            if (ts.forEach(node.arguments, containsYield)) {
                var _a = factory.createCallBinding(factory.createPropertyAccessExpression(node.expression, "bind"), hoistVariableDeclaration), target = _a.target, thisArg = _a.thisArg;
                return ts.setOriginalNode(ts.setTextRange(factory.createNewExpression(factory.createFunctionApplyCall(cacheExpression(ts.visitNode(target, visitor, ts.isExpression)), thisArg, visitElements(node.arguments, factory.createVoidZero())), undefined, []), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformAndEmitStatements(statements, start) {
            if (start === void 0) { start = 0; }
            var numStatements = statements.length;
            for (var i = start; i < numStatements; i++) {
                transformAndEmitStatement(statements[i]);
            }
        }
        function transformAndEmitEmbeddedStatement(node) {
            if (ts.isBlock(node)) {
                transformAndEmitStatements(node.statements);
            }
            else {
                transformAndEmitStatement(node);
            }
        }
        function transformAndEmitStatement(node) {
            var savedInStatementContainingYield = inStatementContainingYield;
            if (!inStatementContainingYield) {
                inStatementContainingYield = containsYield(node);
            }
            transformAndEmitStatementWorker(node);
            inStatementContainingYield = savedInStatementContainingYield;
        }
        function transformAndEmitStatementWorker(node) {
            switch (node.kind) {
                case 233:
                    return transformAndEmitBlock(node);
                case 236:
                    return transformAndEmitExpressionStatement(node);
                case 237:
                    return transformAndEmitIfStatement(node);
                case 238:
                    return transformAndEmitDoStatement(node);
                case 239:
                    return transformAndEmitWhileStatement(node);
                case 240:
                    return transformAndEmitForStatement(node);
                case 241:
                    return transformAndEmitForInStatement(node);
                case 243:
                    return transformAndEmitContinueStatement(node);
                case 244:
                    return transformAndEmitBreakStatement(node);
                case 245:
                    return transformAndEmitReturnStatement(node);
                case 246:
                    return transformAndEmitWithStatement(node);
                case 247:
                    return transformAndEmitSwitchStatement(node);
                case 248:
                    return transformAndEmitLabeledStatement(node);
                case 249:
                    return transformAndEmitThrowStatement(node);
                case 250:
                    return transformAndEmitTryStatement(node);
                default:
                    return emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function transformAndEmitBlock(node) {
            if (containsYield(node)) {
                transformAndEmitStatements(node.statements);
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function transformAndEmitExpressionStatement(node) {
            emitStatement(ts.visitNode(node, visitor, ts.isStatement));
        }
        function transformAndEmitVariableDeclarationList(node) {
            for (var _i = 0, _a = node.declarations; _i < _a.length; _i++) {
                var variable = _a[_i];
                var name = factory.cloneNode(variable.name);
                ts.setCommentRange(name, variable.name);
                hoistVariableDeclaration(name);
            }
            var variables = ts.getInitializedVariables(node);
            var numVariables = variables.length;
            var variablesWritten = 0;
            var pendingExpressions = [];
            while (variablesWritten < numVariables) {
                for (var i = variablesWritten; i < numVariables; i++) {
                    var variable = variables[i];
                    if (containsYield(variable.initializer) && pendingExpressions.length > 0) {
                        break;
                    }
                    pendingExpressions.push(transformInitializedVariable(variable));
                }
                if (pendingExpressions.length) {
                    emitStatement(factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions)));
                    variablesWritten += pendingExpressions.length;
                    pendingExpressions = [];
                }
            }
            return undefined;
        }
        function transformInitializedVariable(node) {
            return ts.setSourceMapRange(factory.createAssignment(ts.setSourceMapRange(factory.cloneNode(node.name), node.name), ts.visitNode(node.initializer, visitor, ts.isExpression)), node);
        }
        function transformAndEmitIfStatement(node) {
            if (containsYield(node)) {
                if (containsYield(node.thenStatement) || containsYield(node.elseStatement)) {
                    var endLabel = defineLabel();
                    var elseLabel = node.elseStatement ? defineLabel() : undefined;
                    emitBreakWhenFalse(node.elseStatement ? elseLabel : endLabel, ts.visitNode(node.expression, visitor, ts.isExpression), node.expression);
                    transformAndEmitEmbeddedStatement(node.thenStatement);
                    if (node.elseStatement) {
                        emitBreak(endLabel);
                        markLabel(elseLabel);
                        transformAndEmitEmbeddedStatement(node.elseStatement);
                    }
                    markLabel(endLabel);
                }
                else {
                    emitStatement(ts.visitNode(node, visitor, ts.isStatement));
                }
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function transformAndEmitDoStatement(node) {
            if (containsYield(node)) {
                var conditionLabel = defineLabel();
                var loopLabel = defineLabel();
                beginLoopBlock(conditionLabel);
                markLabel(loopLabel);
                transformAndEmitEmbeddedStatement(node.statement);
                markLabel(conditionLabel);
                emitBreakWhenTrue(loopLabel, ts.visitNode(node.expression, visitor, ts.isExpression));
                endLoopBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitDoStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLoopBlock();
                node = ts.visitEachChild(node, visitor, context);
                endLoopBlock();
                return node;
            }
            else {
                return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformAndEmitWhileStatement(node) {
            if (containsYield(node)) {
                var loopLabel = defineLabel();
                var endLabel = beginLoopBlock(loopLabel);
                markLabel(loopLabel);
                emitBreakWhenFalse(endLabel, ts.visitNode(node.expression, visitor, ts.isExpression));
                transformAndEmitEmbeddedStatement(node.statement);
                emitBreak(loopLabel);
                endLoopBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitWhileStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLoopBlock();
                node = ts.visitEachChild(node, visitor, context);
                endLoopBlock();
                return node;
            }
            else {
                return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformAndEmitForStatement(node) {
            if (containsYield(node)) {
                var conditionLabel = defineLabel();
                var incrementLabel = defineLabel();
                var endLabel = beginLoopBlock(incrementLabel);
                if (node.initializer) {
                    var initializer = node.initializer;
                    if (ts.isVariableDeclarationList(initializer)) {
                        transformAndEmitVariableDeclarationList(initializer);
                    }
                    else {
                        emitStatement(ts.setTextRange(factory.createExpressionStatement(ts.visitNode(initializer, visitor, ts.isExpression)), initializer));
                    }
                }
                markLabel(conditionLabel);
                if (node.condition) {
                    emitBreakWhenFalse(endLabel, ts.visitNode(node.condition, visitor, ts.isExpression));
                }
                transformAndEmitEmbeddedStatement(node.statement);
                markLabel(incrementLabel);
                if (node.incrementor) {
                    emitStatement(ts.setTextRange(factory.createExpressionStatement(ts.visitNode(node.incrementor, visitor, ts.isExpression)), node.incrementor));
                }
                emitBreak(conditionLabel);
                endLoopBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitForStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLoopBlock();
            }
            var initializer = node.initializer;
            if (initializer && ts.isVariableDeclarationList(initializer)) {
                for (var _i = 0, _a = initializer.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    hoistVariableDeclaration(variable.name);
                }
                var variables = ts.getInitializedVariables(initializer);
                node = factory.updateForStatement(node, variables.length > 0
                    ? factory.inlineExpressions(ts.map(variables, transformInitializedVariable))
                    : undefined, ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitor, ts.isExpression), ts.visitIterationBody(node.statement, visitor, context));
            }
            else {
                node = ts.visitEachChild(node, visitor, context);
            }
            if (inStatementContainingYield) {
                endLoopBlock();
            }
            return node;
        }
        function transformAndEmitForInStatement(node) {
            if (containsYield(node)) {
                var keysArray = declareLocal();
                var key = declareLocal();
                var keysIndex = factory.createLoopVariable();
                var initializer = node.initializer;
                hoistVariableDeclaration(keysIndex);
                emitAssignment(keysArray, factory.createArrayLiteralExpression());
                emitStatement(factory.createForInStatement(key, ts.visitNode(node.expression, visitor, ts.isExpression), factory.createExpressionStatement(factory.createCallExpression(factory.createPropertyAccessExpression(keysArray, "push"), undefined, [key]))));
                emitAssignment(keysIndex, factory.createNumericLiteral(0));
                var conditionLabel = defineLabel();
                var incrementLabel = defineLabel();
                var endLabel = beginLoopBlock(incrementLabel);
                markLabel(conditionLabel);
                emitBreakWhenFalse(endLabel, factory.createLessThan(keysIndex, factory.createPropertyAccessExpression(keysArray, "length")));
                var variable = void 0;
                if (ts.isVariableDeclarationList(initializer)) {
                    for (var _i = 0, _a = initializer.declarations; _i < _a.length; _i++) {
                        var variable_1 = _a[_i];
                        hoistVariableDeclaration(variable_1.name);
                    }
                    variable = factory.cloneNode(initializer.declarations[0].name);
                }
                else {
                    variable = ts.visitNode(initializer, visitor, ts.isExpression);
                    ts.Debug.assert(ts.isLeftHandSideExpression(variable));
                }
                emitAssignment(variable, factory.createElementAccessExpression(keysArray, keysIndex));
                transformAndEmitEmbeddedStatement(node.statement);
                markLabel(incrementLabel);
                emitStatement(factory.createExpressionStatement(factory.createPostfixIncrement(keysIndex)));
                emitBreak(conditionLabel);
                endLoopBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitForInStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLoopBlock();
            }
            var initializer = node.initializer;
            if (ts.isVariableDeclarationList(initializer)) {
                for (var _i = 0, _a = initializer.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    hoistVariableDeclaration(variable.name);
                }
                node = factory.updateForInStatement(node, initializer.declarations[0].name, ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitNode(node.statement, visitor, ts.isStatement, factory.liftToBlock));
            }
            else {
                node = ts.visitEachChild(node, visitor, context);
            }
            if (inStatementContainingYield) {
                endLoopBlock();
            }
            return node;
        }
        function transformAndEmitContinueStatement(node) {
            var label = findContinueTarget(node.label ? ts.idText(node.label) : undefined);
            if (label > 0) {
                emitBreak(label, node);
            }
            else {
                emitStatement(node);
            }
        }
        function visitContinueStatement(node) {
            if (inStatementContainingYield) {
                var label = findContinueTarget(node.label && ts.idText(node.label));
                if (label > 0) {
                    return createInlineBreak(label, node);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformAndEmitBreakStatement(node) {
            var label = findBreakTarget(node.label ? ts.idText(node.label) : undefined);
            if (label > 0) {
                emitBreak(label, node);
            }
            else {
                emitStatement(node);
            }
        }
        function visitBreakStatement(node) {
            if (inStatementContainingYield) {
                var label = findBreakTarget(node.label && ts.idText(node.label));
                if (label > 0) {
                    return createInlineBreak(label, node);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformAndEmitReturnStatement(node) {
            emitReturn(ts.visitNode(node.expression, visitor, ts.isExpression), node);
        }
        function visitReturnStatement(node) {
            return createInlineReturn(ts.visitNode(node.expression, visitor, ts.isExpression), node);
        }
        function transformAndEmitWithStatement(node) {
            if (containsYield(node)) {
                beginWithBlock(cacheExpression(ts.visitNode(node.expression, visitor, ts.isExpression)));
                transformAndEmitEmbeddedStatement(node.statement);
                endWithBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function transformAndEmitSwitchStatement(node) {
            if (containsYield(node.caseBlock)) {
                var caseBlock = node.caseBlock;
                var numClauses = caseBlock.clauses.length;
                var endLabel = beginSwitchBlock();
                var expression = cacheExpression(ts.visitNode(node.expression, visitor, ts.isExpression));
                var clauseLabels = [];
                var defaultClauseIndex = -1;
                for (var i = 0; i < numClauses; i++) {
                    var clause = caseBlock.clauses[i];
                    clauseLabels.push(defineLabel());
                    if (clause.kind === 288 && defaultClauseIndex === -1) {
                        defaultClauseIndex = i;
                    }
                }
                var clausesWritten = 0;
                var pendingClauses = [];
                while (clausesWritten < numClauses) {
                    var defaultClausesSkipped = 0;
                    for (var i = clausesWritten; i < numClauses; i++) {
                        var clause = caseBlock.clauses[i];
                        if (clause.kind === 287) {
                            if (containsYield(clause.expression) && pendingClauses.length > 0) {
                                break;
                            }
                            pendingClauses.push(factory.createCaseClause(ts.visitNode(clause.expression, visitor, ts.isExpression), [
                                createInlineBreak(clauseLabels[i], clause.expression)
                            ]));
                        }
                        else {
                            defaultClausesSkipped++;
                        }
                    }
                    if (pendingClauses.length) {
                        emitStatement(factory.createSwitchStatement(expression, factory.createCaseBlock(pendingClauses)));
                        clausesWritten += pendingClauses.length;
                        pendingClauses = [];
                    }
                    if (defaultClausesSkipped > 0) {
                        clausesWritten += defaultClausesSkipped;
                        defaultClausesSkipped = 0;
                    }
                }
                if (defaultClauseIndex >= 0) {
                    emitBreak(clauseLabels[defaultClauseIndex]);
                }
                else {
                    emitBreak(endLabel);
                }
                for (var i = 0; i < numClauses; i++) {
                    markLabel(clauseLabels[i]);
                    transformAndEmitStatements(caseBlock.clauses[i].statements);
                }
                endSwitchBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitSwitchStatement(node) {
            if (inStatementContainingYield) {
                beginScriptSwitchBlock();
            }
            node = ts.visitEachChild(node, visitor, context);
            if (inStatementContainingYield) {
                endSwitchBlock();
            }
            return node;
        }
        function transformAndEmitLabeledStatement(node) {
            if (containsYield(node)) {
                beginLabeledBlock(ts.idText(node.label));
                transformAndEmitEmbeddedStatement(node.statement);
                endLabeledBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitLabeledStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLabeledBlock(ts.idText(node.label));
            }
            node = ts.visitEachChild(node, visitor, context);
            if (inStatementContainingYield) {
                endLabeledBlock();
            }
            return node;
        }
        function transformAndEmitThrowStatement(node) {
            var _a;
            emitThrow(ts.visitNode((_a = node.expression) !== null && _a !== void 0 ? _a : factory.createVoidZero(), visitor, ts.isExpression), node);
        }
        function transformAndEmitTryStatement(node) {
            if (containsYield(node)) {
                beginExceptionBlock();
                transformAndEmitEmbeddedStatement(node.tryBlock);
                if (node.catchClause) {
                    beginCatchBlock(node.catchClause.variableDeclaration);
                    transformAndEmitEmbeddedStatement(node.catchClause.block);
                }
                if (node.finallyBlock) {
                    beginFinallyBlock();
                    transformAndEmitEmbeddedStatement(node.finallyBlock);
                }
                endExceptionBlock();
            }
            else {
                emitStatement(ts.visitEachChild(node, visitor, context));
            }
        }
        function containsYield(node) {
            return !!node && (node.transformFlags & 524288) !== 0;
        }
        function countInitialNodesWithoutYield(nodes) {
            var numNodes = nodes.length;
            for (var i = 0; i < numNodes; i++) {
                if (containsYield(nodes[i])) {
                    return i;
                }
            }
            return -1;
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            if (ts.isIdentifier(node)) {
                return substituteExpressionIdentifier(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            if (!ts.isGeneratedIdentifier(node) && renamedCatchVariables && renamedCatchVariables.has(ts.idText(node))) {
                var original = ts.getOriginalNode(node);
                if (ts.isIdentifier(original) && original.parent) {
                    var declaration = resolver.getReferencedValueDeclaration(original);
                    if (declaration) {
                        var name = renamedCatchVariableDeclarations[ts.getOriginalNodeId(declaration)];
                        if (name) {
                            var clone_6 = ts.setParent(ts.setTextRange(factory.cloneNode(name), name), name.parent);
                            ts.setSourceMapRange(clone_6, node);
                            ts.setCommentRange(clone_6, node);
                            return clone_6;
                        }
                    }
                }
            }
            return node;
        }
        function cacheExpression(node) {
            if (ts.isGeneratedIdentifier(node) || ts.getEmitFlags(node) & 4096) {
                return node;
            }
            var temp = factory.createTempVariable(hoistVariableDeclaration);
            emitAssignment(temp, node, node);
            return temp;
        }
        function declareLocal(name) {
            var temp = name
                ? factory.createUniqueName(name)
                : factory.createTempVariable(undefined);
            hoistVariableDeclaration(temp);
            return temp;
        }
        function defineLabel() {
            if (!labelOffsets) {
                labelOffsets = [];
            }
            var label = nextLabelId;
            nextLabelId++;
            labelOffsets[label] = -1;
            return label;
        }
        function markLabel(label) {
            ts.Debug.assert(labelOffsets !== undefined, "No labels were defined.");
            labelOffsets[label] = operations ? operations.length : 0;
        }
        function beginBlock(block) {
            if (!blocks) {
                blocks = [];
                blockActions = [];
                blockOffsets = [];
                blockStack = [];
            }
            var index = blockActions.length;
            blockActions[index] = 0;
            blockOffsets[index] = operations ? operations.length : 0;
            blocks[index] = block;
            blockStack.push(block);
            return index;
        }
        function endBlock() {
            var block = peekBlock();
            if (block === undefined)
                return ts.Debug.fail("beginBlock was never called.");
            var index = blockActions.length;
            blockActions[index] = 1;
            blockOffsets[index] = operations ? operations.length : 0;
            blocks[index] = block;
            blockStack.pop();
            return block;
        }
        function peekBlock() {
            return ts.lastOrUndefined(blockStack);
        }
        function peekBlockKind() {
            var block = peekBlock();
            return block && block.kind;
        }
        function beginWithBlock(expression) {
            var startLabel = defineLabel();
            var endLabel = defineLabel();
            markLabel(startLabel);
            beginBlock({
                kind: 1,
                expression: expression,
                startLabel: startLabel,
                endLabel: endLabel
            });
        }
        function endWithBlock() {
            ts.Debug.assert(peekBlockKind() === 1);
            var block = endBlock();
            markLabel(block.endLabel);
        }
        function beginExceptionBlock() {
            var startLabel = defineLabel();
            var endLabel = defineLabel();
            markLabel(startLabel);
            beginBlock({
                kind: 0,
                state: 0,
                startLabel: startLabel,
                endLabel: endLabel
            });
            emitNop();
            return endLabel;
        }
        function beginCatchBlock(variable) {
            ts.Debug.assert(peekBlockKind() === 0);
            var name;
            if (ts.isGeneratedIdentifier(variable.name)) {
                name = variable.name;
                hoistVariableDeclaration(variable.name);
            }
            else {
                var text = ts.idText(variable.name);
                name = declareLocal(text);
                if (!renamedCatchVariables) {
                    renamedCatchVariables = new ts.Map();
                    renamedCatchVariableDeclarations = [];
                    context.enableSubstitution(79);
                }
                renamedCatchVariables.set(text, true);
                renamedCatchVariableDeclarations[ts.getOriginalNodeId(variable)] = name;
            }
            var exception = peekBlock();
            ts.Debug.assert(exception.state < 1);
            var endLabel = exception.endLabel;
            emitBreak(endLabel);
            var catchLabel = defineLabel();
            markLabel(catchLabel);
            exception.state = 1;
            exception.catchVariable = name;
            exception.catchLabel = catchLabel;
            emitAssignment(name, factory.createCallExpression(factory.createPropertyAccessExpression(state, "sent"), undefined, []));
            emitNop();
        }
        function beginFinallyBlock() {
            ts.Debug.assert(peekBlockKind() === 0);
            var exception = peekBlock();
            ts.Debug.assert(exception.state < 2);
            var endLabel = exception.endLabel;
            emitBreak(endLabel);
            var finallyLabel = defineLabel();
            markLabel(finallyLabel);
            exception.state = 2;
            exception.finallyLabel = finallyLabel;
        }
        function endExceptionBlock() {
            ts.Debug.assert(peekBlockKind() === 0);
            var exception = endBlock();
            var state = exception.state;
            if (state < 2) {
                emitBreak(exception.endLabel);
            }
            else {
                emitEndfinally();
            }
            markLabel(exception.endLabel);
            emitNop();
            exception.state = 3;
        }
        function beginScriptLoopBlock() {
            beginBlock({
                kind: 3,
                isScript: true,
                breakLabel: -1,
                continueLabel: -1
            });
        }
        function beginLoopBlock(continueLabel) {
            var breakLabel = defineLabel();
            beginBlock({
                kind: 3,
                isScript: false,
                breakLabel: breakLabel,
                continueLabel: continueLabel,
            });
            return breakLabel;
        }
        function endLoopBlock() {
            ts.Debug.assert(peekBlockKind() === 3);
            var block = endBlock();
            var breakLabel = block.breakLabel;
            if (!block.isScript) {
                markLabel(breakLabel);
            }
        }
        function beginScriptSwitchBlock() {
            beginBlock({
                kind: 2,
                isScript: true,
                breakLabel: -1
            });
        }
        function beginSwitchBlock() {
            var breakLabel = defineLabel();
            beginBlock({
                kind: 2,
                isScript: false,
                breakLabel: breakLabel,
            });
            return breakLabel;
        }
        function endSwitchBlock() {
            ts.Debug.assert(peekBlockKind() === 2);
            var block = endBlock();
            var breakLabel = block.breakLabel;
            if (!block.isScript) {
                markLabel(breakLabel);
            }
        }
        function beginScriptLabeledBlock(labelText) {
            beginBlock({
                kind: 4,
                isScript: true,
                labelText: labelText,
                breakLabel: -1
            });
        }
        function beginLabeledBlock(labelText) {
            var breakLabel = defineLabel();
            beginBlock({
                kind: 4,
                isScript: false,
                labelText: labelText,
                breakLabel: breakLabel
            });
        }
        function endLabeledBlock() {
            ts.Debug.assert(peekBlockKind() === 4);
            var block = endBlock();
            if (!block.isScript) {
                markLabel(block.breakLabel);
            }
        }
        function supportsUnlabeledBreak(block) {
            return block.kind === 2
                || block.kind === 3;
        }
        function supportsLabeledBreakOrContinue(block) {
            return block.kind === 4;
        }
        function supportsUnlabeledContinue(block) {
            return block.kind === 3;
        }
        function hasImmediateContainingLabeledBlock(labelText, start) {
            for (var j = start; j >= 0; j--) {
                var containingBlock = blockStack[j];
                if (supportsLabeledBreakOrContinue(containingBlock)) {
                    if (containingBlock.labelText === labelText) {
                        return true;
                    }
                }
                else {
                    break;
                }
            }
            return false;
        }
        function findBreakTarget(labelText) {
            if (blockStack) {
                if (labelText) {
                    for (var i = blockStack.length - 1; i >= 0; i--) {
                        var block = blockStack[i];
                        if (supportsLabeledBreakOrContinue(block) && block.labelText === labelText) {
                            return block.breakLabel;
                        }
                        else if (supportsUnlabeledBreak(block) && hasImmediateContainingLabeledBlock(labelText, i - 1)) {
                            return block.breakLabel;
                        }
                    }
                }
                else {
                    for (var i = blockStack.length - 1; i >= 0; i--) {
                        var block = blockStack[i];
                        if (supportsUnlabeledBreak(block)) {
                            return block.breakLabel;
                        }
                    }
                }
            }
            return 0;
        }
        function findContinueTarget(labelText) {
            if (blockStack) {
                if (labelText) {
                    for (var i = blockStack.length - 1; i >= 0; i--) {
                        var block = blockStack[i];
                        if (supportsUnlabeledContinue(block) && hasImmediateContainingLabeledBlock(labelText, i - 1)) {
                            return block.continueLabel;
                        }
                    }
                }
                else {
                    for (var i = blockStack.length - 1; i >= 0; i--) {
                        var block = blockStack[i];
                        if (supportsUnlabeledContinue(block)) {
                            return block.continueLabel;
                        }
                    }
                }
            }
            return 0;
        }
        function createLabel(label) {
            if (label !== undefined && label > 0) {
                if (labelExpressions === undefined) {
                    labelExpressions = [];
                }
                var expression = factory.createNumericLiteral(-1);
                if (labelExpressions[label] === undefined) {
                    labelExpressions[label] = [expression];
                }
                else {
                    labelExpressions[label].push(expression);
                }
                return expression;
            }
            return factory.createOmittedExpression();
        }
        function createInstruction(instruction) {
            var literal = factory.createNumericLiteral(instruction);
            ts.addSyntheticTrailingComment(literal, 3, getInstructionName(instruction));
            return literal;
        }
        function createInlineBreak(label, location) {
            ts.Debug.assertLessThan(0, label, "Invalid label");
            return ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression([
                createInstruction(3),
                createLabel(label)
            ])), location);
        }
        function createInlineReturn(expression, location) {
            return ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression(expression
                ? [createInstruction(2), expression]
                : [createInstruction(2)])), location);
        }
        function createGeneratorResume(location) {
            return ts.setTextRange(factory.createCallExpression(factory.createPropertyAccessExpression(state, "sent"), undefined, []), location);
        }
        function emitNop() {
            emitWorker(0);
        }
        function emitStatement(node) {
            if (node) {
                emitWorker(1, [node]);
            }
            else {
                emitNop();
            }
        }
        function emitAssignment(left, right, location) {
            emitWorker(2, [left, right], location);
        }
        function emitBreak(label, location) {
            emitWorker(3, [label], location);
        }
        function emitBreakWhenTrue(label, condition, location) {
            emitWorker(4, [label, condition], location);
        }
        function emitBreakWhenFalse(label, condition, location) {
            emitWorker(5, [label, condition], location);
        }
        function emitYieldStar(expression, location) {
            emitWorker(7, [expression], location);
        }
        function emitYield(expression, location) {
            emitWorker(6, [expression], location);
        }
        function emitReturn(expression, location) {
            emitWorker(8, [expression], location);
        }
        function emitThrow(expression, location) {
            emitWorker(9, [expression], location);
        }
        function emitEndfinally() {
            emitWorker(10);
        }
        function emitWorker(code, args, location) {
            if (operations === undefined) {
                operations = [];
                operationArguments = [];
                operationLocations = [];
            }
            if (labelOffsets === undefined) {
                markLabel(defineLabel());
            }
            var operationIndex = operations.length;
            operations[operationIndex] = code;
            operationArguments[operationIndex] = args;
            operationLocations[operationIndex] = location;
        }
        function build() {
            blockIndex = 0;
            labelNumber = 0;
            labelNumbers = undefined;
            lastOperationWasAbrupt = false;
            lastOperationWasCompletion = false;
            clauses = undefined;
            statements = undefined;
            exceptionBlockStack = undefined;
            currentExceptionBlock = undefined;
            withBlockStack = undefined;
            var buildResult = buildStatements();
            return emitHelpers().createGeneratorHelper(ts.setEmitFlags(factory.createFunctionExpression(undefined, undefined, undefined, undefined, [factory.createParameterDeclaration(undefined, undefined, undefined, state)], undefined, factory.createBlock(buildResult, buildResult.length > 0)), 524288));
        }
        function buildStatements() {
            if (operations) {
                for (var operationIndex = 0; operationIndex < operations.length; operationIndex++) {
                    writeOperation(operationIndex);
                }
                flushFinalLabel(operations.length);
            }
            else {
                flushFinalLabel(0);
            }
            if (clauses) {
                var labelExpression = factory.createPropertyAccessExpression(state, "label");
                var switchStatement = factory.createSwitchStatement(labelExpression, factory.createCaseBlock(clauses));
                return [ts.startOnNewLine(switchStatement)];
            }
            if (statements) {
                return statements;
            }
            return [];
        }
        function flushLabel() {
            if (!statements) {
                return;
            }
            appendLabel(!lastOperationWasAbrupt);
            lastOperationWasAbrupt = false;
            lastOperationWasCompletion = false;
            labelNumber++;
        }
        function flushFinalLabel(operationIndex) {
            if (isFinalLabelReachable(operationIndex)) {
                tryEnterLabel(operationIndex);
                withBlockStack = undefined;
                writeReturn(undefined, undefined);
            }
            if (statements && clauses) {
                appendLabel(false);
            }
            updateLabelExpressions();
        }
        function isFinalLabelReachable(operationIndex) {
            if (!lastOperationWasCompletion) {
                return true;
            }
            if (!labelOffsets || !labelExpressions) {
                return false;
            }
            for (var label = 0; label < labelOffsets.length; label++) {
                if (labelOffsets[label] === operationIndex && labelExpressions[label]) {
                    return true;
                }
            }
            return false;
        }
        function appendLabel(markLabelEnd) {
            if (!clauses) {
                clauses = [];
            }
            if (statements) {
                if (withBlockStack) {
                    for (var i = withBlockStack.length - 1; i >= 0; i--) {
                        var withBlock = withBlockStack[i];
                        statements = [factory.createWithStatement(withBlock.expression, factory.createBlock(statements))];
                    }
                }
                if (currentExceptionBlock) {
                    var startLabel = currentExceptionBlock.startLabel, catchLabel = currentExceptionBlock.catchLabel, finallyLabel = currentExceptionBlock.finallyLabel, endLabel = currentExceptionBlock.endLabel;
                    statements.unshift(factory.createExpressionStatement(factory.createCallExpression(factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(state, "trys"), "push"), undefined, [
                        factory.createArrayLiteralExpression([
                            createLabel(startLabel),
                            createLabel(catchLabel),
                            createLabel(finallyLabel),
                            createLabel(endLabel)
                        ])
                    ])));
                    currentExceptionBlock = undefined;
                }
                if (markLabelEnd) {
                    statements.push(factory.createExpressionStatement(factory.createAssignment(factory.createPropertyAccessExpression(state, "label"), factory.createNumericLiteral(labelNumber + 1))));
                }
            }
            clauses.push(factory.createCaseClause(factory.createNumericLiteral(labelNumber), statements || []));
            statements = undefined;
        }
        function tryEnterLabel(operationIndex) {
            if (!labelOffsets) {
                return;
            }
            for (var label = 0; label < labelOffsets.length; label++) {
                if (labelOffsets[label] === operationIndex) {
                    flushLabel();
                    if (labelNumbers === undefined) {
                        labelNumbers = [];
                    }
                    if (labelNumbers[labelNumber] === undefined) {
                        labelNumbers[labelNumber] = [label];
                    }
                    else {
                        labelNumbers[labelNumber].push(label);
                    }
                }
            }
        }
        function updateLabelExpressions() {
            if (labelExpressions !== undefined && labelNumbers !== undefined) {
                for (var labelNumber_1 = 0; labelNumber_1 < labelNumbers.length; labelNumber_1++) {
                    var labels = labelNumbers[labelNumber_1];
                    if (labels !== undefined) {
                        for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
                            var label = labels_1[_i];
                            var expressions = labelExpressions[label];
                            if (expressions !== undefined) {
                                for (var _a = 0, expressions_1 = expressions; _a < expressions_1.length; _a++) {
                                    var expression = expressions_1[_a];
                                    expression.text = String(labelNumber_1);
                                }
                            }
                        }
                    }
                }
            }
        }
        function tryEnterOrLeaveBlock(operationIndex) {
            if (blocks) {
                for (; blockIndex < blockActions.length && blockOffsets[blockIndex] <= operationIndex; blockIndex++) {
                    var block = blocks[blockIndex];
                    var blockAction = blockActions[blockIndex];
                    switch (block.kind) {
                        case 0:
                            if (blockAction === 0) {
                                if (!exceptionBlockStack) {
                                    exceptionBlockStack = [];
                                }
                                if (!statements) {
                                    statements = [];
                                }
                                exceptionBlockStack.push(currentExceptionBlock);
                                currentExceptionBlock = block;
                            }
                            else if (blockAction === 1) {
                                currentExceptionBlock = exceptionBlockStack.pop();
                            }
                            break;
                        case 1:
                            if (blockAction === 0) {
                                if (!withBlockStack) {
                                    withBlockStack = [];
                                }
                                withBlockStack.push(block);
                            }
                            else if (blockAction === 1) {
                                withBlockStack.pop();
                            }
                            break;
                    }
                }
            }
        }
        function writeOperation(operationIndex) {
            tryEnterLabel(operationIndex);
            tryEnterOrLeaveBlock(operationIndex);
            if (lastOperationWasAbrupt) {
                return;
            }
            lastOperationWasAbrupt = false;
            lastOperationWasCompletion = false;
            var opcode = operations[operationIndex];
            if (opcode === 0) {
                return;
            }
            else if (opcode === 10) {
                return writeEndfinally();
            }
            var args = operationArguments[operationIndex];
            if (opcode === 1) {
                return writeStatement(args[0]);
            }
            var location = operationLocations[operationIndex];
            switch (opcode) {
                case 2:
                    return writeAssign(args[0], args[1], location);
                case 3:
                    return writeBreak(args[0], location);
                case 4:
                    return writeBreakWhenTrue(args[0], args[1], location);
                case 5:
                    return writeBreakWhenFalse(args[0], args[1], location);
                case 6:
                    return writeYield(args[0], location);
                case 7:
                    return writeYieldStar(args[0], location);
                case 8:
                    return writeReturn(args[0], location);
                case 9:
                    return writeThrow(args[0], location);
            }
        }
        function writeStatement(statement) {
            if (statement) {
                if (!statements) {
                    statements = [statement];
                }
                else {
                    statements.push(statement);
                }
            }
        }
        function writeAssign(left, right, operationLocation) {
            writeStatement(ts.setTextRange(factory.createExpressionStatement(factory.createAssignment(left, right)), operationLocation));
        }
        function writeThrow(expression, operationLocation) {
            lastOperationWasAbrupt = true;
            lastOperationWasCompletion = true;
            writeStatement(ts.setTextRange(factory.createThrowStatement(expression), operationLocation));
        }
        function writeReturn(expression, operationLocation) {
            lastOperationWasAbrupt = true;
            lastOperationWasCompletion = true;
            writeStatement(ts.setEmitFlags(ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression(expression
                ? [createInstruction(2), expression]
                : [createInstruction(2)])), operationLocation), 384));
        }
        function writeBreak(label, operationLocation) {
            lastOperationWasAbrupt = true;
            writeStatement(ts.setEmitFlags(ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression([
                createInstruction(3),
                createLabel(label)
            ])), operationLocation), 384));
        }
        function writeBreakWhenTrue(label, condition, operationLocation) {
            writeStatement(ts.setEmitFlags(factory.createIfStatement(condition, ts.setEmitFlags(ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression([
                createInstruction(3),
                createLabel(label)
            ])), operationLocation), 384)), 1));
        }
        function writeBreakWhenFalse(label, condition, operationLocation) {
            writeStatement(ts.setEmitFlags(factory.createIfStatement(factory.createLogicalNot(condition), ts.setEmitFlags(ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression([
                createInstruction(3),
                createLabel(label)
            ])), operationLocation), 384)), 1));
        }
        function writeYield(expression, operationLocation) {
            lastOperationWasAbrupt = true;
            writeStatement(ts.setEmitFlags(ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression(expression
                ? [createInstruction(4), expression]
                : [createInstruction(4)])), operationLocation), 384));
        }
        function writeYieldStar(expression, operationLocation) {
            lastOperationWasAbrupt = true;
            writeStatement(ts.setEmitFlags(ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression([
                createInstruction(5),
                expression
            ])), operationLocation), 384));
        }
        function writeEndfinally() {
            lastOperationWasAbrupt = true;
            writeStatement(factory.createReturnStatement(factory.createArrayLiteralExpression([
                createInstruction(7)
            ])));
        }
    }
    ts.transformGenerators = transformGenerators;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformModule(context) {
        function getTransformModuleDelegate(moduleKind) {
            switch (moduleKind) {
                case ts.ModuleKind.AMD: return transformAMDModule;
                case ts.ModuleKind.UMD: return transformUMDModule;
                default: return transformCommonJSModule;
            }
        }
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, startLexicalEnvironment = context.startLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var compilerOptions = context.getCompilerOptions();
        var resolver = context.getEmitResolver();
        var host = context.getEmitHost();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var moduleKind = ts.getEmitModuleKind(compilerOptions);
        var previousOnSubstituteNode = context.onSubstituteNode;
        var previousOnEmitNode = context.onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        context.onEmitNode = onEmitNode;
        context.enableSubstitution(206);
        context.enableSubstitution(208);
        context.enableSubstitution(79);
        context.enableSubstitution(219);
        context.enableSubstitution(292);
        context.enableEmitNotification(300);
        var moduleInfoMap = [];
        var deferredExports = [];
        var currentSourceFile;
        var currentModuleInfo;
        var noSubstitution = [];
        var needUMDDynamicImportHelper;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile ||
                !(ts.isEffectiveExternalModule(node, compilerOptions) ||
                    node.transformFlags & 4194304 ||
                    (ts.isJsonSourceFile(node) && ts.hasJsonModuleEmitEnabled(compilerOptions) && ts.outFile(compilerOptions)))) {
                return node;
            }
            currentSourceFile = node;
            currentModuleInfo = ts.collectExternalModuleInfo(context, node, resolver, compilerOptions);
            moduleInfoMap[ts.getOriginalNodeId(node)] = currentModuleInfo;
            var transformModule = getTransformModuleDelegate(moduleKind);
            var updated = transformModule(node);
            currentSourceFile = undefined;
            currentModuleInfo = undefined;
            needUMDDynamicImportHelper = false;
            return updated;
        }
        function shouldEmitUnderscoreUnderscoreESModule() {
            if (!currentModuleInfo.exportEquals && ts.isExternalModule(currentSourceFile)) {
                return true;
            }
            return false;
        }
        function transformCommonJSModule(node) {
            startLexicalEnvironment();
            var statements = [];
            var ensureUseStrict = ts.getStrictOptionValue(compilerOptions, "alwaysStrict") || (!compilerOptions.noImplicitUseStrict && ts.isExternalModule(currentSourceFile));
            var statementOffset = factory.copyPrologue(node.statements, statements, ensureUseStrict && !ts.isJsonSourceFile(node), topLevelVisitor);
            if (shouldEmitUnderscoreUnderscoreESModule()) {
                ts.append(statements, createUnderscoreUnderscoreESModule());
            }
            if (ts.length(currentModuleInfo.exportedNames)) {
                var chunkSize = 50;
                for (var i = 0; i < currentModuleInfo.exportedNames.length; i += chunkSize) {
                    ts.append(statements, factory.createExpressionStatement(ts.reduceLeft(currentModuleInfo.exportedNames.slice(i, i + chunkSize), function (prev, nextId) { return factory.createAssignment(factory.createPropertyAccessExpression(factory.createIdentifier("exports"), factory.createIdentifier(ts.idText(nextId))), prev); }, factory.createVoidZero())));
                }
            }
            ts.append(statements, ts.visitNode(currentModuleInfo.externalHelpersImportDeclaration, topLevelVisitor, ts.isStatement));
            ts.addRange(statements, ts.visitNodes(node.statements, topLevelVisitor, ts.isStatement, statementOffset));
            addExportEqualsIfNeeded(statements, false);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            var updated = factory.updateSourceFile(node, ts.setTextRange(factory.createNodeArray(statements), node.statements));
            ts.addEmitHelpers(updated, context.readEmitHelpers());
            return updated;
        }
        function transformAMDModule(node) {
            var define = factory.createIdentifier("define");
            var moduleName = ts.tryGetModuleNameFromFile(factory, node, host, compilerOptions);
            var jsonSourceFile = ts.isJsonSourceFile(node) && node;
            var _a = collectAsynchronousDependencies(node, true), aliasedModuleNames = _a.aliasedModuleNames, unaliasedModuleNames = _a.unaliasedModuleNames, importAliasNames = _a.importAliasNames;
            var updated = factory.updateSourceFile(node, ts.setTextRange(factory.createNodeArray([
                factory.createExpressionStatement(factory.createCallExpression(define, undefined, __spreadArray(__spreadArray([], (moduleName ? [moduleName] : []), true), [
                    factory.createArrayLiteralExpression(jsonSourceFile ? ts.emptyArray : __spreadArray(__spreadArray([
                        factory.createStringLiteral("require"),
                        factory.createStringLiteral("exports")
                    ], aliasedModuleNames, true), unaliasedModuleNames, true)),
                    jsonSourceFile ?
                        jsonSourceFile.statements.length ? jsonSourceFile.statements[0].expression : factory.createObjectLiteralExpression() :
                        factory.createFunctionExpression(undefined, undefined, undefined, undefined, __spreadArray([
                            factory.createParameterDeclaration(undefined, undefined, undefined, "require"),
                            factory.createParameterDeclaration(undefined, undefined, undefined, "exports")
                        ], importAliasNames, true), undefined, transformAsynchronousModuleBody(node))
                ], false)))
            ]), node.statements));
            ts.addEmitHelpers(updated, context.readEmitHelpers());
            return updated;
        }
        function transformUMDModule(node) {
            var _a = collectAsynchronousDependencies(node, false), aliasedModuleNames = _a.aliasedModuleNames, unaliasedModuleNames = _a.unaliasedModuleNames, importAliasNames = _a.importAliasNames;
            var moduleName = ts.tryGetModuleNameFromFile(factory, node, host, compilerOptions);
            var umdHeader = factory.createFunctionExpression(undefined, undefined, undefined, undefined, [factory.createParameterDeclaration(undefined, undefined, undefined, "factory")], undefined, ts.setTextRange(factory.createBlock([
                factory.createIfStatement(factory.createLogicalAnd(factory.createTypeCheck(factory.createIdentifier("module"), "object"), factory.createTypeCheck(factory.createPropertyAccessExpression(factory.createIdentifier("module"), "exports"), "object")), factory.createBlock([
                    factory.createVariableStatement(undefined, [
                        factory.createVariableDeclaration("v", undefined, undefined, factory.createCallExpression(factory.createIdentifier("factory"), undefined, [
                            factory.createIdentifier("require"),
                            factory.createIdentifier("exports")
                        ]))
                    ]),
                    ts.setEmitFlags(factory.createIfStatement(factory.createStrictInequality(factory.createIdentifier("v"), factory.createIdentifier("undefined")), factory.createExpressionStatement(factory.createAssignment(factory.createPropertyAccessExpression(factory.createIdentifier("module"), "exports"), factory.createIdentifier("v")))), 1)
                ]), factory.createIfStatement(factory.createLogicalAnd(factory.createTypeCheck(factory.createIdentifier("define"), "function"), factory.createPropertyAccessExpression(factory.createIdentifier("define"), "amd")), factory.createBlock([
                    factory.createExpressionStatement(factory.createCallExpression(factory.createIdentifier("define"), undefined, __spreadArray(__spreadArray([], (moduleName ? [moduleName] : []), true), [
                        factory.createArrayLiteralExpression(__spreadArray(__spreadArray([
                            factory.createStringLiteral("require"),
                            factory.createStringLiteral("exports")
                        ], aliasedModuleNames, true), unaliasedModuleNames, true)),
                        factory.createIdentifier("factory")
                    ], false)))
                ])))
            ], true), undefined));
            var updated = factory.updateSourceFile(node, ts.setTextRange(factory.createNodeArray([
                factory.createExpressionStatement(factory.createCallExpression(umdHeader, undefined, [
                    factory.createFunctionExpression(undefined, undefined, undefined, undefined, __spreadArray([
                        factory.createParameterDeclaration(undefined, undefined, undefined, "require"),
                        factory.createParameterDeclaration(undefined, undefined, undefined, "exports")
                    ], importAliasNames, true), undefined, transformAsynchronousModuleBody(node))
                ]))
            ]), node.statements));
            ts.addEmitHelpers(updated, context.readEmitHelpers());
            return updated;
        }
        function collectAsynchronousDependencies(node, includeNonAmdDependencies) {
            var aliasedModuleNames = [];
            var unaliasedModuleNames = [];
            var importAliasNames = [];
            for (var _i = 0, _a = node.amdDependencies; _i < _a.length; _i++) {
                var amdDependency = _a[_i];
                if (amdDependency.name) {
                    aliasedModuleNames.push(factory.createStringLiteral(amdDependency.path));
                    importAliasNames.push(factory.createParameterDeclaration(undefined, undefined, undefined, amdDependency.name));
                }
                else {
                    unaliasedModuleNames.push(factory.createStringLiteral(amdDependency.path));
                }
            }
            for (var _b = 0, _c = currentModuleInfo.externalImports; _b < _c.length; _b++) {
                var importNode = _c[_b];
                var externalModuleName = ts.getExternalModuleNameLiteral(factory, importNode, currentSourceFile, host, resolver, compilerOptions);
                var importAliasName = ts.getLocalNameForExternalImport(factory, importNode, currentSourceFile);
                if (externalModuleName) {
                    if (includeNonAmdDependencies && importAliasName) {
                        ts.setEmitFlags(importAliasName, 4);
                        aliasedModuleNames.push(externalModuleName);
                        importAliasNames.push(factory.createParameterDeclaration(undefined, undefined, undefined, importAliasName));
                    }
                    else {
                        unaliasedModuleNames.push(externalModuleName);
                    }
                }
            }
            return { aliasedModuleNames: aliasedModuleNames, unaliasedModuleNames: unaliasedModuleNames, importAliasNames: importAliasNames };
        }
        function getAMDImportExpressionForImport(node) {
            if (ts.isImportEqualsDeclaration(node) || ts.isExportDeclaration(node) || !ts.getExternalModuleNameLiteral(factory, node, currentSourceFile, host, resolver, compilerOptions)) {
                return undefined;
            }
            var name = ts.getLocalNameForExternalImport(factory, node, currentSourceFile);
            var expr = getHelperExpressionForImport(node, name);
            if (expr === name) {
                return undefined;
            }
            return factory.createExpressionStatement(factory.createAssignment(name, expr));
        }
        function transformAsynchronousModuleBody(node) {
            startLexicalEnvironment();
            var statements = [];
            var statementOffset = factory.copyPrologue(node.statements, statements, !compilerOptions.noImplicitUseStrict, topLevelVisitor);
            if (shouldEmitUnderscoreUnderscoreESModule()) {
                ts.append(statements, createUnderscoreUnderscoreESModule());
            }
            if (ts.length(currentModuleInfo.exportedNames)) {
                ts.append(statements, factory.createExpressionStatement(ts.reduceLeft(currentModuleInfo.exportedNames, function (prev, nextId) { return factory.createAssignment(factory.createPropertyAccessExpression(factory.createIdentifier("exports"), factory.createIdentifier(ts.idText(nextId))), prev); }, factory.createVoidZero())));
            }
            ts.append(statements, ts.visitNode(currentModuleInfo.externalHelpersImportDeclaration, topLevelVisitor, ts.isStatement));
            if (moduleKind === ts.ModuleKind.AMD) {
                ts.addRange(statements, ts.mapDefined(currentModuleInfo.externalImports, getAMDImportExpressionForImport));
            }
            ts.addRange(statements, ts.visitNodes(node.statements, topLevelVisitor, ts.isStatement, statementOffset));
            addExportEqualsIfNeeded(statements, true);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            var body = factory.createBlock(statements, true);
            if (needUMDDynamicImportHelper) {
                ts.addEmitHelper(body, dynamicImportUMDHelper);
            }
            return body;
        }
        function addExportEqualsIfNeeded(statements, emitAsReturn) {
            if (currentModuleInfo.exportEquals) {
                var expressionResult = ts.visitNode(currentModuleInfo.exportEquals.expression, visitor);
                if (expressionResult) {
                    if (emitAsReturn) {
                        var statement = factory.createReturnStatement(expressionResult);
                        ts.setTextRange(statement, currentModuleInfo.exportEquals);
                        ts.setEmitFlags(statement, 384 | 1536);
                        statements.push(statement);
                    }
                    else {
                        var statement = factory.createExpressionStatement(factory.createAssignment(factory.createPropertyAccessExpression(factory.createIdentifier("module"), "exports"), expressionResult));
                        ts.setTextRange(statement, currentModuleInfo.exportEquals);
                        ts.setEmitFlags(statement, 1536);
                        statements.push(statement);
                    }
                }
            }
        }
        function topLevelVisitor(node) {
            switch (node.kind) {
                case 264:
                    return visitImportDeclaration(node);
                case 263:
                    return visitImportEqualsDeclaration(node);
                case 270:
                    return visitExportDeclaration(node);
                case 269:
                    return visitExportAssignment(node);
                case 235:
                    return visitVariableStatement(node);
                case 254:
                    return visitFunctionDeclaration(node);
                case 255:
                    return visitClassDeclaration(node);
                case 347:
                    return visitMergeDeclarationMarker(node);
                case 348:
                    return visitEndOfDeclarationMarker(node);
                default:
                    return visitor(node);
            }
        }
        function visitorWorker(node, valueIsDiscarded) {
            if (!(node.transformFlags & (4194304 | 2048 | 67108864))) {
                return node;
            }
            switch (node.kind) {
                case 240:
                    return visitForStatement(node);
                case 236:
                    return visitExpressionStatement(node);
                case 210:
                    return visitParenthesizedExpression(node, valueIsDiscarded);
                case 345:
                    return visitPartiallyEmittedExpression(node, valueIsDiscarded);
                case 206:
                    if (ts.isImportCall(node)) {
                        return visitImportCallExpression(node);
                    }
                    break;
                case 219:
                    if (ts.isDestructuringAssignment(node)) {
                        return visitDestructuringAssignment(node, valueIsDiscarded);
                    }
                    break;
                case 217:
                case 218:
                    return visitPreOrPostfixUnaryExpression(node, valueIsDiscarded);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            return visitorWorker(node, false);
        }
        function discardedValueVisitor(node) {
            return visitorWorker(node, true);
        }
        function destructuringNeedsFlattening(node) {
            if (ts.isObjectLiteralExpression(node)) {
                for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
                    var elem = _a[_i];
                    switch (elem.kind) {
                        case 291:
                            if (destructuringNeedsFlattening(elem.initializer)) {
                                return true;
                            }
                            break;
                        case 292:
                            if (destructuringNeedsFlattening(elem.name)) {
                                return true;
                            }
                            break;
                        case 293:
                            if (destructuringNeedsFlattening(elem.expression)) {
                                return true;
                            }
                            break;
                        case 167:
                        case 170:
                        case 171:
                            return false;
                        default: ts.Debug.assertNever(elem, "Unhandled object member kind");
                    }
                }
            }
            else if (ts.isArrayLiteralExpression(node)) {
                for (var _b = 0, _c = node.elements; _b < _c.length; _b++) {
                    var elem = _c[_b];
                    if (ts.isSpreadElement(elem)) {
                        if (destructuringNeedsFlattening(elem.expression)) {
                            return true;
                        }
                    }
                    else if (destructuringNeedsFlattening(elem)) {
                        return true;
                    }
                }
            }
            else if (ts.isIdentifier(node)) {
                return ts.length(getExports(node)) > (ts.isExportName(node) ? 1 : 0);
            }
            return false;
        }
        function visitDestructuringAssignment(node, valueIsDiscarded) {
            if (destructuringNeedsFlattening(node.left)) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 0, !valueIsDiscarded, createAllExportExpressions);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForStatement(node) {
            return factory.updateForStatement(node, ts.visitNode(node.initializer, discardedValueVisitor, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, discardedValueVisitor, ts.isExpression), ts.visitIterationBody(node.statement, visitor, context));
        }
        function visitExpressionStatement(node) {
            return factory.updateExpressionStatement(node, ts.visitNode(node.expression, discardedValueVisitor, ts.isExpression));
        }
        function visitParenthesizedExpression(node, valueIsDiscarded) {
            return factory.updateParenthesizedExpression(node, ts.visitNode(node.expression, valueIsDiscarded ? discardedValueVisitor : visitor, ts.isExpression));
        }
        function visitPartiallyEmittedExpression(node, valueIsDiscarded) {
            return factory.updatePartiallyEmittedExpression(node, ts.visitNode(node.expression, valueIsDiscarded ? discardedValueVisitor : visitor, ts.isExpression));
        }
        function visitPreOrPostfixUnaryExpression(node, valueIsDiscarded) {
            if ((node.operator === 45 || node.operator === 46)
                && ts.isIdentifier(node.operand)
                && !ts.isGeneratedIdentifier(node.operand)
                && !ts.isLocalName(node.operand)
                && !ts.isDeclarationNameOfEnumOrNamespace(node.operand)) {
                var exportedNames = getExports(node.operand);
                if (exportedNames) {
                    var temp = void 0;
                    var expression = ts.visitNode(node.operand, visitor, ts.isExpression);
                    if (ts.isPrefixUnaryExpression(node)) {
                        expression = factory.updatePrefixUnaryExpression(node, expression);
                    }
                    else {
                        expression = factory.updatePostfixUnaryExpression(node, expression);
                        if (!valueIsDiscarded) {
                            temp = factory.createTempVariable(hoistVariableDeclaration);
                            expression = factory.createAssignment(temp, expression);
                            ts.setTextRange(expression, node);
                        }
                        expression = factory.createComma(expression, factory.cloneNode(node.operand));
                        ts.setTextRange(expression, node);
                    }
                    for (var _i = 0, exportedNames_1 = exportedNames; _i < exportedNames_1.length; _i++) {
                        var exportName = exportedNames_1[_i];
                        noSubstitution[ts.getNodeId(expression)] = true;
                        expression = createExportExpression(exportName, expression);
                        ts.setTextRange(expression, node);
                    }
                    if (temp) {
                        noSubstitution[ts.getNodeId(expression)] = true;
                        expression = factory.createComma(expression, temp);
                        ts.setTextRange(expression, node);
                    }
                    return expression;
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitImportCallExpression(node) {
            var externalModuleName = ts.getExternalModuleNameLiteral(factory, node, currentSourceFile, host, resolver, compilerOptions);
            var firstArgument = ts.visitNode(ts.firstOrUndefined(node.arguments), visitor);
            var argument = externalModuleName && (!firstArgument || !ts.isStringLiteral(firstArgument) || firstArgument.text !== externalModuleName.text) ? externalModuleName : firstArgument;
            var containsLexicalThis = !!(node.transformFlags & 8192);
            switch (compilerOptions.module) {
                case ts.ModuleKind.AMD:
                    return createImportCallExpressionAMD(argument, containsLexicalThis);
                case ts.ModuleKind.UMD:
                    return createImportCallExpressionUMD(argument !== null && argument !== void 0 ? argument : factory.createVoidZero(), containsLexicalThis);
                case ts.ModuleKind.CommonJS:
                default:
                    return createImportCallExpressionCommonJS(argument, containsLexicalThis);
            }
        }
        function createImportCallExpressionUMD(arg, containsLexicalThis) {
            needUMDDynamicImportHelper = true;
            if (ts.isSimpleCopiableExpression(arg)) {
                var argClone = ts.isGeneratedIdentifier(arg) ? arg : ts.isStringLiteral(arg) ? factory.createStringLiteralFromNode(arg) : ts.setEmitFlags(ts.setTextRange(factory.cloneNode(arg), arg), 1536);
                return factory.createConditionalExpression(factory.createIdentifier("__syncRequire"), undefined, createImportCallExpressionCommonJS(arg, containsLexicalThis), undefined, createImportCallExpressionAMD(argClone, containsLexicalThis));
            }
            else {
                var temp = factory.createTempVariable(hoistVariableDeclaration);
                return factory.createComma(factory.createAssignment(temp, arg), factory.createConditionalExpression(factory.createIdentifier("__syncRequire"), undefined, createImportCallExpressionCommonJS(temp, containsLexicalThis), undefined, createImportCallExpressionAMD(temp, containsLexicalThis)));
            }
        }
        function createImportCallExpressionAMD(arg, containsLexicalThis) {
            var resolve = factory.createUniqueName("resolve");
            var reject = factory.createUniqueName("reject");
            var parameters = [
                factory.createParameterDeclaration(undefined, undefined, undefined, resolve),
                factory.createParameterDeclaration(undefined, undefined, undefined, reject)
            ];
            var body = factory.createBlock([
                factory.createExpressionStatement(factory.createCallExpression(factory.createIdentifier("require"), undefined, [factory.createArrayLiteralExpression([arg || factory.createOmittedExpression()]), resolve, reject]))
            ]);
            var func;
            if (languageVersion >= 2) {
                func = factory.createArrowFunction(undefined, undefined, parameters, undefined, undefined, body);
            }
            else {
                func = factory.createFunctionExpression(undefined, undefined, undefined, undefined, parameters, undefined, body);
                if (containsLexicalThis) {
                    ts.setEmitFlags(func, 8);
                }
            }
            var promise = factory.createNewExpression(factory.createIdentifier("Promise"), undefined, [func]);
            if (compilerOptions.esModuleInterop) {
                return factory.createCallExpression(factory.createPropertyAccessExpression(promise, factory.createIdentifier("then")), undefined, [emitHelpers().createImportStarCallbackHelper()]);
            }
            return promise;
        }
        function createImportCallExpressionCommonJS(arg, containsLexicalThis) {
            var promiseResolveCall = factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Promise"), "resolve"), undefined, []);
            var requireCall = factory.createCallExpression(factory.createIdentifier("require"), undefined, arg ? [arg] : []);
            if (compilerOptions.esModuleInterop) {
                requireCall = emitHelpers().createImportStarHelper(requireCall);
            }
            var func;
            if (languageVersion >= 2) {
                func = factory.createArrowFunction(undefined, undefined, [], undefined, undefined, requireCall);
            }
            else {
                func = factory.createFunctionExpression(undefined, undefined, undefined, undefined, [], undefined, factory.createBlock([factory.createReturnStatement(requireCall)]));
                if (containsLexicalThis) {
                    ts.setEmitFlags(func, 8);
                }
            }
            return factory.createCallExpression(factory.createPropertyAccessExpression(promiseResolveCall, "then"), undefined, [func]);
        }
        function getHelperExpressionForExport(node, innerExpr) {
            if (!compilerOptions.esModuleInterop || ts.getEmitFlags(node) & 67108864) {
                return innerExpr;
            }
            if (ts.getExportNeedsImportStarHelper(node)) {
                return emitHelpers().createImportStarHelper(innerExpr);
            }
            return innerExpr;
        }
        function getHelperExpressionForImport(node, innerExpr) {
            if (!compilerOptions.esModuleInterop || ts.getEmitFlags(node) & 67108864) {
                return innerExpr;
            }
            if (ts.getImportNeedsImportStarHelper(node)) {
                return emitHelpers().createImportStarHelper(innerExpr);
            }
            if (ts.getImportNeedsImportDefaultHelper(node)) {
                return emitHelpers().createImportDefaultHelper(innerExpr);
            }
            return innerExpr;
        }
        function visitImportDeclaration(node) {
            var statements;
            var namespaceDeclaration = ts.getNamespaceDeclarationNode(node);
            if (moduleKind !== ts.ModuleKind.AMD) {
                if (!node.importClause) {
                    return ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(createRequireCall(node)), node), node);
                }
                else {
                    var variables = [];
                    if (namespaceDeclaration && !ts.isDefaultImport(node)) {
                        variables.push(factory.createVariableDeclaration(factory.cloneNode(namespaceDeclaration.name), undefined, undefined, getHelperExpressionForImport(node, createRequireCall(node))));
                    }
                    else {
                        variables.push(factory.createVariableDeclaration(factory.getGeneratedNameForNode(node), undefined, undefined, getHelperExpressionForImport(node, createRequireCall(node))));
                        if (namespaceDeclaration && ts.isDefaultImport(node)) {
                            variables.push(factory.createVariableDeclaration(factory.cloneNode(namespaceDeclaration.name), undefined, undefined, factory.getGeneratedNameForNode(node)));
                        }
                    }
                    statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createVariableStatement(undefined, factory.createVariableDeclarationList(variables, languageVersion >= 2 ? 2 : 0)), node), node));
                }
            }
            else if (namespaceDeclaration && ts.isDefaultImport(node)) {
                statements = ts.append(statements, factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                    ts.setOriginalNode(ts.setTextRange(factory.createVariableDeclaration(factory.cloneNode(namespaceDeclaration.name), undefined, undefined, factory.getGeneratedNameForNode(node)), node), node)
                ], languageVersion >= 2 ? 2 : 0)));
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfImportDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function createRequireCall(importNode) {
            var moduleName = ts.getExternalModuleNameLiteral(factory, importNode, currentSourceFile, host, resolver, compilerOptions);
            var args = [];
            if (moduleName) {
                args.push(moduleName);
            }
            return factory.createCallExpression(factory.createIdentifier("require"), undefined, args);
        }
        function visitImportEqualsDeclaration(node) {
            ts.Debug.assert(ts.isExternalModuleImportEqualsDeclaration(node), "import= for internal module references should be handled in an earlier transformer.");
            var statements;
            if (moduleKind !== ts.ModuleKind.AMD) {
                if (ts.hasSyntacticModifier(node, 1)) {
                    statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(createExportExpression(node.name, createRequireCall(node))), node), node));
                }
                else {
                    statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                        factory.createVariableDeclaration(factory.cloneNode(node.name), undefined, undefined, createRequireCall(node))
                    ], languageVersion >= 2 ? 2 : 0)), node), node));
                }
            }
            else {
                if (ts.hasSyntacticModifier(node, 1)) {
                    statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(createExportExpression(factory.getExportName(node), factory.getLocalName(node))), node), node));
                }
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfImportEqualsDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function visitExportDeclaration(node) {
            if (!node.moduleSpecifier) {
                return undefined;
            }
            var generatedName = factory.getGeneratedNameForNode(node);
            if (node.exportClause && ts.isNamedExports(node.exportClause)) {
                var statements = [];
                if (moduleKind !== ts.ModuleKind.AMD) {
                    statements.push(ts.setOriginalNode(ts.setTextRange(factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                        factory.createVariableDeclaration(generatedName, undefined, undefined, createRequireCall(node))
                    ])), node), node));
                }
                for (var _i = 0, _a = node.exportClause.elements; _i < _a.length; _i++) {
                    var specifier = _a[_i];
                    if (languageVersion === 0) {
                        statements.push(ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(emitHelpers().createCreateBindingHelper(generatedName, factory.createStringLiteralFromNode(specifier.propertyName || specifier.name), specifier.propertyName ? factory.createStringLiteralFromNode(specifier.name) : undefined)), specifier), specifier));
                    }
                    else {
                        var exportNeedsImportDefault = !!compilerOptions.esModuleInterop &&
                            !(ts.getEmitFlags(node) & 67108864) &&
                            ts.idText(specifier.propertyName || specifier.name) === "default";
                        var exportedValue = factory.createPropertyAccessExpression(exportNeedsImportDefault ? emitHelpers().createImportDefaultHelper(generatedName) : generatedName, specifier.propertyName || specifier.name);
                        statements.push(ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(createExportExpression(factory.getExportName(specifier), exportedValue, undefined, true)), specifier), specifier));
                    }
                }
                return ts.singleOrMany(statements);
            }
            else if (node.exportClause) {
                var statements = [];
                statements.push(ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(createExportExpression(factory.cloneNode(node.exportClause.name), getHelperExpressionForExport(node, moduleKind !== ts.ModuleKind.AMD ?
                    createRequireCall(node) :
                    ts.isExportNamespaceAsDefaultDeclaration(node) ? generatedName :
                        factory.createIdentifier(ts.idText(node.exportClause.name))))), node), node));
                return ts.singleOrMany(statements);
            }
            else {
                return ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(emitHelpers().createExportStarHelper(moduleKind !== ts.ModuleKind.AMD ? createRequireCall(node) : generatedName)), node), node);
            }
        }
        function visitExportAssignment(node) {
            if (node.isExportEquals) {
                return undefined;
            }
            var statements;
            var original = node.original;
            if (original && hasAssociatedEndOfDeclarationMarker(original)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportStatement(deferredExports[id], factory.createIdentifier("default"), ts.visitNode(node.expression, visitor), node, true);
            }
            else {
                statements = appendExportStatement(statements, factory.createIdentifier("default"), ts.visitNode(node.expression, visitor), node, true);
            }
            return ts.singleOrMany(statements);
        }
        function visitFunctionDeclaration(node) {
            var statements;
            if (ts.hasSyntacticModifier(node, 1)) {
                statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createFunctionDeclaration(undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, factory.getDeclarationName(node, true, true), undefined, ts.visitNodes(node.parameters, visitor), undefined, ts.visitEachChild(node.body, visitor, context)), node), node));
            }
            else {
                statements = ts.append(statements, ts.visitEachChild(node, visitor, context));
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfHoistedDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function visitClassDeclaration(node) {
            var statements;
            if (ts.hasSyntacticModifier(node, 1)) {
                statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createClassDeclaration(undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), factory.getDeclarationName(node, true, true), undefined, ts.visitNodes(node.heritageClauses, visitor), ts.visitNodes(node.members, visitor)), node), node));
            }
            else {
                statements = ts.append(statements, ts.visitEachChild(node, visitor, context));
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfHoistedDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function visitVariableStatement(node) {
            var statements;
            var variables;
            var expressions;
            if (ts.hasSyntacticModifier(node, 1)) {
                var modifiers = void 0;
                var removeCommentsOnExpressions = false;
                for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    if (ts.isIdentifier(variable.name) && ts.isLocalName(variable.name)) {
                        if (!modifiers) {
                            modifiers = ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier);
                        }
                        variables = ts.append(variables, variable);
                    }
                    else if (variable.initializer) {
                        if (!ts.isBindingPattern(variable.name) && (ts.isArrowFunction(variable.initializer) || ts.isFunctionExpression(variable.initializer) || ts.isClassExpression(variable.initializer))) {
                            var expression = factory.createAssignment(ts.setTextRange(factory.createPropertyAccessExpression(factory.createIdentifier("exports"), variable.name), variable.name), factory.createIdentifier(ts.getTextOfIdentifierOrLiteral(variable.name)));
                            var updatedVariable = factory.createVariableDeclaration(variable.name, variable.exclamationToken, variable.type, ts.visitNode(variable.initializer, visitor));
                            variables = ts.append(variables, updatedVariable);
                            expressions = ts.append(expressions, expression);
                            removeCommentsOnExpressions = true;
                        }
                        else {
                            expressions = ts.append(expressions, transformInitializedVariable(variable));
                        }
                    }
                }
                if (variables) {
                    statements = ts.append(statements, factory.updateVariableStatement(node, modifiers, factory.updateVariableDeclarationList(node.declarationList, variables)));
                }
                if (expressions) {
                    var statement = ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(factory.inlineExpressions(expressions)), node), node);
                    if (removeCommentsOnExpressions) {
                        ts.removeAllComments(statement);
                    }
                    statements = ts.append(statements, statement);
                }
            }
            else {
                statements = ts.append(statements, ts.visitEachChild(node, visitor, context));
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfVariableStatement(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function createAllExportExpressions(name, value, location) {
            var exportedNames = getExports(name);
            if (exportedNames) {
                var expression = ts.isExportName(name) ? value : factory.createAssignment(name, value);
                for (var _i = 0, exportedNames_2 = exportedNames; _i < exportedNames_2.length; _i++) {
                    var exportName = exportedNames_2[_i];
                    ts.setEmitFlags(expression, 4);
                    expression = createExportExpression(exportName, expression, location);
                }
                return expression;
            }
            return factory.createAssignment(name, value);
        }
        function transformInitializedVariable(node) {
            if (ts.isBindingPattern(node.name)) {
                return ts.flattenDestructuringAssignment(ts.visitNode(node, visitor), undefined, context, 0, false, createAllExportExpressions);
            }
            else {
                return factory.createAssignment(ts.setTextRange(factory.createPropertyAccessExpression(factory.createIdentifier("exports"), node.name), node.name), node.initializer ? ts.visitNode(node.initializer, visitor) : factory.createVoidZero());
            }
        }
        function visitMergeDeclarationMarker(node) {
            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === 235) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node.original);
            }
            return node;
        }
        function hasAssociatedEndOfDeclarationMarker(node) {
            return (ts.getEmitFlags(node) & 4194304) !== 0;
        }
        function visitEndOfDeclarationMarker(node) {
            var id = ts.getOriginalNodeId(node);
            var statements = deferredExports[id];
            if (statements) {
                delete deferredExports[id];
                return ts.append(statements, node);
            }
            return node;
        }
        function appendExportsOfImportDeclaration(statements, decl) {
            if (currentModuleInfo.exportEquals) {
                return statements;
            }
            var importClause = decl.importClause;
            if (!importClause) {
                return statements;
            }
            if (importClause.name) {
                statements = appendExportsOfDeclaration(statements, importClause);
            }
            var namedBindings = importClause.namedBindings;
            if (namedBindings) {
                switch (namedBindings.kind) {
                    case 266:
                        statements = appendExportsOfDeclaration(statements, namedBindings);
                        break;
                    case 267:
                        for (var _i = 0, _a = namedBindings.elements; _i < _a.length; _i++) {
                            var importBinding = _a[_i];
                            statements = appendExportsOfDeclaration(statements, importBinding, true);
                        }
                        break;
                }
            }
            return statements;
        }
        function appendExportsOfImportEqualsDeclaration(statements, decl) {
            if (currentModuleInfo.exportEquals) {
                return statements;
            }
            return appendExportsOfDeclaration(statements, decl);
        }
        function appendExportsOfVariableStatement(statements, node) {
            if (currentModuleInfo.exportEquals) {
                return statements;
            }
            for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                var decl = _a[_i];
                statements = appendExportsOfBindingElement(statements, decl);
            }
            return statements;
        }
        function appendExportsOfBindingElement(statements, decl) {
            if (currentModuleInfo.exportEquals) {
                return statements;
            }
            if (ts.isBindingPattern(decl.name)) {
                for (var _i = 0, _a = decl.name.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (!ts.isOmittedExpression(element)) {
                        statements = appendExportsOfBindingElement(statements, element);
                    }
                }
            }
            else if (!ts.isGeneratedIdentifier(decl.name)) {
                statements = appendExportsOfDeclaration(statements, decl);
            }
            return statements;
        }
        function appendExportsOfHoistedDeclaration(statements, decl) {
            if (currentModuleInfo.exportEquals) {
                return statements;
            }
            if (ts.hasSyntacticModifier(decl, 1)) {
                var exportName = ts.hasSyntacticModifier(decl, 512) ? factory.createIdentifier("default") : factory.getDeclarationName(decl);
                statements = appendExportStatement(statements, exportName, factory.getLocalName(decl), decl);
            }
            if (decl.name) {
                statements = appendExportsOfDeclaration(statements, decl);
            }
            return statements;
        }
        function appendExportsOfDeclaration(statements, decl, liveBinding) {
            var name = factory.getDeclarationName(decl);
            var exportSpecifiers = currentModuleInfo.exportSpecifiers.get(ts.idText(name));
            if (exportSpecifiers) {
                for (var _i = 0, exportSpecifiers_1 = exportSpecifiers; _i < exportSpecifiers_1.length; _i++) {
                    var exportSpecifier = exportSpecifiers_1[_i];
                    statements = appendExportStatement(statements, exportSpecifier.name, name, exportSpecifier.name, undefined, liveBinding);
                }
            }
            return statements;
        }
        function appendExportStatement(statements, exportName, expression, location, allowComments, liveBinding) {
            statements = ts.append(statements, createExportStatement(exportName, expression, location, allowComments, liveBinding));
            return statements;
        }
        function createUnderscoreUnderscoreESModule() {
            var statement;
            if (languageVersion === 0) {
                statement = factory.createExpressionStatement(createExportExpression(factory.createIdentifier("__esModule"), factory.createTrue()));
            }
            else {
                statement = factory.createExpressionStatement(factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "defineProperty"), undefined, [
                    factory.createIdentifier("exports"),
                    factory.createStringLiteral("__esModule"),
                    factory.createObjectLiteralExpression([
                        factory.createPropertyAssignment("value", factory.createTrue())
                    ])
                ]));
            }
            ts.setEmitFlags(statement, 1048576);
            return statement;
        }
        function createExportStatement(name, value, location, allowComments, liveBinding) {
            var statement = ts.setTextRange(factory.createExpressionStatement(createExportExpression(name, value, undefined, liveBinding)), location);
            ts.startOnNewLine(statement);
            if (!allowComments) {
                ts.setEmitFlags(statement, 1536);
            }
            return statement;
        }
        function createExportExpression(name, value, location, liveBinding) {
            return ts.setTextRange(liveBinding && languageVersion !== 0 ? factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "defineProperty"), undefined, [
                factory.createIdentifier("exports"),
                factory.createStringLiteralFromNode(name),
                factory.createObjectLiteralExpression([
                    factory.createPropertyAssignment("enumerable", factory.createTrue()),
                    factory.createPropertyAssignment("get", factory.createFunctionExpression(undefined, undefined, undefined, undefined, [], undefined, factory.createBlock([factory.createReturnStatement(value)])))
                ])
            ]) : factory.createAssignment(factory.createPropertyAccessExpression(factory.createIdentifier("exports"), factory.cloneNode(name)), value), location);
        }
        function modifierVisitor(node) {
            switch (node.kind) {
                case 93:
                case 88:
                    return undefined;
            }
            return node;
        }
        function onEmitNode(hint, node, emitCallback) {
            if (node.kind === 300) {
                currentSourceFile = node;
                currentModuleInfo = moduleInfoMap[ts.getOriginalNodeId(currentSourceFile)];
                previousOnEmitNode(hint, node, emitCallback);
                currentSourceFile = undefined;
                currentModuleInfo = undefined;
            }
            else {
                previousOnEmitNode(hint, node, emitCallback);
            }
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (node.id && noSubstitution[node.id]) {
                return node;
            }
            if (hint === 1) {
                return substituteExpression(node);
            }
            else if (ts.isShorthandPropertyAssignment(node)) {
                return substituteShorthandPropertyAssignment(node);
            }
            return node;
        }
        function substituteShorthandPropertyAssignment(node) {
            var name = node.name;
            var exportedOrImportedName = substituteExpressionIdentifier(name);
            if (exportedOrImportedName !== name) {
                if (node.objectAssignmentInitializer) {
                    var initializer = factory.createAssignment(exportedOrImportedName, node.objectAssignmentInitializer);
                    return ts.setTextRange(factory.createPropertyAssignment(name, initializer), node);
                }
                return ts.setTextRange(factory.createPropertyAssignment(name, exportedOrImportedName), node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79:
                    return substituteExpressionIdentifier(node);
                case 206:
                    return substituteCallExpression(node);
                case 208:
                    return substituteTaggedTemplateExpression(node);
                case 219:
                    return substituteBinaryExpression(node);
            }
            return node;
        }
        function substituteCallExpression(node) {
            if (ts.isIdentifier(node.expression)) {
                var expression = substituteExpressionIdentifier(node.expression);
                noSubstitution[ts.getNodeId(expression)] = true;
                if (!ts.isIdentifier(expression)) {
                    return ts.addEmitFlags(factory.updateCallExpression(node, expression, undefined, node.arguments), 536870912);
                }
            }
            return node;
        }
        function substituteTaggedTemplateExpression(node) {
            if (ts.isIdentifier(node.tag)) {
                var tag = substituteExpressionIdentifier(node.tag);
                noSubstitution[ts.getNodeId(tag)] = true;
                if (!ts.isIdentifier(tag)) {
                    return ts.addEmitFlags(factory.updateTaggedTemplateExpression(node, tag, undefined, node.template), 536870912);
                }
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            var _a, _b;
            if (ts.getEmitFlags(node) & 4096) {
                var externalHelpersModuleName = ts.getExternalHelpersModuleName(currentSourceFile);
                if (externalHelpersModuleName) {
                    return factory.createPropertyAccessExpression(externalHelpersModuleName, node);
                }
                return node;
            }
            else if (!(ts.isGeneratedIdentifier(node) && !(node.autoGenerateFlags & 64)) && !ts.isLocalName(node)) {
                var exportContainer = resolver.getReferencedExportContainer(node, ts.isExportName(node));
                if (exportContainer && exportContainer.kind === 300) {
                    return ts.setTextRange(factory.createPropertyAccessExpression(factory.createIdentifier("exports"), factory.cloneNode(node)), node);
                }
                var importDeclaration = resolver.getReferencedImportDeclaration(node);
                if (importDeclaration) {
                    if (ts.isImportClause(importDeclaration)) {
                        return ts.setTextRange(factory.createPropertyAccessExpression(factory.getGeneratedNameForNode(importDeclaration.parent), factory.createIdentifier("default")), node);
                    }
                    else if (ts.isImportSpecifier(importDeclaration)) {
                        var name = importDeclaration.propertyName || importDeclaration.name;
                        return ts.setTextRange(factory.createPropertyAccessExpression(factory.getGeneratedNameForNode(((_b = (_a = importDeclaration.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent) || importDeclaration), factory.cloneNode(name)), node);
                    }
                }
            }
            return node;
        }
        function substituteBinaryExpression(node) {
            if (ts.isAssignmentOperator(node.operatorToken.kind)
                && ts.isIdentifier(node.left)
                && !ts.isGeneratedIdentifier(node.left)
                && !ts.isLocalName(node.left)
                && !ts.isDeclarationNameOfEnumOrNamespace(node.left)) {
                var exportedNames = getExports(node.left);
                if (exportedNames) {
                    var expression = node;
                    for (var _i = 0, exportedNames_3 = exportedNames; _i < exportedNames_3.length; _i++) {
                        var exportName = exportedNames_3[_i];
                        noSubstitution[ts.getNodeId(expression)] = true;
                        expression = createExportExpression(exportName, expression, node);
                    }
                    return expression;
                }
            }
            return node;
        }
        function getExports(name) {
            if (!ts.isGeneratedIdentifier(name)) {
                var valueDeclaration = resolver.getReferencedImportDeclaration(name)
                    || resolver.getReferencedValueDeclaration(name);
                if (valueDeclaration) {
                    return currentModuleInfo
                        && currentModuleInfo.exportedBindings[ts.getOriginalNodeId(valueDeclaration)];
                }
            }
        }
    }
    ts.transformModule = transformModule;
    var dynamicImportUMDHelper = {
        name: "typescript:dynamicimport-sync-require",
        scoped: true,
        text: "\n            var __syncRequire = typeof module === \"object\" && typeof module.exports === \"object\";"
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformSystemModule(context) {
        var factory = context.factory, startLexicalEnvironment = context.startLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var compilerOptions = context.getCompilerOptions();
        var resolver = context.getEmitResolver();
        var host = context.getEmitHost();
        var previousOnSubstituteNode = context.onSubstituteNode;
        var previousOnEmitNode = context.onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        context.onEmitNode = onEmitNode;
        context.enableSubstitution(79);
        context.enableSubstitution(292);
        context.enableSubstitution(219);
        context.enableSubstitution(229);
        context.enableEmitNotification(300);
        var moduleInfoMap = [];
        var deferredExports = [];
        var exportFunctionsMap = [];
        var noSubstitutionMap = [];
        var contextObjectMap = [];
        var currentSourceFile;
        var moduleInfo;
        var exportFunction;
        var contextObject;
        var hoistedStatements;
        var enclosingBlockScopedContainer;
        var noSubstitution;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile || !(ts.isEffectiveExternalModule(node, compilerOptions) || node.transformFlags & 4194304)) {
                return node;
            }
            var id = ts.getOriginalNodeId(node);
            currentSourceFile = node;
            enclosingBlockScopedContainer = node;
            moduleInfo = moduleInfoMap[id] = ts.collectExternalModuleInfo(context, node, resolver, compilerOptions);
            exportFunction = factory.createUniqueName("exports");
            exportFunctionsMap[id] = exportFunction;
            contextObject = contextObjectMap[id] = factory.createUniqueName("context");
            var dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);
            var moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);
            var moduleBodyFunction = factory.createFunctionExpression(undefined, undefined, undefined, undefined, [
                factory.createParameterDeclaration(undefined, undefined, undefined, exportFunction),
                factory.createParameterDeclaration(undefined, undefined, undefined, contextObject)
            ], undefined, moduleBodyBlock);
            var moduleName = ts.tryGetModuleNameFromFile(factory, node, host, compilerOptions);
            var dependencies = factory.createArrayLiteralExpression(ts.map(dependencyGroups, function (dependencyGroup) { return dependencyGroup.name; }));
            var updated = ts.setEmitFlags(factory.updateSourceFile(node, ts.setTextRange(factory.createNodeArray([
                factory.createExpressionStatement(factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("System"), "register"), undefined, moduleName
                    ? [moduleName, dependencies, moduleBodyFunction]
                    : [dependencies, moduleBodyFunction]))
            ]), node.statements)), 1024);
            if (!ts.outFile(compilerOptions)) {
                ts.moveEmitHelpers(updated, moduleBodyBlock, function (helper) { return !helper.scoped; });
            }
            if (noSubstitution) {
                noSubstitutionMap[id] = noSubstitution;
                noSubstitution = undefined;
            }
            currentSourceFile = undefined;
            moduleInfo = undefined;
            exportFunction = undefined;
            contextObject = undefined;
            hoistedStatements = undefined;
            enclosingBlockScopedContainer = undefined;
            return updated;
        }
        function collectDependencyGroups(externalImports) {
            var groupIndices = new ts.Map();
            var dependencyGroups = [];
            for (var _i = 0, externalImports_1 = externalImports; _i < externalImports_1.length; _i++) {
                var externalImport = externalImports_1[_i];
                var externalModuleName = ts.getExternalModuleNameLiteral(factory, externalImport, currentSourceFile, host, resolver, compilerOptions);
                if (externalModuleName) {
                    var text = externalModuleName.text;
                    var groupIndex = groupIndices.get(text);
                    if (groupIndex !== undefined) {
                        dependencyGroups[groupIndex].externalImports.push(externalImport);
                    }
                    else {
                        groupIndices.set(text, dependencyGroups.length);
                        dependencyGroups.push({
                            name: externalModuleName,
                            externalImports: [externalImport]
                        });
                    }
                }
            }
            return dependencyGroups;
        }
        function createSystemModuleBody(node, dependencyGroups) {
            var statements = [];
            startLexicalEnvironment();
            var ensureUseStrict = ts.getStrictOptionValue(compilerOptions, "alwaysStrict") || (!compilerOptions.noImplicitUseStrict && ts.isExternalModule(currentSourceFile));
            var statementOffset = factory.copyPrologue(node.statements, statements, ensureUseStrict, topLevelVisitor);
            statements.push(factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                factory.createVariableDeclaration("__moduleName", undefined, undefined, factory.createLogicalAnd(contextObject, factory.createPropertyAccessExpression(contextObject, "id")))
            ])));
            ts.visitNode(moduleInfo.externalHelpersImportDeclaration, topLevelVisitor, ts.isStatement);
            var executeStatements = ts.visitNodes(node.statements, topLevelVisitor, ts.isStatement, statementOffset);
            ts.addRange(statements, hoistedStatements);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            var exportStarFunction = addExportStarIfNeeded(statements);
            var modifiers = node.transformFlags & 1048576 ?
                factory.createModifiersFromModifierFlags(256) :
                undefined;
            var moduleObject = factory.createObjectLiteralExpression([
                factory.createPropertyAssignment("setters", createSettersArray(exportStarFunction, dependencyGroups)),
                factory.createPropertyAssignment("execute", factory.createFunctionExpression(modifiers, undefined, undefined, undefined, [], undefined, factory.createBlock(executeStatements, true)))
            ], true);
            statements.push(factory.createReturnStatement(moduleObject));
            return factory.createBlock(statements, true);
        }
        function addExportStarIfNeeded(statements) {
            if (!moduleInfo.hasExportStarsToExportValues) {
                return;
            }
            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {
                var hasExportDeclarationWithExportClause = false;
                for (var _i = 0, _a = moduleInfo.externalImports; _i < _a.length; _i++) {
                    var externalImport = _a[_i];
                    if (externalImport.kind === 270 && externalImport.exportClause) {
                        hasExportDeclarationWithExportClause = true;
                        break;
                    }
                }
                if (!hasExportDeclarationWithExportClause) {
                    var exportStarFunction_1 = createExportStarFunction(undefined);
                    statements.push(exportStarFunction_1);
                    return exportStarFunction_1.name;
                }
            }
            var exportedNames = [];
            if (moduleInfo.exportedNames) {
                for (var _b = 0, _c = moduleInfo.exportedNames; _b < _c.length; _b++) {
                    var exportedLocalName = _c[_b];
                    if (exportedLocalName.escapedText === "default") {
                        continue;
                    }
                    exportedNames.push(factory.createPropertyAssignment(factory.createStringLiteralFromNode(exportedLocalName), factory.createTrue()));
                }
            }
            var exportedNamesStorageRef = factory.createUniqueName("exportedNames");
            statements.push(factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                factory.createVariableDeclaration(exportedNamesStorageRef, undefined, undefined, factory.createObjectLiteralExpression(exportedNames, true))
            ])));
            var exportStarFunction = createExportStarFunction(exportedNamesStorageRef);
            statements.push(exportStarFunction);
            return exportStarFunction.name;
        }
        function createExportStarFunction(localNames) {
            var exportStarFunction = factory.createUniqueName("exportStar");
            var m = factory.createIdentifier("m");
            var n = factory.createIdentifier("n");
            var exports = factory.createIdentifier("exports");
            var condition = factory.createStrictInequality(n, factory.createStringLiteral("default"));
            if (localNames) {
                condition = factory.createLogicalAnd(condition, factory.createLogicalNot(factory.createCallExpression(factory.createPropertyAccessExpression(localNames, "hasOwnProperty"), undefined, [n])));
            }
            return factory.createFunctionDeclaration(undefined, undefined, undefined, exportStarFunction, undefined, [factory.createParameterDeclaration(undefined, undefined, undefined, m)], undefined, factory.createBlock([
                factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                    factory.createVariableDeclaration(exports, undefined, undefined, factory.createObjectLiteralExpression([]))
                ])),
                factory.createForInStatement(factory.createVariableDeclarationList([
                    factory.createVariableDeclaration(n)
                ]), m, factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(condition, factory.createExpressionStatement(factory.createAssignment(factory.createElementAccessExpression(exports, n), factory.createElementAccessExpression(m, n)))), 1)
                ])),
                factory.createExpressionStatement(factory.createCallExpression(exportFunction, undefined, [exports]))
            ], true));
        }
        function createSettersArray(exportStarFunction, dependencyGroups) {
            var setters = [];
            for (var _i = 0, dependencyGroups_1 = dependencyGroups; _i < dependencyGroups_1.length; _i++) {
                var group_2 = dependencyGroups_1[_i];
                var localName = ts.forEach(group_2.externalImports, function (i) { return ts.getLocalNameForExternalImport(factory, i, currentSourceFile); });
                var parameterName = localName ? factory.getGeneratedNameForNode(localName) : factory.createUniqueName("");
                var statements = [];
                for (var _a = 0, _b = group_2.externalImports; _a < _b.length; _a++) {
                    var entry = _b[_a];
                    var importVariableName = ts.getLocalNameForExternalImport(factory, entry, currentSourceFile);
                    switch (entry.kind) {
                        case 264:
                            if (!entry.importClause) {
                                break;
                            }
                        case 263:
                            ts.Debug.assert(importVariableName !== undefined);
                            statements.push(factory.createExpressionStatement(factory.createAssignment(importVariableName, parameterName)));
                            break;
                        case 270:
                            ts.Debug.assert(importVariableName !== undefined);
                            if (entry.exportClause) {
                                if (ts.isNamedExports(entry.exportClause)) {
                                    var properties = [];
                                    for (var _c = 0, _d = entry.exportClause.elements; _c < _d.length; _c++) {
                                        var e = _d[_c];
                                        properties.push(factory.createPropertyAssignment(factory.createStringLiteral(ts.idText(e.name)), factory.createElementAccessExpression(parameterName, factory.createStringLiteral(ts.idText(e.propertyName || e.name)))));
                                    }
                                    statements.push(factory.createExpressionStatement(factory.createCallExpression(exportFunction, undefined, [factory.createObjectLiteralExpression(properties, true)])));
                                }
                                else {
                                    statements.push(factory.createExpressionStatement(factory.createCallExpression(exportFunction, undefined, [
                                        factory.createStringLiteral(ts.idText(entry.exportClause.name)),
                                        parameterName
                                    ])));
                                }
                            }
                            else {
                                statements.push(factory.createExpressionStatement(factory.createCallExpression(exportStarFunction, undefined, [parameterName])));
                            }
                            break;
                    }
                }
                setters.push(factory.createFunctionExpression(undefined, undefined, undefined, undefined, [factory.createParameterDeclaration(undefined, undefined, undefined, parameterName)], undefined, factory.createBlock(statements, true)));
            }
            return factory.createArrayLiteralExpression(setters, true);
        }
        function topLevelVisitor(node) {
            switch (node.kind) {
                case 264:
                    return visitImportDeclaration(node);
                case 263:
                    return visitImportEqualsDeclaration(node);
                case 270:
                    return visitExportDeclaration(node);
                case 269:
                    return visitExportAssignment(node);
                default:
                    return topLevelNestedVisitor(node);
            }
        }
        function visitImportDeclaration(node) {
            var statements;
            if (node.importClause) {
                hoistVariableDeclaration(ts.getLocalNameForExternalImport(factory, node, currentSourceFile));
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfImportDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function visitExportDeclaration(node) {
            ts.Debug.assertIsDefined(node);
            return undefined;
        }
        function visitImportEqualsDeclaration(node) {
            ts.Debug.assert(ts.isExternalModuleImportEqualsDeclaration(node), "import= for internal module references should be handled in an earlier transformer.");
            var statements;
            hoistVariableDeclaration(ts.getLocalNameForExternalImport(factory, node, currentSourceFile));
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfImportEqualsDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function visitExportAssignment(node) {
            if (node.isExportEquals) {
                return undefined;
            }
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var original = node.original;
            if (original && hasAssociatedEndOfDeclarationMarker(original)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportStatement(deferredExports[id], factory.createIdentifier("default"), expression, true);
            }
            else {
                return createExportStatement(factory.createIdentifier("default"), expression, true);
            }
        }
        function visitFunctionDeclaration(node) {
            if (ts.hasSyntacticModifier(node, 1)) {
                hoistedStatements = ts.append(hoistedStatements, factory.updateFunctionDeclaration(node, node.decorators, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, factory.getDeclarationName(node, true, true), undefined, ts.visitNodes(node.parameters, visitor, ts.isParameterDeclaration), undefined, ts.visitNode(node.body, visitor, ts.isBlock)));
            }
            else {
                hoistedStatements = ts.append(hoistedStatements, ts.visitEachChild(node, visitor, context));
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);
            }
            else {
                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);
            }
            return undefined;
        }
        function visitClassDeclaration(node) {
            var statements;
            var name = factory.getLocalName(node);
            hoistVariableDeclaration(name);
            statements = ts.append(statements, ts.setTextRange(factory.createExpressionStatement(factory.createAssignment(name, ts.setTextRange(factory.createClassExpression(ts.visitNodes(node.decorators, visitor, ts.isDecorator), undefined, node.name, undefined, ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause), ts.visitNodes(node.members, visitor, ts.isClassElement)), node))), node));
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfHoistedDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function visitVariableStatement(node) {
            if (!shouldHoistVariableDeclarationList(node.declarationList)) {
                return ts.visitNode(node, visitor, ts.isStatement);
            }
            var expressions;
            var isExportedDeclaration = ts.hasSyntacticModifier(node, 1);
            var isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);
            for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                var variable = _a[_i];
                if (variable.initializer) {
                    expressions = ts.append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));
                }
                else {
                    hoistBindingElement(variable);
                }
            }
            var statements;
            if (expressions) {
                statements = ts.append(statements, ts.setTextRange(factory.createExpressionStatement(factory.inlineExpressions(expressions)), node));
            }
            if (isMarkedDeclaration) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);
            }
            else {
                statements = appendExportsOfVariableStatement(statements, node, false);
            }
            return ts.singleOrMany(statements);
        }
        function hoistBindingElement(node) {
            if (ts.isBindingPattern(node.name)) {
                for (var _i = 0, _a = node.name.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (!ts.isOmittedExpression(element)) {
                        hoistBindingElement(element);
                    }
                }
            }
            else {
                hoistVariableDeclaration(factory.cloneNode(node.name));
            }
        }
        function shouldHoistVariableDeclarationList(node) {
            return (ts.getEmitFlags(node) & 2097152) === 0
                && (enclosingBlockScopedContainer.kind === 300
                    || (ts.getOriginalNode(node).flags & 3) === 0);
        }
        function transformInitializedVariable(node, isExportedDeclaration) {
            var createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;
            return ts.isBindingPattern(node.name)
                ? ts.flattenDestructuringAssignment(node, visitor, context, 0, false, createAssignment)
                : node.initializer ? createAssignment(node.name, ts.visitNode(node.initializer, visitor, ts.isExpression)) : node.name;
        }
        function createExportedVariableAssignment(name, value, location) {
            return createVariableAssignment(name, value, location, true);
        }
        function createNonExportedVariableAssignment(name, value, location) {
            return createVariableAssignment(name, value, location, false);
        }
        function createVariableAssignment(name, value, location, isExportedDeclaration) {
            hoistVariableDeclaration(factory.cloneNode(name));
            return isExportedDeclaration
                ? createExportExpression(name, preventSubstitution(ts.setTextRange(factory.createAssignment(name, value), location)))
                : preventSubstitution(ts.setTextRange(factory.createAssignment(name, value), location));
        }
        function visitMergeDeclarationMarker(node) {
            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === 235) {
                var id = ts.getOriginalNodeId(node);
                var isExportedDeclaration = ts.hasSyntacticModifier(node.original, 1);
                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node.original, isExportedDeclaration);
            }
            return node;
        }
        function hasAssociatedEndOfDeclarationMarker(node) {
            return (ts.getEmitFlags(node) & 4194304) !== 0;
        }
        function visitEndOfDeclarationMarker(node) {
            var id = ts.getOriginalNodeId(node);
            var statements = deferredExports[id];
            if (statements) {
                delete deferredExports[id];
                return ts.append(statements, node);
            }
            else {
                var original = ts.getOriginalNode(node);
                if (ts.isModuleOrEnumDeclaration(original)) {
                    return ts.append(appendExportsOfDeclaration(statements, original), node);
                }
            }
            return node;
        }
        function appendExportsOfImportDeclaration(statements, decl) {
            if (moduleInfo.exportEquals) {
                return statements;
            }
            var importClause = decl.importClause;
            if (!importClause) {
                return statements;
            }
            if (importClause.name) {
                statements = appendExportsOfDeclaration(statements, importClause);
            }
            var namedBindings = importClause.namedBindings;
            if (namedBindings) {
                switch (namedBindings.kind) {
                    case 266:
                        statements = appendExportsOfDeclaration(statements, namedBindings);
                        break;
                    case 267:
                        for (var _i = 0, _a = namedBindings.elements; _i < _a.length; _i++) {
                            var importBinding = _a[_i];
                            statements = appendExportsOfDeclaration(statements, importBinding);
                        }
                        break;
                }
            }
            return statements;
        }
        function appendExportsOfImportEqualsDeclaration(statements, decl) {
            if (moduleInfo.exportEquals) {
                return statements;
            }
            return appendExportsOfDeclaration(statements, decl);
        }
        function appendExportsOfVariableStatement(statements, node, exportSelf) {
            if (moduleInfo.exportEquals) {
                return statements;
            }
            for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                var decl = _a[_i];
                if (decl.initializer || exportSelf) {
                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);
                }
            }
            return statements;
        }
        function appendExportsOfBindingElement(statements, decl, exportSelf) {
            if (moduleInfo.exportEquals) {
                return statements;
            }
            if (ts.isBindingPattern(decl.name)) {
                for (var _i = 0, _a = decl.name.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (!ts.isOmittedExpression(element)) {
                        statements = appendExportsOfBindingElement(statements, element, exportSelf);
                    }
                }
            }
            else if (!ts.isGeneratedIdentifier(decl.name)) {
                var excludeName = void 0;
                if (exportSelf) {
                    statements = appendExportStatement(statements, decl.name, factory.getLocalName(decl));
                    excludeName = ts.idText(decl.name);
                }
                statements = appendExportsOfDeclaration(statements, decl, excludeName);
            }
            return statements;
        }
        function appendExportsOfHoistedDeclaration(statements, decl) {
            if (moduleInfo.exportEquals) {
                return statements;
            }
            var excludeName;
            if (ts.hasSyntacticModifier(decl, 1)) {
                var exportName = ts.hasSyntacticModifier(decl, 512) ? factory.createStringLiteral("default") : decl.name;
                statements = appendExportStatement(statements, exportName, factory.getLocalName(decl));
                excludeName = ts.getTextOfIdentifierOrLiteral(exportName);
            }
            if (decl.name) {
                statements = appendExportsOfDeclaration(statements, decl, excludeName);
            }
            return statements;
        }
        function appendExportsOfDeclaration(statements, decl, excludeName) {
            if (moduleInfo.exportEquals) {
                return statements;
            }
            var name = factory.getDeclarationName(decl);
            var exportSpecifiers = moduleInfo.exportSpecifiers.get(ts.idText(name));
            if (exportSpecifiers) {
                for (var _i = 0, exportSpecifiers_2 = exportSpecifiers; _i < exportSpecifiers_2.length; _i++) {
                    var exportSpecifier = exportSpecifiers_2[_i];
                    if (exportSpecifier.name.escapedText !== excludeName) {
                        statements = appendExportStatement(statements, exportSpecifier.name, name);
                    }
                }
            }
            return statements;
        }
        function appendExportStatement(statements, exportName, expression, allowComments) {
            statements = ts.append(statements, createExportStatement(exportName, expression, allowComments));
            return statements;
        }
        function createExportStatement(name, value, allowComments) {
            var statement = factory.createExpressionStatement(createExportExpression(name, value));
            ts.startOnNewLine(statement);
            if (!allowComments) {
                ts.setEmitFlags(statement, 1536);
            }
            return statement;
        }
        function createExportExpression(name, value) {
            var exportName = ts.isIdentifier(name) ? factory.createStringLiteralFromNode(name) : name;
            ts.setEmitFlags(value, ts.getEmitFlags(value) | 1536);
            return ts.setCommentRange(factory.createCallExpression(exportFunction, undefined, [exportName, value]), value);
        }
        function topLevelNestedVisitor(node) {
            switch (node.kind) {
                case 235:
                    return visitVariableStatement(node);
                case 254:
                    return visitFunctionDeclaration(node);
                case 255:
                    return visitClassDeclaration(node);
                case 240:
                    return visitForStatement(node, true);
                case 241:
                    return visitForInStatement(node);
                case 242:
                    return visitForOfStatement(node);
                case 238:
                    return visitDoStatement(node);
                case 239:
                    return visitWhileStatement(node);
                case 248:
                    return visitLabeledStatement(node);
                case 246:
                    return visitWithStatement(node);
                case 247:
                    return visitSwitchStatement(node);
                case 261:
                    return visitCaseBlock(node);
                case 287:
                    return visitCaseClause(node);
                case 288:
                    return visitDefaultClause(node);
                case 250:
                    return visitTryStatement(node);
                case 290:
                    return visitCatchClause(node);
                case 233:
                    return visitBlock(node);
                case 347:
                    return visitMergeDeclarationMarker(node);
                case 348:
                    return visitEndOfDeclarationMarker(node);
                default:
                    return visitor(node);
            }
        }
        function visitForStatement(node, isTopLevel) {
            var savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;
            enclosingBlockScopedContainer = node;
            node = factory.updateForStatement(node, ts.visitNode(node.initializer, isTopLevel ? visitForInitializer : discardedValueVisitor, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, discardedValueVisitor, ts.isExpression), ts.visitIterationBody(node.statement, isTopLevel ? topLevelNestedVisitor : visitor, context));
            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;
            return node;
        }
        function visitForInStatement(node) {
            var savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;
            enclosingBlockScopedContainer = node;
            node = factory.updateForInStatement(node, visitForInitializer(node.initializer), ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, topLevelNestedVisitor, context));
            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;
            return node;
        }
        function visitForOfStatement(node) {
            var savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;
            enclosingBlockScopedContainer = node;
            node = factory.updateForOfStatement(node, node.awaitModifier, visitForInitializer(node.initializer), ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, topLevelNestedVisitor, context));
            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;
            return node;
        }
        function shouldHoistForInitializer(node) {
            return ts.isVariableDeclarationList(node)
                && shouldHoistVariableDeclarationList(node);
        }
        function visitForInitializer(node) {
            if (shouldHoistForInitializer(node)) {
                var expressions = void 0;
                for (var _i = 0, _a = node.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    expressions = ts.append(expressions, transformInitializedVariable(variable, false));
                    if (!variable.initializer) {
                        hoistBindingElement(variable);
                    }
                }
                return expressions ? factory.inlineExpressions(expressions) : factory.createOmittedExpression();
            }
            else {
                return ts.visitNode(node, discardedValueVisitor, ts.isExpression);
            }
        }
        function visitDoStatement(node) {
            return factory.updateDoStatement(node, ts.visitIterationBody(node.statement, topLevelNestedVisitor, context), ts.visitNode(node.expression, visitor, ts.isExpression));
        }
        function visitWhileStatement(node) {
            return factory.updateWhileStatement(node, ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, topLevelNestedVisitor, context));
        }
        function visitLabeledStatement(node) {
            return factory.updateLabeledStatement(node, node.label, ts.visitNode(node.statement, topLevelNestedVisitor, ts.isStatement, factory.liftToBlock));
        }
        function visitWithStatement(node) {
            return factory.updateWithStatement(node, ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitNode(node.statement, topLevelNestedVisitor, ts.isStatement, factory.liftToBlock));
        }
        function visitSwitchStatement(node) {
            return factory.updateSwitchStatement(node, ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitNode(node.caseBlock, topLevelNestedVisitor, ts.isCaseBlock));
        }
        function visitCaseBlock(node) {
            var savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;
            enclosingBlockScopedContainer = node;
            node = factory.updateCaseBlock(node, ts.visitNodes(node.clauses, topLevelNestedVisitor, ts.isCaseOrDefaultClause));
            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;
            return node;
        }
        function visitCaseClause(node) {
            return factory.updateCaseClause(node, ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitNodes(node.statements, topLevelNestedVisitor, ts.isStatement));
        }
        function visitDefaultClause(node) {
            return ts.visitEachChild(node, topLevelNestedVisitor, context);
        }
        function visitTryStatement(node) {
            return ts.visitEachChild(node, topLevelNestedVisitor, context);
        }
        function visitCatchClause(node) {
            var savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;
            enclosingBlockScopedContainer = node;
            node = factory.updateCatchClause(node, node.variableDeclaration, ts.visitNode(node.block, topLevelNestedVisitor, ts.isBlock));
            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;
            return node;
        }
        function visitBlock(node) {
            var savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;
            enclosingBlockScopedContainer = node;
            node = ts.visitEachChild(node, topLevelNestedVisitor, context);
            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;
            return node;
        }
        function visitorWorker(node, valueIsDiscarded) {
            if (!(node.transformFlags & (2048 | 4194304 | 67108864))) {
                return node;
            }
            switch (node.kind) {
                case 240:
                    return visitForStatement(node, false);
                case 236:
                    return visitExpressionStatement(node);
                case 210:
                    return visitParenthesizedExpression(node, valueIsDiscarded);
                case 345:
                    return visitPartiallyEmittedExpression(node, valueIsDiscarded);
                case 219:
                    if (ts.isDestructuringAssignment(node)) {
                        return visitDestructuringAssignment(node, valueIsDiscarded);
                    }
                    break;
                case 206:
                    if (ts.isImportCall(node)) {
                        return visitImportCallExpression(node);
                    }
                    break;
                case 217:
                case 218:
                    return visitPrefixOrPostfixUnaryExpression(node, valueIsDiscarded);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            return visitorWorker(node, false);
        }
        function discardedValueVisitor(node) {
            return visitorWorker(node, true);
        }
        function visitExpressionStatement(node) {
            return factory.updateExpressionStatement(node, ts.visitNode(node.expression, discardedValueVisitor, ts.isExpression));
        }
        function visitParenthesizedExpression(node, valueIsDiscarded) {
            return factory.updateParenthesizedExpression(node, ts.visitNode(node.expression, valueIsDiscarded ? discardedValueVisitor : visitor, ts.isExpression));
        }
        function visitPartiallyEmittedExpression(node, valueIsDiscarded) {
            return factory.updatePartiallyEmittedExpression(node, ts.visitNode(node.expression, valueIsDiscarded ? discardedValueVisitor : visitor, ts.isExpression));
        }
        function visitImportCallExpression(node) {
            var externalModuleName = ts.getExternalModuleNameLiteral(factory, node, currentSourceFile, host, resolver, compilerOptions);
            var firstArgument = ts.visitNode(ts.firstOrUndefined(node.arguments), visitor);
            var argument = externalModuleName && (!firstArgument || !ts.isStringLiteral(firstArgument) || firstArgument.text !== externalModuleName.text) ? externalModuleName : firstArgument;
            return factory.createCallExpression(factory.createPropertyAccessExpression(contextObject, factory.createIdentifier("import")), undefined, argument ? [argument] : []);
        }
        function visitDestructuringAssignment(node, valueIsDiscarded) {
            if (hasExportedReferenceInDestructuringTarget(node.left)) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 0, !valueIsDiscarded);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function hasExportedReferenceInDestructuringTarget(node) {
            if (ts.isAssignmentExpression(node, true)) {
                return hasExportedReferenceInDestructuringTarget(node.left);
            }
            else if (ts.isSpreadElement(node)) {
                return hasExportedReferenceInDestructuringTarget(node.expression);
            }
            else if (ts.isObjectLiteralExpression(node)) {
                return ts.some(node.properties, hasExportedReferenceInDestructuringTarget);
            }
            else if (ts.isArrayLiteralExpression(node)) {
                return ts.some(node.elements, hasExportedReferenceInDestructuringTarget);
            }
            else if (ts.isShorthandPropertyAssignment(node)) {
                return hasExportedReferenceInDestructuringTarget(node.name);
            }
            else if (ts.isPropertyAssignment(node)) {
                return hasExportedReferenceInDestructuringTarget(node.initializer);
            }
            else if (ts.isIdentifier(node)) {
                var container = resolver.getReferencedExportContainer(node);
                return container !== undefined && container.kind === 300;
            }
            else {
                return false;
            }
        }
        function visitPrefixOrPostfixUnaryExpression(node, valueIsDiscarded) {
            if ((node.operator === 45 || node.operator === 46)
                && ts.isIdentifier(node.operand)
                && !ts.isGeneratedIdentifier(node.operand)
                && !ts.isLocalName(node.operand)
                && !ts.isDeclarationNameOfEnumOrNamespace(node.operand)) {
                var exportedNames = getExports(node.operand);
                if (exportedNames) {
                    var temp = void 0;
                    var expression = ts.visitNode(node.operand, visitor, ts.isExpression);
                    if (ts.isPrefixUnaryExpression(node)) {
                        expression = factory.updatePrefixUnaryExpression(node, expression);
                    }
                    else {
                        expression = factory.updatePostfixUnaryExpression(node, expression);
                        if (!valueIsDiscarded) {
                            temp = factory.createTempVariable(hoistVariableDeclaration);
                            expression = factory.createAssignment(temp, expression)