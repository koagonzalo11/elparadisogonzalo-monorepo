          emitFlags |= 2048;
                }
            }
            checkStrictModeFunctionName(node);
            if (inStrictMode) {
                checkStrictModeFunctionDeclaration(node);
                bindBlockScopedDeclaration(node, 16, 110991);
            }
            else {
                declareSymbolAndAddToSymbolTable(node, 16, 110991);
            }
        }
        function bindFunctionExpression(node) {
            if (!file.isDeclarationFile && !(node.flags & 8388608)) {
                if (ts.isAsyncFunction(node)) {
                    emitFlags |= 2048;
                }
            }
            if (currentFlow) {
                node.flowNode = currentFlow;
            }
            checkStrictModeFunctionName(node);
            var bindingName = node.name ? node.name.escapedText : "__function";
            return bindAnonymousDeclaration(node, 16, bindingName);
        }
        function bindPropertyOrMethodOrAccessor(node, symbolFlags, symbolExcludes) {
            if (!file.isDeclarationFile && !(node.flags & 8388608) && ts.isAsyncFunction(node)) {
                emitFlags |= 2048;
            }
            if (currentFlow && ts.isObjectLiteralOrClassExpressionMethod(node)) {
                node.flowNode = currentFlow;
            }
            return ts.hasDynamicName(node)
                ? bindAnonymousDeclaration(node, symbolFlags, "__computed")
                : declareSymbolAndAddToSymbolTable(node, symbolFlags, symbolExcludes);
        }
        function getInferTypeContainer(node) {
            var extendsType = ts.findAncestor(node, function (n) { return n.parent && ts.isConditionalTypeNode(n.parent) && n.parent.extendsType === n; });
            return extendsType && extendsType.parent;
        }
        function bindTypeParameter(node) {
            if (ts.isJSDocTemplateTag(node.parent)) {
                var container_1 = ts.find(node.parent.parent.tags, ts.isJSDocTypeAlias) || ts.getHostSignatureFromJSDoc(node.parent);
                if (container_1) {
                    if (!container_1.locals) {
                        container_1.locals = ts.createSymbolTable();
                    }
                    declareSymbol(container_1.locals, undefined, node, 262144, 526824);
                }
                else {
                    declareSymbolAndAddToSymbolTable(node, 262144, 526824);
                }
            }
            else if (node.parent.kind === 188) {
                var container_2 = getInferTypeContainer(node.parent);
                if (container_2) {
                    if (!container_2.locals) {
                        container_2.locals = ts.createSymbolTable();
                    }
                    declareSymbol(container_2.locals, undefined, node, 262144, 526824);
                }
                else {
                    bindAnonymousDeclaration(node, 262144, getDeclarationName(node));
                }
            }
            else {
                declareSymbolAndAddToSymbolTable(node, 262144, 526824);
            }
        }
        function shouldReportErrorOnModuleDeclaration(node) {
            var instanceState = getModuleInstanceState(node);
            return instanceState === 1 || (instanceState === 2 && ts.shouldPreserveConstEnums(options));
        }
        function checkUnreachable(node) {
            if (!(currentFlow.flags & 1)) {
                return false;
            }
            if (currentFlow === unreachableFlow) {
                var reportError = (ts.isStatementButNotDeclaration(node) && node.kind !== 234) ||
                    node.kind === 255 ||
                    (node.kind === 259 && shouldReportErrorOnModuleDeclaration(node));
                if (reportError) {
                    currentFlow = reportedUnreachableFlow;
                    if (!options.allowUnreachableCode) {
                        var isError_1 = ts.unreachableCodeIsError(options) &&
                            !(node.flags & 8388608) &&
                            (!ts.isVariableStatement(node) ||
                                !!(ts.getCombinedNodeFlags(node.declarationList) & 3) ||
                                node.declarationList.declarations.some(function (d) { return !!d.initializer; }));
                        eachUnreachableRange(node, function (start, end) { return errorOrSuggestionOnRange(isError_1, start, end, ts.Diagnostics.Unreachable_code_detected); });
                    }
                }
            }
            return true;
        }
    }
    function eachUnreachableRange(node, cb) {
        if (ts.isStatement(node) && isExecutableStatement(node) && ts.isBlock(node.parent)) {
            var statements = node.parent.statements;
            var slice_1 = ts.sliceAfter(statements, node);
            ts.getRangesWhere(slice_1, isExecutableStatement, function (start, afterEnd) { return cb(slice_1[start], slice_1[afterEnd - 1]); });
        }
        else {
            cb(node, node);
        }
    }
    function isExecutableStatement(s) {
        return !ts.isFunctionDeclaration(s) && !isPurelyTypeDeclaration(s) && !ts.isEnumDeclaration(s) &&
            !(ts.isVariableStatement(s) && !(ts.getCombinedNodeFlags(s) & (1 | 2)) && s.declarationList.declarations.some(function (d) { return !d.initializer; }));
    }
    function isPurelyTypeDeclaration(s) {
        switch (s.kind) {
            case 256:
            case 257:
                return true;
            case 259:
                return getModuleInstanceState(s) !== 1;
            case 258:
                return ts.hasSyntacticModifier(s, 2048);
            default:
                return false;
        }
    }
    function isExportsOrModuleExportsOrAlias(sourceFile, node) {
        var i = 0;
        var q = [node];
        while (q.length && i < 100) {
            i++;
            node = q.shift();
            if (ts.isExportsIdentifier(node) || ts.isModuleExportsAccessExpression(node)) {
                return true;
            }
            else if (ts.isIdentifier(node)) {
                var symbol = lookupSymbolForName(sourceFile, node.escapedText);
                if (!!symbol && !!symbol.valueDeclaration && ts.isVariableDeclaration(symbol.valueDeclaration) && !!symbol.valueDeclaration.initializer) {
                    var init = symbol.valueDeclaration.initializer;
                    q.push(init);
                    if (ts.isAssignmentExpression(init, true)) {
                        q.push(init.left);
                        q.push(init.right);
                    }
                }
            }
        }
        return false;
    }
    ts.isExportsOrModuleExportsOrAlias = isExportsOrModuleExportsOrAlias;
    function lookupSymbolForName(container, name) {
        var local = container.locals && container.locals.get(name);
        if (local) {
            return local.exportSymbol || local;
        }
        if (ts.isSourceFile(container) && container.jsGlobalAugmentations && container.jsGlobalAugmentations.has(name)) {
            return container.jsGlobalAugmentations.get(name);
        }
        return container.symbol && container.symbol.exports && container.symbol.exports.get(name);
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createGetSymbolWalker(getRestTypeOfSignature, getTypePredicateOfSignature, getReturnTypeOfSignature, getBaseTypes, resolveStructuredTypeMembers, getTypeOfSymbol, getResolvedSymbol, getConstraintOfTypeParameter, getFirstIdentifier, getTypeArguments) {
        return getSymbolWalker;
        function getSymbolWalker(accept) {
            if (accept === void 0) { accept = function () { return true; }; }
            var visitedTypes = [];
            var visitedSymbols = [];
            return {
                walkType: function (type) {
                    try {
                        visitType(type);
                        return { visitedTypes: ts.getOwnValues(visitedTypes), visitedSymbols: ts.getOwnValues(visitedSymbols) };
                    }
                    finally {
                        ts.clear(visitedTypes);
                        ts.clear(visitedSymbols);
                    }
                },
                walkSymbol: function (symbol) {
                    try {
                        visitSymbol(symbol);
                        return { visitedTypes: ts.getOwnValues(visitedTypes), visitedSymbols: ts.getOwnValues(visitedSymbols) };
                    }
                    finally {
                        ts.clear(visitedTypes);
                        ts.clear(visitedSymbols);
                    }
                },
            };
            function visitType(type) {
                if (!type) {
                    return;
                }
                if (visitedTypes[type.id]) {
                    return;
                }
                visitedTypes[type.id] = type;
                var shouldBail = visitSymbol(type.symbol);
                if (shouldBail)
                    return;
                if (type.flags & 524288) {
                    var objectType = type;
                    var objectFlags = objectType.objectFlags;
                    if (objectFlags & 4) {
                        visitTypeReference(type);
                    }
                    if (objectFlags & 32) {
                        visitMappedType(type);
                    }
                    if (objectFlags & (1 | 2)) {
                        visitInterfaceType(type);
                    }
                    if (objectFlags & (8 | 16)) {
                        visitObjectType(objectType);
                    }
                }
                if (type.flags & 262144) {
                    visitTypeParameter(type);
                }
                if (type.flags & 3145728) {
                    visitUnionOrIntersectionType(type);
                }
                if (type.flags & 4194304) {
                    visitIndexType(type);
                }
                if (type.flags & 8388608) {
                    visitIndexedAccessType(type);
                }
            }
            function visitTypeReference(type) {
                visitType(type.target);
                ts.forEach(getTypeArguments(type), visitType);
            }
            function visitTypeParameter(type) {
                visitType(getConstraintOfTypeParameter(type));
            }
            function visitUnionOrIntersectionType(type) {
                ts.forEach(type.types, visitType);
            }
            function visitIndexType(type) {
                visitType(type.type);
            }
            function visitIndexedAccessType(type) {
                visitType(type.objectType);
                visitType(type.indexType);
                visitType(type.constraint);
            }
            function visitMappedType(type) {
                visitType(type.typeParameter);
                visitType(type.constraintType);
                visitType(type.templateType);
                visitType(type.modifiersType);
            }
            function visitSignature(signature) {
                var typePredicate = getTypePredicateOfSignature(signature);
                if (typePredicate) {
                    visitType(typePredicate.type);
                }
                ts.forEach(signature.typeParameters, visitType);
                for (var _i = 0, _a = signature.parameters; _i < _a.length; _i++) {
                    var parameter = _a[_i];
                    visitSymbol(parameter);
                }
                visitType(getRestTypeOfSignature(signature));
                visitType(getReturnTypeOfSignature(signature));
            }
            function visitInterfaceType(interfaceT) {
                visitObjectType(interfaceT);
                ts.forEach(interfaceT.typeParameters, visitType);
                ts.forEach(getBaseTypes(interfaceT), visitType);
                visitType(interfaceT.thisType);
            }
            function visitObjectType(type) {
                var resolved = resolveStructuredTypeMembers(type);
                for (var _i = 0, _a = resolved.indexInfos; _i < _a.length; _i++) {
                    var info = _a[_i];
                    visitType(info.keyType);
                    visitType(info.type);
                }
                for (var _b = 0, _c = resolved.callSignatures; _b < _c.length; _b++) {
                    var signature = _c[_b];
                    visitSignature(signature);
                }
                for (var _d = 0, _e = resolved.constructSignatures; _d < _e.length; _d++) {
                    var signature = _e[_d];
                    visitSignature(signature);
                }
                for (var _f = 0, _g = resolved.properties; _f < _g.length; _f++) {
                    var p = _g[_f];
                    visitSymbol(p);
                }
            }
            function visitSymbol(symbol) {
                if (!symbol) {
                    return false;
                }
                var symbolId = ts.getSymbolId(symbol);
                if (visitedSymbols[symbolId]) {
                    return false;
                }
                visitedSymbols[symbolId] = symbol;
                if (!accept(symbol)) {
                    return true;
                }
                var t = getTypeOfSymbol(symbol);
                visitType(t);
                if (symbol.exports) {
                    symbol.exports.forEach(visitSymbol);
                }
                ts.forEach(symbol.declarations, function (d) {
                    if (d.type && d.type.kind === 179) {
                        var query = d.type;
                        var entity = getResolvedSymbol(getFirstIdentifier(query.exprName));
                        visitSymbol(entity);
                    }
                });
                return false;
            }
        }
    }
    ts.createGetSymbolWalker = createGetSymbolWalker;
})(ts || (ts = {}));
var ts;
(function (ts) {
    var ambientModuleSymbolRegex = /^".+"$/;
    var anon = "(anonymous)";
    var nextSymbolId = 1;
    var nextNodeId = 1;
    var nextMergeId = 1;
    var nextFlowId = 1;
    var typeofEQFacts = new ts.Map(ts.getEntries({
        string: 1,
        number: 2,
        bigint: 4,
        boolean: 8,
        symbol: 16,
        undefined: 65536,
        object: 32,
        function: 64
    }));
    var typeofNEFacts = new ts.Map(ts.getEntries({
        string: 256,
        number: 512,
        bigint: 1024,
        boolean: 2048,
        symbol: 4096,
        undefined: 524288,
        object: 8192,
        function: 16384
    }));
    var isNotOverloadAndNotAccessor = ts.and(isNotOverload, isNotAccessor);
    var intrinsicTypeKinds = new ts.Map(ts.getEntries({
        Uppercase: 0,
        Lowercase: 1,
        Capitalize: 2,
        Uncapitalize: 3
    }));
    function SymbolLinks() {
    }
    function NodeLinks() {
        this.flags = 0;
    }
    function getNodeId(node) {
        if (!node.id) {
            node.id = nextNodeId;
            nextNodeId++;
        }
        return node.id;
    }
    ts.getNodeId = getNodeId;
    function getSymbolId(symbol) {
        if (!symbol.id) {
            symbol.id = nextSymbolId;
            nextSymbolId++;
        }
        return symbol.id;
    }
    ts.getSymbolId = getSymbolId;
    function isInstantiatedModule(node, preserveConstEnums) {
        var moduleState = ts.getModuleInstanceState(node);
        return moduleState === 1 ||
            (preserveConstEnums && moduleState === 2);
    }
    ts.isInstantiatedModule = isInstantiatedModule;
    function createTypeChecker(host, produceDiagnostics) {
        var getPackagesSet = ts.memoize(function () {
            var set = new ts.Set();
            host.getSourceFiles().forEach(function (sf) {
                if (!sf.resolvedModules)
                    return;
                ts.forEachEntry(sf.resolvedModules, function (r) {
                    if (r && r.packageId)
                        set.add(r.packageId.name);
                });
            });
            return set;
        });
        var cancellationToken;
        var requestedExternalEmitHelpers;
        var externalHelpersModule;
        var Symbol = ts.objectAllocator.getSymbolConstructor();
        var Type = ts.objectAllocator.getTypeConstructor();
        var Signature = ts.objectAllocator.getSignatureConstructor();
        var typeCount = 0;
        var symbolCount = 0;
        var enumCount = 0;
        var totalInstantiationCount = 0;
        var instantiationCount = 0;
        var instantiationDepth = 0;
        var currentNode;
        var emptySymbols = ts.createSymbolTable();
        var arrayVariances = [1];
        var compilerOptions = host.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var moduleKind = ts.getEmitModuleKind(compilerOptions);
        var useDefineForClassFields = ts.getUseDefineForClassFields(compilerOptions);
        var allowSyntheticDefaultImports = ts.getAllowSyntheticDefaultImports(compilerOptions);
        var strictNullChecks = ts.getStrictOptionValue(compilerOptions, "strictNullChecks");
        var strictFunctionTypes = ts.getStrictOptionValue(compilerOptions, "strictFunctionTypes");
        var strictBindCallApply = ts.getStrictOptionValue(compilerOptions, "strictBindCallApply");
        var strictPropertyInitialization = ts.getStrictOptionValue(compilerOptions, "strictPropertyInitialization");
        var noImplicitAny = ts.getStrictOptionValue(compilerOptions, "noImplicitAny");
        var noImplicitThis = ts.getStrictOptionValue(compilerOptions, "noImplicitThis");
        var useUnknownInCatchVariables = ts.getStrictOptionValue(compilerOptions, "useUnknownInCatchVariables");
        var keyofStringsOnly = !!compilerOptions.keyofStringsOnly;
        var freshObjectLiteralFlag = compilerOptions.suppressExcessPropertyErrors ? 0 : 16384;
        var exactOptionalPropertyTypes = compilerOptions.exactOptionalPropertyTypes;
        var checkBinaryExpression = createCheckBinaryExpression();
        var emitResolver = createResolver();
        var nodeBuilder = createNodeBuilder();
        var globals = ts.createSymbolTable();
        var undefinedSymbol = createSymbol(4, "undefined");
        undefinedSymbol.declarations = [];
        var globalThisSymbol = createSymbol(1536, "globalThis", 8);
        globalThisSymbol.exports = globals;
        globalThisSymbol.declarations = [];
        globals.set(globalThisSymbol.escapedName, globalThisSymbol);
        var argumentsSymbol = createSymbol(4, "arguments");
        var requireSymbol = createSymbol(4, "require");
        var apparentArgumentCount;
        var checker = {
            getNodeCount: function () { return ts.sum(host.getSourceFiles(), "nodeCount"); },
            getIdentifierCount: function () { return ts.sum(host.getSourceFiles(), "identifierCount"); },
            getSymbolCount: function () { return ts.sum(host.getSourceFiles(), "symbolCount") + symbolCount; },
            getTypeCount: function () { return typeCount; },
            getInstantiationCount: function () { return totalInstantiationCount; },
            getRelationCacheSizes: function () { return ({
                assignable: assignableRelation.size,
                identity: identityRelation.size,
                subtype: subtypeRelation.size,
                strictSubtype: strictSubtypeRelation.size,
            }); },
            isUndefinedSymbol: function (symbol) { return symbol === undefinedSymbol; },
            isArgumentsSymbol: function (symbol) { return symbol === argumentsSymbol; },
            isUnknownSymbol: function (symbol) { return symbol === unknownSymbol; },
            getMergedSymbol: getMergedSymbol,
            getDiagnostics: getDiagnostics,
            getGlobalDiagnostics: getGlobalDiagnostics,
            getRecursionIdentity: getRecursionIdentity,
            getUnmatchedProperties: getUnmatchedProperties,
            getTypeOfSymbolAtLocation: function (symbol, locationIn) {
                var location = ts.getParseTreeNode(locationIn);
                return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;
            },
            getSymbolsOfParameterPropertyDeclaration: function (parameterIn, parameterName) {
                var parameter = ts.getParseTreeNode(parameterIn, ts.isParameter);
                if (parameter === undefined)
                    return ts.Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.");
                return getSymbolsOfParameterPropertyDeclaration(parameter, ts.escapeLeadingUnderscores(parameterName));
            },
            getDeclaredTypeOfSymbol: getDeclaredTypeOfSymbol,
            getPropertiesOfType: getPropertiesOfType,
            getPropertyOfType: function (type, name) { return getPropertyOfType(type, ts.escapeLeadingUnderscores(name)); },
            getPrivateIdentifierPropertyOfType: function (leftType, name, location) {
                var node = ts.getParseTreeNode(location);
                if (!node) {
                    return undefined;
                }
                var propName = ts.escapeLeadingUnderscores(name);
                var lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(propName, node);
                return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) : undefined;
            },
            getTypeOfPropertyOfType: function (type, name) { return getTypeOfPropertyOfType(type, ts.escapeLeadingUnderscores(name)); },
            getIndexInfoOfType: function (type, kind) { return getIndexInfoOfType(type, kind === 0 ? stringType : numberType); },
            getIndexInfosOfType: getIndexInfosOfType,
            getSignaturesOfType: getSignaturesOfType,
            getIndexTypeOfType: function (type, kind) { return getIndexTypeOfType(type, kind === 0 ? stringType : numberType); },
            getBaseTypes: getBaseTypes,
            getBaseTypeOfLiteralType: getBaseTypeOfLiteralType,
            getWidenedType: getWidenedType,
            getTypeFromTypeNode: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isTypeNode);
                return node ? getTypeFromTypeNode(node) : errorType;
            },
            getParameterType: getTypeAtPosition,
            getParameterIdentifierNameAtPosition: getParameterIdentifierNameAtPosition,
            getPromisedTypeOfPromise: getPromisedTypeOfPromise,
            getAwaitedType: function (type) { return getAwaitedType(type); },
            getReturnTypeOfSignature: getReturnTypeOfSignature,
            isNullableType: isNullableType,
            getNullableType: getNullableType,
            getNonNullableType: getNonNullableType,
            getNonOptionalType: removeOptionalTypeMarker,
            getTypeArguments: getTypeArguments,
            typeToTypeNode: nodeBuilder.typeToTypeNode,
            indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,
            signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,
            symbolToEntityName: nodeBuilder.symbolToEntityName,
            symbolToExpression: nodeBuilder.symbolToExpression,
            symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,
            symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,
            typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,
            getSymbolsInScope: function (locationIn, meaning) {
                var location = ts.getParseTreeNode(locationIn);
                return location ? getSymbolsInScope(location, meaning) : [];
            },
            getSymbolAtLocation: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn);
                return node ? getSymbolAtLocation(node, true) : undefined;
            },
            getIndexInfosAtLocation: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn);
                return node ? getIndexInfosAtLocation(node) : undefined;
            },
            getShorthandAssignmentValueSymbol: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn);
                return node ? getShorthandAssignmentValueSymbol(node) : undefined;
            },
            getExportSpecifierLocalTargetSymbol: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isExportSpecifier);
                return node ? getExportSpecifierLocalTargetSymbol(node) : undefined;
            },
            getExportSymbolOfSymbol: function (symbol) {
                return getMergedSymbol(symbol.exportSymbol || symbol);
            },
            getTypeAtLocation: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn);
                return node ? getTypeOfNode(node) : errorType;
            },
            getTypeOfAssignmentPattern: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isAssignmentPattern);
                return node && getTypeOfAssignmentPattern(node) || errorType;
            },
            getPropertySymbolOfDestructuringAssignment: function (locationIn) {
                var location = ts.getParseTreeNode(locationIn, ts.isIdentifier);
                return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined;
            },
            signatureToString: function (signature, enclosingDeclaration, flags, kind) {
                return signatureToString(signature, ts.getParseTreeNode(enclosingDeclaration), flags, kind);
            },
            typeToString: function (type, enclosingDeclaration, flags) {
                return typeToString(type, ts.getParseTreeNode(enclosingDeclaration), flags);
            },
            symbolToString: function (symbol, enclosingDeclaration, meaning, flags) {
                return symbolToString(symbol, ts.getParseTreeNode(enclosingDeclaration), meaning, flags);
            },
            typePredicateToString: function (predicate, enclosingDeclaration, flags) {
                return typePredicateToString(predicate, ts.getParseTreeNode(enclosingDeclaration), flags);
            },
            writeSignature: function (signature, enclosingDeclaration, flags, kind, writer) {
                return signatureToString(signature, ts.getParseTreeNode(enclosingDeclaration), flags, kind, writer);
            },
            writeType: function (type, enclosingDeclaration, flags, writer) {
                return typeToString(type, ts.getParseTreeNode(enclosingDeclaration), flags, writer);
            },
            writeSymbol: function (symbol, enclosingDeclaration, meaning, flags, writer) {
                return symbolToString(symbol, ts.getParseTreeNode(enclosingDeclaration), meaning, flags, writer);
            },
            writeTypePredicate: function (predicate, enclosingDeclaration, flags, writer) {
                return typePredicateToString(predicate, ts.getParseTreeNode(enclosingDeclaration), flags, writer);
            },
            getAugmentedPropertiesOfType: getAugmentedPropertiesOfType,
            getRootSymbols: getRootSymbols,
            getSymbolOfExpando: getSymbolOfExpando,
            getContextualType: function (nodeIn, contextFlags) {
                var node = ts.getParseTreeNode(nodeIn, ts.isExpression);
                if (!node) {
                    return undefined;
                }
                var containingCall = ts.findAncestor(node, ts.isCallLikeExpression);
                var containingCallResolvedSignature = containingCall && getNodeLinks(containingCall).resolvedSignature;
                if (contextFlags & 4 && containingCall) {
                    var toMarkSkip = node;
                    do {
                        getNodeLinks(toMarkSkip).skipDirectInference = true;
                        toMarkSkip = toMarkSkip.parent;
                    } while (toMarkSkip && toMarkSkip !== containingCall);
                    getNodeLinks(containingCall).resolvedSignature = undefined;
                }
                var result = getContextualType(node, contextFlags);
                if (contextFlags & 4 && containingCall) {
                    var toMarkSkip = node;
                    do {
                        getNodeLinks(toMarkSkip).skipDirectInference = undefined;
                        toMarkSkip = toMarkSkip.parent;
                    } while (toMarkSkip && toMarkSkip !== containingCall);
                    getNodeLinks(containingCall).resolvedSignature = containingCallResolvedSignature;
                }
                return result;
            },
            getContextualTypeForObjectLiteralElement: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isObjectLiteralElementLike);
                return node ? getContextualTypeForObjectLiteralElement(node) : undefined;
            },
            getContextualTypeForArgumentAtIndex: function (nodeIn, argIndex) {
                var node = ts.getParseTreeNode(nodeIn, ts.isCallLikeExpression);
                return node && getContextualTypeForArgumentAtIndex(node, argIndex);
            },
            getContextualTypeForJsxAttribute: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isJsxAttributeLike);
                return node && getContextualTypeForJsxAttribute(node);
            },
            isContextSensitive: isContextSensitive,
            getTypeOfPropertyOfContextualType: getTypeOfPropertyOfContextualType,
            getFullyQualifiedName: getFullyQualifiedName,
            getResolvedSignature: function (node, candidatesOutArray, argumentCount) {
                return getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, 0);
            },
            getResolvedSignatureForSignatureHelp: function (node, candidatesOutArray, argumentCount) {
                return getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, 16);
            },
            getExpandedParameters: getExpandedParameters,
            hasEffectiveRestParameter: hasEffectiveRestParameter,
            containsArgumentsReference: containsArgumentsReference,
            getConstantValue: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, canHaveConstantValue);
                return node ? getConstantValue(node) : undefined;
            },
            isValidPropertyAccess: function (nodeIn, propertyName) {
                var node = ts.getParseTreeNode(nodeIn, ts.isPropertyAccessOrQualifiedNameOrImportTypeNode);
                return !!node && isValidPropertyAccess(node, ts.escapeLeadingUnderscores(propertyName));
            },
            isValidPropertyAccessForCompletions: function (nodeIn, type, property) {
                var node = ts.getParseTreeNode(nodeIn, ts.isPropertyAccessExpression);
                return !!node && isValidPropertyAccessForCompletions(node, type, property);
            },
            getSignatureFromDeclaration: function (declarationIn) {
                var declaration = ts.getParseTreeNode(declarationIn, ts.isFunctionLike);
                return declaration ? getSignatureFromDeclaration(declaration) : undefined;
            },
            isImplementationOfOverload: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isFunctionLike);
                return node ? isImplementationOfOverload(node) : undefined;
            },
            getImmediateAliasedSymbol: getImmediateAliasedSymbol,
            getAliasedSymbol: resolveAlias,
            getEmitResolver: getEmitResolver,
            getExportsOfModule: getExportsOfModuleAsArray,
            getExportsAndPropertiesOfModule: getExportsAndPropertiesOfModule,
            forEachExportAndPropertyOfModule: forEachExportAndPropertyOfModule,
            getSymbolWalker: ts.createGetSymbolWalker(getRestTypeOfSignature, getTypePredicateOfSignature, getReturnTypeOfSignature, getBaseTypes, resolveStructuredTypeMembers, getTypeOfSymbol, getResolvedSymbol, getConstraintOfTypeParameter, ts.getFirstIdentifier, getTypeArguments),
            getAmbientModules: getAmbientModules,
            getJsxIntrinsicTagNamesAt: getJsxIntrinsicTagNamesAt,
            isOptionalParameter: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isParameter);
                return node ? isOptionalParameter(node) : false;
            },
            tryGetMemberInModuleExports: function (name, symbol) { return tryGetMemberInModuleExports(ts.escapeLeadingUnderscores(name), symbol); },
            tryGetMemberInModuleExportsAndProperties: function (name, symbol) { return tryGetMemberInModuleExportsAndProperties(ts.escapeLeadingUnderscores(name), symbol); },
            tryFindAmbientModule: function (moduleName) { return tryFindAmbientModule(moduleName, true); },
            tryFindAmbientModuleWithoutAugmentations: function (moduleName) {
                return tryFindAmbientModule(moduleName, false);
            },
            getApparentType: getApparentType,
            getUnionType: getUnionType,
            isTypeAssignableTo: isTypeAssignableTo,
            createAnonymousType: createAnonymousType,
            createSignature: createSignature,
            createSymbol: createSymbol,
            createIndexInfo: createIndexInfo,
            getAnyType: function () { return anyType; },
            getStringType: function () { return stringType; },
            getNumberType: function () { return numberType; },
            createPromiseType: createPromiseType,
            createArrayType: createArrayType,
            getElementTypeOfArrayType: getElementTypeOfArrayType,
            getBooleanType: function () { return booleanType; },
            getFalseType: function (fresh) { return fresh ? falseType : regularFalseType; },
            getTrueType: function (fresh) { return fresh ? trueType : regularTrueType; },
            getVoidType: function () { return voidType; },
            getUndefinedType: function () { return undefinedType; },
            getNullType: function () { return nullType; },
            getESSymbolType: function () { return esSymbolType; },
            getNeverType: function () { return neverType; },
            getOptionalType: function () { return optionalType; },
            isSymbolAccessible: isSymbolAccessible,
            isArrayType: isArrayType,
            isTupleType: isTupleType,
            isArrayLikeType: isArrayLikeType,
            isTypeInvalidDueToUnionDiscriminant: isTypeInvalidDueToUnionDiscriminant,
            getAllPossiblePropertiesOfTypes: getAllPossiblePropertiesOfTypes,
            getSuggestedSymbolForNonexistentProperty: getSuggestedSymbolForNonexistentProperty,
            getSuggestionForNonexistentProperty: getSuggestionForNonexistentProperty,
            getSuggestedSymbolForNonexistentJSXAttribute: getSuggestedSymbolForNonexistentJSXAttribute,
            getSuggestedSymbolForNonexistentSymbol: function (location, name, meaning) { return getSuggestedSymbolForNonexistentSymbol(location, ts.escapeLeadingUnderscores(name), meaning); },
            getSuggestionForNonexistentSymbol: function (location, name, meaning) { return getSuggestionForNonexistentSymbol(location, ts.escapeLeadingUnderscores(name), meaning); },
            getSuggestedSymbolForNonexistentModule: getSuggestedSymbolForNonexistentModule,
            getSuggestionForNonexistentExport: getSuggestionForNonexistentExport,
            getSuggestedSymbolForNonexistentClassMember: getSuggestedSymbolForNonexistentClassMember,
            getBaseConstraintOfType: getBaseConstraintOfType,
            getDefaultFromTypeParameter: function (type) { return type && type.flags & 262144 ? getDefaultFromTypeParameter(type) : undefined; },
            resolveName: function (name, location, meaning, excludeGlobals) {
                return resolveName(location, ts.escapeLeadingUnderscores(name), meaning, undefined, undefined, false, excludeGlobals);
            },
            getJsxNamespace: function (n) { return ts.unescapeLeadingUnderscores(getJsxNamespace(n)); },
            getJsxFragmentFactory: function (n) {
                var jsxFragmentFactory = getJsxFragmentFactoryEntity(n);
                return jsxFragmentFactory && ts.unescapeLeadingUnderscores(ts.getFirstIdentifier(jsxFragmentFactory).escapedText);
            },
            getAccessibleSymbolChain: getAccessibleSymbolChain,
            getTypePredicateOfSignature: getTypePredicateOfSignature,
            resolveExternalModuleName: function (moduleSpecifierIn) {
                var moduleSpecifier = ts.getParseTreeNode(moduleSpecifierIn, ts.isExpression);
                return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier, true);
            },
            resolveExternalModuleSymbol: resolveExternalModuleSymbol,
            tryGetThisTypeAt: function (nodeIn, includeGlobalThis) {
                var node = ts.getParseTreeNode(nodeIn);
                return node && tryGetThisTypeAt(node, includeGlobalThis);
            },
            getTypeArgumentConstraint: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isTypeNode);
                return node && getTypeArgumentConstraint(node);
            },
            getSuggestionDiagnostics: function (fileIn, ct) {
                var file = ts.getParseTreeNode(fileIn, ts.isSourceFile) || ts.Debug.fail("Could not determine parsed source file.");
                if (ts.skipTypeChecking(file, compilerOptions, host)) {
                    return ts.emptyArray;
                }
                var diagnostics;
                try {
                    cancellationToken = ct;
                    checkSourceFile(file);
                    ts.Debug.assert(!!(getNodeLinks(file).flags & 1));
                    diagnostics = ts.addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName));
                    checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), function (containingNode, kind, diag) {
                        if (!ts.containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & 8388608))) {
                            (diagnostics || (diagnostics = [])).push(__assign(__assign({}, diag), { category: ts.DiagnosticCategory.Suggestion }));
                        }
                    });
                    return diagnostics || ts.emptyArray;
                }
                finally {
                    cancellationToken = undefined;
                }
            },
            runWithCancellationToken: function (token, callback) {
                try {
                    cancellationToken = token;
                    return callback(checker);
                }
                finally {
                    cancellationToken = undefined;
                }
            },
            getLocalTypeParametersOfClassOrInterfaceOrTypeAlias: getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,
            isDeclarationVisible: isDeclarationVisible,
        };
        function getResolvedSignatureWorker(nodeIn, candidatesOutArray, argumentCount, checkMode) {
            var node = ts.getParseTreeNode(nodeIn, ts.isCallLikeExpression);
            apparentArgumentCount = argumentCount;
            var res = node ? getResolvedSignature(node, candidatesOutArray, checkMode) : undefined;
            apparentArgumentCount = undefined;
            return res;
        }
        var tupleTypes = new ts.Map();
        var unionTypes = new ts.Map();
        var intersectionTypes = new ts.Map();
        var stringLiteralTypes = new ts.Map();
        var numberLiteralTypes = new ts.Map();
        var bigIntLiteralTypes = new ts.Map();
        var enumLiteralTypes = new ts.Map();
        var indexedAccessTypes = new ts.Map();
        var templateLiteralTypes = new ts.Map();
        var stringMappingTypes = new ts.Map();
        var substitutionTypes = new ts.Map();
        var subtypeReductionCache = new ts.Map();
        var evolvingArrayTypes = [];
        var undefinedProperties = new ts.Map();
        var unknownSymbol = createSymbol(4, "unknown");
        var resolvingSymbol = createSymbol(0, "__resolving__");
        var anyType = createIntrinsicType(1, "any");
        var autoType = createIntrinsicType(1, "any");
        var wildcardType = createIntrinsicType(1, "any");
        var errorType = createIntrinsicType(1, "error");
        var nonInferrableAnyType = createIntrinsicType(1, "any", 131072);
        var intrinsicMarkerType = createIntrinsicType(1, "intrinsic");
        var unknownType = createIntrinsicType(2, "unknown");
        var undefinedType = createIntrinsicType(32768, "undefined");
        var undefinedWideningType = strictNullChecks ? undefinedType : createIntrinsicType(32768, "undefined", 131072);
        var optionalType = createIntrinsicType(32768, "undefined");
        var missingType = exactOptionalPropertyTypes ? createIntrinsicType(32768, "undefined") : undefinedType;
        var nullType = createIntrinsicType(65536, "null");
        var nullWideningType = strictNullChecks ? nullType : createIntrinsicType(65536, "null", 131072);
        var stringType = createIntrinsicType(4, "string");
        var numberType = createIntrinsicType(8, "number");
        var bigintType = createIntrinsicType(64, "bigint");
        var falseType = createIntrinsicType(512, "false");
        var regularFalseType = createIntrinsicType(512, "false");
        var trueType = createIntrinsicType(512, "true");
        var regularTrueType = createIntrinsicType(512, "true");
        trueType.regularType = regularTrueType;
        trueType.freshType = trueType;
        regularTrueType.regularType = regularTrueType;
        regularTrueType.freshType = trueType;
        falseType.regularType = regularFalseType;
        falseType.freshType = falseType;
        regularFalseType.regularType = regularFalseType;
        regularFalseType.freshType = falseType;
        var booleanType = getUnionType([regularFalseType, regularTrueType]);
        var esSymbolType = createIntrinsicType(4096, "symbol");
        var voidType = createIntrinsicType(16384, "void");
        var neverType = createIntrinsicType(131072, "never");
        var silentNeverType = createIntrinsicType(131072, "never");
        var nonInferrableType = createIntrinsicType(131072, "never", 524288);
        var implicitNeverType = createIntrinsicType(131072, "never");
        var unreachableNeverType = createIntrinsicType(131072, "never");
        var nonPrimitiveType = createIntrinsicType(67108864, "object");
        var stringOrNumberType = getUnionType([stringType, numberType]);
        var stringNumberSymbolType = getUnionType([stringType, numberType, esSymbolType]);
        var keyofConstraintType = keyofStringsOnly ? stringType : stringNumberSymbolType;
        var numberOrBigIntType = getUnionType([numberType, bigintType]);
        var templateConstraintType = getUnionType([stringType, numberType, booleanType, bigintType, nullType, undefinedType]);
        var restrictiveMapper = makeFunctionTypeMapper(function (t) { return t.flags & 262144 ? getRestrictiveTypeParameter(t) : t; });
        var permissiveMapper = makeFunctionTypeMapper(function (t) { return t.flags & 262144 ? wildcardType : t; });
        var emptyObjectType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        var emptyJsxObjectType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        emptyJsxObjectType.objectFlags |= 2048;
        var emptyTypeLiteralSymbol = createSymbol(2048, "__type");
        emptyTypeLiteralSymbol.members = ts.createSymbolTable();
        var emptyTypeLiteralType = createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        var emptyGenericType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        emptyGenericType.instantiations = new ts.Map();
        var anyFunctionType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        anyFunctionType.objectFlags |= 524288;
        var noConstraintType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        var circularConstraintType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        var resolvingDefaultType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        var markerSuperType = createTypeParameter();
        var markerSubType = createTypeParameter();
        markerSubType.constraint = markerSuperType;
        var markerOtherType = createTypeParameter();
        var noTypePredicate = createTypePredicate(1, "<<unresolved>>", 0, anyType);
        var anySignature = createSignature(undefined, undefined, undefined, ts.emptyArray, anyType, undefined, 0, 0);
        var unknownSignature = createSignature(undefined, undefined, undefined, ts.emptyArray, errorType, undefined, 0, 0);
        var resolvingSignature = createSignature(undefined, undefined, undefined, ts.emptyArray, anyType, undefined, 0, 0);
        var silentNeverSignature = createSignature(undefined, undefined, undefined, ts.emptyArray, silentNeverType, undefined, 0, 0);
        var enumNumberIndexInfo = createIndexInfo(numberType, stringType, true);
        var iterationTypesCache = new ts.Map();
        var noIterationTypes = {
            get yieldType() { return ts.Debug.fail("Not supported"); },
            get returnType() { return ts.Debug.fail("Not supported"); },
            get nextType() { return ts.Debug.fail("Not supported"); },
        };
        var anyIterationTypes = createIterationTypes(anyType, anyType, anyType);
        var anyIterationTypesExceptNext = createIterationTypes(anyType, anyType, unknownType);
        var defaultIterationTypes = createIterationTypes(neverType, anyType, undefinedType);
        var asyncIterationTypesResolver = {
            iterableCacheKey: "iterationTypesOfAsyncIterable",
            iteratorCacheKey: "iterationTypesOfAsyncIterator",
            iteratorSymbolName: "asyncIterator",
            getGlobalIteratorType: getGlobalAsyncIteratorType,
            getGlobalIterableType: getGlobalAsyncIterableType,
            getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,
            getGlobalGeneratorType: getGlobalAsyncGeneratorType,
            resolveIterationType: getAwaitedType,
            mustHaveANextMethodDiagnostic: ts.Diagnostics.An_async_iterator_must_have_a_next_method,
            mustBeAMethodDiagnostic: ts.Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,
            mustHaveAValueDiagnostic: ts.Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,
        };
        var syncIterationTypesResolver = {
            iterableCacheKey: "iterationTypesOfIterable",
            iteratorCacheKey: "iterationTypesOfIterator",
            iteratorSymbolName: "iterator",
            getGlobalIteratorType: getGlobalIteratorType,
            getGlobalIterableType: getGlobalIterableType,
            getGlobalIterableIteratorType: getGlobalIterableIteratorType,
            getGlobalGeneratorType: getGlobalGeneratorType,
            resolveIterationType: function (type, _errorNode) { return type; },
            mustHaveANextMethodDiagnostic: ts.Diagnostics.An_iterator_must_have_a_next_method,
            mustBeAMethodDiagnostic: ts.Diagnostics.The_0_property_of_an_iterator_must_be_a_method,
            mustHaveAValueDiagnostic: ts.Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,
        };
        var amalgamatedDuplicates;
        var reverseMappedCache = new ts.Map();
        var inInferTypeForHomomorphicMappedType = false;
        var ambientModulesCache;
        var patternAmbientModules;
        var patternAmbientModuleAugmentations;
        var globalObjectType;
        var globalFunctionType;
        var globalCallableFunctionType;
        var globalNewableFunctionType;
        var globalArrayType;
        var globalReadonlyArrayType;
        var globalStringType;
        var globalNumberType;
        var globalBooleanType;
        var globalRegExpType;
        var globalThisType;
        var anyArrayType;
        var autoArrayType;
        var anyReadonlyArrayType;
        var deferredGlobalNonNullableTypeAlias;
        var deferredGlobalESSymbolConstructorSymbol;
        var deferredGlobalESSymbolConstructorTypeSymbol;
        var deferredGlobalESSymbolType;
        var deferredGlobalTypedPropertyDescriptorType;
        var deferredGlobalPromiseType;
        var deferredGlobalPromiseLikeType;
        var deferredGlobalPromiseConstructorSymbol;
        var deferredGlobalPromiseConstructorLikeType;
        var deferredGlobalIterableType;
        var deferredGlobalIteratorType;
        var deferredGlobalIterableIteratorType;
        var deferredGlobalGeneratorType;
        var deferredGlobalIteratorYieldResultType;
        var deferredGlobalIteratorReturnResultType;
        var deferredGlobalAsyncIterableType;
        var deferredGlobalAsyncIteratorType;
        var deferredGlobalAsyncIterableIteratorType;
        var deferredGlobalAsyncGeneratorType;
        var deferredGlobalTemplateStringsArrayType;
        var deferredGlobalImportMetaType;
        var deferredGlobalImportMetaExpressionType;
        var deferredGlobalExtractSymbol;
        var deferredGlobalOmitSymbol;
        var deferredGlobalBigIntType;
        var allPotentiallyUnusedIdentifiers = new ts.Map();
        var flowLoopStart = 0;
        var flowLoopCount = 0;
        var sharedFlowCount = 0;
        var flowAnalysisDisabled = false;
        var flowInvocationCount = 0;
        var lastFlowNode;
        var lastFlowNodeReachable;
        var flowTypeCache;
        var emptyStringType = getStringLiteralType("");
        var zeroType = getNumberLiteralType(0);
        var zeroBigIntType = getBigIntLiteralType({ negative: false, base10Value: "0" });
        var resolutionTargets = [];
        var resolutionResults = [];
        var resolutionPropertyNames = [];
        var suggestionCount = 0;
        var maximumSuggestionCount = 10;
        var mergedSymbols = [];
        var symbolLinks = [];
        var nodeLinks = [];
        var flowLoopCaches = [];
        var flowLoopNodes = [];
        var flowLoopKeys = [];
        var flowLoopTypes = [];
        var sharedFlowNodes = [];
        var sharedFlowTypes = [];
        var flowNodeReachable = [];
        var flowNodePostSuper = [];
        var potentialThisCollisions = [];
        var potentialNewTargetCollisions = [];
        var potentialWeakMapSetCollisions = [];
        var potentialReflectCollisions = [];
        var awaitedTypeStack = [];
        var diagnostics = ts.createDiagnosticCollection();
        var suggestionDiagnostics = ts.createDiagnosticCollection();
        var typeofTypesByName = new ts.Map(ts.getEntries({
            string: stringType,
            number: numberType,
            bigint: bigintType,
            boolean: booleanType,
            symbol: esSymbolType,
            undefined: undefinedType
        }));
        var typeofType = createTypeofType();
        var _jsxNamespace;
        var _jsxFactoryEntity;
        var outofbandVarianceMarkerHandler;
        var subtypeRelation = new ts.Map();
        var strictSubtypeRelation = new ts.Map();
        var assignableRelation = new ts.Map();
        var comparableRelation = new ts.Map();
        var identityRelation = new ts.Map();
        var enumRelation = new ts.Map();
        var builtinGlobals = ts.createSymbolTable();
        builtinGlobals.set(undefinedSymbol.escapedName, undefinedSymbol);
        initializeTypeChecker();
        return checker;
        function getJsxNamespace(location) {
            if (location) {
                var file = ts.getSourceFileOfNode(location);
                if (file) {
                    if (ts.isJsxOpeningFragment(location)) {
                        if (file.localJsxFragmentNamespace) {
                            return file.localJsxFragmentNamespace;
                        }
                        var jsxFragmentPragma = file.pragmas.get("jsxfrag");
                        if (jsxFragmentPragma) {
                            var chosenPragma = ts.isArray(jsxFragmentPragma) ? jsxFragmentPragma[0] : jsxFragmentPragma;
                            file.localJsxFragmentFactory = ts.parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion);
                            ts.visitNode(file.localJsxFragmentFactory, markAsSynthetic);
                            if (file.localJsxFragmentFactory) {
                                return file.localJsxFragmentNamespace = ts.getFirstIdentifier(file.localJsxFragmentFactory).escapedText;
                            }
                        }
                        var entity = getJsxFragmentFactoryEntity(location);
                        if (entity) {
                            file.localJsxFragmentFactory = entity;
                            return file.localJsxFragmentNamespace = ts.getFirstIdentifier(entity).escapedText;
                        }
                    }
                    else {
                        if (file.localJsxNamespace) {
                            return file.localJsxNamespace;
                        }
                        var jsxPragma = file.pragmas.get("jsx");
                        if (jsxPragma) {
                            var chosenPragma = ts.isArray(jsxPragma) ? jsxPragma[0] : jsxPragma;
                            file.localJsxFactory = ts.parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion);
                            ts.visitNode(file.localJsxFactory, markAsSynthetic);
                            if (file.localJsxFactory) {
                                return file.localJsxNamespace = ts.getFirstIdentifier(file.localJsxFactory).escapedText;
                            }
                        }
                    }
                }
            }
            if (!_jsxNamespace) {
                _jsxNamespace = "React";
                if (compilerOptions.jsxFactory) {
                    _jsxFactoryEntity = ts.parseIsolatedEntityName(compilerOptions.jsxFactory, languageVersion);
                    ts.visitNode(_jsxFactoryEntity, markAsSynthetic);
                    if (_jsxFactoryEntity) {
                        _jsxNamespace = ts.getFirstIdentifier(_jsxFactoryEntity).escapedText;
                    }
                }
                else if (compilerOptions.reactNamespace) {
                    _jsxNamespace = ts.escapeLeadingUnderscores(compilerOptions.reactNamespace);
                }
            }
            if (!_jsxFactoryEntity) {
                _jsxFactoryEntity = ts.factory.createQualifiedName(ts.factory.createIdentifier(ts.unescapeLeadingUnderscores(_jsxNamespace)), "createElement");
            }
            return _jsxNamespace;
            function markAsSynthetic(node) {
                ts.setTextRangePosEnd(node, -1, -1);
                return ts.visitEachChild(node, markAsSynthetic, ts.nullTransformationContext);
            }
        }
        function getEmitResolver(sourceFile, cancellationToken) {
            getDiagnostics(sourceFile, cancellationToken);
            return emitResolver;
        }
        function lookupOrIssueError(location, message, arg0, arg1, arg2, arg3) {
            var diagnostic = location
                ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3)
                : ts.createCompilerDiagnostic(message, arg0, arg1, arg2, arg3);
            var existing = diagnostics.lookup(diagnostic);
            if (existing) {
                return existing;
            }
            else {
                diagnostics.add(diagnostic);
                return diagnostic;
            }
        }
        function errorSkippedOn(key, location, message, arg0, arg1, arg2, arg3) {
            var diagnostic = error(location, message, arg0, arg1, arg2, arg3);
            diagnostic.skippedOn = key;
            return diagnostic;
        }
        function createError(location, message, arg0, arg1, arg2, arg3) {
            return location
                ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3)
                : ts.createCompilerDiagnostic(message, arg0, arg1, arg2, arg3);
        }
        function error(location, message, arg0, arg1, arg2, arg3) {
            var diagnostic = createError(location, message, arg0, arg1, arg2, arg3);
            diagnostics.add(diagnostic);
            return diagnostic;
        }
        function addErrorOrSuggestion(isError, diagnostic) {
            if (isError) {
                diagnostics.add(diagnostic);
            }
            else {
                suggestionDiagnostics.add(__assign(__assign({}, diagnostic), { category: ts.DiagnosticCategory.Suggestion }));
            }
        }
        function errorOrSuggestion(isError, location, message, arg0, arg1, arg2, arg3) {
            if (location.pos < 0 || location.end < 0) {
                if (!isError) {
                    return;
                }
                var file = ts.getSourceFileOfNode(location);
                addErrorOrSuggestion(isError, "message" in message ? ts.createFileDiagnostic(file, 0, 0, message, arg0, arg1, arg2, arg3) : ts.createDiagnosticForFileFromMessageChain(file, message));
                return;
            }
            addErrorOrSuggestion(isError, "message" in message ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3) : ts.createDiagnosticForNodeFromMessageChain(location, message));
        }
        function errorAndMaybeSuggestAwait(location, maybeMissingAwait, message, arg0, arg1, arg2, arg3) {
            var diagnostic = error(location, message, arg0, arg1, arg2, arg3);
            if (maybeMissingAwait) {
                var related = ts.createDiagnosticForNode(location, ts.Diagnostics.Did_you_forget_to_use_await);
                ts.addRelatedInfo(diagnostic, related);
            }
            return diagnostic;
        }
        function addDeprecatedSuggestionWorker(declarations, diagnostic) {
            var deprecatedTag = Array.isArray(declarations) ? ts.forEach(declarations, ts.getJSDocDeprecatedTag) : ts.getJSDocDeprecatedTag(declarations);
            if (deprecatedTag) {
                ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(deprecatedTag, ts.Diagnostics.The_declaration_was_marked_as_deprecated_here));
            }
            suggestionDiagnostics.add(diagnostic);
            return diagnostic;
        }
        function addDeprecatedSuggestion(location, declarations, deprecatedEntity) {
            var diagnostic = ts.createDiagnosticForNode(location, ts.Diagnostics._0_is_deprecated, deprecatedEntity);
            return addDeprecatedSuggestionWorker(declarations, diagnostic);
        }
        function addDeprecatedSuggestionWithSignature(location, declaration, deprecatedEntity, signatureString) {
            var diagnostic = deprecatedEntity
                ? ts.createDiagnosticForNode(location, ts.Diagnostics.The_signature_0_of_1_is_deprecated, signatureString, deprecatedEntity)
                : ts.createDiagnosticForNode(location, ts.Diagnostics._0_is_deprecated, signatureString);
            return addDeprecatedSuggestionWorker(declaration, diagnostic);
        }
        function createSymbol(flags, name, checkFlags) {
            symbolCount++;
            var symbol = new Symbol(flags | 33554432, name);
            symbol.checkFlags = checkFlags || 0;
            return symbol;
        }
        function getExcludedSymbolFlags(flags) {
            var result = 0;
            if (flags & 2)
                result |= 111551;
            if (flags & 1)
                result |= 111550;
            if (flags & 4)
                result |= 0;
            if (flags & 8)
                result |= 900095;
            if (flags & 16)
                result |= 110991;
            if (flags & 32)
                result |= 899503;
            if (flags & 64)
                result |= 788872;
            if (flags & 256)
                result |= 899327;
            if (flags & 128)
                result |= 899967;
            if (flags & 512)
                result |= 110735;
            if (flags & 8192)
                result |= 103359;
            if (flags & 32768)
                result |= 46015;
            if (flags & 65536)
                result |= 78783;
            if (flags & 262144)
                result |= 526824;
            if (flags & 524288)
                result |= 788968;
            if (flags & 2097152)
                result |= 2097152;
            return result;
        }
        function recordMergedSymbol(target, source) {
            if (!source.mergeId) {
                source.mergeId = nextMergeId;
                nextMergeId++;
            }
            mergedSymbols[source.mergeId] = target;
        }
        function cloneSymbol(symbol) {
            var result = createSymbol(symbol.flags, symbol.escapedName);
            result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
            result.parent = symbol.parent;
            if (symbol.valueDeclaration)
                result.valueDeclaration = symbol.valueDeclaration;
            if (symbol.constEnumOnlyModule)
                result.constEnumOnlyModule = true;
            if (symbol.members)
                result.members = new ts.Map(symbol.members);
            if (symbol.exports)
                result.exports = new ts.Map(symbol.exports);
            recordMergedSymbol(result, symbol);
            return result;
        }
        function mergeSymbol(target, source, unidirectional) {
            if (unidirectional === void 0) { unidirectional = false; }
            if (!(target.flags & getExcludedSymbolFlags(source.flags)) ||
                (source.flags | target.flags) & 67108864) {
                if (source === target) {
                    return target;
                }
                if (!(target.flags & 33554432)) {
                    var resolvedTarget = resolveSymbol(target);
                    if (resolvedTarget === unknownSymbol) {
                        return source;
                    }
                    target = cloneSymbol(resolvedTarget);
                }
                if (source.flags & 512 && target.flags & 512 && target.constEnumOnlyModule && !source.constEnumOnlyModule) {
                    target.constEnumOnlyModule = false;
                }
                target.flags |= source.flags;
                if (source.valueDeclaration) {
                    ts.setValueDeclaration(target, source.valueDeclaration);
                }
                ts.addRange(target.declarations, source.declarations);
                if (source.members) {
                    if (!target.members)
                        target.members = ts.createSymbolTable();
                    mergeSymbolTable(target.members, source.members, unidirectional);
                }
                if (source.exports) {
                    if (!target.exports)
                        target.exports = ts.createSymbolTable();
                    mergeSymbolTable(target.exports, source.exports, unidirectional);
                }
                if (!unidirectional) {
                    recordMergedSymbol(target, source);
                }
            }
            else if (target.flags & 1024) {
                if (target !== globalThisSymbol) {
                    error(source.declarations && ts.getNameOfDeclaration(source.declarations[0]), ts.Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity, symbolToString(target));
                }
            }
            else {
                var isEitherEnum = !!(target.flags & 384 || source.flags & 384);
                var isEitherBlockScoped_1 = !!(target.flags & 2 || source.flags & 2);
                var message = isEitherEnum
                    ? ts.Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations
                    : isEitherBlockScoped_1
                        ? ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0
                        : ts.Diagnostics.Duplicate_identifier_0;
                var sourceSymbolFile = source.declarations && ts.getSourceFileOfNode(source.declarations[0]);
                var targetSymbolFile = target.declarations && ts.getSourceFileOfNode(target.declarations[0]);
                var symbolName_1 = symbolToString(source);
                if (sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile !== targetSymbolFile) {
                    var firstFile_1 = ts.comparePaths(sourceSymbolFile.path, targetSymbolFile.path) === -1 ? sourceSymbolFile : targetSymbolFile;
                    var secondFile_1 = firstFile_1 === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile;
                    var filesDuplicates = ts.getOrUpdate(amalgamatedDuplicates, firstFile_1.path + "|" + secondFile_1.path, function () {
                        return ({ firstFile: firstFile_1, secondFile: secondFile_1, conflictingSymbols: new ts.Map() });
                    });
                    var conflictingSymbolInfo = ts.getOrUpdate(filesDuplicates.conflictingSymbols, symbolName_1, function () {
                        return ({ isBlockScoped: isEitherBlockScoped_1, firstFileLocations: [], secondFileLocations: [] });
                    });
                    addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source);
                    addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target);
                }
                else {
                    addDuplicateDeclarationErrorsForSymbols(source, message, symbolName_1, target);
                    addDuplicateDeclarationErrorsForSymbols(target, message, symbolName_1, source);
                }
            }
            return target;
            function addDuplicateLocations(locs, symbol) {
                if (symbol.declarations) {
                    for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                        var decl = _a[_i];
                        ts.pushIfUnique(locs, decl);
                    }
                }
            }
        }
        function addDuplicateDeclarationErrorsForSymbols(target, message, symbolName, source) {
            ts.forEach(target.declarations, function (node) {
                addDuplicateDeclarationError(node, message, symbolName, source.declarations);
            });
        }
        function addDuplicateDeclarationError(node, message, symbolName, relatedNodes) {
            var errorNode = (ts.getExpandoInitializer(node, false) ? ts.getNameOfExpando(node) : ts.getNameOfDeclaration(node)) || node;
            var err = lookupOrIssueError(errorNode, message, symbolName);
            var _loop_7 = function (relatedNode) {
                var adjustedNode = (ts.getExpandoInitializer(relatedNode, false) ? ts.getNameOfExpando(relatedNode) : ts.getNameOfDeclaration(relatedNode)) || relatedNode;
                if (adjustedNode === errorNode)
                    return "continue";
                err.relatedInformation = err.relatedInformation || [];
                var leadingMessage = ts.createDiagnosticForNode(adjustedNode, ts.Diagnostics._0_was_also_declared_here, symbolName);
                var followOnMessage = ts.createDiagnosticForNode(adjustedNode, ts.Diagnostics.and_here);
                if (ts.length(err.relatedInformation) >= 5 || ts.some(err.relatedInformation, function (r) { return ts.compareDiagnostics(r, followOnMessage) === 0 || ts.compareDiagnostics(r, leadingMessage) === 0; }))
                    return "continue";
                ts.addRelatedInfo(err, !ts.length(err.relatedInformation) ? leadingMessage : followOnMessage);
            };
            for (var _i = 0, _a = relatedNodes || ts.emptyArray; _i < _a.length; _i++) {
                var relatedNode = _a[_i];
                _loop_7(relatedNode);
            }
        }
        function combineSymbolTables(first, second) {
            if (!(first === null || first === void 0 ? void 0 : first.size))
                return second;
            if (!(second === null || second === void 0 ? void 0 : second.size))
                return first;
            var combined = ts.createSymbolTable();
            mergeSymbolTable(combined, first);
            mergeSymbolTable(combined, second);
            return combined;
        }
        function mergeSymbolTable(target, source, unidirectional) {
            if (unidirectional === void 0) { unidirectional = false; }
            source.forEach(function (sourceSymbol, id) {
                var targetSymbol = target.get(id);
                target.set(id, targetSymbol ? mergeSymbol(targetSymbol, sourceSymbol, unidirectional) : sourceSymbol);
            });
        }
        function mergeModuleAugmentation(moduleName) {
            var _a, _b, _c;
            var moduleAugmentation = moduleName.parent;
            if (((_a = moduleAugmentation.symbol.declarations) === null || _a === void 0 ? void 0 : _a[0]) !== moduleAugmentation) {
                ts.Debug.assert(moduleAugmentation.symbol.declarations.length > 1);
                return;
            }
            if (ts.isGlobalScopeAugmentation(moduleAugmentation)) {
                mergeSymbolTable(globals, moduleAugmentation.symbol.exports);
            }
            else {
                var moduleNotFoundError = !(moduleName.parent.parent.flags & 8388608)
                    ? ts.Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found
                    : undefined;
                var mainModule_1 = resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError, true);
                if (!mainModule_1) {
                    return;
                }
                mainModule_1 = resolveExternalModuleSymbol(mainModule_1);
                if (mainModule_1.flags & 1920) {
                    if (ts.some(patternAmbientModules, function (module) { return mainModule_1 === module.symbol; })) {
                        var merged = mergeSymbol(moduleAugmentation.symbol, mainModule_1, true);
                        if (!patternAmbientModuleAugmentations) {
                            patternAmbientModuleAugmentations = new ts.Map();
                        }
                        patternAmbientModuleAugmentations.set(moduleName.text, merged);
                    }
                    else {
                        if (((_b = mainModule_1.exports) === null || _b === void 0 ? void 0 : _b.get("__export")) && ((_c = moduleAugmentation.symbol.exports) === null || _c === void 0 ? void 0 : _c.size)) {
                            var resolvedExports = getResolvedMembersOrExportsOfSymbol(mainModule_1, "resolvedExports");
                            for (var _i = 0, _d = ts.arrayFrom(moduleAugmentation.symbol.exports.entries()); _i < _d.length; _i++) {
                                var _e = _d[_i], key = _e[0], value = _e[1];
                                if (resolvedExports.has(key) && !mainModule_1.exports.has(key)) {
                                    mergeSymbol(resolvedExports.get(key), value);
                                }
                            }
                        }
                        mergeSymbol(mainModule_1, moduleAugmentation.symbol);
                    }
                }
                else {
                    error(moduleName, ts.Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity, moduleName.text);
                }
            }
        }
        function addToSymbolTable(target, source, message) {
            source.forEach(function (sourceSymbol, id) {
                var targetSymbol = target.get(id);
                if (targetSymbol) {
                    ts.forEach(targetSymbol.declarations, addDeclarationDiagnostic(ts.unescapeLeadingUnderscores(id), message));
                }
                else {
                    target.set(id, sourceSymbol);
                }
            });
            function addDeclarationDiagnostic(id, message) {
                return function (declaration) { return diagnostics.add(ts.createDiagnosticForNode(declaration, message, id)); };
            }
        }
        function getSymbolLinks(symbol) {
            if (symbol.flags & 33554432)
                return symbol;
            var id = getSymbolId(symbol);
            return symbolLinks[id] || (symbolLinks[id] = new SymbolLinks());
        }
        function getNodeLinks(node) {
            var nodeId = getNodeId(node);
            return nodeLinks[nodeId] || (nodeLinks[nodeId] = new NodeLinks());
        }
        function isGlobalSourceFile(node) {
            return node.kind === 300 && !ts.isExternalOrCommonJsModule(node);
        }
        function getSymbol(symbols, name, meaning) {
            if (meaning) {
                var symbol = getMergedSymbol(symbols.get(name));
                if (symbol) {
                    ts.Debug.assert((ts.getCheckFlags(symbol) & 1) === 0, "Should never get an instantiated symbol here.");
                    if (symbol.flags & meaning) {
                        return symbol;
                    }
                    if (symbol.flags & 2097152) {
                        var target = resolveAlias(symbol);
                        if (target === unknownSymbol || target.flags & meaning) {
                            return symbol;
                        }
                    }
                }
            }
        }
        function getSymbolsOfParameterPropertyDeclaration(parameter, parameterName) {
            var constructorDeclaration = parameter.parent;
            var classDeclaration = parameter.parent.parent;
            var parameterSymbol = getSymbol(constructorDeclaration.locals, parameterName, 111551);
            var propertySymbol = getSymbol(getMembersOfSymbol(classDeclaration.symbol), parameterName, 111551);
            if (parameterSymbol && propertySymbol) {
                return [parameterSymbol, propertySymbol];
            }
            return ts.Debug.fail("There should exist two symbols, one as property declaration and one as parameter declaration");
        }
        function isBlockScopedNameDeclaredBeforeUse(declaration, usage) {
            var declarationFile = ts.getSourceFileOfNode(declaration);
            var useFile = ts.getSourceFileOfNode(usage);
            var declContainer = ts.getEnclosingBlockScopeContainer(declaration);
            if (declarationFile !== useFile) {
                if ((moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) ||
                    (!ts.outFile(compilerOptions)) ||
                    isInTypeQuery(usage) ||
                    declaration.flags & 8388608) {
                    return true;
                }
                if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
                    return true;
                }
                var sourceFiles = host.getSourceFiles();
                return sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(useFile);
            }
            if (declaration.pos <= usage.pos && !(ts.isPropertyDeclaration(declaration) && ts.isThisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken)) {
                if (declaration.kind === 201) {
                    var errorBindingElement = ts.getAncestor(usage, 201);
                    if (errorBindingElement) {
                        return ts.findAncestor(errorBindingElement, ts.isBindingElement) !== ts.findAncestor(declaration, ts.isBindingElement) ||
                            declaration.pos < errorBindingElement.pos;
                    }
                    return isBlockScopedNameDeclaredBeforeUse(ts.getAncestor(declaration, 252), usage);
                }
                else if (declaration.kind === 252) {
                    return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration, usage);
                }
                else if (ts.isClassDeclaration(declaration)) {
                    return !ts.findAncestor(usage, function (n) { return ts.isComputedPropertyName(n) && n.parent.parent === declaration; });
                }
                else if (ts.isPropertyDeclaration(declaration)) {
                    return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, false);
                }
                else if (ts.isParameterPropertyDeclaration(declaration, declaration.parent)) {
                    return !(compilerOptions.target === 99 && useDefineForClassFields
                        && ts.getContainingClass(declaration) === ts.getContainingClass(usage)
                        && isUsedInFunctionOrInstanceProperty(usage, declaration));
                }
                return true;
            }
            if (usage.parent.kind === 273 || (usage.parent.kind === 269 && usage.parent.isExportEquals)) {
                return true;
            }
            if (usage.kind === 269 && usage.isExportEquals) {
                return true;
            }
            if (!!(usage.flags & 4194304) || isInTypeQuery(usage) || usageInTypeDeclaration()) {
                return true;
            }
            if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
                if (compilerOptions.target === 99 && useDefineForClassFields
                    && ts.getContainingClass(declaration)
                    && (ts.isPropertyDeclaration(declaration) || ts.isParameterPropertyDeclaration(declaration, declaration.parent))) {
                    return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, true);
                }
                else {
                    return true;
                }
            }
            return false;
            function usageInTypeDeclaration() {
                return !!ts.findAncestor(usage, function (node) { return ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node); });
            }
            function isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration, usage) {
                switch (declaration.parent.parent.kind) {
                    case 235:
                    case 240:
                    case 242:
                        if (isSameScopeDescendentOf(usage, declaration, declContainer)) {
                            return true;
                        }
                        break;
                }
                var grandparent = declaration.parent.parent;
                return ts.isForInOrOfStatement(grandparent) && isSameScopeDescendentOf(usage, grandparent.expression, declContainer);
            }
            function isUsedInFunctionOrInstanceProperty(usage, declaration) {
                return !!ts.findAncestor(usage, function (current) {
                    if (current === declContainer) {
                        return "quit";
                    }
                    if (ts.isFunctionLike(current)) {
                        return true;
                    }
                    if (ts.isClassStaticBlockDeclaration(current)) {
                        return declaration.pos < usage.pos;
                    }
                    var propertyDeclaration = ts.tryCast(current.parent, ts.isPropertyDeclaration);
                    if (propertyDeclaration) {
                        var initializerOfProperty = propertyDeclaration.initializer === current;
                        if (initializerOfProperty) {
                            if (ts.isStatic(current.parent)) {
                                if (declaration.kind === 167) {
                                    return true;
                                }
                                if (ts.isPropertyDeclaration(declaration) && ts.getContainingClass(usage) === ts.getContainingClass(declaration)) {
                                    var propName = declaration.name;
                                    if (ts.isIdentifier(propName) || ts.isPrivateIdentifier(propName)) {
                                        var type = getTypeOfSymbol(getSymbolOfNode(declaration));
                                        var staticBlocks = ts.filter(declaration.parent.members, ts.isClassStaticBlockDeclaration);
                                        if (isPropertyInitializedInStaticBlocks(propName, type, staticBlocks, declaration.parent.pos, current.pos)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                            else {
                                var isDeclarationInstanceProperty = declaration.kind === 165 && !ts.isStatic(declaration);
                                if (!isDeclarationInstanceProperty || ts.getContainingClass(usage) !== ts.getContainingClass(declaration)) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                });
            }
            function isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, stopAtAnyPropertyDeclaration) {
                if (usage.end > declaration.end) {
                    return false;
                }
                var ancestorChangingReferenceScope = ts.findAncestor(usage, function (node) {
                    if (node === declaration) {
                        return "quit";
                    }
                    switch (node.kind) {
                        case 212:
                            return true;
                        case 165:
                            return stopAtAnyPropertyDeclaration &&
                                (ts.isPropertyDeclaration(declaration) && node.parent === declaration.parent
                                    || ts.isParameterPropertyDeclaration(declaration, declaration.parent) && node.parent === declaration.parent.parent)
                                ? "quit" : true;
                        case 233:
                            switch (node.parent.kind) {
                                case 170:
                                case 167:
                                case 171:
                                    return true;
                                default:
                                    return false;
                            }
                        default:
                            return false;
                    }
                });
                return ancestorChangingReferenceScope === undefined;
            }
        }
        function useOuterVariableScopeInParameter(result, location, lastLocation) {
            var target = ts.getEmitScriptTarget(compilerOptions);
            var functionLocation = location;
            if (ts.isParameter(lastLocation)
                && functionLocation.body
                && result.valueDeclaration
                && result.valueDeclaration.pos >= functionLocation.body.pos
                && result.valueDeclaration.end <= functionLocation.body.end) {
                if (target >= 2) {
                    var links = getNodeLinks(functionLocation);
                    if (links.declarationRequiresScopeChange === undefined) {
                        links.declarationRequiresScopeChange = ts.forEach(functionLocation.parameters, requiresScopeChange) || false;
                    }
                    return !links.declarationRequiresScopeChange;
                }
            }
            return false;
            function requiresScopeChange(node) {
                return requiresScopeChangeWorker(node.name)
                    || !!node.initializer && requiresScopeChangeWorker(node.initializer);
            }
            function requiresScopeChangeWorker(node) {
                switch (node.kind) {
                    case 212:
                    case 211:
                    case 254:
                    case 169:
                        return false;
                    case 167:
                    case 170:
                    case 171:
                    case 291:
                        return requiresScopeChangeWorker(node.name);
                    case 165:
                        if (ts.hasStaticModifier(node)) {
                            return target < 99 || !useDefineForClassFields;
                        }
                        return requiresScopeChangeWorker(node.name);
                    default:
                        if (ts.isNullishCoalesce(node) || ts.isOptionalChain(node)) {
                            return target < 7;
                        }
                        if (ts.isBindingElement(node) && node.dotDotDotToken && ts.isObjectBindingPattern(node.parent)) {
                            return target < 4;
                        }
                        if (ts.isTypeNode(node))
                            return false;
                        return ts.forEachChild(node, requiresScopeChangeWorker) || false;
                }
            }
        }
        function resolveName(location, name, meaning, nameNotFoundMessage, nameArg, isUse, excludeGlobals, issueSuggestions) {
            if (excludeGlobals === void 0) { excludeGlobals = false; }
            return resolveNameHelper(location, name, meaning, nameNotFoundMessage, nameArg, isUse, excludeGlobals, getSymbol, issueSuggestions);
        }
        function resolveNameHelper(location, name, meaning, nameNotFoundMessage, nameArg, isUse, excludeGlobals, lookup, issueSuggestions) {
            var _a;
            var originalLocation = location;
            var result;
            var lastLocation;
            var lastSelfReferenceLocation;
            var propertyWithInvalidInitializer;
            var associatedDeclarationForContainingInitializerOrBindingName;
            var withinDeferredContext = false;
            var errorLocation = location;
            var grandparent;
            var isInExternalModule = false;
            loop: while (location) {
                if (location.locals && !isGlobalSourceFile(location)) {
                    if (result = lookup(location.locals, name, meaning)) {
                        var useResult = true;
                        if (ts.isFunctionLike(location) && lastLocation && lastLocation !== location.body) {
                            if (meaning & result.flags & 788968 && lastLocation.kind !== 315) {
                                useResult = result.flags & 262144
                                    ? lastLocation === location.type ||
                                        lastLocation.kind === 162 ||
                                        lastLocation.kind === 161
                                    : false;
                            }
                            if (meaning & result.flags & 3) {
                                if (useOuterVariableScopeInParameter(result, location, lastLocation)) {
                                    useResult = false;
                                }
                                else if (result.flags & 1) {
                                    useResult =
                                        lastLocation.kind === 162 ||
                                            (lastLocation === location.type &&
                                                !!ts.findAncestor(result.valueDeclaration, ts.isParameter));
                                }
                            }
                        }
                        else if (location.kind === 187) {
                            useResult = lastLocation === location.trueType;
                        }
                        if (useResult) {
                            break loop;
                        }
                        else {
                            result = undefined;
                        }
                    }
                }
                withinDeferredContext = withinDeferredContext || getIsDeferredContext(location, lastLocation);
                switch (location.kind) {
                    case 300:
                        if (!ts.isExternalOrCommonJsModule(location))
                            break;
                        isInExternalModule = true;
                    case 259:
                        var moduleExports = getSymbolOfNode(location).exports || emptySymbols;
                        if (location.kind === 300 || (ts.isModuleDeclaration(location) && location.flags & 8388608 && !ts.isGlobalScopeAugmentation(location))) {
                            if (result = moduleExports.get("default")) {
                                var localSymbol = ts.getLocalSymbolForExportDefault(result);
                                if (localSymbol && (result.flags & meaning) && localSymbol.escapedName === name) {
                                    break loop;
                                }
                                result = undefined;
                            }
                            var moduleExport = moduleExports.get(name);
                            if (moduleExport &&
                                moduleExport.flags === 2097152 &&
                                (ts.getDeclarationOfKind(moduleExport, 273) || ts.getDeclarationOfKind(moduleExport, 272))) {
                                break;
                            }
                        }
                        if (name !== "default" && (result = lookup(moduleExports, name, meaning & 2623475))) {
                            if (ts.isSourceFile(location) && location.commonJsModuleIndicator && !((_a = result.declarations) === null || _a === void 0 ? void 0 : _a.some(ts.isJSDocTypeAlias))) {
                                result = undefined;
                            }
                            else {
                                break loop;
                            }
                        }
                        break;
                    case 258:
                        if (result = lookup(getSymbolOfNode(location).exports, name, meaning & 8)) {
                            break loop;
                        }
                        break;
                    case 165:
                        if (!ts.isStatic(location)) {
                            var ctor = findConstructorDeclaration(location.parent);
                            if (ctor && ctor.locals) {
                                if (lookup(ctor.locals, name, meaning & 111551)) {
                                    propertyWithInvalidInitializer = location;
                                }
                            }
                        }
                        break;
                    case 255:
                    case 224:
                    case 256:
                        if (result = lookup(getSymbolOfNode(location).members || emptySymbols, name, meaning & 788968)) {
                            if (!isTypeParameterSymbolDeclaredInContainer(result, location)) {
                                result = undefined;
                                break;
                            }
                            if (lastLocation && ts.isStatic(lastLocation)) {
                                error(errorLocation, ts.Diagnostics.Static_members_cannot_reference_class_type_parameters);
                                return undefined;
                            }
                            break loop;
                        }
                        if (location.kind === 224 && meaning & 32) {
                            var className = location.name;
                            if (className && name === className.escapedText) {
                                result = location.symbol;
                                break loop;
                            }
                        }
                        break;
                    case 226:
                        if (lastLocation === location.expression && location.parent.token === 94) {
                            var container = location.parent.parent;
                            if (ts.isClassLike(container) && (result = lookup(getSymbolOfNode(container).members, name, meaning & 788968))) {
                                if (nameNotFoundMessage) {
                                    error(errorLocation, ts.Diagnostics.Base_class_expressions_cannot_reference_class_type_parameters);
                                }
                                return undefined;
                            }
                        }
                        break;
                    case 160:
                        grandparent = location.parent.parent;
                        if (ts.isClassLike(grandparent) || grandparent.kind === 256) {
                            if (result = lookup(getSymbolOfNode(grandparent).members, name, meaning & 788968)) {
                                error(errorLocation, ts.Diagnostics.A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type);
                                return undefined;
                            }
                        }
                        break;
                    case 212:
                        if (compilerOptions.target >= 2) {
                            break;
                        }
                    case 167:
                    case 169:
                    case 170:
                    case 171:
                    case 254:
                        if (meaning & 3 && name === "arguments") {
                            result = argumentsSymbol;
                            break loop;
                        }
                        break;
                    case 211:
                        if (meaning & 3 && name === "arguments") {
                            result = argumentsSymbol;
                            break loop;
                        }
                        if (meaning & 16) {
                            var functionName = location.name;
                            if (functionName && name === functionName.escapedText) {
                                result = location.symbol;
                                break loop;
                            }
                        }
                        break;
                    case 163:
                        if (location.parent && location.parent.kind === 162) {
                            location = location.parent;
                        }
                        if (location.parent && (ts.isClassElement(location.parent) || location.parent.kind === 255)) {
                            location = location.parent;
                        }
                        break;
                    case 340:
                    case 333:
                    case 334:
                        var root = ts.getJSDocRoot(location);
                        if (root) {
                            location = root.parent;
                        }
                        break;
                    case 162:
                        if (lastLocation && (lastLocation === location.initializer ||
                            lastLocation === location.name && ts.isBindingPattern(lastLocation))) {
                            if (!associatedDeclarationForContainingInitializerOrBindingName) {
                                associatedDeclarationForContainingInitializerOrBindingName = location;
                            }
                        }
                        break;
                    case 201:
                        if (lastLocation && (lastLocation === location.initializer ||
                            lastLocation === location.name && ts.isBindingPattern(lastLocation))) {
                            if (ts.isParameterDeclaration(location) && !associatedDeclarationForContainingInitializerOrBindingName) {
                                associatedDeclarationForContainingInitializerOrBindingName = location;
                            }
                        }
                        break;
                    case 188:
                        if (meaning & 262144) {
                            var parameterName = location.typeParameter.name;
                            if (parameterName && name === parameterName.escapedText) {
                                result = location.typeParameter.symbol;
                                break loop;
                            }
                        }
                        break;
                }
                if (isSelfReferenceLocation(location)) {
                    lastSelfReferenceLocation = location;
                }
                lastLocation = location;
                location = location.parent;
            }
            if (isUse && result && (!lastSelfReferenceLocation || result !== lastSelfReferenceLocation.symbol)) {
                result.isReferenced |= meaning;
            }
            if (!result) {
                if (lastLocation) {
                    ts.Debug.assert(lastLocation.kind === 300);
                    if (lastLocation.commonJsModuleIndicator && name === "exports" && meaning & lastLocation.symbol.flags) {
                        return lastLocation.symbol;
                    }
                }
                if (!excludeGlobals) {
                    result = lookup(globals, name, meaning);
                }
            }
            if (!result) {
                if (originalLocation && ts.isInJSFile(originalLocation) && originalLocation.parent) {
                    if (ts.isRequireCall(originalLocation.parent, false)) {
                        return requireSymbol;
                    }
                }
            }
            if (!result) {
                if (nameNotFoundMessage) {
                    if (!errorLocation ||
                        !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) &&
                            !checkAndReportErrorForExtendingInterface(errorLocation) &&
                            !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) &&
                            !checkAndReportErrorForExportingPrimitiveType(errorLocation, name) &&
                            !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) &&
                            !checkAndReportErrorForUsingNamespaceModuleAsValue(errorLocation, name, meaning) &&
                            !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning)) {
                        var suggestion = void 0;
                        if (issueSuggestions && suggestionCount < maximumSuggestionCount) {
                            suggestion = getSuggestedSymbolForNonexistentSymbol(originalLocation, name, meaning);
                            var isGlobalScopeAugmentationDeclaration = (suggestion === null || suggestion === void 0 ? void 0 : suggestion.valueDeclaration) && ts.isAmbientModule(suggestion.valueDeclaration) && ts.isGlobalScopeAugmentation(suggestion.valueDeclaration);
                            if (isGlobalScopeAugmentationDeclaration) {
                                suggestion = undefined;
                            }
                            if (suggestion) {
                                var suggestionName = symbolToString(suggestion);
                                var isUncheckedJS = isUncheckedJSSuggestion(originalLocation, suggestion, false);
                                var message = isUncheckedJS ? ts.Diagnostics.Could_not_find_name_0_Did_you_mean_1 : ts.Diagnostics.Cannot_find_name_0_Did_you_mean_1;
                                var diagnostic = createError(errorLocation, message, diagnosticName(nameArg), suggestionName);
                                addErrorOrSuggestion(!isUncheckedJS, diagnostic);
                                if (suggestion.valueDeclaration) {
                                    ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(suggestion.valueDeclaration, ts.Diagnostics._0_is_declared_here, suggestionName));
                                }
                            }
                        }
                        if (!suggestion) {
                            if (nameArg) {
                                var lib = getSuggestedLibForNonExistentName(nameArg);
                                if (lib) {
                                    error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg), lib);
                                }
                                else {
                                    error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg));
                                }
                            }
                        }
                        suggestionCount++;
                    }
                }
                return undefined;
            }
            if (nameNotFoundMessage) {
                if (propertyWithInvalidInitializer && !(compilerOptions.target === 99 && useDefineForClassFields)) {
                    var propertyName = propertyWithInvalidInitializer.name;
                    error(errorLocation, ts.Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, ts.declarationNameToString(propertyName), diagnosticName(nameArg));
                    return undefined;
                }
                if (errorLocation &&
                    (meaning & 2 ||
                        ((meaning & 32 || meaning & 384) && (meaning & 111551) === 111551))) {
                    var exportOrLocalSymbol = getExportSymbolOfValueSymbolIfExported(result);
                    if (exportOrLocalSymbol.flags & 2 || exportOrLocalSymbol.flags & 32 || exportOrLocalSymbol.flags & 384) {
                        checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation);
                    }
                }
                if (result && isInExternalModule && (meaning & 111551) === 111551 && !(originalLocation.flags & 4194304)) {
                    var merged = getMergedSymbol(result);
                    if (ts.length(merged.declarations) && ts.every(merged.declarations, function (d) { return ts.isNamespaceExportDeclaration(d) || ts.isSourceFile(d) && !!d.symbol.globalExports; })) {
                        errorOrSuggestion(!compilerOptions.allowUmdGlobalAccess, errorLocation, ts.Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, ts.unescapeLeadingUnderscores(name));
                    }
                }
                if (result && associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning & 111551) === 111551) {
                    var candidate = getMergedSymbol(getLateBoundSymbol(result));
                    var root = ts.getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName);
                    if (candidate === getSymbolOfNode(associatedDeclarationForContainingInitializerOrBindingName)) {
                        error(errorLocation, ts.Diagnostics.Parameter_0_cannot_reference_itself, ts.declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name));
                    }
                    else if (candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && lookup(root.parent.locals, candidate.escapedName, meaning) === candidate) {
                        error(errorLocation, ts.Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, ts.declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), ts.declarationNameToString(errorLocation));
                    }
                }
                if (result && errorLocation && meaning & 111551 && result.flags & 2097152) {
                    checkSymbolUsageInExpressionContext(result, name, errorLocation);
                }
            }
            return result;
        }
        function checkSymbolUsageInExpressionContext(symbol, name, useSite) {
            if (!ts.isValidTypeOnlyAliasUseSite(useSite)) {
                var typeOnlyDeclaration = getTypeOnlyAliasDeclaration(symbol);
                if (typeOnlyDeclaration) {
                    var isExport = ts.typeOnlyDeclarationIsExport(typeOnlyDeclaration);
                    var message = isExport
                        ? ts.Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type
                        : ts.Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type;
                    var relatedMessage = isExport
                        ? ts.Diagnostics._0_was_exported_here
                        : ts.Diagnostics._0_was_imported_here;
                    var unescapedName = ts.unescapeLeadingUnderscores(name);
                    ts.addRelatedInfo(error(useSite, message, unescapedName), ts.createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, unescapedName));
                }
            }
        }
        function getIsDeferredContext(location, lastLocation) {
            if (location.kind !== 212 && location.kind !== 211) {
                return ts.isTypeQueryNode(location) || ((ts.isFunctionLikeDeclaration(location) ||
                    (location.kind === 165 && !ts.isStatic(location))) && (!lastLocation || lastLocation !== location.name));
            }
            if (lastLocation && lastLocation === location.name) {
                return false;
            }
            if (location.asteriskToken || ts.hasSyntacticModifier(location, 256)) {
                return true;
            }
            return !ts.getImmediatelyInvokedFunctionExpression(location);
        }
        function isSelfReferenceLocation(node) {
            switch (node.kind) {
                case 254:
                case 255:
                case 256:
                case 258:
                case 257:
                case 259:
                    return true;
                default:
                    return false;
            }
        }
        function diagnosticName(nameArg) {
            return ts.isString(nameArg) ? ts.unescapeLeadingUnderscores(nameArg) : ts.declarationNameToString(nameArg);
        }
        function isTypeParameterSymbolDeclaredInContainer(symbol, container) {
            if (symbol.declarations) {
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    if (decl.kind === 161) {
                        var parent = ts.isJSDocTemplateTag(decl.parent) ? ts.getJSDocHost(decl.parent) : decl.parent;
                        if (parent === container) {
                            return !(ts.isJSDocTemplateTag(decl.parent) && ts.find(decl.parent.parent.tags, ts.isJSDocTypeAlias));
                        }
                    }
                }
            }
            return false;
        }
        function checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) {
            if (!ts.isIdentifier(errorLocation) || errorLocation.escapedText !== name || isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation)) {
                return false;
            }
            var container = ts.getThisContainer(errorLocation, false);
            var location = container;
            while (location) {
                if (ts.isClassLike(location.parent)) {
                    var classSymbol = getSymbolOfNode(location.parent);
                    if (!classSymbol) {
                        break;
                    }
                    var constructorType = getTypeOfSymbol(classSymbol);
                    if (getPropertyOfType(constructorType, name)) {
                        error(errorLocation, ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, diagnosticName(nameArg), symbolToString(classSymbol));
                        return true;
                    }
                    if (location === container && !ts.isStatic(location)) {
                        var instanceType = getDeclaredTypeOfSymbol(classSymbol).thisType;
                        if (getPropertyOfType(instanceType, name)) {
                            error(errorLocation, ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, diagnosticName(nameArg));
                            return true;
                        }
                    }
                }
                location = location.parent;
            }
            return false;
        }
        function checkAndReportErrorForExtendingInterface(errorLocation) {
            var expression = getEntityNameForExtendingInterface(errorLocation);
            if (expression && resolveEntityName(expression, 64, true)) {
                error(errorLocation, ts.Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements, ts.getTextOfNode(expression));
                return true;
            }
            return false;
        }
        function getEntityNameForExtendingInterface(node) {
            switch (node.kind) {
                case 79:
                case 204:
                    return node.parent ? getEntityNameForExtendingInterface(node.parent) : undefined;
                case 226:
                    if (ts.isEntityNameExpression(node.expression)) {
                        return node.expression;
                    }
                default:
                    return undefined;
            }
        }
        function checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) {
            var namespaceMeaning = 1920 | (ts.isInJSFile(errorLocation) ? 111551 : 0);
            if (meaning === namespaceMeaning) {
                var symbol = resolveSymbol(resolveName(errorLocation, name, 788968 & ~namespaceMeaning, undefined, undefined, false));
                var parent = errorLocation.parent;
                if (symbol) {
                    if (ts.isQualifiedName(parent)) {
                        ts.Debug.assert(parent.left === errorLocation, "Should only be resolving left side of qualified name as a namespace");
                        var propName = parent.right.escapedText;
                        var propType = getPropertyOfType(getDeclaredTypeOfSymbol(symbol), propName);
                        if (propType) {
                            error(parent, ts.Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, ts.unescapeLeadingUnderscores(name), ts.unescapeLeadingUnderscores(propName));
                            return true;
                        }
                    }
                    error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here, ts.unescapeLeadingUnderscores(name));
                    return true;
                }
            }
            return false;
        }
        function checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning) {
            if (meaning & (788968 & ~1920)) {
                var symbol = resolveSymbol(resolveName(errorLocation, name, ~788968 & 111551, undefined, undefined, false));
                if (symbol && !(symbol.flags & 1920)) {
                    error(errorLocation, ts.Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, ts.unescapeLeadingUnderscores(name));
                    return true;
                }
            }
            return false;
        }
        function isPrimitiveTypeName(name) {
            return name === "any" || name === "string" || name === "number" || name === "boolean" || name === "never" || name === "unknown";
        }
        function checkAndReportErrorForExportingPrimitiveType(errorLocation, name) {
            if (isPrimitiveTypeName(name) && errorLocation.parent.kind === 273) {
                error(errorLocation, ts.Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, name);
                return true;
            }
            return false;
        }
        function checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) {
            if (meaning & (111551 & ~1024)) {
                if (isPrimitiveTypeName(name)) {
                    error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, ts.unescapeLeadingUnderscores(name));
                    return true;
                }
                var symbol = resolveSymbol(resolveName(errorLocation, name, 788968 & ~111551, undefined, undefined, false));
                if (symbol && !(symbol.flags & 1024)) {
                    var rawName = ts.unescapeLeadingUnderscores(name);
                    if (isES2015OrLaterConstructorName(name)) {
                        error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later, rawName);
                    }
                    else if (maybeMappedType(errorLocation, symbol)) {
                        error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0, rawName, rawName === "K" ? "P" : "K");
                    }
                    else {
                        error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, rawName);
                    }
                    return true;
                }
            }
            return false;
        }
        function maybeMappedType(node, symbol) {
            var container = ts.findAncestor(node.parent, function (n) {
                return ts.isComputedPropertyName(n) || ts.isPropertySignature(n) ? false : ts.isTypeLiteralNode(n) || "quit";
            });
            if (container && container.members.length === 1) {
                var type = getDeclaredTypeOfSymbol(symbol);
                return !!(type.flags & 1048576) && allTypesAssignableToKind(type, 384, true);
            }
            return false;
        }
        function isES2015OrLaterConstructorName(n) {
            switch (n) {
                case "Promise":
                case "Symbol":
                case "Map":
                case "WeakMap":
                case "Set":
                case "WeakSet":
                    return true;
            }
            return false;
        }
        function checkAndReportErrorForUsingNamespaceModuleAsValue(errorLocation, name, meaning) {
            if (meaning & (111551 & ~1024 & ~788968)) {
                var symbol = resolveSymbol(resolveName(errorLocation, name, 1024 & ~111551, undefined, undefined, false));
                if (symbol) {
                    error(errorLocation, ts.Diagnostics.Cannot_use_namespace_0_as_a_value, ts.unescapeLeadingUnderscores(name));
                    return true;
                }
            }
            else if (meaning & (788968 & ~1024 & ~111551)) {
                var symbol = resolveSymbol(resolveName(errorLocation, name, (512 | 1024) & ~788968, undefined, undefined, false));
                if (symbol) {
                    error(errorLocation, ts.Diagnostics.Cannot_use_namespace_0_as_a_type, ts.unescapeLeadingUnderscores(name));
                    return true;
                }
            }
            return false;
        }
        function checkResolvedBlockScopedVariable(result, errorLocation) {
            var _a;
            ts.Debug.assert(!!(result.flags & 2 || result.flags & 32 || result.flags & 384));
            if (result.flags & (16 | 1 | 67108864) && result.flags & 32) {
                return;
            }
            var declaration = (_a = result.declarations) === null || _a === void 0 ? void 0 : _a.find(function (d) { return ts.isBlockOrCatchScoped(d) || ts.isClassLike(d) || (d.kind === 258); });
            if (declaration === undefined)
                return ts.Debug.fail("checkResolvedBlockScopedVariable could not find block-scoped declaration");
            if (!(declaration.flags & 8388608) && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation)) {
                var diagnosticMessage = void 0;
                var declarationName = ts.declarationNameToString(ts.getNameOfDeclaration(declaration));
                if (result.flags & 2) {
                    diagnosticMessage = error(errorLocation, ts.Diagnostics.Block_scoped_variable_0_used_before_its_declaration, declarationName);
                }
                else if (result.flags & 32) {
                    diagnosticMessage = error(errorLocation, ts.Diagnostics.Class_0_used_before_its_declaration, declarationName);
                }
                else if (result.flags & 256) {
                    diagnosticMessage = error(errorLocation, ts.Diagnostics.Enum_0_used_before_its_declaration, declarationName);
                }
                else {
                    ts.Debug.assert(!!(result.flags & 128));
                    if (ts.shouldPreserveConstEnums(compilerOptions)) {
                        diagnosticMessage = error(errorLocation, ts.Diagnostics.Enum_0_used_before_its_declaration, declarationName);
                    }
                }
                if (diagnosticMessage) {
                    ts.addRelatedInfo(diagnosticMessage, ts.createDiagnosticForNode(declaration, ts.Diagnostics._0_is_declared_here, declarationName));
                }
            }
        }
        function isSameScopeDescendentOf(initial, parent, stopAt) {
            return !!parent && !!ts.findAncestor(initial, function (n) { return n === stopAt || ts.isFunctionLike(n) ? "quit" : n === parent; });
        }
        function getAnyImportSyntax(node) {
            switch (node.kind) {
                case 263:
                    return node;
                case 265:
                    return node.parent;
                case 266:
                    return node.parent.parent;
                case 268:
                    return node.parent.parent.parent;
                default:
                    return undefined;
            }
        }
        function getDeclarationOfAliasSymbol(symbol) {
            return symbol.declarations && ts.findLast(symbol.declarations, isAliasSymbolDeclaration);
        }
        function isAliasSymbolDeclaration(node) {
            return node.kind === 263
                || node.kind === 262
                || node.kind === 265 && !!node.name
                || node.kind === 266
                || node.kind === 272
                || node.kind === 268
                || node.kind === 273
                || node.kind === 269 && ts.exportAssignmentIsAlias(node)
                || ts.isBinaryExpression(node) && ts.getAssignmentDeclarationKind(node) === 2 && ts.exportAssignmentIsAlias(node)
                || ts.isAccessExpression(node)
                    && ts.isBinaryExpression(node.parent)
                    && node.parent.left === node
                    && node.parent.operatorToken.kind === 63
                    && isAliasableOrJsExpression(node.parent.right)
                || node.kind === 292
                || node.kind === 291 && isAliasableOrJsExpression(node.initializer)
                || ts.isRequireVariableDeclaration(node);
        }
        function isAliasableOrJsExpression(e) {
            return ts.isAliasableExpression(e) || ts.isFunctionExpression(e) && isJSConstructor(e);
        }
        function getTargetOfImportEqualsDeclaration(node, dontResolveAlias) {
            var commonJSPropertyAccess = getCommonJSPropertyAccess(node);
            if (commonJSPropertyAccess) {
                var name = ts.getLeftmostAccessExpression(commonJSPropertyAccess.expression).arguments[0];
                return ts.isIdentifier(commonJSPropertyAccess.name)
                    ? resolveSymbol(getPropertyOfType(resolveExternalModuleTypeByLiteral(name), commonJSPropertyAccess.name.escapedText))
                    : undefined;
            }
            if (ts.isVariableDeclaration(node) || node.moduleReference.kind === 275) {
                var immediate = resolveExternalModuleName(node, ts.getExternalModuleRequireArgument(node) || ts.getExternalModuleImportEqualsDeclarationExpression(node));
                var resolved_4 = resolveExternalModuleSymbol(immediate);
                markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved_4, false);
                return resolved_4;
            }
            var resolved = getSymbolOfPartOfRightHandSideOfImportEquals(node.moduleReference, dontResolveAlias);
            checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved);
            return resolved;
        }
        function checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved) {
            if (markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false) && !node.isTypeOnly) {
                var typeOnlyDeclaration = getTypeOnlyAliasDeclaration(getSymbolOfNode(node));
                var isExport = ts.typeOnlyDeclarationIsExport(typeOnlyDeclaration);
                var message = isExport
                    ? ts.Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type
                    : ts.Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type;
                var relatedMessage = isExport
                    ? ts.Diagnostics._0_was_exported_here
                    : ts.Diagnostics._0_was_imported_here;
                var name = ts.unescapeLeadingUnderscores(typeOnlyDeclaration.name.escapedText);
                ts.addRelatedInfo(error(node.moduleReference, message), ts.createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name));
            }
        }
        function resolveExportByName(moduleSymbol, name, sourceNode, dontResolveAlias) {
            var exportValue = moduleSymbol.exports.get("export=");
            var exportSymbol = exportValue ? getPropertyOfType(getTypeOfSymbol(exportValue), name) : moduleSymbol.exports.get(name);
            var resolved = resolveSymbol(exportSymbol, dontResolveAlias);
            markSymbolOfAliasDeclarationIfTypeOnly(sourceNode, exportSymbol, resolved, false);
            return resolved;
        }
        function isSyntacticDefault(node) {
            return ((ts.isExportAssignment(node) && !node.isExportEquals) || ts.hasSyntacticModifier(node, 512) || ts.isExportSpecifier(node));
        }
        function canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias) {
            if (!allowSyntheticDefaultImports) {
                return false;
            }
            if (!file || file.isDeclarationFile) {
                var defaultExportSymbol = resolveExportByName(moduleSymbol, "default", undefined, true);
                if (defaultExportSymbol && ts.some(defaultExportSymbol.declarations, isSyntacticDefault)) {
                    return false;
                }
                if (resolveExportByName(moduleSymbol, ts.escapeLeadingUnderscores("__esModule"), undefined, dontResolveAlias)) {
                    return false;
                }
                return true;
            }
            if (!ts.isSourceFileJS(file)) {
                return hasExportAssignmentSymbol(moduleSymbol);
            }
            return !file.externalModuleIndicator && !resolveExportByName(moduleSymbol, ts.escapeLeadingUnderscores("__esModule"), undefined, dontResolveAlias);
        }
        function getTargetOfImportClause(node, dontResolveAlias) {
            var _a;
            var moduleSymbol = resolveExternalModuleName(node, node.parent.moduleSpecifier);
            if (moduleSymbol) {
                var exportDefaultSymbol = void 0;
                if (ts.isShorthandAmbientModuleSymbol(moduleSymbol)) {
                    exportDefaultSymbol = moduleSymbol;
                }
                else {
                    exportDefaultSymbol = resolveExportByName(moduleSymbol, "default", node, dontResolveAlias);
                }
                var file = (_a = moduleSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isSourceFile);
                var hasSyntheticDefault = canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias);
                if (!exportDefaultSymbol && !hasSyntheticDefault) {
                    if (hasExportAssignmentSymbol(moduleSymbol)) {
                        var compilerOptionName = moduleKind >= ts.ModuleKind.ES2015 ? "allowSyntheticDefaultImports" : "esModuleInterop";
                        var exportEqualsSymbol = moduleSymbol.exports.get("export=");
                        var exportAssignment = exportEqualsSymbol.valueDeclaration;
                        var err = error(node.name, ts.Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag, symbolToString(moduleSymbol), compilerOptionName);
                        if (exportAssignment) {
                            ts.addRelatedInfo(err, ts.createDiagnosticForNode(exportAssignment, ts.Diagnostics.This_module_is_declared_with_using_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag, compilerOptionName));
                        }
                    }
                    else {
                        reportNonDefaultExport(moduleSymbol, node);
                    }
                }
                else if (hasSyntheticDefault) {
                    var resolved = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias);
                    markSymbolOfAliasDeclarationIfTypeOnly(node, moduleSymbol, resolved, false);
                    return resolved;
                }
                markSymbolOfAliasDeclarationIfTypeOnly(node, exportDefaultSymbol, undefined, false);
                return exportDefaultSymbol;
            }
        }
        function reportNonDefaultExport(moduleSymbol, node) {
            var _a, _b, _c;
            if ((_a = moduleSymbol.exports) === null || _a === void 0 ? void 0 : _a.has(node.symbol.escapedName)) {
                error(node.name, ts.Diagnostics.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead, symbolToString(moduleSymbol), symbolToString(node.symbol));
            }
            else {
                var diagnostic = error(node.name, ts.Diagnostics.Module_0_has_no_default_export, symbolToString(moduleSymbol));
                var exportStar = (_b = moduleSymbol.exports) === null || _b === void 0 ? void 0 : _b.get("__export");
                if (exportStar) {
                    var defaultExport = (_c = exportStar.declarations) === null || _c === void 0 ? void 0 : _c.find(function (decl) {
                        var _a, _b;
                        return !!(ts.isExportDeclaration(decl) && decl.moduleSpecifier &&
                            ((_b = (_a = resolveExternalModuleName(decl, decl.moduleSpecifier)) === null || _a === void 0 ? void 0 : _a.exports) === null || _b === void 0 ? void 0 : _b.has("default")));
                    });
                    if (defaultExport) {
                        ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(defaultExport, ts.Diagnostics.export_Asterisk_does_not_re_export_a_default));
                    }
                }
            }
        }
        function getTargetOfNamespaceImport(node, dontResolveAlias) {
            var moduleSpecifier = node.parent.parent.moduleSpecifier;
            var immediate = resolveExternalModuleName(node, moduleSpecifier);
            var resolved = resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false);
            markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false);
            return resolved;
        }
        function getTargetOfNamespaceExport(node, dontResolveAlias) {
            var moduleSpecifier = node.parent.moduleSpecifier;
            var immediate = moduleSpecifier && resolveExternalModuleName(node, moduleSpecifier);
            var resolved = moduleSpecifier && resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false);
            markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false);
            return resolved;
        }
        function combineValueAndTypeSymbols(valueSymbol, typeSymbol) {
            if (valueSymbol === unknownSymbol && typeSymbol === unknownSymbol) {
                return unknownSymbol;
            }
            if (valueSymbol.flags & (788968 | 1920)) {
                return valueSymbol;
            }
            var result = createSymbol(valueSymbol.flags | typeSymbol.flags, valueSymbol.escapedName);
            result.declarations = ts.deduplicate(ts.concatenate(valueSymbol.declarations, typeSymbol.declarations), ts.equateValues);
            result.parent = valueSymbol.parent || typeSymbol.parent;
            if (valueSymbol.valueDeclaration)
                result.valueDeclaration = valueSymbol.valueDeclaration;
            if (typeSymbol.members)
                result.members = new ts.Map(typeSymbol.members);
            if (valueSymbol.exports)
                result.exports = new ts.Map(valueSymbol.exports);
            return result;
        }
        function getExportOfModule(symbol, name, specifier, dontResolveAlias) {
            if (symbol.flags & 1536) {
                var exportSymbol = getExportsOfSymbol(symbol).get(name.escapedText);
                var resolved = resolveSymbol(exportSymbol, dontResolveAlias);
                markSymbolOfAliasDeclarationIfTypeOnly(specifier, exportSymbol, resolved, false);
                return resolved;
            }
        }
        function getPropertyOfVariable(symbol, name) {
            if (symbol.flags & 3) {
                var typeAnnotation = symbol.valueDeclaration.type;
                if (typeAnnotation) {
                    return resolveSymbol(getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name));
                }
            }
        }
        function getExternalModuleMember(node, specifier, dontResolveAlias) {
            var _a, _b;
            if (dontResolveAlias === void 0) { dontResolveAlias = false; }
            var moduleSpecifier = ts.getExternalModuleRequireArgument(node) || node.moduleSpecifier;
            var moduleSymbol = resolveExternalModuleName(node, moduleSpecifier);
            var name = !ts.isPropertyAccessExpression(specifier) && specifier.propertyName || specifier.name;
            if (!ts.isIdentifier(name)) {
                return undefined;
            }
            var suppressInteropError = name.escapedText === "default" && !!(compilerOptions.allowSyntheticDefaultImports || compilerOptions.esModuleInterop);
            var targetSymbol = resolveESModuleSymbol(moduleSymbol, moduleSpecifier, false, suppressInteropError);
            if (targetSymbol) {
                if (name.escapedText) {
                    if (ts.isShorthandAmbientModuleSymbol(moduleSymbol)) {
                        return moduleSymbol;
                    }
                    var symbolFromVariable = void 0;
                    if (moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get("export=")) {
                        symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), name.escapedText, true);
                    }
                    else {
                        symbolFromVariable = getPropertyOfVariable(targetSymbol, name.escapedText);
                    }
                    symbolFromVariable = resolveSymbol(symbolFromVariable, dontResolveAlias);
                    var symbolFromModule = getExportOfModule(targetSymbol, name, specifier, dontResolveAlias);
                    if (symbolFromModule === undefined && name.escapedText === "default") {
                        var file = (_a = moduleSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isSourceFile);
                        if (canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias)) {
                            symbolFromModule = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias);
                        }
                    }
                    var symbol = symbolFromModule && symbolFromVariable && symbolFromModule !== symbolFromVariable ?
                        combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule) :
                        symbolFromModule || symbolFromVariable;
                    if (!symbol) {
                        var moduleName = getFullyQualifiedName(moduleSymbol, node);
                        var declarationName = ts.declarationNameToString(name);
                        var suggestion = getSuggestedSymbolForNonexistentModule(name, targetSymbol);
                        if (suggestion !== undefined) {
                            var suggestionName = symbolToString(suggestion);
                            var diagnostic = error(name, ts.Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, moduleName, declarationName, suggestionName);
                            if (suggestion.valueDeclaration) {
                                ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(suggestion.valueDeclaration, ts.Diagnostics._0_is_declared_here, suggestionName));
                            }
                        }
                        else {
                            if ((_b = moduleSymbol.exports) === null || _b === void 0 ? void 0 : _b.has("default")) {
                                error(name, ts.Diagnostics.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead, moduleName, declarationName);
                            }
                            else {
                                reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName);
                            }
                        }
                    }
                    return symbol;
                }
            }
        }
        function reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName) {
            var _a, _b;
            var localSymbol = (_b = (_a = moduleSymbol.valueDeclaration) === null || _a === void 0 ? void 0 : _a.locals) === null || _b === void 0 ? void 0 : _b.get(name.escapedText);
            var exports = moduleSymbol.exports;
            if (localSymbol) {
                var exportedEqualsSymbol = exports === null || exports === void 0 ? void 0 : exports.get("export=");
                if (exportedEqualsSymbol) {
                    getSymbolIfSameReference(exportedEqualsSymbol, localSymbol) ? reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName) :
                        error(name, ts.Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName);
                }
                else {
                    var exportedSymbol = exports ? ts.find(symbolsToArray(exports), function (symbol) { return !!getSymbolIfSameReference(symbol, localSymbol); }) : undefined;
                    var diagnostic = exportedSymbol ? error(name, ts.Diagnostics.Module_0_declares_1_locally_but_it_is_exported_as_2, moduleName, declarationName, symbolToString(exportedSymbol)) :
                        error(name, ts.Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported, moduleName, declarationName);
                    if (localSymbol.declarations) {
                        ts.addRelatedInfo.apply(void 0, __spreadArray([diagnostic], ts.map(localSymbol.declarations, function (decl, index) {
                            return ts.createDiagnosticForNode(decl, index === 0 ? ts.Diagnostics._0_is_declared_here : ts.Diagnostics.and_here, declarationName);
                        }), false));
                    }
                }
            }
            else {
                error(name, ts.Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName);
            }
        }
        function reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName) {
            if (moduleKind >= ts.ModuleKind.ES2015) {
                var message = compilerOptions.esModuleInterop ? ts.Diagnostics._0_can_only_be_imported_by_using_a_default_import :
                    ts.Diagnostics._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
                error(name, message, declarationName);
            }
            else {
                if (ts.isInJSFile(node)) {
                    var message = compilerOptions.esModuleInterop ? ts.Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import :
                        ts.Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
                    error(name, message, declarationName);
                }
                else {
                    var message = compilerOptions.esModuleInterop ? ts.Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import :
                        ts.Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
                    error(name, message, declarationName, declarationName, moduleName);
                }
            }
        }
        function getTargetOfImportSpecifier(node, dontResolveAlias) {
            var root = ts.isBindingElement(node) ? ts.getRootDeclaration(node) : node.parent.parent.parent;
            var commonJSPropertyAccess = getCommonJSPropertyAccess(root);
            var resolved = getExternalModuleMember(root, commonJSPropertyAccess || node, dontResolveAlias);
            var name = node.propertyName || node.name;
            if (commonJSPropertyAccess && resolved && ts.isIdentifier(name)) {
                return resolveSymbol(getPropertyOfType(getTypeOfSymbol(resolved), name.escapedText), dontResolveAlias);
            }
            markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false);
            return resolved;
        }
        function getCommonJSPropertyAccess(node) {
            if (ts.isVariableDeclaration(node) && node.initializer && ts.isPropertyAccessExpression(node.initializer)) {
                return node.initializer;
            }
        }
        function getTargetOfNamespaceExportDeclaration(node, dontResolveAlias) {
            var resolved = resolveExternalModuleSymbol(node.parent.symbol, dontResolveAlias);
            markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false);
            return resolved;
        }
        function getTargetOfExportSpecifier(node, meaning, dontResolveAlias) {
            var resolved = node.parent.parent.moduleSpecifier ?
                getExternalModuleMember(node.parent.parent, node, dontResolveAlias) :
                resolveEntityName(node.propertyName || node.name, meaning, false, dontResolveAlias);
            markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false);
            return resolved;
        }
        function getTargetOfExportAssignment(node, dontResolveAlias) {
            var expression = ts.isExportAssignment(node) ? node.expression : node.right;
            var resolved = getTargetOfAliasLikeExpression(expression, dontResolveAlias);
            markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false);
            return resolved;
        }
        function getTargetOfAliasLikeExpression(expression, dontResolveAlias) {
            if (ts.isClassExpression(expression)) {
                return checkExpressionCached(expression).symbol;
            }
            if (!ts.isEntityName(expression) && !ts.isEntityNameExpression(expression)) {
                return undefined;
            }
            var aliasLike = resolveEntityName(expression, 111551 | 788968 | 1920, true, dontResolveAlias);
            if (aliasLike) {
                return aliasLike;
            }
            checkExpressionCached(expression);
            return getNodeLinks(expression).resolvedSymbol;
        }
        function getTargetOfPropertyAssignment(node, dontRecursivelyResolve) {
            var expression = node.initializer;
            return getTargetOfAliasLikeExpression(expression, dontRecursivelyResolve);
        }
        function getTargetOfAccessExpression(node, dontRecursivelyResolve) {
            if (!(ts.isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === 63)) {
                return undefined;
            }
            return getTargetOfAliasLikeExpression(node.parent.right, dontRecursivelyResolve);
        }
        function getTargetOfAliasDeclaration(node, dontRecursivelyResolve) {
            if (dontRecursivelyResolve === void 0) { dontRecursivelyResolve = false; }
            switch (node.kind) {
                case 263:
                case 252:
                    return getTargetOfImportEqualsDeclaration(node, dontRecursivelyResolve);
                case 265:
                    return getTargetOfImportClause(node, dontRecursivelyResolve);
                case 266:
                    return getTargetOfNamespaceImport(node, dontRecursivelyResolve);
                case 272:
                    return getTargetOfNamespaceExport(node, dontRecursivelyResolve);
                case 268:
                case 201:
                    return getTargetOfImportSpecifier(node, dontRecursivelyResolve);
                case 273:
                    return getTargetOfExportSpecifier(node, 111551 | 788968 | 1920, dontRecursivelyResolve);
                case 269:
                case 219:
                    return getTargetOfExportAssignment(node, dontRecursivelyResolve);
                case 262:
                    return getTargetOfNamespaceExportDeclaration(node, dontRecursivelyResolve);
                case 292:
                    return resolveEntityName(node.name, 111551 | 788968 | 1920, true, dontRecursivelyResolve);
                case 291:
                    return getTargetOfPropertyAssignment(node, dontRecursivelyResolve);
                case 205:
                case 204:
                    return getTargetOfAccessExpression(node, dontRecursivelyResolve);
                default:
                    return ts.Debug.fail();
            }
        }
        function isNonLocalAlias(symbol, excludes) {
            if (excludes === void 0) { excludes = 111551 | 788968 | 1920; }
            if (!symbol)
                return false;
            return (symbol.flags & (2097152 | excludes)) === 2097152 || !!(symbol.flags & 2097152 && symbol.flags & 67108864);
        }
        function resolveSymbol(symbol, dontResolveAlias) {
            return !dontResolveAlias && isNonLocalAlias(symbol) ? resolveAlias(symbol) : symbol;
        }
        function resolveAlias(symbol) {
            ts.Debug.assert((symbol.flags & 2097152) !== 0, "Should only get Alias here.");
            var links = getSymbolLinks(symbol);
            if (!links.target) {
                links.target = resolvingSymbol;
                var node = getDeclarationOfAliasSymbol(symbol);
                if (!node)
                    return ts.Debug.fail();
                var target = getTargetOfAliasDeclaration(node);
                if (links.target === resolvingSymbol) {
                    links.target = target || unknownSymbol;
                }
                else {
                    error(node, ts.Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));
                }
            }
            else if (links.target === resolvingSymbol) {
                links.target = unknownSymbol;
            }
            return links.target;
        }
        function tryResolveAlias(symbol) {
            var links = getSymbolLinks(symbol);
            if (links.target !== resolvingSymbol) {
                return resolveAlias(symbol);
            }
            return undefined;
        }
        function markSymbolOfAliasDeclarationIfTypeOnly(aliasDeclaration, immediateTarget, finalTarget, overwriteEmpty) {
            if (!aliasDeclaration || ts.isPropertyAccessExpression(aliasDeclaration))
                return false;
            var sourceSymbol = getSymbolOfNode(aliasDeclaration);
            if (ts.isTypeOnlyImportOrExportDeclaration(aliasDeclaration)) {
                var links_1 = getSymbolLinks(sourceSymbol);
                links_1.typeOnlyDeclaration = aliasDeclaration;
                return true;
            }
            var links = getSymbolLinks(sourceSymbol);
            return markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, immediateTarget, overwriteEmpty)
                || markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, finalTarget, overwriteEmpty);
        }
        function markSymbolOfAliasDeclarationIfTypeOnlyWorker(aliasDeclarationLinks, target, overwriteEmpty) {
            var _a, _b, _c;
            if (target && (aliasDeclarationLinks.typeOnlyDeclaration === undefined || overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration === false)) {
                var exportSymbol = (_b = (_a = target.exports) === null || _a === void 0 ? void 0 : _a.get("export=")) !== null && _b !== void 0 ? _b : target;
                var typeOnly = exportSymbol.declarations && ts.find(exportSymbol.declarations, ts.isTypeOnlyImportOrExportDeclaration);
                aliasDeclarationLinks.typeOnlyDeclaration = (_c = typeOnly !== null && typeOnly !== void 0 ? typeOnly : getSymbolLinks(exportSymbol).typeOnlyDeclaration) !== null && _c !== void 0 ? _c : false;
            }
            return !!aliasDeclarationLinks.typeOnlyDeclaration;
        }
        function getTypeOnlyAliasDeclaration(symbol) {
            if (!(symbol.flags & 2097152)) {
                return undefined;
            }
            var links = getSymbolLinks(symbol);
            return links.typeOnlyDeclaration || undefined;
        }
        function markExportAsReferenced(node) {
            var symbol = getSymbolOfNode(node);
            var target = resolveAlias(symbol);
            if (target) {
                var markAlias = target === unknownSymbol ||
                    ((target.flags & 111551) && !isConstEnumOrConstEnumOnlyModule(target) && !getTypeOnlyAliasDeclaration(symbol));
                if (markAlias) {
                    markAliasSymbolAsReferenced(symbol);
                }
            }
        }
        function markAliasSymbolAsReferenced(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.referenced) {
                links.referenced = true;
                var node = getDeclarationOfAliasSymbol(symbol);
                if (!node)
                    return ts.Debug.fail();
                if (ts.isInternalModuleImportEqualsDeclaration(node)) {
                    var target = resolveSymbol(symbol);
                    if (target === unknownSymbol || target.flags & 111551) {
                        checkExpressionCached(node.moduleReference);
                    }
                }
            }
        }
        function markConstEnumAliasAsReferenced(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.constEnumReferenced) {
                links.constEnumReferenced = true;
            }
        }
        function getSymbolOfPartOfRightHandSideOfImportEquals(entityName, dontResolveAlias) {
            if (entityName.kind === 79 && ts.isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
                entityName = entityName.parent;
            }
            if (entityName.kind === 79 || entityName.parent.kind === 159) {
                return resolveEntityName(entityName, 1920, false, dontResolveAlias);
            }
            else {
                ts.Debug.assert(entityName.parent.kind === 263);
                return resolveEntityName(entityName, 111551 | 788968 | 1920, false, dontResolveAlias);
            }
        }
        function getFullyQualifiedName(symbol, containingLocation) {
            return symbol.parent ? getFullyQualifiedName(symbol.parent, containingLocation) + "." + symbolToString(symbol) : symbolToString(symbol, containingLocation, undefined, 16 | 4);
        }
        function resolveEntityName(name, meaning, ignoreErrors, dontResolveAlias, location) {
            if (ts.nodeIsMissing(name)) {
                return undefined;
            }
            var namespaceMeaning = 1920 | (ts.isInJSFile(name) ? meaning & 111551 : 0);
            var symbol;
            if (name.kind === 79) {
                var message = meaning === namespaceMeaning || ts.nodeIsSynthesized(name) ? ts.Diagnostics.Cannot_find_namespace_0 : getCannotFindNameDiagnosticForName(ts.getFirstIdentifier(name));
                var symbolFromJSPrototype = ts.isInJSFile(name) && !ts.nodeIsSynthesized(name) ? resolveEntityNameFromAssignmentDeclaration(name, meaning) : undefined;
                symbol = getMergedSymbol(resolveName(location || name, name.escapedText, meaning, ignoreErrors || symbolFromJSPrototype ? undefined : message, name, true));
                if (!symbol) {
                    return getMergedSymbol(symbolFromJSPrototype);
                }
            }
            else if (name.kind === 159 || name.kind === 204) {
                var left = name.kind === 159 ? name.left : name.expression;
                var right = name.kind === 159 ? name.right : name.name;
                var namespace = resolveEntityName(left, namespaceMeaning, ignoreErrors, false, location);
                if (!namespace || ts.nodeIsMissing(right)) {
                    return undefined;
                }
                else if (namespace === unknownSymbol) {
                    return namespace;
                }
                if (namespace.valueDeclaration &&
                    ts.isInJSFile(namespace.valueDeclaration) &&
                    ts.isVariableDeclaration(namespace.valueDeclaration) &&
                    namespace.valueDeclaration.initializer &&
                    isCommonJsRequire(namespace.valueDeclaration.initializer)) {
                    var moduleName = namespace.valueDeclaration.initializer.arguments[0];
                    var moduleSym = resolveExternalModuleName(moduleName, moduleName);
                    if (moduleSym) {
                        var resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
                        if (resolvedModuleSymbol) {
                            namespace = resolvedModuleSymbol;
                        }
                    }
                }
                symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, meaning));
                if (!symbol) {
                    if (!ignoreErrors) {
                        var namespaceName = getFullyQualifiedName(namespace);
                        var declarationName = ts.declarationNameToString(right);
                        var suggestion = getSuggestedSymbolForNonexistentModule(right, namespace);
                        suggestion ?
                            error(right, ts.Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, namespaceName, declarationName, symbolToString(suggestion)) :
                            error(right, ts.Diagnostics.Namespace_0_has_no_exported_member_1, namespaceName, declarationName);
                    }
                    return undefined;
                }
            }
            else {
                throw ts.Debug.assertNever(name, "Unknown entity name kind.");
            }
            ts.Debug.assert((ts.getCheckFlags(symbol) & 1) === 0, "Should never get an instantiated symbol here.");
            if (!ts.nodeIsSynthesized(name) && ts.isEntityName(name) && (symbol.flags & 2097152 || name.parent.kind === 269)) {
                markSymbolOfAliasDeclarationIfTypeOnly(ts.getAliasDeclarationFromName(name), symbol, undefined, true);
            }
            return (symbol.flags & meaning) || dontResolveAlias ? symbol : resolveAlias(symbol);
        }
        function resolveEntityNameFromAssignmentDeclaration(name, meaning) {
            if (isJSDocTypeReference(name.parent)) {
                var secondaryLocation = getAssignmentDeclarationLocation(name.parent);
                if (secondaryLocation) {
                    return resolveName(secondaryLocation, name.escapedText, meaning, undefined, name, true);
                }
            }
        }
        function getAssignmentDeclarationLocation(node) {
            var typeAlias = ts.findAncestor(node, function (node) { return !(ts.isJSDocNode(node) || node.flags & 4194304) ? "quit" : ts.isJSDocTypeAlias(node); });
            if (typeAlias) {
                return;
            }
            var host = ts.getJSDocHost(node);
            if (host &&
                ts.isExpressionStatement(host) &&
                ts.isBinaryExpression(host.expression) &&
                ts.getAssignmentDeclarationKind(host.expression) === 3) {
                var symbol = getSymbolOfNode(host.expression.left);
                if (symbol) {
                    return getDeclarationOfJSPrototypeContainer(symbol);
                }
            }
            if (host && (ts.isObjectLiteralMethod(host) || ts.isPropertyAssignment(host)) &&
                ts.isBinaryExpression(host.parent.parent) &&
                ts.getAssignmentDeclarationKind(host.parent.parent) === 6) {
                var symbol = getSymbolOfNode(host.parent.parent.left);
                if (symbol) {
                    return getDeclarationOfJSPrototypeContainer(symbol);
                }
            }
            var sig = ts.getEffectiveJSDocHost(node);
            if (sig && ts.isFunctionLike(sig)) {
                var symbol = getSymbolOfNode(sig);
                return symbol && symbol.valueDeclaration;
            }
        }
        function getDeclarationOfJSPrototypeContainer(symbol) {
            var decl = symbol.parent.valueDeclaration;
            if (!decl) {
                return undefined;
            }
            var initializer = ts.isAssignmentDeclaration(decl) ? ts.getAssignedExpandoInitializer(decl) :
                ts.hasOnlyExpressionInitializer(decl) ? ts.getDeclaredExpandoInitializer(decl) :
                    undefined;
            return initializer || decl;
        }
        function getExpandoSymbol(symbol) {
            var decl = symbol.valueDeclaration;
            if (!decl || !ts.isInJSFile(decl) || symbol.flags & 524288 || ts.getExpandoInitializer(decl, false)) {
                return undefined;
            }
            var init = ts.isVariableDeclaration(decl) ? ts.getDeclaredExpandoInitializer(decl) : ts.getAssignedExpandoInitializer(decl);
            if (init) {
                var initSymbol = getSymbolOfNode(init);
                if (initSymbol) {
                    return mergeJSSymbols(initSymbol, symbol);
                }
            }
        }
        function resolveExternalModuleName(location, moduleReferenceExpression, ignoreErrors) {
            var isClassic = ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.Classic;
            var errorMessage = isClassic ?
                ts.Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_the_paths_option
                : ts.Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations;
            return resolveExternalModuleNameWorker(location, moduleReferenceExpression, ignoreErrors ? undefined : errorMessage);
        }
        function resolveExternalModuleNameWorker(location, moduleReferenceExpression, moduleNotFoundError, isForAugmentation) {
            if (isForAugmentation === void 0) { isForAugmentation = false; }
            return ts.isStringLiteralLike(moduleReferenceExpression)
                ? resolveExternalModule(location, moduleReferenceExpression.text, moduleNotFoundError, moduleReferenceExpression, isForAugmentation)
                : undefined;
        }
        function resolveExternalModule(location, moduleReference, moduleNotFoundError, errorNode, isForAugmentation) {
            if (isForAugmentation === void 0) { isForAugmentation = false; }
            if (ts.startsWith(moduleReference, "@types/")) {
                var diag = ts.Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1;
                var withoutAtTypePrefix = ts.removePrefix(moduleReference, "@types/");
                error(errorNode, diag, withoutAtTypePrefix, moduleReference);
            }
            var ambientModule = tryFindAmbientModule(moduleReference, true);
            if (ambientModule) {
                return ambientModule;
            }
            var currentSourceFile = ts.getSourceFileOfNode(location);
            var resolvedModule = ts.getResolvedModule(currentSourceFile, moduleReference);
            var resolutionDiagnostic = resolvedModule && ts.getResolutionDiagnostic(compilerOptions, resolvedModule);
            var sourceFile = resolvedModule && !resolutionDiagnostic && host.getSourceFile(resolvedModule.resolvedFileName);
            if (sourceFile) {
                if (sourceFile.symbol) {
                    if (resolvedModule.isExternalLibraryImport && !ts.resolutionExtensionIsTSOrJson(resolvedModule.extension)) {
                        errorOnImplicitAnyModule(false, errorNode, resolvedModule, moduleReference);
                    }
                    return getMergedSymbol(sourceFile.symbol);
                }
                if (moduleNotFoundError) {
                    error(errorNode, ts.Diagnostics.File_0_is_not_a_module, sourceFile.fileName);
                }
                return undefined;
            }
            if (patternAmbientModules) {
                var pattern = ts.findBestPatternMatch(patternAmbientModules, function (_) { return _.pattern; }, moduleReference);
                if (pattern) {
                    var augmentation = patternAmbientModuleAugmentations && patternAmbientModuleAugmentations.get(moduleReference);
                    if (augmentation) {
                        return getMergedSymbol(augmentation);
                    }
                    return getMergedSymbol(pattern.symbol);
                }
            }
            if (resolvedModule && !ts.resolutionExtensionIsTSOrJson(resolvedModule.extension) && resolutionDiagnostic === undefined || resolutionDiagnostic === ts.Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type) {
                if (isForAugmentation) {
                    var diag = ts.Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented;
                    error(errorNode, diag, moduleReference, resolvedModule.resolvedFileName);
                }
                else {
                    errorOnImplicitAnyModule(noImplicitAny && !!moduleNotFoundError, errorNode, resolvedModule, moduleReference);
                }
                return undefined;
            }
            if (moduleNotFoundError) {
                if (resolvedModule) {
                    var redirect = host.getProjectReferenceRedirect(resolvedModule.resolvedFileName);
                    if (redirect) {
                        error(errorNode, ts.Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, resolvedModule.resolvedFileName);
                        return undefined;
                    }
                }
                if (resolutionDiagnostic) {
                    error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName);
                }
                else {
                    var tsExtension = ts.tryExtractTSExtension(moduleReference);
                    if (tsExtension) {
                        var diag = ts.Diagnostics.An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead;
                        var importSourceWithoutExtension = ts.removeExtension(moduleReference, tsExtension);
                        var replacedImportSource = importSourceWithoutExtension;
                        var moduleKind_1 = ts.getEmitModuleKind(compilerOptions);
                        if (moduleKind_1 >= ts.ModuleKind.ES2015) {
                            replacedImportSource += ".js";
                        }
                        error(errorNode, diag, tsExtension, replacedImportSource);
                    }
                    else if (!compilerOptions.resolveJsonModule &&
                        ts.fileExtensionIs(moduleReference, ".json") &&
                        ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeJs &&
                        ts.hasJsonModuleEmitEnabled(compilerOptions)) {
                        error(errorNode, ts.Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension, moduleReference);
                    }
                    else {
                        error(errorNode, moduleNotFoundError, moduleReference);
                    }
                }
            }
            return undefined;
        }
        function errorOnImplicitAnyModule(isError, errorNode, _a, moduleReference) {
            var packageId = _a.packageId, resolvedFileName = _a.resolvedFileName;
            var errorInfo = !ts.isExternalModuleNameRelative(moduleReference) && packageId
                ? typesPackageExists(packageId.name)
                    ? ts.chainDiagnosticMessages(undefined, ts.Diagnostics.If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1, packageId.name, ts.mangleScopedPackageName(packageId.name))
                    : ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0, moduleReference, ts.mangleScopedPackageName(packageId.name))
                : undefined;
            errorOrSuggestion(isError, errorNode, ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type, moduleReference, resolvedFileName));
        }
        function typesPackageExists(packageName) {
            return getPackagesSet().has(ts.getTypesPackageName(packageName));
        }
        function resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) {
            if (moduleSymbol === null || moduleSymbol === void 0 ? void 0 : moduleSymbol.exports) {
                var exportEquals = resolveSymbol(moduleSymbol.exports.get("export="), dontResolveAlias);
                var exported = getCommonJsExportEquals(getMergedSymbol(exportEquals), getMergedSymbol(moduleSymbol));
                return getMergedSymbol(exported) || moduleSymbol;
            }
            return undefined;
        }
        function getCommonJsExportEquals(exported, moduleSymbol) {
            if (!exported || exported === unknownSymbol || exported === moduleSymbol || moduleSymbol.exports.size === 1 || exported.flags & 2097152) {
                return exported;
            }
            var links = getSymbolLinks(exported);
            if (links.cjsExportMerged) {
                return links.cjsExportMerged;
            }
            var merged = exported.flags & 33554432 ? exported : cloneSymbol(exported);
            merged.flags = merged.flags | 512;
            if (merged.exports === undefined) {
                merged.exports = ts.createSymbolTable();
            }
            moduleSymbol.exports.forEach(function (s, name) {
                if (name === "export=")
                    return;
                merged.exports.set(name, merged.exports.has(name) ? mergeSymbol(merged.exports.get(name), s) : s);
            });
            getSymbolLinks(merged).cjsExportMerged = merged;
            return links.cjsExportMerged = merged;
        }
        function resolveESModuleSymbol(moduleSymbol, referencingLocation, dontResolveAlias, suppressInteropError) {
            var symbol = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias);
            if (!dontResolveAlias && symbol) {
                if (!suppressInteropError && !(symbol.flags & (1536 | 3)) && !ts.getDeclarationOfKind(symbol, 300)) {
                    var compilerOptionName = moduleKind >= ts.ModuleKind.ES2015
                        ? "allowSyntheticDefaultImports"
                        : "esModuleInterop";
                    error(referencingLocation, ts.Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export, compilerOptionName);
                    return symbol;
                }
                if (compilerOptions.esModuleInterop) {
                    var referenceParent = referencingLocation.parent;
                    if ((ts.isImportDeclaration(referenceParent) && ts.getNamespaceDeclarationNode(referenceParent)) ||
                        ts.isImportCall(referenceParent)) {
                        var type = getTypeOfSymbol(symbol);
                        var sigs = getSignaturesOfStructuredType(type, 0);
                        if (!sigs || !sigs.length) {
                            sigs = getSignaturesOfStructuredType(type, 1);
                        }
                        if (sigs && sigs.length) {
                            var moduleType = getTypeWithSyntheticDefaultImportType(type, symbol, moduleSymbol);
                            var result = createSymbol(symbol.flags, symbol.escapedName);
                            result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
                            result.parent = symbol.parent;
                            result.target = symbol;
                            result.originatingImport = referenceParent;
                            if (symbol.valueDeclaration)
                                result.valueDeclaration = symbol.valueDeclaration;
                            if (symbol.constEnumOnlyModule)
                                result.constEnumOnlyModule = true;
                            if (symbol.members)
                                result.members = new ts.Map(symbol.members);
                            if (symbol.exports)
                                result.exports = new ts.Map(symbol.exports);
                            var resolvedModuleType = resolveStructuredTypeMembers(moduleType);
                            result.type = createAnonymousType(result, resolvedModuleType.members, ts.emptyArray, ts.emptyArray, resolvedModuleType.indexInfos);
                            return result;
                        }
                    }
                }
            }
            return symbol;
        }
        function hasExportAssignmentSymbol(moduleSymbol) {
            return moduleSymbol.exports.get("export=") !== undefined;
        }
        function getExportsOfModuleAsArray(moduleSymbol) {
            return symbolsToArray(getExportsOfModule(moduleSymbol));
        }
        function getExportsAndPropertiesOfModule(moduleSymbol) {
            var exports = getExportsOfModuleAsArray(moduleSymbol);
            var exportEquals = resolveExternalModuleSymbol(moduleSymbol);
            if (exportEquals !== moduleSymbol) {
                var type = getTypeOfSymbol(exportEquals);
                if (shouldTreatPropertiesOfExternalModuleAsExports(type)) {
                    ts.addRange(exports, getPropertiesOfType(type));
                }
            }
            return exports;
        }
        function forEachExportAndPropertyOfModule(moduleSymbol, cb) {
            var exports = getExportsOfModule(moduleSymbol);
            exports.forEach(function (symbol, key) {
                if (!isReservedMemberName(key)) {
                    cb(symbol, key);
                }
            });
            var exportEquals = resolveExternalModuleSymbol(moduleSymbol);
            if (exportEquals !== moduleSymbol) {
                var type = getTypeOfSymbol(exportEquals);
                if (shouldTreatPropertiesOfExternalModuleAsExports(type)) {
                    getPropertiesOfType(type).forEach(function (symbol) {
                        cb(symbol, symbol.escapedName);
                    });
                }
            }
        }
        function tryGetMemberInModuleExports(memberName, moduleSymbol) {
            var symbolTable = getExportsOfModule(moduleSymbol);
            if (symbolTable) {
                return symbolTable.get(memberName);
            }
        }
        function tryGetMemberInModuleExportsAndProperties(memberName, moduleSymbol) {
            var symbol = tryGetMemberInModuleExports(memberName, moduleSymbol);
            if (symbol) {
                return symbol;
            }
            var exportEquals = resolveExternalModuleSymbol(moduleSymbol);
            if (exportEquals === moduleSymbol) {
                return undefined;
            }
            var type = getTypeOfSymbol(exportEquals);
            return shouldTreatPropertiesOfExternalModuleAsExports(type) ? getPropertyOfType(type, memberName) : undefined;
        }
        function shouldTreatPropertiesOfExternalModuleAsExports(resolvedExternalModuleType) {
            return !(resolvedExternalModuleType.flags & 131068 ||
                ts.getObjectFlags(resolvedExternalModuleType) & 1 ||
                isArrayType(resolvedExternalModuleType) ||
                isTupleType(resolvedExternalModuleType));
        }
        function getExportsOfSymbol(symbol) {
            return symbol.flags & 6256 ? getResolvedMembersOrExportsOfSymbol(symbol, "resolvedExports") :
                symbol.flags & 1536 ? getExportsOfModule(symbol) :
                    symbol.exports || emptySymbols;
        }
        function getExportsOfModule(moduleSymbol) {
            var links = getSymbolLinks(moduleSymbol);
            return links.resolvedExports || (links.resolvedExports = getExportsOfModuleWorker(moduleSymbol));
        }
        function extendExportSymbols(target, source, lookupTable, exportNode) {
            if (!source)
                return;
            source.forEach(function (sourceSymbol, id) {
                if (id === "default")
                    return;
                var targetSymbol = target.get(id);
                if (!targetSymbol) {
                    target.set(id, sourceSymbol);
                    if (lookupTable && exportNode) {
                        lookupTable.set(id, {
                            specifierText: ts.getTextOfNode(exportNode.moduleSpecifier)
                        });
                    }
                }
                else if (lookupTable && exportNode && targetSymbol && resolveSymbol(targetSymbol) !== resolveSymbol(sourceSymbol)) {
                    var collisionTracker = lookupTable.get(id);
                    if (!collisionTracker.exportsWithDuplicate) {
                        collisionTracker.exportsWithDuplicate = [exportNode];
                    }
                    else {
                        collisionTracker.exportsWithDuplicate.push(exportNode);
                    }
                }
            });
        }
        function getExportsOfModuleWorker(moduleSymbol) {
            var visitedSymbols = [];
            moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
            return visit(moduleSymbol) || emptySymbols;
            function visit(symbol) {
                if (!(symbol && symbol.exports && ts.pushIfUnique(visitedSymbols, symbol))) {
                    return;
                }
                var symbols = new ts.Map(symbol.exports);
                var exportStars = symbol.exports.get("__export");
                if (exportStars) {
                    var nestedSymbols = ts.createSymbolTable();
                    var lookupTable_1 = new ts.Map();
                    if (exportStars.declarations) {
                        for (var _i = 0, _a = exportStars.declarations; _i < _a.length; _i++) {
                            var node = _a[_i];
                            var resolvedModule = resolveExternalModuleName(node, node.moduleSpecifier);
                            var exportedSymbols = visit(resolvedModule);
                            extendExportSymbols(nestedSymbols, exportedSymbols, lookupTable_1, node);
                        }
                    }
                    lookupTable_1.forEach(function (_a, id) {
                        var exportsWithDuplicate = _a.exportsWithDuplicate;
                        if (id === "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id)) {
                            return;
                        }
                        for (var _i = 0, exportsWithDuplicate_1 = exportsWithDuplicate; _i < exportsWithDuplicate_1.length; _i++) {
                            var node = exportsWithDuplicate_1[_i];
                            diagnostics.add(ts.createDiagnosticForNode(node, ts.Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity, lookupTable_1.get(id).specifierText, ts.unescapeLeadingUnderscores(id)));
                        }
                    });
                    extendExportSymbols(symbols, nestedSymbols);
                }
                return symbols;
            }
        }
        function getMergedSymbol(symbol) {
            var merged;
            return symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol;
        }
        function getSymbolOfNode(node) {
            return getMergedSymbol(node.symbol && getLateBoundSymbol(node.symbol));
        }
        function getParentOfSymbol(symbol) {
            return getMergedSymbol(symbol.parent && getLateBoundSymbol(symbol.parent));
        }
        function getAlternativeContainingModules(symbol, enclosingDeclaration) {
            var containingFile = ts.getSourceFileOfNode(enclosingDeclaration);
            var id = getNodeId(containingFile);
            var links = getSymbolLinks(symbol);
            var results;
            if (links.extendedContainersByFile && (results = links.extendedContainersByFile.get(id))) {
                return results;
            }
            if (containingFile && containingFile.imports) {
                for (var _i = 0, _a = containingFile.imports; _i < _a.length; _i++) {
                    var importRef = _a[_i];
                    if (ts.nodeIsSynthesized(importRef))
                        continue;
                    var resolvedModule = resolveExternalModuleName(enclosingDeclaration, importRef, true);
                    if (!resolvedModule)
                        continue;
                    var ref = getAliasForSymbolInContainer(resolvedModule, symbol);
                    if (!ref)
                        continue;
                    results = ts.append(results, resolvedModule);
                }
                if (ts.length(results)) {
                    (links.extendedContainersByFile || (links.extendedContainersByFile = new ts.Map())).set(id, results);
                    return results;
                }
            }
            if (links.extendedContainers) {
                return links.extendedContainers;
            }
            var otherFiles = host.getSourceFiles();
            for (var _b = 0, otherFiles_1 = otherFiles; _b < otherFiles_1.length; _b++) {
                var file = otherFiles_1[_b];
                if (!ts.isExternalModule(file))
                    continue;
                var sym = getSymbolOfNode(file);
                var ref = getAliasForSymbolInContainer(sym, symbol);
                if (!ref)
                    continue;
                results = ts.append(results, sym);
            }
            return links.extendedContainers = results || ts.emptyArray;
        }
        function getContainersOfSymbol(symbol, enclosingDeclaration, meaning) {
            var container = getParentOfSymbol(symbol);
            if (container && !(symbol.flags & 262144)) {
                var additionalContainers = ts.mapDefined(container.declarations, fileSymbolIfFileSymbolExportEqualsContainer);
                var reexportContainers = enclosingDeclaration && getAlternativeContainingModules(symbol, enclosingDeclaration);
                var objectLiteralContainer = getVariableDeclarationOfObjectLiteral(container, meaning);
                if (enclosingDeclaration &&
                    container.flags & getQualifiedLeftMeaning(meaning) &&
                    getAccessibleSymbolChain(container, enclosingDeclaration, 1920, false)) {
                    return ts.append(ts.concatenate(ts.concatenate([container], additionalContainers), reexportContainers), objectLiteralContainer);
                }
                var firstVariableMatch = !(container.flags & getQualifiedLeftMeaning(meaning))
                    && container.flags & 788968
                    && getDeclaredTypeOfSymbol(container).flags & 524288
                    && meaning === 111551
                    ? forEachSymbolTableInScope(enclosingDeclaration, function (t) {
                        return ts.forEachEntry(t, function (s) {
                            if (s.flags & getQualifiedLeftMeaning(meaning) && getTypeOfSymbol(s) === getDeclaredTypeOfSymbol(container)) {
                                return s;
                            }
                        });
                    }) : undefined;
                var res = firstVariableMatch ? __spreadArray(__spreadArray([firstVariableMatch], additionalContainers, true), [container], false) : __spreadArray(__spreadArray([], additionalContainers, true), [container], false);
                res = ts.append(res, objectLiteralContainer);
                res = ts.addRange(res, reexportContainers);
                return res;
            }
            var candidates = ts.mapDefined(symbol.declarations, function (d) {
                if (!ts.isAmbientModule(d) && d.parent && hasNonGlobalAugmentationExternalModuleSymbol(d.parent)) {
                    return getSymbolOfNode(d.parent);
                }
                if (ts.isClassExpression(d) && ts.isBinaryExpression(d.parent) && d.parent.operatorToken.kind === 63 && ts.isAccessExpression(d.parent.left) && ts.isEntityNameExpression(d.parent.left.expression)) {
                    if (ts.isModuleExportsAccessExpression(d.parent.left) || ts.isExportsIdentifier(d.parent.left.expression)) {
                        return getSymbolOfNode(ts.getSourceFileOfNode(d));
                    }
                    checkExpressionCached(d.parent.left.expression);
                    return getNodeLinks(d.parent.left.expression).resolvedSymbol;
                }
            });
            if (!ts.length(candidates)) {
                return undefined;
            }
            return ts.mapDefined(candidates, function (candidate) { return getAliasForSymbolInContainer(candidate, symbol) ? candidate : undefined; });
            function fileSymbolIfFileSymbolExportEqualsContainer(d) {
                return container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container);
            }
        }
        function getVariableDeclarationOfObjectLiteral(symbol, meaning) {
            var firstDecl = !!ts.length(symbol.declarations) && ts.first(symbol.declarations);
            if (meaning & 111551 && firstDecl && firstDecl.parent && ts.isVariableDeclaration(firstDecl.parent)) {
                if (ts.isObjectLiteralExpression(firstDecl) && firstDecl === firstDecl.parent.initializer || ts.isTypeLiteralNode(firstDecl) && firstDecl === firstDecl.parent.type) {
                    return getSymbolOfNode(firstDecl.parent);
                }
            }
        }
        function getFileSymbolIfFileSymbolExportEqualsContainer(d, container) {
            var fileSymbol = getExternalModuleContainer(d);
            var exported = fileSymbol && fileSymbol.exports && fileSymbol.exports.get("export=");
            return exported && getSymbolIfSameReference(exported, container) ? fileSymbol : undefined;
        }
        function getAliasForSymbolInContainer(container, symbol) {
            if (container === getParentOfSymbol(symbol)) {
                return symbol;
            }
            var exportEquals = container.exports && container.exports.get("export=");
            if (exportEquals && getSymbolIfSameReference(exportEquals, symbol)) {
                return container;
            }
            var exports = getExportsOfSymbol(container);
            var quick = exports.get(symbol.escapedName);
            if (quick && getSymbolIfSameReference(quick, symbol)) {
                return quick;
            }
            return ts.forEachEntry(exports, function (exported) {
                if (getSymbolIfSameReference(exported, symbol)) {
                    return exported;
                }
            });
        }
        function getSymbolIfSameReference(s1, s2) {
            if (getMergedSymbol(resolveSymbol(getMergedSymbol(s1))) === getMergedSymbol(resolveSymbol(getMergedSymbol(s2)))) {
                return s1;
            }
        }
        function getExportSymbolOfValueSymbolIfExported(symbol) {
            return getMergedSymbol(symbol && (symbol.flags & 1048576) !== 0 ? symbol.exportSymbol : symbol);
        }
        function symbolIsValue(symbol) {
            return !!(symbol.flags & 111551 || symbol.flags & 2097152 && resolveAlias(symbol).flags & 111551 && !getTypeOnlyAliasDeclaration(symbol));
        }
        function findConstructorDeclaration(node) {
            var members = node.members;
            for (var _i = 0, members_3 = members; _i < members_3.length; _i++) {
                var member = members_3[_i];
                if (member.kind === 169 && ts.nodeIsPresent(member.body)) {
                    return member;
                }
            }
        }
        function createType(flags) {
            var result = new Type(checker, flags);
            typeCount++;
            result.id = typeCount;
            if (produceDiagnostics) {
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.recordType(result);
            }
            return result;
        }
        function createOriginType(flags) {
            return new Type(checker, flags);
        }
        function createIntrinsicType(kind, intrinsicName, objectFlags) {
            if (objectFlags === void 0) { objectFlags = 0; }
            var type = createType(kind);
            type.intrinsicName = intrinsicName;
            type.objectFlags = objectFlags;
            return type;
        }
        function createObjectType(objectFlags, symbol) {
            var type = createType(524288);
            type.objectFlags = objectFlags;
            type.symbol = symbol;
            type.members = undefined;
            type.properties = undefined;
            type.callSignatures = undefined;
            type.constructSignatures = undefined;
            type.indexInfos = undefined;
            return type;
        }
        function createTypeofType() {
            return getUnionType(ts.arrayFrom(typeofEQFacts.keys(), getStringLiteralType));
        }
        function createTypeParameter(symbol) {
            var type = createType(262144);
            if (symbol)
                type.symbol = symbol;
            return type;
        }
        function isReservedMemberName(name) {
            return name.charCodeAt(0) === 95 &&
                name.charCodeAt(1) === 95 &&
                name.charCodeAt(2) !== 95 &&
                name.charCodeAt(2) !== 64 &&
                name.charCodeAt(2) !== 35;
        }
        function getNamedMembers(members) {
            var result;
            members.forEach(function (symbol, id) {
                if (!isReservedMemberName(id) && symbolIsValue(symbol)) {
                    (result || (result = [])).push(symbol);
                }
            });
            return result || ts.emptyArray;
        }
        function getNamedOrIndexSignatureMembers(members) {
            var result = getNamedMembers(members);
            var index = getIndexSymbolFromSymbolTable(members);
            return index ? ts.concatenate(result, [index]) : result;
        }
        function setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos) {
            var resolved = type;
            resolved.members = members;
            resolved.properties = ts.emptyArray;
            resolved.callSignatures = callSignatures;
            resolved.constructSignatures = constructSignatures;
            resolved.indexInfos = indexInfos;
            if (members !== emptySymbols)
                resolved.properties = getNamedMembers(members);
            return resolved;
        }
        function createAnonymousType(symbol, members, callSignatures, constructSignatures, indexInfos) {
            return setStructuredTypeMembers(createObjectType(16, symbol), members, callSignatures, constructSignatures, indexInfos);
        }
        function getResolvedTypeWithoutAbstractConstructSignatures(type) {
            if (type.constructSignatures.length === 0)
                return type;
            if (type.objectTypeWithoutAbstractConstructSignatures)
                return type.objectTypeWithoutAbstractConstructSignatures;
            var constructSignatures = ts.filter(type.constructSignatures, function (signature) { return !(signature.flags & 4); });
            if (type.constructSignatures === constructSignatures)
                return type;
            var typeCopy = createAnonymousType(type.symbol, type.members, type.callSignatures, ts.some(constructSignatures) ? constructSignatures : ts.emptyArray, type.indexInfos);
            type.objectTypeWithoutAbstractConstructSignatures = typeCopy;
            typeCopy.objectTypeWithoutAbstractConstructSignatures = typeCopy;
            return typeCopy;
        }
        function forEachSymbolTableInScope(enclosingDeclaration, callback) {
            var result;
            var _loop_8 = function (location) {
                if (location.locals && !isGlobalSourceFile(location)) {
                    if (result = callback(location.locals, undefined, true, location)) {
                        return { value: result };
                    }
                }
                switch (location.kind) {
                    case 300:
                        if (!ts.isExternalOrCommonJsModule(location)) {
                            break;
                        }
                    case 259:
                        var sym = getSymbolOfNode(location);
                        if (result = callback((sym === null || sym === void 0 ? void 0 : sym.exports) || emptySymbols, undefined, true, location)) {
                            return { value: result };
                        }
                        break;
                    case 255:
                    case 224:
                    case 256:
                        var table_1;
                        (getSymbolOfNode(location).members || emptySymbols).forEach(function (memberSymbol, key) {
                            if (memberSymbol.flags & (788968 & ~67108864)) {
                                (table_1 || (table_1 = ts.createSymbolTable())).set(key, memberSymbol);
                            }
                        });
                        if (table_1 && (result = callback(table_1, undefined, false, location))) {
                            return { value: result };
                        }
                        break;
                }
            };
            for (var location = enclosingDeclaration; location; location = location.parent) {
                var state_2 = _loop_8(location);
                if (typeof state_2 === "object")
                    return state_2.value;
            }
            return callback(globals, undefined, true);
        }
        function getQualifiedLeftMeaning(rightMeaning) {
            return rightMeaning === 111551 ? 111551 : 1920;
        }
        function getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, useOnlyExternalAliasing, visitedSymbolTablesMap) {
            if (visitedSymbolTablesMap === void 0) { visitedSymbolTablesMap = new ts.Map(); }
            if (!(symbol && !isPropertyOrMethodDeclarationSymbol(symbol))) {
                return undefined;
            }
            var links = getSymbolLinks(symbol);
            var cache = (links.accessibleChainCache || (links.accessibleChainCache = new ts.Map()));
            var firstRelevantLocation = forEachSymbolTableInScope(enclosingDeclaration, function (_, __, ___, node) { return node; });
            var key = (useOnlyExternalAliasing ? 0 : 1) + "|" + (firstRelevantLocation && getNodeId(firstRelevantLocation)) + "|" + meaning;
            if (cache.has(key)) {
                return cache.get(key);
            }
            var id = getSymbolId(symbol);
            var visitedSymbolTables = visitedSymbolTablesMap.get(id);
            if (!visitedSymbolTables) {
                visitedSymbolTablesMap.set(id, visitedSymbolTables = []);
            }
            var result = forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable);
            cache.set(key, result);
            return result;
            function getAccessibleSymbolChainFromSymbolTable(symbols, ignoreQualification, isLocalNameLookup) {
                if (!ts.pushIfUnique(visitedSymbolTables, symbols)) {
                    return undefined;
                }
                var result = trySymbolTable(symbols, ignoreQualification, isLocalNameLookup);
                visitedSymbolTables.pop();
                return result;
            }
            function canQualifySymbol(symbolFromSymbolTable, meaning) {
                return !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) ||
                    !!getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing, visitedSymbolTablesMap);
            }
            function isAccessible(symbolFromSymbolTable, resolvedAliasSymbol, ignoreQualification) {
                return (symbol === (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(symbol) === getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) &&
                    !ts.some(symbolFromSymbolTable.declarations, hasNonGlobalAugmentationExternalModuleSymbol) &&
                    (ignoreQualification || canQualifySymbol(getMergedSymbol(symbolFromSymbolTable), meaning));
            }
            function trySymbolTable(symbols, ignoreQualification, isLocalNameLookup) {
                if (isAccessible(symbols.get(symbol.escapedName), undefined, ignoreQualification)) {
                    return [symbol];
                }
                var result = ts.forEachEntry(symbols, function (symbolFromSymbolTable) {
                    if (symbolFromSymbolTable.flags & 2097152
                        && symbolFromSymbolTable.escapedName !== "export="
                        && symbolFromSymbolTable.escapedName !== "default"
                        && !(ts.isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && ts.isExternalModule(ts.getSourceFileOfNode(enclosingDeclaration)))
                        && (!useOnlyExternalAliasing || ts.some(symbolFromSymbolTable.declarations, ts.isExternalModuleImportEqualsDeclaration))
                        && (isLocalNameLookup ? !ts.some(symbolFromSymbolTable.declarations, ts.isNamespaceReexportDeclaration) : true)
                        && (ignoreQualification || !ts.getDeclarationOfKind(symbolFromSymbolTable, 273))) {
                        var resolvedImportedSymbol = resolveAlias(symbolFromSymbolTable);
                        var candidate = getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification);
                        if (candidate) {
                            return candidate;
                        }
                    }
                    if (symbolFromSymbolTable.escapedName === symbol.escapedName && symbolFromSymbolTable.exportSymbol) {
                        if (isAccessible(getMergedSymbol(symbolFromSymbolTable.exportSymbol), undefined, ignoreQualification)) {
                            return [symbol];
                        }
                    }
                });
                return result || (symbols === globals ? getCandidateListForSymbol(globalThisSymbol, globalThisSymbol, ignoreQualification) : undefined);
            }
            function getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification) {
                if (isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification)) {
                    return [symbolFromSymbolTable];
                }
                var candidateTable = getExportsOfSymbol(resolvedImportedSymbol);
                var accessibleSymbolsFromExports = candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable, true);
                if (accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning))) {
                    return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);
                }
            }
        }
        function needsQualification(symbol, enclosingDeclaration, meaning) {
            var qualify = false;
            forEachSymbolTableInScope(enclosingDeclaration, function (symbolTable) {
                var symbolFromSymbolTable = getMergedSymbol(symbolTable.get(symbol.escapedName));
                if (!symbolFromSymbolTable) {
                    return false;
                }
                if (symbolFromSymbolTable === symbol) {
                    return true;
                }
                symbolFromSymbolTable = (symbolFromSymbolTable.flags & 2097152 && !ts.getDeclarationOfKind(symbolFromSymbolTable, 273)) ? resolveAlias(symbolFromSymbolTable) : symbolFromSymbolTable;
                if (symbolFromSymbolTable.flags & meaning) {
                    qualify = true;
                    return true;
                }
                return false;
            });
            return qualify;
        }
        function isPropertyOrMethodDeclarationSymbol(symbol) {
            if (symbol.declarations && symbol.declarations.length) {
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    switch (declaration.kind) {
                        case 165:
                        case 167:
                        case 170:
                        case 171:
                            continue;
                        default:
                            return false;
                    }
                }
                return true;
            }
            return false;
        }
        function isTypeSymbolAccessible(typeSymbol, enclosingDeclaration) {
            var access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, 788968, false, true);
            return access.accessibility === 0;
        }
        function isValueSymbolAccessible(typeSymbol, enclosingDeclaration) {
            var access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, 111551, false, true);
            return access.accessibility === 0;
        }
        function isSymbolAccessibleByFlags(typeSymbol, enclosingDeclaration, flags) {
            var access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, flags, false, false);
            return access.accessibility === 0;
        }
        function isAnySymbolAccessible(symbols, enclosingDeclaration, initialSymbol, meaning, shouldComputeAliasesToMakeVisible, allowModules) {
            if (!ts.length(symbols))
                return;
            var hadAccessibleChain;
            var earlyModuleBail = false;
            for (var _i = 0, _a = symbols; _i < _a.length; _i++) {
                var symbol = _a[_i];
                var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, false);
                if (accessibleSymbolChain) {
                    hadAccessibleChain = symbol;
                    var hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0], shouldComputeAliasesToMakeVisible);
                    if (hasAccessibleDeclarations) {
                        return hasAccessibleDeclarations;
                    }
                }
                if (allowModules) {
                    if (ts.some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                        if (shouldComputeAliasesToMakeVisible) {
                            earlyModuleBail = true;
                            continue;
                        }
                        return {
                            accessibility: 0
                        };
                    }
                }
                var containers = getContainersOfSymbol(symbol, enclosingDeclaration, meaning);
                var parentResult = isAnySymbolAccessible(containers, enclosingDeclaration, initialSymbol, initialSymbol === symbol ? getQualifiedLeftMeaning(meaning) : meaning, shouldComputeAliasesToMakeVisible, allowModules);
                if (parentResult) {
                    return parentResult;
                }
            }
            if (earlyModuleBail) {
                return {
                    accessibility: 0
                };
            }
            if (hadAccessibleChain) {
                return {
                    accessibility: 1,
                    errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                    errorModuleName: hadAccessibleChain !== initialSymbol ? symbolToString(hadAccessibleChain, enclosingDeclaration, 1920) : undefined,
                };
            }
        }
        function isSymbolAccessible(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible) {
            return isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible, true);
        }
        function isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible, allowModules) {
            if (symbol && enclosingDeclaration) {
                var result = isAnySymbolAccessible([symbol], enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible, allowModules);
                if (result) {
                    return result;
                }
                var symbolExternalModule = ts.forEach(symbol.declarations, getExternalModuleContainer);
                if (symbolExternalModule) {
                    var enclosingExternalModule = getExternalModuleContainer(enclosingDeclaration);
                    if (symbolExternalModule !== enclosingExternalModule) {
                        return {
                            accessibility: 2,
                            errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),
                            errorModuleName: symbolToString(symbolExternalModule),
                            errorNode: ts.isInJSFile(enclosingDeclaration) ? enclosingDeclaration : undefined,
                        };
                    }
                }
                return {
                    accessibility: 1,
                    errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),
                };
            }
            return { accessibility: 0 };
        }
        function getExternalModuleContainer(declaration) {
            var node = ts.findAncestor(declaration, hasExternalModuleSymbol);
            return node && getSymbolOfNode(node);
        }
        function hasExternalModuleSymbol(declaration) {
            return ts.isAmbientModule(declaration) || (declaration.kind === 300 && ts.isExternalOrCommonJsModule(declaration));
        }
        function hasNonGlobalAugmentationExternalModuleSymbol(declaration) {
            return ts.isModuleWithStringLiteralName(declaration) || (declaration.kind === 300 && ts.isExternalOrCommonJsModule(declaration));
        }
        function hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) {
            var aliasesToMakeVisible;
            if (!ts.every(ts.filter(symbol.declarations, function (d) { return d.kind !== 79; }), getIsDeclarationVisible)) {
                return undefined;
            }
            return { accessibility: 0, aliasesToMakeVisible: aliasesToMakeVisible };
            function getIsDeclarationVisible(declaration) {
                var _a, _b;
                if (!isDeclarationVisible(declaration)) {
                    var anyImportSyntax = getAnyImportSyntax(declaration);
                    if (anyImportSyntax &&
                        !ts.hasSyntacticModifier(anyImportSyntax, 1) &&
                        isDeclarationVisible(anyImportSyntax.parent)) {
                        return addVisibleAlias(declaration, anyImportSyntax);
                    }
                    else if (ts.isVariableDeclaration(declaration) && ts.isVariableStatement(declaration.parent.parent) &&
                        !ts.hasSyntacticModifier(declaration.parent.parent, 1) &&
                        isDeclarationVisible(declaration.parent.parent.parent)) {
                        return addVisibleAlias(declaration, declaration.parent.parent);
                    }
                    else if (ts.isLateVisibilityPaintedStatement(declaration)
                        && !ts.hasSyntacticModifier(declaration, 1)
                        && isDeclarationVisible(declaration.parent)) {
                        return addVisibleAlias(declaration, declaration);
                    }
                    else if (symbol.flags & 2097152 && ts.isBindingElement(declaration) && ts.isInJSFile(declaration) && ((_a = declaration.parent) === null || _a === void 0 ? void 0 : _a.parent)
                        && ts.isVariableDeclaration(declaration.parent.parent)
                        && ((_b = declaration.parent.parent.parent) === null || _b === void 0 ? void 0 : _b.parent) && ts.isVariableStatement(declaration.parent.parent.parent.parent)
                        && !ts.hasSyntacticModifier(declaration.parent.parent.parent.parent, 1)
                        && declaration.parent.parent.parent.parent.parent
                        && isDeclarationVisible(declaration.parent.parent.parent.parent.parent)) {
                        return addVisibleAlias(declaration, declaration.parent.parent.parent.parent);
                    }
                    return false;
                }
                return true;
            }
            function addVisibleAlias(declaration, aliasingStatement) {
                if (shouldComputeAliasToMakeVisible) {
                    getNodeLinks(declaration).isVisible = true;
                    aliasesToMakeVisible = ts.appendIfUnique(aliasesToMakeVisible, aliasingStatement);
                }
                return true;
            }
        }
        function isEntityNameVisible(entityName, enclosingDeclaration) {
            var meaning;
            if (entityName.parent.kind === 179 ||
                ts.isExpressionWithTypeArgumentsInClassExtendsClause(entityName.parent) ||
                entityName.parent.kind === 160) {
                meaning = 111551 | 1048576;
            }
            else if (entityName.kind === 159 || entityName.kind === 204 ||
                entityName.parent.kind === 263) {
                meaning = 1920;
            }
            else {
                meaning = 788968;
            }
            var firstIdentifier = ts.getFirstIdentifier(entityName);
            var symbol = resolveName(enclosingDeclaration, firstIdentifier.escapedText, meaning, undefined, undefined, false);
            if (symbol && symbol.flags & 262144 && meaning & 788968) {
                return { accessibility: 0 };
            }
            return (symbol && hasVisibleDeclarations(symbol, true)) || {
                accessibility: 1,
                errorSymbolName: ts.getTextOfNode(firstIdentifier),
                errorNode: firstIdentifier
            };
        }
        function symbolToString(symbol, enclosingDeclaration, meaning, flags, writer) {
            if (flags === void 0) { flags = 4; }
            var nodeFlags = 70221824;
            if (flags & 2) {
                nodeFlags |= 128;
            }
            if (flags & 1) {
                nodeFlags |= 512;
            }
            if (flags & 8) {
                nodeFlags |= 16384;
            }
            if (flags & 16) {
                nodeFlags |= 134217728;
            }
            var builder = flags & 4 ? nodeBuilder.symbolToExpression : nodeBuilder.symbolToEntityName;
            return writer ? symbolToStringWorker(writer).getText() : ts.usingSingleLineStringWriter(symbolToStringWorker);
            function symbolToStringWorker(writer) {
                var entity = builder(symbol, meaning, enclosingDeclaration, nodeFlags);
                var printer = (enclosingDeclaration === null || enclosingDeclaration === void 0 ? void 0 : enclosingDeclaration.kind) === 300 ? ts.createPrinter({ removeComments: true, neverAsciiEscape: true }) : ts.createPrinter({ removeComments: true });
                var sourceFile = enclosingDeclaration && ts.getSourceFileOfNode(enclosingDeclaration);
                printer.writeNode(4, entity, sourceFile, writer);
                return writer;
            }
        }
        function signatureToString(signature, enclosingDeclaration, flags, kind, writer) {
            if (flags === void 0) { flags = 0; }
            return writer ? signatureToStringWorker(writer).getText() : ts.usingSingleLineStringWriter(signatureToStringWorker);
            function signatureToStringWorker(writer) {
                var sigOutput;
                if (flags & 262144) {
                    sigOutput = kind === 1 ? 178 : 177;
                }
                else {
                    sigOutput = kind === 1 ? 173 : 172;
                }
                var sig = nodeBuilder.signatureToSignatureDeclaration(signature, sigOutput, enclosingDeclaration, toNodeBuilderFlags(flags) | 70221824 | 512);
                var printer = ts.createPrinter({ removeComments: true, omitTrailingSemicolon: true });
                var sourceFile = enclosingDeclaration && ts.getSourceFileOfNode(enclosingDeclaration);
                printer.writeNode(4, sig, sourceFile, ts.getTrailingSemicolonDeferringWriter(writer));
                return writer;
            }
        }
        function typeToString(type, enclosingDeclaration, flags, writer) {
            if (flags === void 0) { flags = 1048576 | 16384; }
            if (writer === void 0) { writer = ts.createTextWriter(""); }
            var noTruncation = compilerOptions.noErrorTruncation || flags & 1;
            var typeNode = nodeBuilder.typeToTypeNode(type, enclosingDeclaration, toNodeBuilderFlags(flags) | 70221824 | (noTruncation ? 1 : 0), writer);
            if (typeNode === undefined)
                return ts.Debug.fail("should always get typenode");
            var options = { removeComments: true };
            var printer = ts.createPrinter(options);
            var sourceFile = enclosingDeclaration && ts.getSourceFileOfNode(enclosingDeclaration);
            printer.writeNode(4, typeNode, sourceFile, writer);
            var result = writer.getText();
            var maxLength = noTruncation ? ts.noTruncationMaximumTruncationLength * 2 : ts.defaultMaximumTruncationLength * 2;
            if (maxLength && result && result.length >= maxLength) {
                return result.substr(0, maxLength - "...".length) + "...";
            }
            return result;
        }
        function getTypeNamesForErrorDisplay(left, right) {
            var leftStr = symbolValueDeclarationIsContextSensitive(left.symbol) ? typeToString(left, left.symbol.valueDeclaration) : typeToString(left);
            var rightStr = symbolValueDeclarationIsContextSensitive(right.symbol) ? typeToString(right, right.symbol.valueDeclaration) : typeToString(right);
            if (leftStr === rightStr) {
                leftStr = getTypeNameForErrorDisplay(left);
                rightStr = getTypeNameForErrorDisplay(right);
            }
            return [leftStr, rightStr];
        }
        function getTypeNameForErrorDisplay(type) {
            return typeToString(type, undefined, 64);
        }
        function symbolValueDeclarationIsContextSensitive(symbol) {
            return symbol && !!symbol.valueDeclaration && ts.isExpression(symbol.valueDeclaration) && !isContextSensitive(symbol.valueDeclaration);
        }
        function toNodeBuilderFlags(flags) {
            if (flags === void 0) { flags = 0; }
            return flags & 814775659;
        }
        function isClassInstanceSide(type) {
            return !!type.symbol && !!(type.symbol.flags & 32) && (type === getDeclaredTypeOfClassOrInterface(type.symbol) || (!!(type.flags & 524288) && !!(ts.getObjectFlags(type) & 16777216)));
        }
        function createNodeBuilder() {
            return {
                typeToTypeNode: function (type, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return typeToTypeNodeHelper(type, context); });
                },
                indexInfoToIndexSignatureDeclaration: function (indexInfo, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return indexInfoToIndexSignatureDeclarationHelper(indexInfo, context, undefined); });
                },
                signatureToSignatureDeclaration: function (signature, kind, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return signatureToSignatureDeclarationHelper(signature, kind, context); });
                },
                symbolToEntityName: function (symbol, meaning, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return symbolToName(symbol, context, meaning, false); });
                },
                symbolToExpression: function (symbol, meaning, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return symbolToExpression(symbol, context, meaning); });
                },
                symbolToTypeParameterDeclarations: function (symbol, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return typeParametersToTypeParameterDeclarations(symbol, context); });
                },
                symbolToParameterDeclaration: function (symbol, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return symbolToParameterDeclaration(symbol, context); });
                },
                typeParameterToDeclaration: function (parameter, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return typeParameterToDeclaration(parameter, context); });
                },
                symbolTableToDeclarationStatements: function (symbolTable, enclosingDeclaration, flags, tracker, bundled) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return symbolTableToDeclarationStatements(symbolTable, context, bundled); });
                },
            };
            function withContext(enclosingDeclaration, flags, tracker, cb) {
                var _a, _b;
                ts.Debug.assert(enclosingDeclaration === undefined || (enclosingDeclaration.flags & 8) === 0);
                var context = {
                    enclosingDeclaration: enclosingDeclaration,
                    flags: flags || 0,
                    tracker: tracker && tracker.trackSymbol ? tracker : { trackSymbol: function () { return false; }, moduleResolverHost: flags & 134217728 ? {
                            getCommonSourceDirectory: !!host.getCommonSourceDirectory ? function () { return host.getCommonSourceDirectory(); } : function () { return ""; },
                            getCurrentDirectory: function () { return host.getCurrentDirectory(); },
                            getSymlinkCache: ts.maybeBind(host, host.getSymlinkCache),
                            useCaseSensitiveFileNames: ts.maybeBind(host, host.useCaseSensitiveFileNames),
                            redirectTargetsMap: host.redirectTargetsMap,
                            getProjectReferenceRedirect: function (fileName) { return host.getProjectReferenceRedirect(fileName); },
                            isSourceOfProjectReferenceRedirect: function (fileName) { return host.isSourceOfProjectReferenceRedirect(fileName); },
                            fileExists: function (fileName) { return host.fileExists(fileName); },
                            getFileIncludeReasons: function () { return host.getFileIncludeReasons(); },
                        } : undefined },
                    encounteredError: false,
                    reportedDiagnostic: false,
                    visitedTypes: undefined,
                    symbolDepth: undefined,
                    inferTypeParameters: undefined,
                    approximateLength: 0
                };
                context.tracker = wrapSymbolTrackerToReportForContext(context, context.tracker);
                var resultingNode = cb(context);
                if (context.truncating && context.flags & 1) {
                    (_b = (_a = context.tracker) === null || _a === void 0 ? void 0 : _a.reportTruncationError) === null || _b === void 0 ? void 0 : _b.call(_a);
                }
                return context.encounteredError ? undefined : resultingNode;
            }
            function wrapSymbolTrackerToReportForContext(context, tracker) {
                var oldTrackSymbol = tracker.trackSymbol;
                return __assign(__assign({}, tracker), { reportCyclicStructureError: wrapReportedDiagnostic(tracker.reportCyclicStructureError), reportInaccessibleThisError: wrapReportedDiagnostic(tracker.reportInaccessibleThisError), reportInaccessibleUniqueSymbolError: wrapReportedDiagnostic(tracker.reportInaccessibleUniqueSymbolError), reportLikelyUnsafeImportRequiredError: wrapReportedDiagnostic(tracker.reportLikelyUnsafeImportRequiredError), reportNonlocalAugmentation: wrapReportedDiagnostic(tracker.reportNonlocalAugmentation), reportPrivateInBaseOfClassExpression: wrapReportedDiagnostic(tracker.reportPrivateInBaseOfClassExpression), reportNonSerializableProperty: wrapReportedDiagnostic(tracker.reportNonSerializableProperty), trackSymbol: oldTrackSymbol && (function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        var result = oldTrackSymbol.apply(void 0, args);
                        if (result) {
                            context.reportedDiagnostic = true;
                        }
                        return result;
                    }) });
                function wrapReportedDiagnostic(method) {
                    if (!method) {
                        return method;
                    }
                    return (function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        context.reportedDiagnostic = true;
                        return method.apply(void 0, args);
                    });
                }
            }
            function checkTruncationLength(context) {
                if (context.truncating)
                    return context.truncating;
                return context.truncating = context.approximateLength > ((context.flags & 1) ? ts.noTruncationMaximumTruncationLength : ts.defaultMaximumTruncationLength);
            }
            function typeToTypeNodeHelper(type, context) {
                if (cancellationToken && cancellationToken.throwIfCancellationRequested) {
                    cancellationToken.throwIfCancellationRequested();
                }
                var inTypeAlias = context.flags & 8388608;
                context.flags &= ~8388608;
                if (!type) {
                    if (!(context.flags & 262144)) {
                        context.encounteredError = true;
                        return undefined;
                    }
                    context.approximateLength += 3;
                    return ts.factory.createKeywordTypeNode(129);
                }
                if (!(context.flags & 536870912)) {
                    type = getReducedType(type);
                }
                if (type.flags & 1) {
                    context.approximateLength += 3;
                    return ts.factory.createKeywordTypeNode(type === intrinsicMarkerType ? 137 : 129);
                }
                if (type.flags & 2) {
                    return ts.factory.createKeywordTypeNode(153);
                }
                if (type.flags & 4) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(148);
                }
                if (type.flags & 8) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(145);
                }
                if (type.flags & 64) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(156);
                }
                if (type.flags & 16 && !type.aliasSymbol) {
                    context.approximateLength += 7;
                    return ts.factory.createKeywordTypeNode(132);
                }
                if (type.flags & 1024 && !(type.flags & 1048576)) {
                    var parentSymbol = getParentOfSymbol(type.symbol);
                    var parentName = symbolToTypeNode(parentSymbol, context, 788968);
                    if (getDeclaredTypeOfSymbol(parentSymbol) === type) {
                        return parentName;
                    }
                    var memberName = ts.symbolName(type.symbol);
                    if (ts.isIdentifierText(memberName, 0)) {
                        return appendReferenceToType(parentName, ts.factory.createTypeReferenceNode(memberName, undefined));
                    }
                    if (ts.isImportTypeNode(parentName)) {
                        parentName.isTypeOf = true;
                        return ts.factory.createIndexedAccessTypeNode(parentName, ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(memberName)));
                    }
                    else if (ts.isTypeReferenceNode(parentName)) {
                        return ts.factory.createIndexedAccessTypeNode(ts.factory.createTypeQueryNode(parentName.typeName), ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(memberName)));
                    }
                    else {
                        return ts.Debug.fail("Unhandled type node kind returned from `symbolToTypeNode`.");
                    }
                }
                if (type.flags & 1056) {
                    return symbolToTypeNode(type.symbol, context, 788968);
                }
                if (type.flags & 128) {
                    context.approximateLength += (type.value.length + 2);
                    return ts.factory.createLiteralTypeNode(ts.setEmitFlags(ts.factory.createStringLiteral(type.value, !!(context.flags & 268435456)), 16777216));
                }
                if (type.flags & 256) {
                    var value = type.value;
                    context.approximateLength += ("" + value).length;
                    return ts.factory.createLiteralTypeNode(value < 0 ? ts.factory.createPrefixUnaryExpression(40, ts.factory.createNumericLiteral(-value)) : ts.factory.createNumericLiteral(value));
                }
                if (type.flags & 2048) {
                    context.approximateLength += (ts.pseudoBigIntToString(type.value).length) + 1;
                    return ts.factory.createLiteralTypeNode((ts.factory.createBigIntLiteral(type.value)));
                }
                if (type.flags & 512) {
                    context.approximateLength += type.intrinsicName.length;
                    return ts.factory.createLiteralTypeNode(type.intrinsicName === "true" ? ts.factory.createTrue() : ts.factory.createFalse());
                }
                if (type.flags & 8192) {
                    if (!(context.flags & 1048576)) {
                        if (isValueSymbolAccessible(type.symbol, context.enclosingDeclaration)) {
                            context.approximateLength += 6;
                            return symbolToTypeNode(type.symbol, context, 111551);
                        }
                        if (context.tracker.reportInaccessibleUniqueSymbolError) {
                            context.tracker.reportInaccessibleUniqueSymbolError();
                        }
                    }
                    context.approximateLength += 13;
                    return ts.factory.createTypeOperatorNode(152, ts.factory.createKeywordTypeNode(149));
                }
                if (type.flags & 16384) {
                    context.approximateLength += 4;
                    return ts.factory.createKeywordTypeNode(114);
                }
                if (type.flags & 32768) {
                    context.approximateLength += 9;
                    return ts.factory.createKeywordTypeNode(151);
                }
                if (type.flags & 65536) {
                    context.approximateLength += 4;
                    return ts.factory.createLiteralTypeNode(ts.factory.createNull());
                }
                if (type.flags & 131072) {
                    context.approximateLength += 5;
                    return ts.factory.createKeywordTypeNode(142);
                }
                if (type.flags & 4096) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(149);
                }
                if (type.flags & 67108864) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(146);
                }
                if (isThisTypeParameter(type)) {
                    if (context.flags & 4194304) {
                        if (!context.encounteredError && !(context.flags & 32768)) {
                            context.encounteredError = true;
                        }
                        if (context.tracker.reportInaccessibleThisError) {
                            context.tracker.reportInaccessibleThisError();
                        }
                    }
                    context.approximateLength += 4;
                    return ts.factory.createThisTypeNode();
                }
                if (!inTypeAlias && type.aliasSymbol && (context.flags & 16384 || isTypeSymbolAccessible(type.aliasSymbol, context.enclosingDeclaration))) {
                    var typeArgumentNodes = mapToTypeNodes(type.aliasTypeArguments, context);
                    if (isReservedMemberName(type.aliasSymbol.escapedName) && !(type.aliasSymbol.flags & 32))
                        return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(""), typeArgumentNodes);
                    return symbolToTypeNode(type.aliasSymbol, context, 788968, typeArgumentNodes);
                }
                var objectFlags = ts.getObjectFlags(type);
                if (objectFlags & 4) {
                    ts.Debug.assert(!!(type.flags & 524288));
                    return type.node ? visitAndTransformType(type, typeReferenceToTypeNode) : typeReferenceToTypeNode(type);
                }
                if (type.flags & 262144 || objectFlags & 3) {
                    if (type.flags & 262144 && ts.contains(context.inferTypeParameters, type)) {
                        context.approximateLength += (ts.symbolName(type.symbol).length + 6);
                        return ts.factory.createInferTypeNode(typeParameterToDeclarationWithConstraint(type, context, undefined));
                    }
                    if (context.flags & 4 &&
                        type.flags & 262144 &&
                        !isTypeSymbolAccessible(type.symbol, context.enclosingDeclaration)) {
                        var name = typeParameterToName(type, context);
                        context.approximateLength += ts.idText(name).length;
                        return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(ts.idText(name)), undefined);
                    }
                    return type.symbol
                        ? symbolToTypeNode(type.symbol, context, 788968)
                        : ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("?"), undefined);
                }
                if (type.flags & 1048576 && type.origin) {
                    type = type.origin;
                }
                if (type.flags & (1048576 | 2097152)) {
                    var types = type.flags & 1048576 ? formatUnionTypes(type.types) : type.types;
                    if (ts.length(types) === 1) {
                        return typeToTypeNodeHelper(types[0], context);
                    }
                    var typeNodes = mapToTypeNodes(types, context, true);
                    if (typeNodes && typeNodes.length > 0) {
                        return type.flags & 1048576 ? ts.factory.createUnionTypeNode(typeNodes) : ts.factory.createIntersectionTypeNode(typeNodes);
                    }
                    else {
                        if (!context.encounteredError && !(context.flags & 262144)) {
                            context.encounteredError = true;
                        }
                        return undefined;
                    }
                }
                if (objectFlags & (16 | 32)) {
                    ts.Debug.assert(!!(type.flags & 524288));
                    return createAnonymousTypeNode(type);
                }
                if (type.flags & 4194304) {
                    var indexedType = type.type;
                    context.approximateLength += 6;
                    var indexTypeNode = typeToTypeNodeHelper(indexedType, context);
                    return ts.factory.createTypeOperatorNode(139, indexTypeNode);
                }
                if (type.flags & 134217728) {
                    var texts_1 = type.texts;
                    var types_1 = type.types;
                    var templateHead = ts.factory.createTemplateHead(texts_1[0]);
                    var templateSpans = ts.factory.createNodeArray(ts.map(types_1, function (t, i) { return ts.factory.createTemplateLiteralTypeSpan(typeToTypeNodeHelper(t, context), (i < types_1.length - 1 ? ts.factory.createTemplateMiddle : ts.factory.createTemplateTail)(texts_1[i + 1])); }));
                    context.approximateLength += 2;
                    return ts.factory.createTemplateLiteralType(templateHead, templateSpans);
                }
                if (type.flags & 268435456) {
                    var typeNode = typeToTypeNodeHelper(type.type, context);
                    return symbolToTypeNode(type.symbol, context, 788968, [typeNode]);
                }
                if (type.flags & 8388608) {
                    var objectTypeNode = typeToTypeNodeHelper(type.objectType, context);
                    var indexTypeNode = typeToTypeNodeHelper(type.indexType, context);
                    context.approximateLength += 2;
                    return ts.factory.createIndexedAccessTypeNode(objectTypeNode, indexTypeNode);
                }
                if (type.flags & 16777216) {
                    return visitAndTransformType(type, function (type) { return conditionalTypeToTypeNode(type); });
                }
                if (type.flags & 33554432) {
                    return typeToTypeNodeHelper(type.baseType, context);
                }
                return ts.Debug.fail("Should be unreachable.");
                function conditionalTypeToTypeNode(type) {
                    var checkTypeNode = typeToTypeNodeHelper(type.checkType, context);
                    var saveInferTypeParameters = context.inferTypeParameters;
                    context.inferTypeParameters = type.root.inferTypeParameters;
                    var extendsTypeNode = typeToTypeNodeHelper(type.extendsType, context);
                    context.inferTypeParameters = saveInferTypeParameters;
                    var trueTypeNode = typeToTypeNodeOrCircularityElision(getTrueTypeFromConditionalType(type));
                    var falseTypeNode = typeToTypeNodeOrCircularityElision(getFalseTypeFromConditionalType(type));
                    context.approximateLength += 15;
                    return ts.factory.createConditionalTypeNode(checkTypeNode, extendsTypeNode, trueTypeNode, falseTypeNode);
                }
                function typeToTypeNodeOrCircularityElision(type) {
                    var _a, _b, _c;
                    if (type.flags & 1048576) {
                        if ((_a = context.visitedTypes) === null || _a === void 0 ? void 0 : _a.has(getTypeId(type))) {
                            if (!(context.flags & 131072)) {
                                context.encounteredError = true;
                                (_c = (_b = context.tracker) === null || _b === void 0 ? void 0 : _b.reportCyclicStructureError) === null || _c === void 0 ? void 0 : _c.call(_b);
                            }
                            return createElidedInformationPlaceholder(context);
                        }
                        return visitAndTransformType(type, function (type) { return typeToTypeNodeHelper(type, context); });
                    }
                    return typeToTypeNodeHelper(type, context);
                }
                function createMappedTypeNodeFromType(type) {
                    ts.Debug.assert(!!(type.flags & 524288));
                    var readonlyToken = type.declaration.readonlyToken ? ts.factory.createToken(type.declaration.readonlyToken.kind) : undefined;
                    var questionToken = type.declaration.questionToken ? ts.factory.createToken(type.declaration.questionToken.kind) : undefined;
                    var appropriateConstraintTypeNode;
                    if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                        appropriateConstraintTypeNode = ts.factory.createTypeOperatorNode(139, typeToTypeNodeHelper(getModifiersTypeFromMappedType(type), context));
                    }
                    else {
                        appropriateConstraintTypeNode = typeToTypeNodeHelper(getConstraintTypeFromMappedType(type), context);
                    }
                    var typeParameterNode = typeParameterToDeclarationWithConstraint(getTypeParameterFromMappedType(type), context, appropriateConstraintTypeNode);
                    var nameTypeNode = type.declaration.nameType ? typeToTypeNodeHelper(getNameTypeFromMappedType(type), context) : undefined;
                    var templateTypeNode = typeToTypeNodeHelper(removeMissingType(getTemplateTypeFromMappedType(type), !!(getMappedTypeModifiers(type) & 4)), context);
                    var mappedTypeNode = ts.factory.createMappedTypeNode(readonlyToken, typeParameterNode, nameTypeNode, questionToken, templateTypeNode);
                    context.approximateLength += 10;
                    return ts.setEmitFlags(mappedTypeNode, 1);
                }
                function createAnonymousTypeNode(type) {
                    var _a;
                    var typeId = type.id;
                    var symbol = type.symbol;
                    if (symbol) {
                        var isInstanceType = isClassInstanceSide(type) ? 788968 : 111551;
                        if (isJSConstructor(symbol.valueDeclaration)) {
                            return symbolToTypeNode(symbol, context, isInstanceType);
                        }
                        else if (symbol.flags & 32
                            && !getBaseTypeVariableOfClass(symbol)
                            && !(symbol.valueDeclaration && symbol.valueDeclaration.kind === 224 && context.flags & 2048) ||
                            symbol.flags & (384 | 512) ||
                            shouldWriteTypeOfFunctionSymbol()) {
                            return symbolToTypeNode(symbol, context, isInstanceType);
                        }
                        else if ((_a = context.visitedTypes) === null || _a === void 0 ? void 0 : _a.has(typeId)) {
                            var typeAlias = getTypeAliasForTypeLiteral(type);
                            if (typeAlias) {
                                return symbolToTypeNode(typeAlias, context, 788968);
                            }
                            else {
                                return createElidedInformationPlaceholder(context);
                            }
                        }
                        else {
                            return visitAndTransformType(type, createTypeNodeFromObjectType);
                        }
                    }
                    else {
                        return createTypeNodeFromObjectType(type);
                    }
                    function shouldWriteTypeOfFunctionSymbol() {
                        var _a;
                        var isStaticMethodSymbol = !!(symbol.flags & 8192) &&
                            ts.some(symbol.declarations, function (declaration) { return ts.isStatic(declaration); });
                        var isNonLocalFunctionSymbol = !!(symbol.flags & 16) &&
                            (symbol.parent ||
                                ts.forEach(symbol.declarations, function (declaration) {
                                    return declaration.parent.kind === 300 || declaration.parent.kind === 260;
                                }));
                        if (isStaticMethodSymbol || isNonLocalFunctionSymbol) {
                            return (!!(context.flags & 4096) || ((_a = context.visitedTypes) === null || _a === void 0 ? void 0 : _a.has(typeId))) &&
                                (!(context.flags & 8) || isValueSymbolAccessible(symbol, context.enclosingDeclaration));
                        }
                    }
                }
                function visitAndTransformType(type, transform) {
                    var _a, _b;
                    var typeId = type.id;
                    var isConstructorObject = ts.getObjectFlags(type) & 16 && type.symbol && type.symbol.flags & 32;
                    var id = ts.getObjectFlags(type) & 4 && type.node ? "N" + getNodeId(type.node) :
                        type.flags & 16777216 ? "N" + getNodeId(type.root.node) :
                            type.symbol ? (isConstructorObject ? "+" : "") + getSymbolId(type.symbol) :
                                undefined;
                    if (!context.visitedTypes) {
                        context.visitedTypes = new ts.Set();
                    }
                    if (id && !context.symbolDepth) {
                        context.symbolDepth = new ts.Map();
                    }
                    var links = context.enclosingDeclaration && getNodeLinks(context.enclosingDeclaration);
                    var key = getTypeId(type) + "|" + context.flags;
                    if (links) {
                        links.serializedTypes || (links.serializedTypes = new ts.Map());
                    }
                    var cachedResult = (_a = links === null || links === void 0 ? void 0 : links.serializedTypes) === null || _a === void 0 ? void 0 : _a.get(key);
                    if (cachedResult) {
                        if (cachedResult.truncating) {
                            context.truncating = true;
                        }
                        context.approximateLength += cachedResult.addedLength;
                        return deepCloneOrReuseNode(cachedResult);
                    }
                    var depth;
                    if (id) {
                        depth = context.symbolDepth.get(id) || 0;
                        if (depth > 10) {
                            return createElidedInformationPlaceholder(context);
                        }
                        context.symbolDepth.set(id, depth + 1);
                    }
                    context.visitedTypes.add(typeId);
                    var startLength = context.approximateLength;
                    var result = transform(type);
                    var addedLength = context.approximateLength - startLength;
                    if (!context.reportedDiagnostic && !context.encounteredError) {
                        if (context.truncating) {
                            result.truncating = true;
                        }
                        result.addedLength = addedLength;
                        (_b = links === null || links === void 0 ? void 0 : links.serializedTypes) === null || _b === void 0 ? void 0 : _b.set(key, result);
                    }
                    context.visitedTypes.delete(typeId);
                    if (id) {
                        context.symbolDepth.set(id, depth);
                    }
                    return result;
                    function deepCloneOrReuseNode(node) {
                        if (!ts.nodeIsSynthesized(node) && ts.getParseTreeNode(node) === node) {
                            return node;
                        }
                        return ts.setTextRange(ts.factory.cloneNode(ts.visitEachChild(node, deepCloneOrReuseNode, ts.nullTransformationContext)), node);
                    }
                }
                function createTypeNodeFromObjectType(type) {
                    if (isGenericMappedType(type) || type.containsError) {
                        return createMappedTypeNodeFromType(type);
                    }
                    var resolved = resolveStructuredTypeMembers(type);
                    if (!resolved.properties.length && !resolved.indexInfos.length) {
                        if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {
                            context.approximateLength += 2;
                            return ts.setEmitFlags(ts.factory.createTypeLiteralNode(undefined), 1);
                        }
                        if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {
                            var signature = resolved.callSignatures[0];
                            var signatureNode = signatureToSignatureDeclarationHelper(signature, 177, context);
                            return signatureNode;
                        }
                        if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {
                            var signature = resolved.constructSignatures[0];
                            var signatureNode = signatureToSignatureDeclarationHelper(signature, 178, context);
                            return signatureNode;
                        }
                    }
                    var abstractSignatures = ts.filter(resolved.constructSignatures, function (signature) { return !!(signature.flags & 4); });
                    if (ts.some(abstractSignatures)) {
                        var types = ts.map(abstractSignatures, getOrCreateTypeFromSignature);
                        var typeElementCount = resolved.callSignatures.length +
                            (resolved.constructSignatures.length - abstractSignatures.length) +
                            resolved.indexInfos.length +
                            (context.flags & 2048 ?
                                ts.countWhere(resolved.properties, function (p) { return !(p.flags & 4194304); }) :
                                ts.length(resolved.properties));
                        if (typeElementCount) {
                            types.push(getResolvedTypeWithoutAbstractConstructSignatures(resolved));
                        }
                        return typeToTypeNodeHelper(getIntersectionType(types), context);
                    }
                    var savedFlags = context.flags;
                    context.flags |= 4194304;
                    var members = createTypeNodesFromResolvedType(resolved);
                    context.flags = savedFlags;
                    var typeLiteralNode = ts.factory.createTypeLiteralNode(members);
                    context.approximateLength += 2;
                    ts.setEmitFlags(typeLiteralNode, (context.flags & 1024) ? 0 : 1);
                    return typeLiteralNode;
                }
                function typeReferenceToTypeNode(type) {
                    var typeArguments = getTypeArguments(type);
                    if (type.target === globalArrayType || type.target === globalReadonlyArrayType) {
                        if (context.flags & 2) {
                            var typeArgumentNode = typeToTypeNodeHelper(typeArguments[0], context);
                            return ts.factory.createTypeReferenceNode(type.target === globalArrayType ? "Array" : "ReadonlyArray", [typeArgumentNode]);
                        }
                        var elementType = typeToTypeNodeHelper(typeArguments[0], context);
                        var arrayType = ts.factory.createArrayTypeNode(elementType);
                        return type.target === globalArrayType ? arrayType : ts.factory.createTypeOperatorNode(143, arrayType);
                    }
                    else if (type.target.objectFlags & 8) {
                        typeArguments = ts.sameMap(typeArguments, function (t, i) { return removeMissingType(t, !!(type.target.elementFlags[i] & 2)); });
                        if (typeArguments.length > 0) {
                            var arity = getTypeReferenceArity(type);
                            var tupleConstituentNodes = mapToTypeNodes(typeArguments.slice(0, arity), context);
                            if (tupleConstituentNodes) {
                                if (type.target.labeledElementDeclarations) {
                                    for (var i = 0; i < tupleConstituentNodes.length; i++) {
                                        var flags = type.target.elementFlags[i];
                                        tupleConstituentNodes[i] = ts.factory.createNamedTupleMember(flags & 12 ? ts.factory.createToken(25) : undefined, ts.factory.createIdentifier(ts.unescapeLeadingUnderscores(getTupleElementLabel(type.target.labeledElementDeclarations[i]))), flags & 2 ? ts.factory.createToken(57) : undefined, flags & 4 ? ts.factory.createArrayTypeNode(tupleConstituentNodes[i]) :
                                            tupleConstituentNodes[i]);
                                    }
                                }
                                else {
                                    for (var i = 0; i < Math.min(arity, tupleConstituentNodes.length); i++) {
                                        var flags = type.target.elementFlags[i];
                                        tupleConstituentNodes[i] =
                                            flags & 12 ? ts.factory.createRestTypeNode(flags & 4 ? ts.factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i]) :
                                                flags & 2 ? ts.factory.createOptionalTypeNode(tupleConstituentNodes[i]) :
                                                    tupleConstituentNodes[i];
                                    }
                                }
                                var tupleTypeNode = ts.setEmitFlags(ts.factory.createTupleTypeNode(tupleConstituentNodes), 1);
                                return type.target.readonly ? ts.factory.createTypeOperatorNode(143, tupleTypeNode) : tupleTypeNode;
                            }
                        }
                        if (context.encounteredError || (context.flags & 524288)) {
                            var tupleTypeNode = ts.setEmitFlags(ts.factory.createTupleTypeNode([]), 1);
                            return type.target.readonly ? ts.factory.createTypeOperatorNode(143, tupleTypeNode) : tupleTypeNode;
                        }
                        context.encounteredError = true;
                        return undefined;
                    }
                    else if (context.flags & 2048 &&
                        type.symbol.valueDeclaration &&
                        ts.isClassLike(type.symbol.valueDeclaration) &&
                        !isValueSymbolAccessible(type.symbol, context.enclosingDeclaration)) {
                        return createAnonymousTypeNode(type);
                    }
                    else {
                        var outerTypeParameters = type.target.outerTypeParameters;
                        var i = 0;
                        var resultType = void 0;
                        if (outerTypeParameters) {
                            var length_2 = outerTypeParameters.length;
                            while (i < length_2) {
                                var start = i;
                                var parent = getParentSymbolOfTypeParameter(outerTypeParameters[i]);
                                do {
                                    i++;
                                } while (i < length_2 && getParentSymbolOfTypeParameter(outerTypeParameters[i]) === parent);
                                if (!ts.rangeEquals(outerTypeParameters, typeArguments, start, i)) {
                                    var typeArgumentSlice = mapToTypeNodes(typeArguments.slice(start, i), context);
                                    var flags_3 = context.flags;
                                    context.flags |= 16;
                                    var ref = symbolToTypeNode(parent, context, 788968, typeArgumentSlice);
                                    context.flags = flags_3;
                                    resultType = !resultType ? ref : appendReferenceToType(resultType, ref);
                                }
                            }
                        }
                        var typeArgumentNodes = void 0;
                        if (typeArguments.length > 0) {
                            var typeParameterCount = (type.target.typeParameters || ts.emptyArray).length;
                            typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context);
                        }
                        var flags = context.flags;
                        context.flags |= 16;
                        var finalRef = symbolToTypeNode(type.symbol, context, 788968, typeArgumentNodes);
                        context.flags = flags;
                        return !resultType ? finalRef : appendReferenceToType(resultType, finalRef);
                    }
                }
                function appendReferenceToType(root, ref) {
                    if (ts.isImportTypeNode(root)) {
                        var typeArguments = root.typeArguments;
                        var qualifier = root.qualifier;
                        if (qualifier) {
                            if (ts.isIdentifier(qualifier)) {
                                qualifier = ts.factory.updateIdentifier(qualifier, typeArguments);
                            }
                            else {
                                qualifier = ts.factory.updateQualifiedName(qualifier, qualifier.left, ts.factory.updateIdentifier(qualifier.right, typeArguments));
                            }
                        }
                        typeArguments = ref.typeArguments;
                        var ids = getAccessStack(ref);
                        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
                            var id = ids_1[_i];
                            qualifier = qualifier ? ts.factory.createQualifiedName(qualifier, id) : id;
                        }
                        return ts.factory.updateImportTypeNode(root, root.argument, qualifier, typeArguments, root.isTypeOf);
                    }
                    else {
                        var typeArguments = root.typeArguments;
                        var typeName = root.typeName;
                        if (ts.isIdentifier(typeName)) {
                            typeName = ts.factory.updateIdentifier(typeName, typeArguments);
                        }
                        else {
                            typeName = ts.factory.updateQualifiedName(typeName, typeName.left, ts.factory.updateIdentifier(typeName.right, typeArguments));
                        }
                        typeArguments = ref.typeArguments;
                        var ids = getAccessStack(ref);
                        for (var _a = 0, ids_2 = ids; _a < ids_2.length; _a++) {
                            var id = ids_2[_a];
                            typeName = ts.factory.createQualifiedName(typeName, id);
                        }
                        return ts.factory.updateTypeReferenceNode(root, typeName, typeArguments);
                    }
                }
                function getAccessStack(ref) {
                    var state = ref.typeName;
                    var ids = [];
                    while (!ts.isIdentifier(state)) {
                        ids.unshift(state.right);
                        state = state.left;
                    }
                    ids.unshift(state);
                    return ids;
                }
                function createTypeNodesFromResolvedType(resolvedType) {
                    if (checkTruncationLength(context)) {
                        return [ts.factory.createPropertySignature(undefined, "...", undefined, undefined)];
                    }
                    var typeElements = [];
                    for (var _i = 0, _a = resolvedType.callSignatures; _i < _a.length; _i++) {
                        var signature = _a[_i];
                        typeElements.push(signatureToSignatureDeclarationHelper(signature, 172, context));
                    }
                    for (var _b = 0, _c = resolvedType.constructSignatures; _b < _c.length; _b++) {
                        var signature = _c[_b];
                        if (signature.flags & 4)
                            continue;
                        typeElements.push(signatureToSignatureDeclarationHelper(signature, 173, context));
                    }
                    for (var _d = 0, _e = resolvedType.indexInfos; _d < _e.length; _d++) {
                        var info = _e[_d];
                        typeElements.push(indexInfoToIndexSignatureDeclarationHelper(info, context, resolvedType.objectFlags & 1024 ? createElidedInformationPlaceholder(context) : undefined));
                    }
                    var properties = resolvedType.properties;
                    if (!properties) {
                        return typeElements;
                    }
                    var i = 0;
                    for (var _f = 0, properties_1 = properties; _f < properties_1.length; _f++) {
                        var propertySymbol = properties_1[_f];
                        i++;
                        if (context.flags & 2048) {
                            if (propertySymbol.flags & 4194304) {
                                continue;
                            }
                            if (ts.getDeclarationModifierFlagsFromSymbol(propertySymbol) & (8 | 16) && context.tracker.reportPrivateInBaseOfClassExpression) {
                                context.tracker.reportPrivateInBaseOfClassExpression(ts.unescapeLeadingUnderscores(propertySymbol.escapedName));
                            }
                        }
                        if (checkTruncationLength(context) && (i + 2 < properties.length - 1)) {
                            typeElements.push(ts.factory.createPropertySignature(undefined, "... " + (properties.length - i) + " more ...", undefined, undefined));
                            addPropertyToElementList(properties[properties.length - 1], context, typeElements);
                            break;
                        }
                        addPropertyToElementList(propertySymbol, context, typeElements);
                    }
                    return typeElements.length ? typeElements : undefined;
                }
            }
            function createElidedInformationPlaceholder(context) {
                context.approximateLength += 3;
                if (!(context.flags & 1)) {
                    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("..."), undefined);
                }
                return ts.factory.createKeywordTypeNode(129);
            }
            function shouldUsePlaceholderForProperty(propertySymbol, context) {
                var _a;
                return !!(ts.getCheckFlags(propertySymbol) & 8192)
                    && (ts.contains(context.reverseMappedStack, propertySymbol)
                        || (((_a = context.reverseMappedStack) === null || _a === void 0 ? void 0 : _a[0])
                            && !(ts.getObjectFlags(ts.last(context.reverseMappedStack).propertyType) & 16)));
            }
            function addPropertyToElementList(propertySymbol, context, typeElements) {
                var _a, _b;
                var propertyIsReverseMapped = !!(ts.getCheckFlags(propertySymbol) & 8192);
                var propertyType = shouldUsePlaceholderForProperty(propertySymbol, context) ?
                    anyType : getNonMissingTypeOfSymbol(propertySymbol);
                var saveEnclosingDeclaration = context.enclosingDeclaration;
                context.enclosingDeclaration = undefined;
                if (context.tracker.trackSymbol && ts.getCheckFlags(propertySymbol) & 4096 && isLateBoundName(propertySymbol.escapedName)) {
                    if (propertySymbol.declarations) {
                        var decl = ts.first(propertySymbol.declarations);
                        if (hasLateBindableName(decl)) {
                            if (ts.isBinaryExpression(decl)) {
                                var name = ts.getNameOfDeclaration(decl);
                                if (name && ts.isElementAccessExpression(name) && ts.isPropertyAccessEntityNameExpression(name.argumentExpression)) {
                                    trackComputedName(name.argumentExpression, saveEnclosingDeclaration, context);
                                }
                            }
                            else {
                                trackComputedName(decl.name.expression, saveEnclosingDeclaration, context);
                            }
                        }
                    }
                    else if ((_a = context.tracker) === null || _a === void 0 ? void 0 : _a.reportNonSerializableProperty) {
                        context.tracker.reportNonSerializableProperty(symbolToString(propertySymbol));
                    }
                }
                context.enclosingDeclaration = propertySymbol.valueDeclaration || ((_b = propertySymbol.declarations) === null || _b === void 0 ? void 0 : _b[0]) || saveEnclosingDeclaration;
                var propertyName = getPropertyNameNodeForSymbol(propertySymbol, context);
                context.enclosingDeclaration = saveEnclosingDeclaration;
                context.approximateLength += (ts.symbolName(propertySymbol).length + 1);
                var optionalToken = propertySymbol.flags & 16777216 ? ts.factory.createToken(57) : undefined;
                if (propertySymbol.flags & (16 | 8192) && !getPropertiesOfObjectType(propertyType).length && !isReadonlySymbol(propertySymbol)) {
                    var signatures = getSignaturesOfType(filterType(propertyType, function (t) { return !(t.flags & 32768); }), 0);
                    for (var _i = 0, signatures_1 = signatures; _i < signatures_1.length; _i++) {
                        var signature = signatures_1[_i];
                        var methodDeclaration = signatureToSignatureDeclarationHelper(signature, 166, context, { name: propertyName, questionToken: optionalToken });
                        typeElements.push(preserveCommentsOn(methodDeclaration));
                    }
                }
                else {
                    var propertyTypeNode = void 0;
                    if (shouldUsePlaceholderForProperty(propertySymbol, context)) {
                        propertyTypeNode = createElidedInformationPlaceholder(context);
                    }
                    else {
                        if (propertyIsReverseMapped) {
                            context.reverseMappedStack || (context.reverseMappedStack = []);
                            context.reverseMappedStack.push(propertySymbol);
                        }
                        propertyTypeNode = propertyType ? serializeTypeForDeclaration(context, propertyType, propertySymbol, saveEnclosingDeclaration) : ts.factory.createKeywordTypeNode(129);
                        if (propertyIsReverseMapped) {
                            context.reverseMappedStack.pop();
                        }
                    }
                    var modifiers = isReadonlySymbol(propertySymbol) ? [ts.factory.createToken(143)] : undefined;
                    if (modifiers) {
                        context.approximateLength += 9;
                    }
                    var propertySignature = ts.factory.createPropertySignature(modifiers, propertyName, optionalToken, propertyTypeNode);
                    typeElements.push(preserveCommentsOn(propertySignature));
                }
                function preserveCommentsOn(node) {
                    var _a;
                    if (ts.some(propertySymbol.declarations, function (d) { return d.kind === 342; })) {
                        var d = (_a = propertySymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(function (d) { return d.kind === 342; });
                        var commentText = ts.getTextOfJSDocComment(d.comment);
                        if (commentText) {
                            ts.setSyntheticLeadingComments(node, [{ kind: 3, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }]);
                        }
                    }
                    else if (propertySymbol.valueDeclaration) {
                        ts.setCommentRange(node, propertySymbol.valueDeclaration);
                    }
                    return node;
                }
            }
            function mapToTypeNodes(types, context, isBareList) {
                if (ts.some(types)) {
                    if (checkTruncationLength(context)) {
                        if (!isBareList) {
                            return [ts.factory.createTypeReferenceNode("...", undefined)];
                        }
                        else if (types.length > 2) {
                            return [
                                typeToTypeNodeHelper(types[0], context),
                                ts.factory.createTypeReferenceNode("... " + (types.length - 2) + " more ...", undefined),
                                typeToTypeNodeHelper(types[types.length - 1], context)
                            ];
                        }
                    }
                    var mayHaveNameCollisions = !(context.flags & 64);
                    var seenNames = mayHaveNameCollisions ? ts.createUnderscoreEscapedMultiMap() : undefined;
                    var result_5 = []