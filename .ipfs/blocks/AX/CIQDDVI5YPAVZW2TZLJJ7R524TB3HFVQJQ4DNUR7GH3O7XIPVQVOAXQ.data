tKind = server.ProjectKind || (server.ProjectKind = {}));
        /* @internal */
        function countEachFileTypes(infos, includeSizes) {
            if (includeSizes === void 0) { includeSizes = false; }
            var result = {
                js: 0, jsSize: 0,
                jsx: 0, jsxSize: 0,
                ts: 0, tsSize: 0,
                tsx: 0, tsxSize: 0,
                dts: 0, dtsSize: 0,
                deferred: 0, deferredSize: 0,
            };
            for (var _i = 0, infos_1 = infos; _i < infos_1.length; _i++) {
                var info = infos_1[_i];
                var fileSize = includeSizes ? info.getTelemetryFileSize() : 0;
                switch (info.scriptKind) {
                    case 1 /* JS */:
                        result.js += 1;
                        result.jsSize += fileSize;
                        break;
                    case 2 /* JSX */:
                        result.jsx += 1;
                        result.jsxSize += fileSize;
                        break;
                    case 3 /* TS */:
                        if (ts.fileExtensionIs(info.fileName, ".d.ts" /* Dts */)) {
                            result.dts += 1;
                            result.dtsSize += fileSize;
                        }
                        else {
                            result.ts += 1;
                            result.tsSize += fileSize;
                        }
                        break;
                    case 4 /* TSX */:
                        result.tsx += 1;
                        result.tsxSize += fileSize;
                        break;
                    case 7 /* Deferred */:
                        result.deferred += 1;
                        result.deferredSize += fileSize;
                        break;
                }
            }
            return result;
        }
        server.countEachFileTypes = countEachFileTypes;
        function hasOneOrMoreJsAndNoTsFiles(project) {
            var counts = countEachFileTypes(project.getScriptInfos());
            return counts.js > 0 && counts.ts === 0 && counts.tsx === 0;
        }
        function allRootFilesAreJsOrDts(project) {
            var counts = countEachFileTypes(project.getRootScriptInfos());
            return counts.ts === 0 && counts.tsx === 0;
        }
        server.allRootFilesAreJsOrDts = allRootFilesAreJsOrDts;
        function allFilesAreJsOrDts(project) {
            var counts = countEachFileTypes(project.getScriptInfos());
            return counts.ts === 0 && counts.tsx === 0;
        }
        server.allFilesAreJsOrDts = allFilesAreJsOrDts;
        /* @internal */
        function hasNoTypeScriptSource(fileNames) {
            return !fileNames.some(function (fileName) { return (ts.fileExtensionIs(fileName, ".ts" /* Ts */) && !ts.fileExtensionIs(fileName, ".d.ts" /* Dts */)) || ts.fileExtensionIs(fileName, ".tsx" /* Tsx */); });
        }
        server.hasNoTypeScriptSource = hasNoTypeScriptSource;
        function isGeneratedFileWatcher(watch) {
            return watch.generatedFilePath !== undefined;
        }
        var Project = /** @class */ (function () {
            /*@internal*/
            function Project(
            /*@internal*/ projectName, projectKind, projectService, documentRegistry, hasExplicitListOfFiles, lastFileExceededProgramSize, compilerOptions, compileOnSaveEnabled, watchOptions, directoryStructureHost, currentDirectory) {
                var _this = this;
                this.projectName = projectName;
                this.projectKind = projectKind;
                this.projectService = projectService;
                this.documentRegistry = documentRegistry;
                this.compilerOptions = compilerOptions;
                this.compileOnSaveEnabled = compileOnSaveEnabled;
                this.watchOptions = watchOptions;
                this.rootFiles = [];
                this.rootFilesMap = new ts.Map();
                this.plugins = [];
                /*@internal*/
                /**
                 * This is map from files to unresolved imports in it
                 * Maop does not contain entries for files that do not have unresolved imports
                 * This helps in containing the set of files to invalidate
                 */
                this.cachedUnresolvedImportsPerFile = new ts.Map();
                /*@internal*/
                this.hasAddedorRemovedFiles = false;
                /*@internal*/
                this.hasAddedOrRemovedSymlinks = false;
                /**
                 * Last version that was reported.
                 */
                this.lastReportedVersion = 0;
                /**
                 * Current project's program version. (incremented everytime new program is created that is not complete reuse from the old one)
                 * This property is changed in 'updateGraph' based on the set of files in program
                 */
                this.projectProgramVersion = 0;
                /**
                 * Current version of the project state. It is changed when:
                 * - new root file was added/removed
                 * - edit happen in some file that is currently included in the project.
                 * This property is different from projectStructureVersion since in most cases edits don't affect set of files in the project
                 */
                this.projectStateVersion = 0;
                this.isInitialLoadPending = ts.returnFalse;
                /*@internal*/
                this.dirty = false;
                /*@internal*/
                this.typingFiles = server.emptyArray;
                /*@internal*/
                this.moduleSpecifierCache = server.createModuleSpecifierCache(this);
                /*@internal*/
                this.globalCacheResolutionModuleName = ts.JsTyping.nonRelativeModuleNameForTypingCache;
                this.directoryStructureHost = directoryStructureHost;
                this.currentDirectory = this.projectService.getNormalizedAbsolutePath(currentDirectory || "");
                this.getCanonicalFileName = this.projectService.toCanonicalFileName;
                this.cancellationToken = new ts.ThrottledCancellationToken(this.projectService.cancellationToken, this.projectService.throttleWaitMilliseconds);
                if (!this.compilerOptions) {
                    this.compilerOptions = ts.getDefaultCompilerOptions();
                    this.compilerOptions.allowNonTsExtensions = true;
                    this.compilerOptions.allowJs = true;
                }
                else if (hasExplicitListOfFiles || ts.getAllowJSCompilerOption(this.compilerOptions) || this.projectService.hasDeferredExtension()) {
                    // If files are listed explicitly or allowJs is specified, allow all extensions
                    this.compilerOptions.allowNonTsExtensions = true;
                }
                switch (projectService.serverMode) {
                    case ts.LanguageServiceMode.Semantic:
                        this.languageServiceEnabled = true;
                        break;
                    case ts.LanguageServiceMode.PartialSemantic:
                        this.languageServiceEnabled = true;
                        this.compilerOptions.noResolve = true;
                        this.compilerOptions.types = [];
                        break;
                    case ts.LanguageServiceMode.Syntactic:
                        this.languageServiceEnabled = false;
                        this.compilerOptions.noResolve = true;
                        this.compilerOptions.types = [];
                        break;
                    default:
                        ts.Debug.assertNever(projectService.serverMode);
                }
                this.setInternalCompilerOptionsForEmittingJsFiles();
                var host = this.projectService.host;
                if (this.projectService.logger.loggingEnabled()) {
                    this.trace = function (s) { return _this.writeLog(s); };
                }
                else if (host.trace) {
                    this.trace = function (s) { return host.trace(s); };
                }
                this.realpath = ts.maybeBind(host, host.realpath);
                // Use the current directory as resolution root only if the project created using current directory string
                this.resolutionCache = ts.createResolutionCache(this, currentDirectory && this.currentDirectory, 
                /*logChangesWhenResolvingModule*/ true);
                this.languageService = ts.createLanguageService(this, this.documentRegistry, this.projectService.serverMode);
                if (lastFileExceededProgramSize) {
                    this.disableLanguageService(lastFileExceededProgramSize);
                }
                this.markAsDirty();
                if (projectKind !== ProjectKind.AutoImportProvider) {
                    this.projectService.pendingEnsureProjectForOpenFiles = true;
                }
            }
            /*@internal*/
            Project.prototype.getResolvedProjectReferenceToRedirect = function (_fileName) {
                return undefined;
            };
            Project.prototype.isNonTsProject = function () {
                server.updateProjectIfDirty(this);
                return allFilesAreJsOrDts(this);
            };
            Project.prototype.isJsOnlyProject = function () {
                server.updateProjectIfDirty(this);
                return hasOneOrMoreJsAndNoTsFiles(this);
            };
            Project.resolveModule = function (moduleName, initialDir, host, log, logErrors) {
                var resolvedPath = ts.normalizeSlashes(host.resolvePath(ts.combinePaths(initialDir, "node_modules")));
                log("Loading " + moduleName + " from " + initialDir + " (resolved to " + resolvedPath + ")");
                var result = host.require(resolvedPath, moduleName); // TODO: GH#18217
                if (result.error) {
                    var err = result.error.stack || result.error.message || JSON.stringify(result.error);
                    (logErrors || log)("Failed to load module '" + moduleName + "' from " + resolvedPath + ": " + err);
                    return undefined;
                }
                return result.module;
            };
            Project.prototype.isKnownTypesPackageName = function (name) {
                return this.typingsCache.isKnownTypesPackageName(name);
            };
            Project.prototype.installPackage = function (options) {
                return this.typingsCache.installPackage(__assign(__assign({}, options), { projectName: this.projectName, projectRootPath: this.toPath(this.currentDirectory) }));
            };
            /*@internal*/
            Project.prototype.getGlobalTypingsCacheLocation = function () {
                return this.getGlobalCache();
            };
            Object.defineProperty(Project.prototype, "typingsCache", {
                get: function () {
                    return this.projectService.typingsCache;
                },
                enumerable: false,
                configurable: true
            });
            /*@internal*/
            Project.prototype.getSymlinkCache = function () {
                if (!this.symlinks) {
                    this.symlinks = ts.createSymlinkCache(this.getCurrentDirectory(), this.getCanonicalFileName);
                }
                if (this.program && !this.symlinks.hasProcessedResolutions()) {
                    this.symlinks.setSymlinksFromResolutions(this.program.getSourceFiles(), this.program.getResolvedTypeReferenceDirectives());
                }
                return this.symlinks;
            };
            // Method of LanguageServiceHost
            Project.prototype.getCompilationSettings = function () {
                return this.compilerOptions;
            };
            // Method to support public API
            Project.prototype.getCompilerOptions = function () {
                return this.getCompilationSettings();
            };
            Project.prototype.getNewLine = function () {
                return this.projectService.host.newLine;
            };
            Project.prototype.getProjectVersion = function () {
                return this.projectStateVersion.toString();
            };
            Project.prototype.getProjectReferences = function () {
                return undefined;
            };
            Project.prototype.getScriptFileNames = function () {
                var _this = this;
                if (!this.rootFiles) {
                    return ts.emptyArray;
                }
                var result;
                this.rootFilesMap.forEach(function (value) {
                    if (_this.languageServiceEnabled || (value.info && value.info.isScriptOpen())) {
                        // if language service is disabled - process only files that are open
                        (result || (result = [])).push(value.fileName);
                    }
                });
                return ts.addRange(result, this.typingFiles) || ts.emptyArray;
            };
            Project.prototype.getOrCreateScriptInfoAndAttachToProject = function (fileName) {
                var scriptInfo = this.projectService.getOrCreateScriptInfoNotOpenedByClient(fileName, this.currentDirectory, this.directoryStructureHost);
                if (scriptInfo) {
                    var existingValue = this.rootFilesMap.get(scriptInfo.path);
                    if (existingValue && existingValue.info !== scriptInfo) {
                        // This was missing path earlier but now the file exists. Update the root
                        this.rootFiles.push(scriptInfo);
                        existingValue.info = scriptInfo;
                    }
                    scriptInfo.attachToProject(this);
                }
                return scriptInfo;
            };
            Project.prototype.getScriptKind = function (fileName) {
                var info = this.getOrCreateScriptInfoAndAttachToProject(fileName);
                return (info && info.scriptKind); // TODO: GH#18217
            };
            Project.prototype.getScriptVersion = function (filename) {
                // Don't attach to the project if version is asked
                var info = this.projectService.getOrCreateScriptInfoNotOpenedByClient(filename, this.currentDirectory, this.directoryStructureHost);
                return (info && info.getLatestVersion()); // TODO: GH#18217
            };
            Project.prototype.getScriptSnapshot = function (filename) {
                var scriptInfo = this.getOrCreateScriptInfoAndAttachToProject(filename);
                if (scriptInfo) {
                    return scriptInfo.getSnapshot();
                }
            };
            Project.prototype.getCancellationToken = function () {
                return this.cancellationToken;
            };
            Project.prototype.getCurrentDirectory = function () {
                return this.currentDirectory;
            };
            Project.prototype.getDefaultLibFileName = function () {
                var nodeModuleBinDir = ts.getDirectoryPath(ts.normalizePath(this.projectService.getExecutingFilePath()));
                return ts.combinePaths(nodeModuleBinDir, ts.getDefaultLibFileName(this.compilerOptions));
            };
            Project.prototype.useCaseSensitiveFileNames = function () {
                return this.projectService.host.useCaseSensitiveFileNames;
            };
            Project.prototype.readDirectory = function (path, extensions, exclude, include, depth) {
                return this.directoryStructureHost.readDirectory(path, extensions, exclude, include, depth);
            };
            Project.prototype.readFile = function (fileName) {
                return this.projectService.host.readFile(fileName);
            };
            Project.prototype.writeFile = function (fileName, content) {
                return this.projectService.host.writeFile(fileName, content);
            };
            Project.prototype.fileExists = function (file) {
                // As an optimization, don't hit the disks for files we already know don't exist
                // (because we're watching for their creation).
                var path = this.toPath(file);
                return !this.isWatchedMissingFile(path) && this.directoryStructureHost.fileExists(file);
            };
            Project.prototype.resolveModuleNames = function (moduleNames, containingFile, reusedNames, redirectedReference) {
                return this.resolutionCache.resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference);
            };
            Project.prototype.getResolvedModuleWithFailedLookupLocationsFromCache = function (moduleName, containingFile) {
                return this.resolutionCache.getResolvedModuleWithFailedLookupLocationsFromCache(moduleName, containingFile);
            };
            Project.prototype.resolveTypeReferenceDirectives = function (typeDirectiveNames, containingFile, redirectedReference) {
                return this.resolutionCache.resolveTypeReferenceDirectives(typeDirectiveNames, containingFile, redirectedReference);
            };
            Project.prototype.directoryExists = function (path) {
                return this.directoryStructureHost.directoryExists(path); // TODO: GH#18217
            };
            Project.prototype.getDirectories = function (path) {
                return this.directoryStructureHost.getDirectories(path); // TODO: GH#18217
            };
            /*@internal*/
            Project.prototype.getCachedDirectoryStructureHost = function () {
                return undefined; // TODO: GH#18217
            };
            /*@internal*/
            Project.prototype.toPath = function (fileName) {
                return ts.toPath(fileName, this.currentDirectory, this.projectService.toCanonicalFileName);
            };
            /*@internal*/
            Project.prototype.watchDirectoryOfFailedLookupLocation = function (directory, cb, flags) {
                return this.projectService.watchFactory.watchDirectory(directory, cb, flags, this.projectService.getWatchOptions(this), ts.WatchType.FailedLookupLocations, this);
            };
            /*@internal*/
            Project.prototype.clearInvalidateResolutionOfFailedLookupTimer = function () {
                return this.projectService.throttledOperations.cancel(this.getProjectName() + "FailedLookupInvalidation");
            };
            /*@internal*/
            Project.prototype.scheduleInvalidateResolutionsOfFailedLookupLocations = function () {
                var _this = this;
                this.projectService.throttledOperations.schedule(this.getProjectName() + "FailedLookupInvalidation", /*delay*/ 1000, function () {
                    if (_this.resolutionCache.invalidateResolutionsOfFailedLookupLocations()) {
                        _this.projectService.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(_this);
                    }
                });
            };
            /*@internal*/
            Project.prototype.invalidateResolutionsOfFailedLookupLocations = function () {
                if (this.clearInvalidateResolutionOfFailedLookupTimer() &&
                    this.resolutionCache.invalidateResolutionsOfFailedLookupLocations()) {
                    this.markAsDirty();
                    this.projectService.delayEnsureProjectForOpenFiles();
                }
            };
            /*@internal*/
            Project.prototype.onInvalidatedResolution = function () {
                this.projectService.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(this);
            };
            /*@internal*/
            Project.prototype.watchTypeRootsDirectory = function (directory, cb, flags) {
                return this.projectService.watchFactory.watchDirectory(directory, cb, flags, this.projectService.getWatchOptions(this), ts.WatchType.TypeRoots, this);
            };
            /*@internal*/
            Project.prototype.hasChangedAutomaticTypeDirectiveNames = function () {
                return this.resolutionCache.hasChangedAutomaticTypeDirectiveNames();
            };
            /*@internal*/
            Project.prototype.onChangedAutomaticTypeDirectiveNames = function () {
                this.projectService.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(this);
            };
            /*@internal*/
            Project.prototype.getGlobalCache = function () {
                return this.getTypeAcquisition().enable ? this.projectService.typingsInstaller.globalTypingsCacheLocation : undefined;
            };
            /*@internal*/
            Project.prototype.fileIsOpen = function (filePath) {
                return this.projectService.openFiles.has(filePath);
            };
            /*@internal*/
            Project.prototype.writeLog = function (s) {
                this.projectService.logger.info(s);
            };
            Project.prototype.log = function (s) {
                this.writeLog(s);
            };
            Project.prototype.error = function (s) {
                this.projectService.logger.msg(s, server.Msg.Err);
            };
            Project.prototype.setInternalCompilerOptionsForEmittingJsFiles = function () {
                if (this.projectKind === ProjectKind.Inferred || this.projectKind === ProjectKind.External) {
                    this.compilerOptions.noEmitForJsFiles = true;
                }
            };
            /**
             * Get the errors that dont have any file name associated
             */
            Project.prototype.getGlobalProjectErrors = function () {
                return ts.filter(this.projectErrors, function (diagnostic) { return !diagnostic.file; }) || server.emptyArray;
            };
            /**
             * Get all the project errors
             */
            Project.prototype.getAllProjectErrors = function () {
                return this.projectErrors || server.emptyArray;
            };
            Project.prototype.setProjectErrors = function (projectErrors) {
                this.projectErrors = projectErrors;
            };
            Project.prototype.getLanguageService = function (ensureSynchronized) {
                if (ensureSynchronized === void 0) { ensureSynchronized = true; }
                if (ensureSynchronized) {
                    server.updateProjectIfDirty(this);
                }
                return this.languageService;
            };
            /** @internal */
            Project.prototype.getSourceMapper = function () {
                return this.getLanguageService().getSourceMapper();
            };
            /** @internal */
            Project.prototype.clearSourceMapperCache = function () {
                this.languageService.clearSourceMapperCache();
            };
            /*@internal*/
            Project.prototype.getDocumentPositionMapper = function (generatedFileName, sourceFileName) {
                return this.projectService.getDocumentPositionMapper(this, generatedFileName, sourceFileName);
            };
            /*@internal*/
            Project.prototype.getSourceFileLike = function (fileName) {
                return this.projectService.getSourceFileLike(fileName, this);
            };
            /*@internal*/
            Project.prototype.shouldEmitFile = function (scriptInfo) {
                return scriptInfo &&
                    !scriptInfo.isDynamicOrHasMixedContent() &&
                    !this.program.isSourceOfProjectReferenceRedirect(scriptInfo.path);
            };
            Project.prototype.getCompileOnSaveAffectedFileList = function (scriptInfo) {
                var _this = this;
                if (!this.languageServiceEnabled) {
                    return [];
                }
                server.updateProjectIfDirty(this);
                this.builderState = ts.BuilderState.create(this.program, this.projectService.toCanonicalFileName, this.builderState, /*disableUseFileVersionAsSignature*/ true);
                return ts.mapDefined(ts.BuilderState.getFilesAffectedBy(this.builderState, this.program, scriptInfo.path, this.cancellationToken, ts.maybeBind(this.projectService.host, this.projectService.host.createHash)), function (sourceFile) { return _this.shouldEmitFile(_this.projectService.getScriptInfoForPath(sourceFile.path)) ? sourceFile.fileName : undefined; });
            };
            /**
             * Returns true if emit was conducted
             */
            Project.prototype.emitFile = function (scriptInfo, writeFile) {
                if (!this.languageServiceEnabled || !this.shouldEmitFile(scriptInfo)) {
                    return { emitSkipped: true, diagnostics: server.emptyArray };
                }
                var _a = this.getLanguageService().getEmitOutput(scriptInfo.fileName), emitSkipped = _a.emitSkipped, diagnostics = _a.diagnostics, outputFiles = _a.outputFiles;
                if (!emitSkipped) {
                    for (var _i = 0, outputFiles_1 = outputFiles; _i < outputFiles_1.length; _i++) {
                        var outputFile = outputFiles_1[_i];
                        var outputFileAbsoluteFileName = ts.getNormalizedAbsolutePath(outputFile.name, this.currentDirectory);
                        writeFile(outputFileAbsoluteFileName, outputFile.text, outputFile.writeByteOrderMark);
                    }
                    // Update the signature
                    if (this.builderState && ts.getEmitDeclarations(this.compilerOptions)) {
                        var dtsFiles = outputFiles.filter(function (f) { return ts.fileExtensionIs(f.name, ".d.ts" /* Dts */); });
                        if (dtsFiles.length === 1) {
                            var sourceFile = this.program.getSourceFile(scriptInfo.fileName);
                            var signature = this.projectService.host.createHash ?
                                this.projectService.host.createHash(dtsFiles[0].text) :
                                ts.generateDjb2Hash(dtsFiles[0].text);
                            ts.BuilderState.updateSignatureOfFile(this.builderState, signature, sourceFile.resolvedPath);
                        }
                    }
                }
                return { emitSkipped: emitSkipped, diagnostics: diagnostics };
            };
            Project.prototype.enableLanguageService = function () {
                if (this.languageServiceEnabled || this.projectService.serverMode === ts.LanguageServiceMode.Syntactic) {
                    return;
                }
                this.languageServiceEnabled = true;
                this.lastFileExceededProgramSize = undefined;
                this.projectService.onUpdateLanguageServiceStateForProject(this, /*languageServiceEnabled*/ true);
            };
            Project.prototype.disableLanguageService = function (lastFileExceededProgramSize) {
                if (!this.languageServiceEnabled) {
                    return;
                }
                ts.Debug.assert(this.projectService.serverMode !== ts.LanguageServiceMode.Syntactic);
                this.languageService.cleanupSemanticCache();
                this.languageServiceEnabled = false;
                this.lastFileExceededProgramSize = lastFileExceededProgramSize;
                this.builderState = undefined;
                if (this.autoImportProviderHost) {
                    this.autoImportProviderHost.close();
                }
                this.autoImportProviderHost = undefined;
                this.resolutionCache.closeTypeRootsWatch();
                this.clearGeneratedFileWatch();
                this.projectService.onUpdateLanguageServiceStateForProject(this, /*languageServiceEnabled*/ false);
            };
            Project.prototype.getProjectName = function () {
                return this.projectName;
            };
            Project.prototype.removeLocalTypingsFromTypeAcquisition = function (newTypeAcquisition) {
                if (!newTypeAcquisition || !newTypeAcquisition.include) {
                    // Nothing to filter out, so just return as-is
                    return newTypeAcquisition;
                }
                return __assign(__assign({}, newTypeAcquisition), { include: this.removeExistingTypings(newTypeAcquisition.include) });
            };
            Project.prototype.getExternalFiles = function () {
                var _this = this;
                return ts.sort(ts.flatMap(this.plugins, function (plugin) {
                    if (typeof plugin.module.getExternalFiles !== "function")
                        return;
                    try {
                        return plugin.module.getExternalFiles(_this);
                    }
                    catch (e) {
                        _this.projectService.logger.info("A plugin threw an exception in getExternalFiles: " + e);
                        if (e.stack) {
                            _this.projectService.logger.info(e.stack);
                        }
                    }
                }));
            };
            Project.prototype.getSourceFile = function (path) {
                if (!this.program) {
                    return undefined;
                }
                return this.program.getSourceFileByPath(path);
            };
            /* @internal */
            Project.prototype.getSourceFileOrConfigFile = function (path) {
                var options = this.program.getCompilerOptions();
                return path === options.configFilePath ? options.configFile : this.getSourceFile(path);
            };
            Project.prototype.close = function () {
                var _this = this;
                if (this.program) {
                    // if we have a program - release all files that are enlisted in program but arent root
                    // The releasing of the roots happens later
                    // The project could have pending update remaining and hence the info could be in the files but not in program graph
                    for (var _i = 0, _a = this.program.getSourceFiles(); _i < _a.length; _i++) {
                        var f = _a[_i];
                        this.detachScriptInfoIfNotRoot(f.fileName);
                    }
                    this.program.forEachResolvedProjectReference(function (ref) {
                        return _this.detachScriptInfoFromProject(ref.sourceFile.fileName);
                    });
                }
                // Release external files
                ts.forEach(this.externalFiles, function (externalFile) { return _this.detachScriptInfoIfNotRoot(externalFile); });
                // Always remove root files from the project
                for (var _b = 0, _c = this.rootFiles; _b < _c.length; _b++) {
                    var root = _c[_b];
                    root.detachFromProject(this);
                }
                this.projectService.pendingEnsureProjectForOpenFiles = true;
                this.rootFiles = undefined;
                this.rootFilesMap = undefined;
                this.externalFiles = undefined;
                this.program = undefined;
                this.builderState = undefined;
                this.resolutionCache.clear();
                this.resolutionCache = undefined;
                this.cachedUnresolvedImportsPerFile = undefined;
                this.moduleSpecifierCache = undefined;
                this.directoryStructureHost = undefined;
                this.exportMapCache = undefined;
                this.projectErrors = undefined;
                // Clean up file watchers waiting for missing files
                if (this.missingFilesMap) {
                    ts.clearMap(this.missingFilesMap, ts.closeFileWatcher);
                    this.missingFilesMap = undefined;
                }
                this.clearGeneratedFileWatch();
                this.clearInvalidateResolutionOfFailedLookupTimer();
                if (this.autoImportProviderHost) {
                    this.autoImportProviderHost.close();
                }
                this.autoImportProviderHost = undefined;
                // signal language service to release source files acquired from document registry
                this.languageService.dispose();
                this.languageService = undefined;
            };
            Project.prototype.detachScriptInfoIfNotRoot = function (uncheckedFilename) {
                var info = this.projectService.getScriptInfo(uncheckedFilename);
                // We might not find the script info in case its not associated with the project any more
                // and project graph was not updated (eg delayed update graph in case of files changed/deleted on the disk)
                if (info && !this.isRoot(info)) {
                    info.detachFromProject(this);
                }
            };
            Project.prototype.isClosed = function () {
                return this.rootFiles === undefined;
            };
            Project.prototype.hasRoots = function () {
                return this.rootFiles && this.rootFiles.length > 0;
            };
            /*@internal*/
            Project.prototype.isOrphan = function () {
                return false;
            };
            Project.prototype.getRootFiles = function () {
                return this.rootFiles && this.rootFiles.map(function (info) { return info.fileName; });
            };
            /*@internal*/
            Project.prototype.getRootFilesMap = function () {
                return this.rootFilesMap;
            };
            Project.prototype.getRootScriptInfos = function () {
                return this.rootFiles;
            };
            Project.prototype.getScriptInfos = function () {
                var _this = this;
                if (!this.languageServiceEnabled) {
                    // if language service is not enabled - return just root files
                    return this.rootFiles;
                }
                return ts.map(this.program.getSourceFiles(), function (sourceFile) {
                    var scriptInfo = _this.projectService.getScriptInfoForPath(sourceFile.resolvedPath);
                    ts.Debug.assert(!!scriptInfo, "getScriptInfo", function () { return "scriptInfo for a file '" + sourceFile.fileName + "' Path: '" + sourceFile.path + "' / '" + sourceFile.resolvedPath + "' is missing."; });
                    return scriptInfo;
                });
            };
            Project.prototype.getExcludedFiles = function () {
                return server.emptyArray;
            };
            Project.prototype.getFileNames = function (excludeFilesFromExternalLibraries, excludeConfigFiles) {
                if (!this.program) {
                    return [];
                }
                if (!this.languageServiceEnabled) {
                    // if language service is disabled assume that all files in program are root files + default library
                    var rootFiles = this.getRootFiles();
                    if (this.compilerOptions) {
                        var defaultLibrary = ts.getDefaultLibFilePath(this.compilerOptions);
                        if (defaultLibrary) {
                            (rootFiles || (rootFiles = [])).push(server.asNormalizedPath(defaultLibrary));
                        }
                    }
                    return rootFiles;
                }
                var result = [];
                for (var _i = 0, _a = this.program.getSourceFiles(); _i < _a.length; _i++) {
                    var f = _a[_i];
                    if (excludeFilesFromExternalLibraries && this.program.isSourceFileFromExternalLibrary(f)) {
                        continue;
                    }
                    result.push(server.asNormalizedPath(f.fileName));
                }
                if (!excludeConfigFiles) {
                    var configFile = this.program.getCompilerOptions().configFile;
                    if (configFile) {
                        result.push(server.asNormalizedPath(configFile.fileName));
                        if (configFile.extendedSourceFiles) {
                            for (var _b = 0, _c = configFile.extendedSourceFiles; _b < _c.length; _b++) {
                                var f = _c[_b];
                                result.push(server.asNormalizedPath(f));
                            }
                        }
                    }
                }
                return result;
            };
            /* @internal */
            Project.prototype.getFileNamesWithRedirectInfo = function (includeProjectReferenceRedirectInfo) {
                var _this = this;
                return this.getFileNames().map(function (fileName) { return ({
                    fileName: fileName,
                    isSourceOfProjectReferenceRedirect: includeProjectReferenceRedirectInfo && _this.isSourceOfProjectReferenceRedirect(fileName)
                }); });
            };
            Project.prototype.hasConfigFile = function (configFilePath) {
                if (this.program && this.languageServiceEnabled) {
                    var configFile = this.program.getCompilerOptions().configFile;
                    if (configFile) {
                        if (configFilePath === server.asNormalizedPath(configFile.fileName)) {
                            return true;
                        }
                        if (configFile.extendedSourceFiles) {
                            for (var _i = 0, _a = configFile.extendedSourceFiles; _i < _a.length; _i++) {
                                var f = _a[_i];
                                if (configFilePath === server.asNormalizedPath(f)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            };
            Project.prototype.containsScriptInfo = function (info) {
                if (this.isRoot(info))
                    return true;
                if (!this.program)
                    return false;
                var file = this.program.getSourceFileByPath(info.path);
                return !!file && file.resolvedPath === info.path;
            };
            Project.prototype.containsFile = function (filename, requireOpen) {
                var info = this.projectService.getScriptInfoForNormalizedPath(filename);
                if (info && (info.isScriptOpen() || !requireOpen)) {
                    return this.containsScriptInfo(info);
                }
                return false;
            };
            Project.prototype.isRoot = function (info) {
                var _a;
                return this.rootFilesMap && ((_a = this.rootFilesMap.get(info.path)) === null || _a === void 0 ? void 0 : _a.info) === info;
            };
            // add a root file to project
            Project.prototype.addRoot = function (info, fileName) {
                ts.Debug.assert(!this.isRoot(info));
                this.rootFiles.push(info);
                this.rootFilesMap.set(info.path, { fileName: fileName || info.fileName, info: info });
                info.attachToProject(this);
                this.markAsDirty();
            };
            // add a root file that doesnt exist on host
            Project.prototype.addMissingFileRoot = function (fileName) {
                var path = this.projectService.toPath(fileName);
                this.rootFilesMap.set(path, { fileName: fileName });
                this.markAsDirty();
            };
            Project.prototype.removeFile = function (info, fileExists, detachFromProject) {
                if (this.isRoot(info)) {
                    this.removeRoot(info);
                }
                if (fileExists) {
                    // If file is present, just remove the resolutions for the file
                    this.resolutionCache.removeResolutionsOfFile(info.path);
                }
                else {
                    this.resolutionCache.invalidateResolutionOfFile(info.path);
                }
                this.cachedUnresolvedImportsPerFile.delete(info.path);
                if (detachFromProject) {
                    info.detachFromProject(this);
                }
                this.markAsDirty();
            };
            Project.prototype.registerFileUpdate = function (fileName) {
                (this.updatedFileNames || (this.updatedFileNames = new ts.Set())).add(fileName);
            };
            /*@internal*/
            Project.prototype.markFileAsDirty = function (changedFile) {
                this.markAsDirty();
                if (this.exportMapCache && !this.exportMapCache.isEmpty()) {
                    (this.changedFilesForExportMapCache || (this.changedFilesForExportMapCache = new ts.Set())).add(changedFile);
                }
            };
            Project.prototype.markAsDirty = function () {
                if (!this.dirty) {
                    this.projectStateVersion++;
                    this.dirty = true;
                }
            };
            /*@internal*/
            Project.prototype.onAutoImportProviderSettingsChanged = function () {
                var _a;
                if (this.autoImportProviderHost === false) {
                    this.autoImportProviderHost = undefined;
                }
                else {
                    (_a = this.autoImportProviderHost) === null || _a === void 0 ? void 0 : _a.markAsDirty();
                }
            };
            /*@internal*/
            Project.prototype.onPackageJsonChange = function (packageJsonPath) {
                var _a;
                if ((_a = this.packageJsonsForAutoImport) === null || _a === void 0 ? void 0 : _a.has(packageJsonPath)) {
                    this.moduleSpecifierCache.clear();
                    if (this.autoImportProviderHost) {
                        this.autoImportProviderHost.markAsDirty();
                    }
                }
            };
            /* @internal */
            Project.prototype.onFileAddedOrRemoved = function (isSymlink) {
                this.hasAddedorRemovedFiles = true;
                if (isSymlink) {
                    this.hasAddedOrRemovedSymlinks = true;
                }
            };
            /**
             * Updates set of files that contribute to this project
             * @returns: true if set of files in the project stays the same and false - otherwise.
             */
            Project.prototype.updateGraph = function () {
                var _a;
                ts.perfLogger.logStartUpdateGraph();
                this.resolutionCache.startRecordingFilesWithChangedResolutions();
                var hasNewProgram = this.updateGraphWorker();
                var hasAddedorRemovedFiles = this.hasAddedorRemovedFiles;
                this.hasAddedorRemovedFiles = false;
                this.hasAddedOrRemovedSymlinks = false;
                var changedFiles = this.resolutionCache.finishRecordingFilesWithChangedResolutions() || server.emptyArray;
                for (var _i = 0, changedFiles_1 = changedFiles; _i < changedFiles_1.length; _i++) {
                    var file = changedFiles_1[_i];
                    // delete cached information for changed files
                    this.cachedUnresolvedImportsPerFile.delete(file);
                }
                // update builder only if language service is enabled
                // otherwise tell it to drop its internal state
                if (this.languageServiceEnabled && this.projectService.serverMode === ts.LanguageServiceMode.Semantic) {
                    // 1. no changes in structure, no changes in unresolved imports - do nothing
                    // 2. no changes in structure, unresolved imports were changed - collect unresolved imports for all files
                    // (can reuse cached imports for files that were not changed)
                    // 3. new files were added/removed, but compilation settings stays the same - collect unresolved imports for all new/modified files
                    // (can reuse cached imports for files that were not changed)
                    // 4. compilation settings were changed in the way that might affect module resolution - drop all caches and collect all data from the scratch
                    if (hasNewProgram || changedFiles.length) {
                        this.lastCachedUnresolvedImportsList = getUnresolvedImports(this.program, this.cachedUnresolvedImportsPerFile);
                    }
                    this.projectService.typingsCache.enqueueInstallTypingsForProject(this, this.lastCachedUnresolvedImportsList, hasAddedorRemovedFiles);
                }
                else {
                    this.lastCachedUnresolvedImportsList = undefined;
                }
                var isFirstProgramLoad = this.projectProgramVersion === 0 && hasNewProgram;
                if (hasNewProgram) {
                    this.projectProgramVersion++;
                }
                if (hasAddedorRemovedFiles) {
                    if (!this.autoImportProviderHost)
                        this.autoImportProviderHost = undefined;
                    (_a = this.autoImportProviderHost) === null || _a === void 0 ? void 0 : _a.markAsDirty();
                }
                if (isFirstProgramLoad) {
                    // Preload auto import provider so it's not created during completions request
                    this.getPackageJsonAutoImportProvider();
                }
                ts.perfLogger.logStopUpdateGraph();
                return !hasNewProgram;
            };
            /*@internal*/
            Project.prototype.updateTypingFiles = function (typingFiles) {
                var _this = this;
                if (ts.enumerateInsertsAndDeletes(typingFiles, this.typingFiles, ts.getStringComparer(!this.useCaseSensitiveFileNames()), 
                /*inserted*/ ts.noop, function (removed) { return _this.detachScriptInfoFromProject(removed); })) {
                    // If typing files changed, then only schedule project update
                    this.typingFiles = typingFiles;
                    // Invalidate files with unresolved imports
                    this.resolutionCache.setFilesWithInvalidatedNonRelativeUnresolvedImports(this.cachedUnresolvedImportsPerFile);
                    this.projectService.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(this);
                }
            };
            /* @internal */
            Project.prototype.getCurrentProgram = function () {
                return this.program;
            };
            Project.prototype.removeExistingTypings = function (include) {
                var existing = ts.getAutomaticTypeDirectiveNames(this.getCompilerOptions(), this.directoryStructureHost);
                return include.filter(function (i) { return existing.indexOf(i) < 0; });
            };
            Project.prototype.updateGraphWorker = function () {
                var _this = this;
                var oldProgram = this.program;
                ts.Debug.assert(!this.isClosed(), "Called update graph worker of closed project");
                this.writeLog("Starting updateGraphWorker: Project: " + this.getProjectName());
                var start = ts.timestamp();
                this.hasInvalidatedResolution = this.resolutionCache.createHasInvalidatedResolution();
                this.resolutionCache.startCachingPerDirectoryResolution();
                this.program = this.languageService.getProgram(); // TODO: GH#18217
                this.dirty = false;
                this.resolutionCache.finishCachingPerDirectoryResolution();
                ts.Debug.assert(oldProgram === undefined || this.program !== undefined);
                // bump up the version if
                // - oldProgram is not set - this is a first time updateGraph is called
                // - newProgram is different from the old program and structure of the old program was not reused.
                var hasNewProgram = false;
                if (this.program && (!oldProgram || (this.program !== oldProgram && this.program.structureIsReused !== 2 /* Completely */))) {
                    hasNewProgram = true;
                    if (oldProgram) {
                        for (var _i = 0, _a = oldProgram.getSourceFiles(); _i < _a.length; _i++) {
                            var f = _a[_i];
                            var newFile = this.program.getSourceFileByPath(f.resolvedPath);
                            if (!newFile || (f.resolvedPath === f.path && newFile.resolvedPath !== f.path)) {
                                // new program does not contain this file - detach it from the project
                                // - remove resolutions only if the new program doesnt contain source file by the path (not resolvedPath since path is used for resolution)
                                this.detachScriptInfoFromProject(f.fileName, !!this.program.getSourceFileByPath(f.path));
                            }
                        }
                        oldProgram.forEachResolvedProjectReference(function (resolvedProjectReference) {
                            if (!_this.program.getResolvedProjectReferenceByPath(resolvedProjectReference.sourceFile.path)) {
                                _this.detachScriptInfoFromProject(resolvedProjectReference.sourceFile.fileName);
                            }
                        });
                    }
                    // Update the missing file paths watcher
                    ts.updateMissingFilePathsWatch(this.program, this.missingFilesMap || (this.missingFilesMap = new ts.Map()), 
                    // Watch the missing files
                    function (missingFilePath) { return _this.addMissingFileWatcher(missingFilePath); });
                    if (this.generatedFilesMap) {
                        var outPath = ts.outFile(this.compilerOptions);
                        if (isGeneratedFileWatcher(this.generatedFilesMap)) {
                            // --out
                            if (!outPath || !this.isValidGeneratedFileWatcher(ts.removeFileExtension(outPath) + ".d.ts" /* Dts */, this.generatedFilesMap)) {
                                this.clearGeneratedFileWatch();
                            }
                        }
                        else {
                            // MultiFile
                            if (outPath) {
                                this.clearGeneratedFileWatch();
                            }
                            else {
                                this.generatedFilesMap.forEach(function (watcher, source) {
                                    var sourceFile = _this.program.getSourceFileByPath(source);
                                    if (!sourceFile ||
                                        sourceFile.resolvedPath !== source ||
                                        !_this.isValidGeneratedFileWatcher(ts.getDeclarationEmitOutputFilePathWorker(sourceFile.fileName, _this.compilerOptions, _this.currentDirectory, _this.program.getCommonSourceDirectory(), _this.getCanonicalFileName), watcher)) {
                                        ts.closeFileWatcherOf(watcher);
                                        _this.generatedFilesMap.delete(source);
                                    }
                                });
                            }
                        }
                    }
                    // Watch the type locations that would be added to program as part of automatic type resolutions
                    if (this.languageServiceEnabled && this.projectService.serverMode === ts.LanguageServiceMode.Semantic) {
                        this.resolutionCache.updateTypeRootsWatch();
                    }
                }
                if (this.exportMapCache && !this.exportMapCache.isEmpty()) {
                    this.exportMapCache.releaseSymbols();
                    if (this.hasAddedorRemovedFiles || oldProgram && !this.program.structureIsReused) {
                        this.exportMapCache.clear();
                    }
                    else if (this.changedFilesForExportMapCache && oldProgram && this.program) {
                        ts.forEachKey(this.changedFilesForExportMapCache, function (fileName) {
                            var oldSourceFile = oldProgram.getSourceFileByPath(fileName);
                            var sourceFile = _this.program.getSourceFileByPath(fileName);
                            if (!oldSourceFile || !sourceFile) {
                                _this.exportMapCache.clear();
                                return true;
                            }
                            return _this.exportMapCache.onFileChanged(oldSourceFile, sourceFile, !!_this.getTypeAcquisition().enable);
                        });
                    }
                }
                if (this.changedFilesForExportMapCache) {
                    this.changedFilesForExportMapCache.clear();
                }
                if (this.hasAddedOrRemovedSymlinks || this.program && !this.program.structureIsReused && this.getCompilerOptions().preserveSymlinks) {
                    // With --preserveSymlinks, we may not determine that a file is a symlink, so we never set `hasAddedOrRemovedSymlinks`
                    this.symlinks = undefined;
                    this.moduleSpecifierCache.clear();
                }
                var oldExternalFiles = this.externalFiles || server.emptyArray;
                this.externalFiles = this.getExternalFiles();
                ts.enumerateInsertsAndDeletes(this.externalFiles, oldExternalFiles, ts.getStringComparer(!this.useCaseSensitiveFileNames()), 
                // Ensure a ScriptInfo is created for new external files. This is performed indirectly
                // by the host for files in the program when the program is retrieved above but
                // the program doesn't contain external files so this must be done explicitly.
                function (inserted) {
                    var scriptInfo = _this.projectService.getOrCreateScriptInfoNotOpenedByClient(inserted, _this.currentDirectory, _this.directoryStructureHost);
                    scriptInfo === null || scriptInfo === void 0 ? void 0 : scriptInfo.attachToProject(_this);
                }, function (removed) { return _this.detachScriptInfoFromProject(removed); });
                var elapsed = ts.timestamp() - start;
                this.sendPerformanceEvent("UpdateGraph", elapsed);
                this.writeLog("Finishing updateGraphWorker: Project: " + this.getProjectName() + " Version: " + this.getProjectVersion() + " structureChanged: " + hasNewProgram + (this.program ? " structureIsReused:: " + ts.StructureIsReused[this.program.structureIsReused] : "") + " Elapsed: " + elapsed + "ms");
                if (this.hasAddedorRemovedFiles) {
                    this.print(/*writeProjectFileNames*/ true);
                }
                else if (this.program !== oldProgram) {
                    this.writeLog("Different program with same set of files");
                }
                return hasNewProgram;
            };
            /* @internal */
            Project.prototype.sendPerformanceEvent = function (kind, durationMs) {
                this.projectService.sendPerformanceEvent(kind, durationMs);
            };
            Project.prototype.detachScriptInfoFromProject = function (uncheckedFileName, noRemoveResolution) {
                var scriptInfoToDetach = this.projectService.getScriptInfo(uncheckedFileName);
                if (scriptInfoToDetach) {
                    scriptInfoToDetach.detachFromProject(this);
                    if (!noRemoveResolution) {
                        this.resolutionCache.removeResolutionsOfFile(scriptInfoToDetach.path);
                    }
                }
            };
            Project.prototype.addMissingFileWatcher = function (missingFilePath) {
                var _this = this;
                var _a;
                if (isConfiguredProject(this)) {
                    // If this file is referenced config file, we are already watching it, no need to watch again
                    var configFileExistenceInfo = this.projectService.configFileExistenceInfoCache.get(missingFilePath);
                    if ((_a = configFileExistenceInfo === null || configFileExistenceInfo === void 0 ? void 0 : configFileExistenceInfo.config) === null || _a === void 0 ? void 0 : _a.projects.has(this.canonicalConfigFilePath))
                        return ts.noopFileWatcher;
                }
                var fileWatcher = this.projectService.watchFactory.watchFile(missingFilePath, function (fileName, eventKind) {
                    if (isConfiguredProject(_this)) {
                        _this.getCachedDirectoryStructureHost().addOrDeleteFile(fileName, missingFilePath, eventKind);
                    }
                    if (eventKind === ts.FileWatcherEventKind.Created && _this.missingFilesMap.has(missingFilePath)) {
                        _this.missingFilesMap.delete(missingFilePath);
                        fileWatcher.close();
                        // When a missing file is created, we should update the graph.
                        _this.projectService.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(_this);
                    }
                }, ts.PollingInterval.Medium, this.projectService.getWatchOptions(this), ts.WatchType.MissingFile, this);
                return fileWatcher;
            };
            Project.prototype.isWatchedMissingFile = function (path) {
                return !!this.missingFilesMap && this.missingFilesMap.has(path);
            };
            /* @internal */
            Project.prototype.addGeneratedFileWatch = function (generatedFile, sourceFile) {
                if (ts.outFile(this.compilerOptions)) {
                    // Single watcher
                    if (!this.generatedFilesMap) {
                        this.generatedFilesMap = this.createGeneratedFileWatcher(generatedFile);
                    }
                }
                else {
                    // Map
                    var path = this.toPath(sourceFile);
                    if (this.generatedFilesMap) {
                        if (isGeneratedFileWatcher(this.generatedFilesMap)) {
                            ts.Debug.fail(this.projectName + " Expected to not have --out watcher for generated file with options: " + JSON.stringify(this.compilerOptions));
                            return;
                        }
                        if (this.generatedFilesMap.has(path))
                            return;
                    }
                    else {
                        this.generatedFilesMap = new ts.Map();
                    }
                    this.generatedFilesMap.set(path, this.createGeneratedFileWatcher(generatedFile));
                }
            };
            Project.prototype.createGeneratedFileWatcher = function (generatedFile) {
                var _this = this;
                return {
                    generatedFilePath: this.toPath(generatedFile),
                    watcher: this.projectService.watchFactory.watchFile(generatedFile, function () {
                        _this.clearSourceMapperCache();
                        _this.projectService.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(_this);
                    }, ts.PollingInterval.High, this.projectService.getWatchOptions(this), ts.WatchType.MissingGeneratedFile, this)
                };
            };
            Project.prototype.isValidGeneratedFileWatcher = function (generateFile, watcher) {
                return this.toPath(generateFile) === watcher.generatedFilePath;
            };
            Project.prototype.clearGeneratedFileWatch = function () {
                if (this.generatedFilesMap) {
                    if (isGeneratedFileWatcher(this.generatedFilesMap)) {
                        ts.closeFileWatcherOf(this.generatedFilesMap);
                    }
                    else {
                        ts.clearMap(this.generatedFilesMap, ts.closeFileWatcherOf);
                    }
                    this.generatedFilesMap = undefined;
                }
            };
            Project.prototype.getScriptInfoForNormalizedPath = function (fileName) {
                var scriptInfo = this.projectService.getScriptInfoForPath(this.toPath(fileName));
                if (scriptInfo && !scriptInfo.isAttached(this)) {
                    return server.Errors.ThrowProjectDoesNotContainDocument(fileName, this);
                }
                return scriptInfo;
            };
            Project.prototype.getScriptInfo = function (uncheckedFileName) {
                return this.projectService.getScriptInfo(uncheckedFileName);
            };
            Project.prototype.filesToString = function (writeProjectFileNames) {
                if (this.isInitialLoadPending())
                    return "\tFiles (0) InitialLoadPending\n";
                if (!this.program)
                    return "\tFiles (0) NoProgram\n";
                var sourceFiles = this.program.getSourceFiles();
                var strBuilder = "\tFiles (" + sourceFiles.length + ")\n";
                if (writeProjectFileNames) {
                    for (var _i = 0, sourceFiles_1 = sourceFiles; _i < sourceFiles_1.length; _i++) {
                        var file = sourceFiles_1[_i];
                        strBuilder += "\t" + file.fileName + "\n";
                    }
                    strBuilder += "\n\n";
                    ts.explainFiles(this.program, function (s) { return strBuilder += "\t" + s + "\n"; });
                }
                return strBuilder;
            };
            /*@internal*/
            Project.prototype.print = function (writeProjectFileNames) {
                this.writeLog("Project '" + this.projectName + "' (" + ProjectKind[this.projectKind] + ")");
                this.writeLog(this.filesToString(writeProjectFileNames && this.projectService.logger.hasLevel(server.LogLevel.verbose)));
                this.writeLog("-----------------------------------------------");
                if (this.autoImportProviderHost) {
                    this.autoImportProviderHost.print(/*writeProjectFileNames*/ false);
                }
            };
            Project.prototype.setCompilerOptions = function (compilerOptions) {
                if (compilerOptions) {
                    compilerOptions.allowNonTsExtensions = true;
                    var oldOptions = this.compilerOptions;
                    this.compilerOptions = compilerOptions;
                    this.setInternalCompilerOptionsForEmittingJsFiles();
                    if (ts.changesAffectModuleResolution(oldOptions, compilerOptions)) {
                        // reset cached unresolved imports if changes in compiler options affected module resolution
                        this.cachedUnresolvedImportsPerFile.clear();
                        this.lastCachedUnresolvedImportsList = undefined;
                        this.resolutionCache.clear();
                        this.moduleSpecifierCache.clear();
                    }
                    this.markAsDirty();
                }
            };
            /*@internal*/
            Project.prototype.setWatchOptions = function (watchOptions) {
                this.watchOptions = watchOptions;
            };
            /*@internal*/
            Project.prototype.getWatchOptions = function () {
                return this.watchOptions;
            };
            Project.prototype.setTypeAcquisition = function (newTypeAcquisition) {
                if (newTypeAcquisition) {
                    this.typeAcquisition = this.removeLocalTypingsFromTypeAcquisition(newTypeAcquisition);
                }
            };
            Project.prototype.getTypeAcquisition = function () {
                return this.typeAcquisition || {};
            };
            /* @internal */
            Project.prototype.getChangesSinceVersion = function (lastKnownVersion, includeProjectReferenceRedirectInfo) {
                var _this = this;
                var includeProjectReferenceRedirectInfoIfRequested = includeProjectReferenceRedirectInfo
                    ? function (files) { return ts.arrayFrom(files.entries(), function (_a) {
                        var fileName = _a[0], isSourceOfProjectReferenceRedirect = _a[1];
                        return ({
                            fileName: fileName,
                            isSourceOfProjectReferenceRedirect: isSourceOfProjectReferenceRedirect
                        });
                    }); }
                    : function (files) { return ts.arrayFrom(files.keys()); };
                // Update the graph only if initial configured project load is not pending
                if (!this.isInitialLoadPending()) {
                    server.updateProjectIfDirty(this);
                }
                var info = {
                    projectName: this.getProjectName(),
                    version: this.projectProgramVersion,
                    isInferred: isInferredProject(this),
                    options: this.getCompilationSettings(),
                    languageServiceDisabled: !this.languageServiceEnabled,
                    lastFileExceededProgramSize: this.lastFileExceededProgramSize
                };
                var updatedFileNames = this.updatedFileNames;
                this.updatedFileNames = undefined;
                // check if requested version is the same that we have reported last time
                if (this.lastReportedFileNames && lastKnownVersion === this.lastReportedVersion) {
                    // if current structure version is the same - return info without any changes
                    if (this.projectProgramVersion === this.lastReportedVersion && !updatedFileNames) {
                        return { info: info, projectErrors: this.getGlobalProjectErrors() };
                    }
                    // compute and return the difference
                    var lastReportedFileNames_1 = this.lastReportedFileNames;
                    var externalFiles = this.getExternalFiles().map(function (f) { return ({
                        fileName: server.toNormalizedPath(f),
                        isSourceOfProjectReferenceRedirect: false
                    }); });
                    var currentFiles_1 = ts.arrayToMap(this.getFileNamesWithRedirectInfo(!!includeProjectReferenceRedirectInfo).concat(externalFiles), function (info) { return info.fileName; }, function (info) { return info.isSourceOfProjectReferenceRedirect; });
                    var added_1 = new ts.Map();
                    var removed_1 = new ts.Map();
                    var updated = updatedFileNames ? ts.arrayFrom(updatedFileNames.keys()) : [];
                    var updatedRedirects_1 = [];
                    ts.forEachEntry(currentFiles_1, function (isSourceOfProjectReferenceRedirect, fileName) {
                        if (!lastReportedFileNames_1.has(fileName)) {
                            added_1.set(fileName, isSourceOfProjectReferenceRedirect);
                        }
                        else if (includeProjectReferenceRedirectInfo && isSourceOfProjectReferenceRedirect !== lastReportedFileNames_1.get(fileName)) {
                            updatedRedirects_1.push({
                                fileName: fileName,
                                isSourceOfProjectReferenceRedirect: isSourceOfProjectReferenceRedirect
                            });
                        }
                    });
                    ts.forEachEntry(lastReportedFileNames_1, function (isSourceOfProjectReferenceRedirect, fileName) {
                        if (!currentFiles_1.has(fileName)) {
                            removed_1.set(fileName, isSourceOfProjectReferenceRedirect);
                        }
                    });
                    this.lastReportedFileNames = currentFiles_1;
                    this.lastReportedVersion = this.projectProgramVersion;
                    return {
                        info: info,
                        changes: {
                            added: includeProjectReferenceRedirectInfoIfRequested(added_1),
                            removed: includeProjectReferenceRedirectInfoIfRequested(removed_1),
                            updated: includeProjectReferenceRedirectInfo
                                ? updated.map(function (fileName) { return ({
                                    fileName: fileName,
                                    isSourceOfProjectReferenceRedirect: _this.isSourceOfProjectReferenceRedirect(fileName)
                                }); })
                                : updated,
                            updatedRedirects: includeProjectReferenceRedirectInfo ? updatedRedirects_1 : undefined
                        },
                        projectErrors: this.getGlobalProjectErrors()
                    };
                }
                else {
                    // unknown version - return everything
                    var projectFileNames = this.getFileNamesWithRedirectInfo(!!includeProjectReferenceRedirectInfo);
                    var externalFiles = this.getExternalFiles().map(function (f) { return ({
                        fileName: server.toNormalizedPath(f),
                        isSourceOfProjectReferenceRedirect: false
                    }); });
                    var allFiles = projectFileNames.concat(externalFiles);
                    this.lastReportedFileNames = ts.arrayToMap(allFiles, function (info) { return info.fileName; }, function (info) { return info.isSourceOfProjectReferenceRedirect; });
                    this.lastReportedVersion = this.projectProgramVersion;
                    return {
                        info: info,
                        files: includeProjectReferenceRedirectInfo ? allFiles : allFiles.map(function (f) { return f.fileName; }),
                        projectErrors: this.getGlobalProjectErrors()
                    };
                }
            };
            // remove a root file from project
            Project.prototype.removeRoot = function (info) {
                ts.orderedRemoveItem(this.rootFiles, info);
                this.rootFilesMap.delete(info.path);
            };
            /*@internal*/
            Project.prototype.isSourceOfProjectReferenceRedirect = function (fileName) {
                return !!this.program && this.program.isSourceOfProjectReferenceRedirect(fileName);
            };
            Project.prototype.enableGlobalPlugins = function (options, pluginConfigOverrides) {
                var host = this.projectService.host;
                if (!host.require) {
                    this.projectService.logger.info("Plugins were requested but not running in environment that supports 'require'. Nothing will be loaded");
                    return;
                }
                // Search any globally-specified probe paths, then our peer node_modules
                var searchPaths = __spreadArray(__spreadArray([], this.projectService.pluginProbeLocations, true), [
                    // ../../.. to walk from X/node_modules/typescript/lib/tsserver.js to X/node_modules/
                    ts.combinePaths(this.projectService.getExecutingFilePath(), "../../.."),
                ], false);
                if (this.projectService.globalPlugins) {
                    var _loop_1 = function (globalPluginName) {
                        // Skip empty names from odd commandline parses
                        if (!globalPluginName)
                            return "continue";
                        // Skip already-locally-loaded plugins
                        if (options.plugins && options.plugins.some(function (p) { return p.name === globalPluginName; }))
                            return "continue";
                        // Provide global: true so plugins can detect why they can't find their config
                        this_1.projectService.logger.info("Loading global plugin " + globalPluginName);
                        this_1.enablePlugin({ name: globalPluginName, global: true }, searchPaths, pluginConfigOverrides);
                    };
                    var this_1 = this;
                    // Enable global plugins with synthetic configuration entries
                    for (var _i = 0, _a = this.projectService.globalPlugins; _i < _a.length; _i++) {
                        var globalPluginName = _a[_i];
                        _loop_1(globalPluginName);
                    }
                }
            };
            Project.prototype.enablePlugin = function (pluginConfigEntry, searchPaths, pluginConfigOverrides) {
                var _this = this;
                this.projectService.logger.info("Enabling plugin " + pluginConfigEntry.name + " from candidate paths: " + searchPaths.join(","));
                if (!pluginConfigEntry.name || ts.parsePackageName(pluginConfigEntry.name).rest) {
                    this.projectService.logger.info("Skipped loading plugin " + (pluginConfigEntry.name || JSON.stringify(pluginConfigEntry)) + " because only package name is allowed plugin name");
                    return;
                }
                var log = function (message) { return _this.projectService.logger.info(message); };
                var errorLogs;
                var logError = function (message) { (errorLogs || (errorLogs = [])).push(message); };
                var resolvedModule = ts.firstDefined(searchPaths, function (searchPath) {
                    return Project.resolveModule(pluginConfigEntry.name, searchPath, _this.projectService.host, log, logError);
                });
                if (resolvedModule) {
                    var configurationOverride = pluginConfigOverrides && pluginConfigOverrides.get(pluginConfigEntry.name);
                    if (configurationOverride) {
                        // Preserve the name property since it's immutable
                        var pluginName = pluginConfigEntry.name;
                        pluginConfigEntry = configurationOverride;
                        pluginConfigEntry.name = pluginName;
                    }
                    this.enableProxy(resolvedModule, pluginConfigEntry);
                }
                else {
                    ts.forEach(errorLogs, log);
                    this.projectService.logger.info("Couldn't find " + pluginConfigEntry.name);
                }
            };
            Project.prototype.enableProxy = function (pluginModuleFactory, configEntry) {
                try {
                    if (typeof pluginModuleFactory !== "function") {
                        this.projectService.logger.info("Skipped loading plugin " + configEntry.name + " because it did not expose a proper factory function");
                        return;
                    }
                    var info = {
                        config: configEntry,
                        project: this,
                        languageService: this.languageService,
                        languageServiceHost: this,
                        serverHost: this.projectService.host,
                        session: this.projectService.session
                    };
                    var pluginModule = pluginModuleFactory({ typescript: ts });
                    var newLS = pluginModule.create(info);
                    for (var _i = 0, _a = Object.keys(this.languageService); _i < _a.length; _i++) {
                        var k = _a[_i];
                        // eslint-disable-next-line no-in-operator
                        if (!(k in newLS)) {
                            this.projectService.logger.info("Plugin activation warning: Missing proxied method " + k + " in created LS. Patching.");
                            newLS[k] = this.languageService[k];
                        }
                    }
                    this.projectService.logger.info("Plugin validation succeeded");
                    this.languageService = newLS;
                    this.plugins.push({ name: configEntry.name, module: pluginModule });
                }
                catch (e) {
                    this.projectService.logger.info("Plugin activation failed: " + e);
                }
            };
            /*@internal*/
            Project.prototype.onPluginConfigurationChanged = function (pluginName, configuration) {
                this.plugins.filter(function (plugin) { return plugin.name === pluginName; }).forEach(function (plugin) {
                    if (plugin.module.onConfigurationChanged) {
                        plugin.module.onConfigurationChanged(configuration);
                    }
                });
            };
            /** Starts a new check for diagnostics. Call this if some file has updated that would cause diagnostics to be changed. */
            Project.prototype.refreshDiagnostics = function () {
                this.projectService.sendProjectsUpdatedInBackgroundEvent();
            };
            /*@internal*/
            Project.prototype.getPackageJsonsVisibleToFile = function (fileName, rootDir) {
                if (this.projectService.serverMode !== ts.LanguageServiceMode.Semantic)
                    return server.emptyArray;
                return this.projectService.getPackageJsonsVisibleToFile(fileName, rootDir);
            };
            /*@internal*/
            Project.prototype.getNearestAncestorDirectoryWithPackageJson = function (fileName) {
                return this.projectService.getNearestAncestorDirectoryWithPackageJson(fileName);
            };
            /*@internal*/
            Project.prototype.getPackageJsonsForAutoImport = function (rootDir) {
                var packageJsons = this.getPackageJsonsVisibleToFile(ts.combinePaths(this.currentDirectory, ts.inferredTypesContainingFile), rootDir);
                this.packageJsonsForAutoImport = new ts.Set(packageJsons.map(function (p) { return p.fileName; }));
                return packageJsons;
            };
            /*@internal*/
            Project.prototype.getCachedExportInfoMap = function () {
                return this.exportMapCache || (this.exportMapCache = ts.createCacheableExportInfoMap(this));
            };
            /*@internal*/
            Project.prototype.clearCachedExportInfoMap = function () {
                var _a;
                (_a = this.exportMapCache) === null || _a === void 0 ? void 0 : _a.clear();
            };
            /*@internal*/
            Project.prototype.getModuleSpecifierCache = function () {
                return this.moduleSpecifierCache;
            };
            /*@internal*/
            Project.prototype.includePackageJsonAutoImports = function () {
                if (this.projectService.includePackageJsonAutoImports() === 0 /* Off */ ||
                    !this.languageServiceEnabled ||
                    ts.isInsideNodeModules(this.currentDirectory) ||
                    !this.isDefaultProjectForOpenFiles()) {
                    return 0 /* Off */;
                }
                return this.projectService.includePackageJsonAutoImports();
            };
            /*@internal*/
            Project.prototype.getModuleResolutionHostForAutoImportProvider = function () {
                var _a, _b;
                if (this.program) {
                    return {
                        fileExists: this.program.fileExists,
                        directoryExists: this.program.directoryExists,
                        realpath: this.program.realpath || ((_a = this.projectService.host.realpath) === null || _a === void 0 ? void 0 : _a.bind(this.projectService.host)),
                        getCurrentDirectory: this.getCurrentDirectory.bind(this),
                        readFile: this.projectService.host.readFile.bind(this.projectService.host),
                        getDirectories: this.projectService.host.getDirectories.bind(this.projectService.host),
                        trace: (_b = this.projectService.host.trace) === null || _b === void 0 ? void 0 : _b.bind(this.projectService.host),
                    };
                }
                return this.projectService.host;
            };
            /*@internal*/
            Project.prototype.getPackageJsonAutoImportProvider = function () {
                if (this.autoImportProviderHost === false) {
                    return undefined;
                }
                if (this.projectService.serverMode !== ts.LanguageServiceMode.Semantic) {
                    this.autoImportProviderHost = false;
                    return undefined;
                }
                if (this.autoImportProviderHost) {
                    server.updateProjectIfDirty(this.autoImportProviderHost);
                    if (this.autoImportProviderHost.isEmpty()) {
                        this.autoImportProviderHost.close();
                        this.autoImportProviderHost = undefined;
                        return undefined;
                    }
                    return this.autoImportProviderHost.getCurrentProgram();
                }
                var dependencySelection = this.includePackageJsonAutoImports();
                if (dependencySelection) {
                    var start = ts.timestamp();
                    this.autoImportProviderHost = AutoImportProviderProject.create(dependencySelection, this, this.getModuleResolutionHostForAutoImportProvider(), this.documentRegistry);
                    if (this.autoImportProviderHost) {
                        server.updateProjectIfDirty(this.autoImportProviderHost);
                        this.sendPerformanceEvent("CreatePackageJsonAutoImportProvider", ts.timestamp() - start);
                        return this.autoImportProviderHost.getCurrentProgram();
                    }
                }
            };
            /*@internal*/
            Project.prototype.isDefaultProjectForOpenFiles = function () {
                var _this = this;
                return !!ts.forEachEntry(this.projectService.openFiles, function (_, fileName) { return _this.projectService.tryGetDefaultProjectForFile(server.toNormalizedPath(fileName)) === _this; });
            };
            /*@internal*/
            Project.prototype.watchNodeModulesForPackageJsonChanges = function (directoryPath) {
                return this.projectService.watchPackageJsonsInNodeModules(this.toPath(directoryPath), this);
            };
            /*@internal*/
            Project.prototype.getIncompleteCompletionsCache = function () {
                return this.projectService.getIncompleteCompletionsCache();
            };
            return Project;
        }());
        server.Project = Project;
        function getUnresolvedImports(program, cachedUnresolvedImportsPerFile) {
            var ambientModules = program.getTypeChecker().getAmbientModules().map(function (mod) { return ts.stripQuotes(mod.getName()); });
            return ts.sortAndDeduplicate(ts.flatMap(program.getSourceFiles(), function (sourceFile) {
                return extractUnresolvedImportsFromSourceFile(sourceFile, ambientModules, cachedUnresolvedImportsPerFile);
            }));
        }
        function extractUnresolvedImportsFromSourceFile(file, ambientModules, cachedUnresolvedImportsPerFile) {
            return ts.getOrUpdate(cachedUnresolvedImportsPerFile, file.path, function () {
                if (!file.resolvedModules)
                    return server.emptyArray;
                var unresolvedImports;
                file.resolvedModules.forEach(function (resolvedModule, name) {
                    // pick unresolved non-relative names
                    if ((!resolvedModule || !ts.resolutionExtensionIsTSOrJson(resolvedModule.extension)) &&
                        !ts.isExternalModuleNameRelative(name) &&
                        !ambientModules.some(function (m) { return m === name; })) {
                        unresolvedImports = ts.append(unresolvedImports, ts.parsePackageName(name).packageName);
                    }
                });
                return unresolvedImports || server.emptyArray;
            });
        }
        /**
         * If a file is opened and no tsconfig (or jsconfig) is found,
         * the file and its imports/references are put into an InferredProject.
         */
        var InferredProject = /** @class */ (function (_super) {
            __extends(InferredProject, _super);
            /*@internal*/
            function InferredProject(projectService, documentRegistry, compilerOptions, watchOptions, projectRootPath, currentDirectory, pluginConfigOverrides, typeAcquisition) {
                var _this = _super.call(this, projectService.newInferredProjectName(), ProjectKind.Inferred, projectService, documentRegistry, 
                // TODO: GH#18217
                /*files*/ undefined, 
                /*lastFileExceededProgramSize*/ undefined, compilerOptions, 
                /*compileOnSaveEnabled*/ false, watchOptions, projectService.host, currentDirectory) || this;
                _this._isJsInferredProject = false;
                _this.typeAcquisition = typeAcquisition;
                _this.projectRootPath = projectRootPath && projectService.toCanonicalFileName(projectRootPath);
                if (!projectRootPath && !projectService.useSingleInferredProject) {
                    _this.canonicalCurrentDirectory = projectService.toCanonicalFileName(_this.currentDirectory);
                }
                _this.enableGlobalPlugins(_this.getCompilerOptions(), pluginConfigOverrides);
                return _this;
            }
            InferredProject.prototype.toggleJsInferredProject = function (isJsInferredProject) {
                if (isJsInferredProject !== this._isJsInferredProject) {
                    this._isJsInferredProject = isJsInferredProject;
                    this.setCompilerOptions();
                }
            };
            InferredProject.prototype.setCompilerOptions = function (options) {
                // Avoid manipulating the given options directly
                if (!options && !this.getCompilationSettings()) {
                    return;
                }
                var newOptions = ts.cloneCompilerOptions(options || this.getCompilationSettings());
                if (this._isJsInferredProject && typeof newOptions.maxNodeModuleJsDepth !== "number") {
                    newOptions.maxNodeModuleJsDepth = 2;
                }
                else if (!this._isJsInferredProject) {
                    newOptions.maxNodeModuleJsDepth = undefined;
                }
                newOptions.allowJs = true;
                _super.prototype.setCompilerOptions.call(this, newOptions);
            };
            InferredProject.prototype.addRoot = function (info) {
                ts.Debug.assert(info.isScriptOpen());
                this.projectService.startWatchingConfigFilesForInferredProjectRoot(info);
                if (!this._isJsInferredProject && info.isJavaScript()) {
                    this.toggleJsInferredProject(/*isJsInferredProject*/ true);
                }
                _super.prototype.addRoot.call(this, info);
            };
            InferredProject.prototype.removeRoot = function (info) {
                this.projectService.stopWatchingConfigFilesForInferredProjectRoot(info);
                _super.prototype.removeRoot.call(this, info);
                if (this._isJsInferredProject && info.isJavaScript()) {
                    if (ts.every(this.getRootScriptInfos(), function (rootInfo) { return !rootInfo.isJavaScript(); })) {
                        this.toggleJsInferredProject(/*isJsInferredProject*/ false);
                    }
                }
            };
            /*@internal*/
            InferredProject.prototype.isOrphan = function () {
                return !this.hasRoots();
            };
            InferredProject.prototype.isProjectWithSingleRoot = function () {
                // - when useSingleInferredProject is not set and projectRootPath is not set,
                //   we can guarantee that this will be the only root
                // - other wise it has single root if it has single root script info
                return (!this.projectRootPath && !this.projectService.useSingleInferredProject) ||
                    this.getRootScriptInfos().length === 1;
            };
            InferredProject.prototype.close = function () {
                var _this = this;
                ts.forEach(this.getRootScriptInfos(), function (info) { return _this.projectService.stopWatchingConfigFilesForInferredProjectRoot(info); });
                _super.prototype.close.call(this);
            };
            InferredProject.prototype.getTypeAcquisition = function () {
                return this.typeAcquisition || {
                    enable: allRootFilesAreJsOrDts(this),
                    include: ts.emptyArray,
                    exclude: ts.emptyArray
                };
            };
            return InferredProject;
        }(Project));
        server.InferredProject = InferredProject;
        var AutoImportProviderProject = /** @class */ (function (_super) {
            __extends(AutoImportProviderProject, _super);
            /*@internal*/
            function AutoImportProviderProject(hostProject, initialRootNames, documentRegistry, compilerOptions) {
                var _this = _super.call(this, hostProject.projectService.newAutoImportProviderProjectName(), ProjectKind.AutoImportProvider, hostProject.projectService, documentRegistry, 
                /*hasExplicitListOfFiles*/ false, 
                /*lastFileExceededProgramSize*/ undefined, compilerOptions, 
                /*compileOnSaveEnabled*/ false, hostProject.getWatchOptions(), hostProject.projectService.host, hostProject.currentDirectory) || this;
                _this.hostProject = hostProject;
                _this.rootFileNames = initialRootNames;
                _this.useSourceOfProjectReferenceRedirect = ts.maybeBind(_this.hostProject, _this.hostProject.useSourceOfProjectReferenceRedirect);
                _this.getParsedCommandLine = ts.maybeBind(_this.hostProject, _this.hostProject.getParsedCommandLine);
                return _this;
            }
            /*@internal*/
            AutoImportProviderProject.getRootFileNames = function (dependencySelection, hostProject, moduleResolutionHost, compilerOptions) {
                var _a, _b, _c;
                if (!dependencySelection) {
                    return ts.emptyArray;
                }
                var program = hostProject.getCurrentProgram();
                if (!program) {
                    return ts.emptyArray;
                }
                var dependencyNames;
                var rootNames;
                var rootFileName = ts.combinePaths(hostProject.currentDirectory, ts.inferredTypesContainingFile);
                var packageJsons = hostProject.getPackageJsonsForAutoImport(ts.combinePaths(hostProject.currentDirectory, rootFileName));
                for (var _i = 0, packageJsons_1 = packageJsons; _i < packageJsons_1.length; _i++) {
                    var packageJson = packageJsons_1[_i];
                    (_a = packageJson.dependencies) === null || _a === void 0 ? void 0 : _a.forEach(function (_, dependenyName) { return addDependency(dependenyName); });
                    (_b = packageJson.peerDependencies) === null || _b === void 0 ? void 0 : _b.forEach(function (_, dependencyName) { return addDependency(dependencyName); });
                }
                if (dependencyNames) {
                    var resolutions = ts.map(ts.arrayFrom(dependencyNames.keys()), function (name) { return ts.resolveTypeReferenceDirective(name, rootFileName, compilerOptions, moduleResolutionHost); });
                    var symlinkCache = hostProject.getSymlinkCache();
                    for (var _d = 0, resolutions_1 = resolutions; _d < resolutions_1.length; _d++) {
                        var resolution = resolutions_1[_d];
                        if (!((_c = resolution.resolvedTypeReferenceDirective) === null || _c === void 0 ? void 0 : _c.resolvedFileName))
                            continue;
                        var _e = resolution.resolvedTypeReferenceDirective, resolvedFileName = _e.resolvedFileName, originalPath = _e.originalPath;
                        if (!program.getSourceFile(resolvedFileName) && (!originalPath || !program.getSourceFile(originalPath))) {
                            rootNames = ts.append(rootNames, resolvedFileName);
                            // Avoid creating a large project that would significantly slow down time to editor interactivity
                            if (dependencySelection === 2 /* Auto */ && rootNames.length > this.maxDependencies) {
                                return ts.emptyArray;
                            }
                            if (originalPath) {
                                symlinkCache.setSymlinkedDirectoryFromSymlinkedFile(originalPath, resolvedFileName);
                            }
                        }
                    }
                }
                return rootNames || ts.emptyArray;
                function addDependency(dependency) {
                    if (!ts.startsWith(dependency, "@types/")) {
                        (dependencyNames || (dependencyNames = new ts.Set())).add(dependency);
                    }
                }
            };
            /*@internal*/
            AutoImportProviderProject.create = function (dependencySelection, hostProject, moduleResolutionHost, documentRegistry) {
                if (dependencySelection === 0 /* Off */) {
                    return undefined;
                }
                var compilerOptions = __assign(__assign({}, hostProject.getCompilerOptions()), this.compilerOptionsOverrides);
                var rootNames = this.getRootFileNames(dependencySelection, hostProject, moduleResolutionHost, compilerOptions);
                if (!rootNames.length) {
                    return undefined;
                }
                return new AutoImportProviderProject(hostProject, rootNames, documentRegistry, compilerOptions);
            };
            /*@internal*/
            AutoImportProviderProject.prototype.isEmpty = function () {
                return !ts.some(this.rootFileNames);
            };
            AutoImportProviderProject.prototype.isOrphan = function () {
                return true;
            };
            AutoImportProviderProject.prototype.updateGraph = function () {
                var rootFileNames = this.rootFileNames;
                if (!rootFileNames) {
                    rootFileNames = AutoImportProviderProject.getRootFileNames(this.hostProject.includePackageJsonAutoImports(), this.hostProject, this.hostProject.getModuleResolutionHostForAutoImportProvider(), this.getCompilationSettings());
                }
                this.projectService.setFileNamesOfAutoImportProviderProject(this, rootFileNames);
                this.rootFileNames = rootFileNames;
                var oldProgram = this.getCurrentProgram();
                var hasSameSetOfFiles = _super.prototype.updateGraph.call(this);
                if (oldProgram && oldProgram !== this.getCurrentProgram()) {
                    this.hostProject.clearCachedExportInfoMap();
                }
                return hasSameSetOfFiles;
            };
            AutoImportProviderProject.prototype.hasRoots = function () {
                var _a;
                return !!((_a = this.rootFileNames) === null || _a === void 0 ? void 0 : _a.length);
            };
            AutoImportProviderProject.prototype.markAsDirty = function () {
                this.rootFileNames = undefined;
                _super.prototype.markAsDirty.call(this);
            };
            AutoImportProviderProject.prototype.getScriptFileNames = function () {
                return this.rootFileNames || ts.emptyArray;
            };
            AutoImportProviderProject.prototype.getLanguageService = function () {
                throw new Error("AutoImportProviderProject language service should never be used. To get the program, use `project.getCurrentProgram()`.");
            };
            /*@internal*/
            AutoImportProviderProject.prototype.onAutoImportProviderSettingsChanged = function () {
                throw new Error("AutoImportProviderProject is an auto import provider; use `markAsDirty()` instead.");
            };
            /*@internal*/
            AutoImportProviderProject.prototype.onPackageJsonChange = function () {
                throw new Error("package.json changes should be notified on an AutoImportProvider's host project");
            };
            AutoImportProviderProject.prototype.getModuleResolutionHostForAutoImportProvider = function () {
                throw new Error("AutoImportProviderProject cannot provide its own host; use `hostProject.getModuleResolutionHostForAutomImportProvider()` instead.");
            };
            AutoImportProviderProject.prototype.getProjectReferences = function () {
                return this.hostProject.getProjectReferences();
            };
            /*@internal*/
            AutoImportProviderProject.prototype.includePackageJsonAutoImports = function () {
                return 0 /* Off */;
            };
            AutoImportProviderProject.prototype.getTypeAcquisition = function () {
                return { enable: false };
            };
            /*@internal*/
            AutoImportProviderProject.prototype.getSymlinkCache = function () {
                return this.hostProject.getSymlinkCache();
            };
            /*@internal*/
            AutoImportProviderProject.maxDependencies = 10;
            /*@internal*/
            AutoImportProviderProject.compilerOptionsOverrides = {
                diagnostics: false,
                skipLibCheck: true,
                sourceMap: false,
                types: ts.emptyArray,
                lib: ts.emptyArray,
                noLib: true,
            };
            return AutoImportProviderProject;
        }(Project));
        server.AutoImportProviderProject = AutoImportProviderProject;
        /**
         * If a file is opened, the server will look for a tsconfig (or jsconfig)
         * and if successful create a ConfiguredProject for it.
         * Otherwise it will create an InferredProject.
         */
        var ConfiguredProject = /** @class */ (function (_super) {
            __extends(ConfiguredProject, _super);
            /*@internal*/
            function ConfiguredProject(configFileName, canonicalConfigFilePath, projectService, documentRegistry, cachedDirectoryStructureHost) {
                var _this = _super.call(this, configFileName, ProjectKind.Configured, projectService, documentRegistry, 
                /*hasExplicitListOfFiles*/ false, 
                /*lastFileExceededProgramSize*/ undefined, 
                /*compilerOptions*/ {}, 
                /*compileOnSaveEnabled*/ false, 
                /*watchOptions*/ undefined, cachedDirectoryStructureHost, ts.getDirectoryPath(configFileName)) || this;
                _this.canonicalConfigFilePath = canonicalConfigFilePath;
                /* @internal */
                _this.openFileWatchTriggered = new ts.Map();
                /*@internal*/
                _this.canConfigFileJsonReportNoInputFiles = false;
                /** Ref count to the project when opened from external project */
                _this.externalProjectRefCount = 0;
                /*@internal*/
                _this.isInitialLoadPending = ts.returnTrue;
                /*@internal*/
                _this.sendLoadingProjectFinish = false;
                return _this;
            }
            /* @internal */
            ConfiguredProject.prototype.setCompilerHost = function (host) {
                this.compilerHost = host;
            };
            /* @internal */
            ConfiguredProject.prototype.getCompilerHost = function () {
                return this.compilerHost;
            };
            /* @internal */
            ConfiguredProject.prototype.useSourceOfProjectReferenceRedirect = function () {
                return this.languageServiceEnabled;
            };
            /* @internal */
            ConfiguredProject.prototype.getParsedCommandLine = function (fileName) {
                var configFileName = server.asNormalizedPath(ts.normalizePath(fileName));
                var canonicalConfigFilePath = server.asNormalizedPath(this.projectService.toCanonicalFileName(configFileName));
                // Ensure the config file existience info is cached
                var configFileExistenceInfo = this.projectService.configFileExistenceInfoCache.get(canonicalConfigFilePath);
                if (!configFileExistenceInfo) {
                    this.projectService.configFileExistenceInfoCache.set(canonicalConfigFilePath, configFileExistenceInfo = { exists: this.projectService.host.fileExists(configFileName) });
                }
                // Ensure we have upto date parsed command line
                this.projectService.ensureParsedConfigUptoDate(configFileName, canonicalConfigFilePath, configFileExistenceInfo, this);
                // Watch wild cards if LS is enabled
                if (this.languageServiceEnabled && this.projectService.serverMode === ts.LanguageServiceMode.Semantic) {
                    this.projectService.watchWildcards(configFileName, configFileExistenceInfo, this);
                }
                return configFileExistenceInfo.exists ? configFileExistenceInfo.config.parsedCommandLine : undefined;
            };
            /* @internal */
            ConfiguredProject.prototype.onReleaseParsedCommandLine = function (fileName) {
                this.releaseParsedConfig(server.asNormalizedPath(this.projectService.toCanonicalFileName(server.asNormalizedPath(ts.normalizePath(fileName)))));
            };
            /* @internal */
            ConfiguredProject.prototype.releaseParsedConfig = function (canonicalConfigFilePath) {
                this.projectService.stopWatchingWildCards(canonicalConfigFilePath, this);
                this.projectService.releaseParsedConfig(canonicalConfigFilePath, this);
            };
            /**
             * If the project has reload from disk pending, it reloads (and then updates graph as part of that) instead of just updating the graph
             * @returns: true if set of files in the project stays the same and false - otherwise.
             */
            ConfiguredProject.prototype.updateGraph = function () {
                var isInitialLoad = this.isInitialLoadPending();
                this.isInitialLoadPending = ts.returnFalse;
                var reloadLevel = this.pendingReload;
                this.pendingReload = ts.ConfigFileProgramReloadLevel.None;
                var result;
                switch (reloadLevel) {
                    case ts.ConfigFileProgramReloadLevel.Partial:
                        this.openFileWatchTriggered.clear();
                        result = this.projectService.reloadFileNamesOfConfiguredProject(this);
                        break;
                    case ts.ConfigFileProgramReloadLevel.Full:
                        this.openFileWatchTriggered.clear();
                        var reason = ts.Debug.checkDefined(this.pendingReloadReason);
                        this.pendingReloadReason = undefined;
                        this.projectService.reloadConfiguredProject(this, reason, isInitialLoad, /*clearSemanticCache*/ false);
                        result = true;
                        break;
                    default:
                        result = _super.prototype.updateGraph.call(this);
                }
                this.compilerHost = undefined;
                this.projectService.sendProjectLoadingFinishEvent(this);
                this.projectService.sendProjectTelemetry(this);
                return result;
            };
            /*@internal*/
            ConfiguredProject.prototype.getCachedDirectoryStructureHost = function () {
                return this.directoryStructureHost;
            };
            ConfiguredProject.prototype.getConfigFilePath = function () {
                return server.asNormalizedPath(this.getProjectName());
            };
            ConfiguredProject.prototype.getProjectReferences = function () {
                return this.projectReferences;
            };
            ConfiguredProject.prototype.updateReferences = function (refs) {
                this.projectReferences = refs;
                this.potentialProjectReferences = undefined;
            };
            /*@internal*/
            ConfiguredProject.prototype.setPotentialProjectReference = function (canonicalConfigPath) {
                ts.Debug.assert(this.isInitialLoadPending());
                (this.potentialProjectReferences || (this.potentialProjectReferences = new ts.Set())).add(canonicalConfigPath);
            };
            /*@internal*/
            ConfiguredProject.prototype.getResolvedProjectReferenceToRedirect = function (fileName) {
                var program = this.getCurrentProgram();
                return program && program.getResolvedProjectReferenceToRedirect(fileName);
            };
            /*@internal*/
            ConfiguredProject.prototype.forEachResolvedProjectReference = function (cb) {
                var _a;
                return (_a = this.getCurrentProgram()) === null || _a === void 0 ? void 0 : _a.forEachResolvedProjectReference(cb);
            };
            /*@internal*/
            ConfiguredProject.prototype.enablePluginsWithOptions = function (options, pluginConfigOverrides) {
                var host = this.projectService.host;
                if (!host.require) {
                    this.projectService.logger.info("Plugins were requested but not running in environment that supports 'require'. Nothing will be loaded");
                    return;
                }
                // Search our peer node_modules, then any globally-specified probe paths
                // ../../.. to walk from X/node_modules/typescript/lib/tsserver.js to X/node_modules/
                var searchPaths = __spreadArray([ts.combinePaths(this.projectService.getExecutingFilePath(), "../../..")], this.projectService.pluginProbeLocations, true);
                if (this.projectService.allowLocalPluginLoads) {
                    var local = ts.getDirectoryPath(this.canonicalConfigFilePath);
                    this.projectService.logger.info("Local plugin loading enabled; adding " + local + " to search paths");
                    searchPaths.unshift(local);
                }
                // Enable tsconfig-specified plugins
                if (options.plugins) {
                    for (var _i = 0, _a = options.plugins; _i < _a.length; _i++) {
                        var pluginConfigEntry = _a[_i];
                        this.enablePlugin(pluginConfigEntry, searchPaths, pluginConfigOverrides);
                    }
                }
                this.enableGlobalPlugins(options, pluginConfigOverrides);
            };
            /**
             * Get the errors that dont have any file name associated
             */
            ConfiguredProject.prototype.getGlobalProjectErrors = function () {
                return ts.filter(this.projectErrors, function (diagnostic) { return !diagnostic.file; }) || server.emptyArray;
            };
            /**
             * Get all the project errors
             */
            ConfiguredProject.prototype.getAllProjectErrors = function () {
                return this.projectErrors || server.emptyArray;
            };
            ConfiguredProject.prototype.setProjectErrors = function (projectErrors) {
                this.projectErrors = projectErrors;
            };
            ConfiguredProject.prototype.close = function () {
                var _this = this;
                this.projectService.configFileExistenceInfoCache.forEach(function (_configFileExistenceInfo, canonicalConfigFilePath) {
                    return _this.releaseParsedConfig(canonicalConfigFilePath);
                });
                this.projectErrors = undefined;
                this.openFileWatchTriggered.clear();
                this.compilerHost = undefined;
                _super.prototype.close.call(this);
            };
            /* @internal */
            ConfiguredProject.prototype.addExternalProjectReference = function () {
                this.externalProjectRefCount++;
            };
            /* @internal */
            ConfiguredProject.prototype.deleteExternalProjectReference = function () {
                this.externalProjectRefCount--;
            };
            /* @internal */
            ConfiguredProject.prototype.isSolution = function () {
                return this.getRootFilesMap().size === 0 &&
                    !this.canConfigFileJsonReportNoInputFiles;
            };
            /* @internal */
            /** Find the configured project from the project references in project which contains the info directly */
            ConfiguredProject.prototype.getDefaultChildProjectFromProjectWithReferences = function (info) {
                return server.forEachResolvedProjectReferenceProject(this, info.path, function (child) { return server.projectContainsInfoDirectly(child, info) ?
                    child :
                    undefined; }, server.ProjectReferenceProjectLoadKind.Find);
            };
            /** Returns true if the project is needed by any of the open script info/external project */
            /* @internal */
            ConfiguredProject.prototype.hasOpenRef = function () {
                var _this = this;
                var _a;
                if (!!this.externalProjectRefCount) {
                    return true;
                }
                // Closed project doesnt have any reference
                if (this.isClosed()) {
                    return false;
                }
                var configFileExistenceInfo = this.projectService.configFileExistenceInfoCache.get(this.canonicalConfigFilePath);
                if (this.projectService.hasPendingProjectUpdate(this)) {
                    // If there is pending update for this project,
                    // we dont know if this project would be needed by any of the open files impacted by this config file
                    // In that case keep the project alive if there are open files impacted by this project
                    return !!((_a = configFileExistenceInfo.openFilesImpactedByConfigFile) === null || _a === void 0 ? void 0 : _a.size);
                }
                // If there is no pending update for this project,
                // We know exact set of open files that get impacted by this configured project as the files in the project
                // The project is referenced only if open files impacted by this project are present in this project
                return !!configFileExistenceInfo.openFilesImpactedByConfigFile && ts.forEachEntry(configFileExistenceInfo.openFilesImpactedByConfigFile, function (_value, infoPath) {
                    var info = _this.projectService.getScriptInfoForPath(infoPath);
                    return _this.containsScriptInfo(info) ||
                        !!server.forEachResolvedProjectReferenceProject(_this, info.path, function (child) { return child.containsScriptInfo(info); }, server.ProjectReferenceProjectLoadKind.Find);
                }) || false;
            };
            /*@internal*/
            ConfiguredProject.prototype.hasExternalProjectRef = function () {
                return !!this.externalProjectRefCount;
            };
            ConfiguredProject.prototype.getEffectiveTypeRoots = function () {
                return ts.getEffectiveTypeRoots(this.getCompilationSettings(), this.directoryStructureHost) || [];
            };
            /*@internal*/
            ConfiguredProject.prototype.updateErrorOnNoInputFiles = function (fileNames) {
                ts.updateErrorForNoInputFiles(fileNames, this.getConfigFilePath(), this.getCompilerOptions().configFile.configFileSpecs, this.projectErrors, this.canConfigFileJsonReportNoInputFiles);
            };
            return ConfiguredProject;
        }(Project));
        server.ConfiguredProject = ConfiguredProject;
        /**
         * Project whose configuration is handled externally, such as in a '.csproj'.
         * These are created only if a host explicitly calls `openExternalProject`.
         */
        var ExternalProject = /** @class */ (function (_super) {
            __extends(ExternalProject, _super);
            /*@internal*/
            function ExternalProject(externalProjectName, projectService, documentRegistry, compilerOptions, lastFileExceededProgramSize, compileOnSaveEnabled, projectFilePath, pluginConfigOverrides, watchOptions) {
                var _this = _super.call(this, externalProjectName, ProjectKind.External, projectService, documentRegistry, 
                /*hasExplicitListOfFiles*/ true, lastFileExceededProgramSize, compilerOptions, compileOnSaveEnabled, watchOptions, projectService.host, ts.getDirectoryPath(projectFilePath || ts.normalizeSlashes(externalProjectName))) || this;
                _this.externalProjectName = externalProjectName;
                _this.compileOnSaveEnabled = compileOnSaveEnabled;
                _this.excludedFiles = [];
                _this.enableGlobalPlugins(_this.getCompilerOptions(), pluginConfigOverrides);
                return _this;
            }
            ExternalProject.prototype.updateGraph = function () {
                var result = _super.prototype.updateGraph.call(this);
                this.projectService.sendProjectTelemetry(this);
                return result;
            };
            ExternalProject.prototype.getExcludedFiles = function () {
                return this.excludedFiles;
            };
            return ExternalProject;
        }(Project));
        server.ExternalProject = ExternalProject;
        /* @internal */
        function isInferredProject(project) {
            return project.projectKind === ProjectKind.Inferred;
        }
        server.isInferredProject = isInferredProject;
        /* @internal */
        function isConfiguredProject(project) {
            return project.projectKind === ProjectKind.Configured;
        }
        server.isConfiguredProject = isConfiguredProject;
        /* @internal */
        function isExternalProject(project) {
            return project.projectKind === ProjectKind.External;
        }
        server.isExternalProject = isExternalProject;
    })(server = ts.server || (ts.server = {}));
})(ts || (ts = {}));
var ts;
(function (ts) {
    var server;
    (function (server) {
        server.maxProgramSizeForNonTsFiles = 20 * 1024 * 1024;
        /*@internal*/
        server.maxFileSize = 4 * 1024 * 1024;
        server.ProjectsUpdatedInBackgroundEvent = "projectsUpdatedInBackground";
        server.ProjectLoadingStartEvent = "projectLoadingStart";
        server.ProjectLoadingFinishEvent = "projectLoadingFinish";
        server.LargeFileReferencedEvent = "largeFileReferenced";
        server.ConfigFileDiagEvent = "configFileDiag";
        server.ProjectLanguageServiceStateEvent = "projectLanguageServiceState";
        server.ProjectInfoTelemetryEvent = "projectInfo";
        server.OpenFileInfoTelemetryEvent = "openFileInfo";
        var ensureProjectForOpenFileSchedule = "*ensureProjectForOpenFiles*";
        function prepareConvertersForEnumLikeCompilerOptions(commandLineOptions) {
            var map = new ts.Map();
            for (var _i = 0, commandLineOptions_1 = commandLineOptions; _i < commandLineOptions_1.length; _i++) {
                var option = commandLineOptions_1[_i];
                if (typeof option.type === "object") {
                    var optionMap = option.type;
                    // verify that map contains only numbers
                    optionMap.forEach(function (value) {
                        ts.Debug.assert(typeof value === "number");
                    });
                    map.set(option.name, optionMap);
                }
            }
            return map;
        }
        var compilerOptionConverters = prepareConvertersForEnumLikeCompilerOptions(ts.optionDeclarations);
        var watchOptionsConverters = prepareConvertersForEnumLikeCompilerOptions(ts.optionsForWatch);
        var indentStyle = new ts.Map(ts.getEntries({
            none: ts.IndentStyle.None,
            block: ts.IndentStyle.Block,
            smart: ts.IndentStyle.Smart
        }));
        /**
         * How to understand this block:
         *  * The 'match' property is a regexp that matches a filename.
         *  * If 'match' is successful, then:
         *     * All files from 'exclude' are removed from the project. See below.
         *     * All 'types' are included in ATA
         *  * What the heck is 'exclude' ?
         *     * An array of an array of strings and numbers
         *     * Each array is:
         *       * An array of strings and numbers
         *       * The strings are literals
         *       * The numbers refer to capture group indices from the 'match' regexp
         *          * Remember that '1' is the first group
         *       * These are concatenated together to form a new regexp
         *       * Filenames matching these regexps are excluded from the project
         * This default value is tested in tsserverProjectSystem.ts; add tests there
         *   if you are changing this so that you can be sure your regexp works!
         */
        var defaultTypeSafeList = {
            "jquery": {
                // jquery files can have names like "jquery-1.10.2.min.js" (or "jquery.intellisense.js")
                match: /jquery(-[\d\.]+)?(\.intellisense)?(\.min)?\.js$/i,
                types: ["jquery"]
            },
            "WinJS": {
                // e.g. c:/temp/UWApp1/lib/winjs-4.0.1/js/base.js
                match: /^(.*\/winjs-[.\d]+)\/js\/base\.js$/i,
                exclude: [["^", 1, "/.*"]],
                types: ["winjs"] // And fetch the @types package for WinJS
            },
            "Kendo": {
                // e.g. /Kendo3/wwwroot/lib/kendo/kendo.all.min.js
                match: /^(.*\/kendo(-ui)?)\/kendo\.all(\.min)?\.js$/i,
                exclude: [["^", 1, "/.*"]],
                types: ["kendo-ui"]
            },
            "Office Nuget": {
                // e.g. /scripts/Office/1/excel-15.debug.js
                match: /^(.*\/office\/1)\/excel-\d+\.debug\.js$/i,
                exclude: [["^", 1, "/.*"]],
                types: ["office"] // @types package to fetch instead
            },
            "References": {
                match: /^(.*\/_references\.js)$/i,
                exclude: [["^", 1, "$"]]
            }
        };
        function convertFormatOptions(protocolOptions) {
            if (ts.isString(protocolOptions.indentStyle)) {
                protocolOptions.indentStyle = indentStyle.get(protocolOptions.indentStyle.toLowerCase());
                ts.Debug.assert(protocolOptions.indentStyle !== undefined);
            }
            return protocolOptions;
        }
        server.convertFormatOptions = convertFormatOptions;
        function convertCompilerOptions(protocolOptions) {
            compilerOptionConverters.forEach(function (mappedValues, id) {
                var propertyValue = protocolOptions[id];
                if (ts.isString(propertyValue)) {
                    protocolOptions[id] = mappedValues.get(propertyValue.toLowerCase());
                }
            });
            return protocolOptions;
        }
        server.convertCompilerOptions = convertCompilerOptions;
        function convertWatchOptions(protocolOptions, currentDirectory) {
            var watchOptions;
            var errors;
            ts.optionsForWatch.forEach(function (option) {
                var propertyValue = protocolOptions[option.name];
                if (propertyValue === undefined)
                    return;
                var mappedValues = watchOptionsConverters.get(option.name);
                (watchOptions || (watchOptions = {}))[option.name] = mappedValues ?
                    ts.isString(propertyValue) ? mappedValues.get(propertyValue.toLowerCase()) : propertyValue :
                    ts.convertJsonOption(option, propertyValue, currentDirectory || "", errors || (errors = []));
            });
            return watchOptions && { watchOptions: watchOptions, errors: errors };
        }
        server.convertWatchOptions = convertWatchOptions;
        function convertTypeAcquisition(protocolOptions) {
            var result;
            ts.typeAcquisitionDeclarations.forEach(function (option) {
                var propertyValue = protocolOptions[option.name];
                if (propertyValue === undefined)
                    return;
                (result || (result = {}))[option.name] = propertyValue;
            });
            return result;
        }
        server.convertTypeAcquisition = convertTypeAcquisition;
        function tryConvertScriptKindName(scriptKindName) {
            return ts.isString(scriptKindName) ? convertScriptKindName(scriptKindName) : scriptKindName;
        }
        server.tryConvertScriptKindName = tryConvertScriptKindName;
        function convertScriptKindName(scriptKindName) {
            switch (scriptKindName) {
                case "JS":
                    return 1 /* JS */;
                case "JSX":
                    return 2 /* JSX */;
                case "TS":
                    return 3 /* TS */;
                case "TSX":
                    return 4 /* TSX */;
                default:
                    return 0 /* Unknown */;
            }
        }
        server.convertScriptKindName = convertScriptKindName;
        /*@internal*/
        function convertUserPreferences(preferences) {
            var lazyConfiguredProjectsFromExternalProject = preferences.lazyConfiguredProjectsFromExternalProject, userPreferences = __rest(preferences, ["lazyConfiguredProjectsFromExternalProject"]);
            return userPreferences;
        }
        server.convertUserPreferences = convertUserPreferences;
        var fileNamePropertyReader = {
            getFileName: function (x) { return x; },
            getScriptKind: function (fileName, extraFileExtensions) {
                var result;
                if (extraFileExtensions) {
                    var fileExtension_1 = ts.getAnyExtensionFromPath(fileName);
                    if (fileExtension_1) {
                        ts.some(extraFileExtensions, function (info) {
                            if (info.extension === fileExtension_1) {
                                result = info.scriptKind;
                                return true;
                            }
                            return false;
                        });
                    }
                }
                return result; // TODO: GH#18217
            },
            hasMixedContent: function (fileName, extraFileExtensions) { return ts.some(extraFileExtensions, function (ext) { return ext.isMixedContent && ts.fileExtensionIs(fileName, ext.extension); }); },
        };
        var externalFilePropertyReader = {
            getFileName: function (x) { return x.fileName; },
            getScriptKind: function (x) { return tryConvertScriptKindName(x.scriptKind); },
            hasMixedContent: function (x) { return !!x.hasMixedContent; },
        };
        function findProjectByName(projectName, projects) {
            for (var _i = 0, projects_1 = projects; _i < projects_1.length; _i++) {
                var proj = projects_1[_i];
                if (proj.getProjectName() === projectName) {
                    return proj;
                }
            }
        }
        var noopConfigFileWatcher = { close: ts.noop };
        function isOpenScriptInfo(infoOrFileNameOrConfig) {
            return !!infoOrFileNameOrConfig.containingProjects;
        }
        function isAncestorConfigFileInfo(infoOrFileNameOrConfig) {
            return !!infoOrFileNameOrConfig.configFileInfo;
        }
        /*@internal*/
        /** Kind of operation to perform to get project reference project */
        var ProjectReferenceProjectLoadKind;
        (function (ProjectReferenceProjectLoadKind) {
            /** Find existing project for project reference */
            ProjectReferenceProjectLoadKind[ProjectReferenceProjectLoadKind["Find"] = 0] = "Find";
            /** Find existing project or create one for the project reference */
            ProjectReferenceProjectLoadKind[ProjectReferenceProjectLoadKind["FindCreate"] = 1] = "FindCreate";
            /** Find existing project or create and load it for the project reference */
            ProjectReferenceProjectLoadKind[ProjectReferenceProjectLoadKind["FindCreateLoad"] = 2] = "FindCreateLoad";
        })(ProjectReferenceProjectLoadKind = server.ProjectReferenceProjectLoadKind || (server.ProjectReferenceProjectLoadKind = {}));
        function forEachResolvedProjectReferenceProject(project, fileName, cb, projectReferenceProjectLoadKind, reason) {
            var _a;
            var resolvedRefs = (_a = project.getCurrentProgram()) === null || _a === void 0 ? void 0 : _a.getResolvedProjectReferences();
            if (!resolvedRefs)
                return undefined;
            var seenResolvedRefs;
            var possibleDefaultRef = fileName ? project.getResolvedProjectReferenceToRedirect(fileName) : undefined;
            if (possibleDefaultRef) {
                // Try to find the name of the file directly through resolved project references
                var configFileName = server.toNormalizedPath(possibleDefaultRef.sourceFile.fileName);
                var child = project.projectService.findConfiguredProjectByProjectName(configFileName);
                if (child) {
                    var result = cb(child);
                    if (result)
                        return result;
                }
                else if (projectReferenceProjectLoadKind !== ProjectReferenceProjectLoadKind.Find) {
                    seenResolvedRefs = new ts.Map();
                    // Try to see if this project can be loaded
                    var result = forEachResolvedProjectReferenceProjectWorker(resolvedRefs, project.getCompilerOptions(), function (ref, loadKind) { return possibleDefaultRef === ref ? callback(ref, loadKind) : undefined; }, projectReferenceProjectLoadKind, project.projectService, seenResolvedRefs);
                    if (result)
                        return result;
                    // Cleanup seenResolvedRefs
                    seenResolvedRefs.clear();
                }
            }
            return forEachResolvedProjectReferenceProjectWorker(resolvedRefs, project.getCompilerOptions(), function (ref, loadKind) { return possibleDefaultRef !== ref ? callback(ref, loadKind) : undefined; }, projectReferenceProjectLoadKind, project.projectService, seenResolvedRefs);
            function callback(ref, loadKind) {
                var configFileName = server.toNormalizedPath(ref.sourceFile.fileName);
                var child = project.projectService.findConfiguredProjectByProjectName(configFileName) || (loadKind === ProjectReferenceProjectLoadKind.Find ?
                    undefined :
                    loadKind === ProjectReferenceProjectLoadKind.FindCreate ?
                        project.projectService.createConfiguredProject(configFileName) :
                        loadKind === ProjectReferenceProjectLoadKind.FindCreateLoad ?
                            project.projectService.createAndLoadConfiguredProject(configFileName, reason) :
                            ts.Debug.assertNever(loadKind));
                return child && cb(child);
            }
        }
        server.forEachResolvedProjectReferenceProject = forEachResolvedProjectReferenceProject;
        function forEachResolvedProjectReferenceProjectWorker(resolvedProjectReferences, parentOptions, cb, projectReferenceProjectLoadKind, projectService, seenResolvedRefs) {
            var loadKind = parentOptions.disableReferencedProjectLoad ? ProjectReferenceProjectLoadKind.Find : projectReferenceProjectLoadKind;
            return ts.forEach(resolvedProjectReferences, function (ref) {
                if (!ref)
                    return undefined;
                var configFileName = server.toNormalizedPath(ref.sourceFile.fileName);
                var canonicalPath = projectService.toCanonicalFileName(configFileName);
                var seenValue = seenResolvedRefs === null || seenResolvedRefs === void 0 ? void 0 : seenResolvedRefs.get(canonicalPath);
                if (seenValue !== undefined && seenValue >= loadKind) {
                    return undefined;
                }
                var result = cb(ref, loadKind);
                if (result) {
                    return result;
                }
                (seenResolvedRefs || (seenResolvedRefs = new ts.Map())).set(canonicalPath, loadKind);
                return ref.references && forEachResolvedProjectReferenceProjectWorker(ref.references, ref.commandLine.options, cb, loadKind, projectService, seenResolvedRefs);
            });
        }
        function forEachPotentialProjectReference(project, cb) {
            return project.potentialProjectReferences &&
                ts.forEachKey(project.potentialProjectReferences, cb);
        }
        function forEachAnyProjectReferenceKind(project, cb, cbProjectRef, cbPotentialProjectRef) {
            return project.getCurrentProgram() ?
                project.forEachResolvedProjectReference(cb) :
                project.isInitialLoadPending() ?
                    forEachPotentialProjectReference(project, cbPotentialProjectRef) :
                    ts.forEach(project.getProjectReferences(), cbProjectRef);
        }
        function callbackRefProject(project, cb, refPath) {
            var refProject = refPath && project.projectService.configuredProjects.get(refPath);
            return refProject && cb(refProject);
        }
        function forEachReferencedProject(project, cb) {
            return forEachAnyProjectReferenceKind(project, function (resolvedRef) { return callbackRefProject(project, cb, resolvedRef.sourceFile.path); }, function (projectRef) { return callbackRefProject(project, cb, project.toPath(ts.resolveProjectReferencePath(projectRef))); }, function (potentialProjectRef) { return callbackRefProject(project, cb, potentialProjectRef); });
        }
        function getDetailWatchInfo(watchType, project) {
            return (ts.isString(project) ? "Config: " + project + " " : project ? "Project: " + project.getProjectName() + " " : "") + "WatchType: " + watchType;
        }
        function isScriptInfoWatchedFromNodeModules(info) {
            return !info.isScriptOpen() && info.mTime !== undefined;
        }
        /*@internal*/
        /** true if script info is part of project and is not in project because it is referenced from project reference source */
        function projectContainsInfoDirectly(project, info) {
            return project.containsScriptInfo(info) &&
                !project.isSourceOfProjectReferenceRedirect(info.path);
        }
        server.projectContainsInfoDirectly = projectContainsInfoDirectly;
        /*@internal*/
        function updateProjectIfDirty(project) {
            project.invalidateResolutionsOfFailedLookupLocations();
            return project.dirty && project.updateGraph();
        }
        server.updateProjectIfDirty = updateProjectIfDirty;
        function setProjectOptionsUsed(project) {
            if (server.isConfiguredProject(project)) {
                project.projectOptions = true;
            }
        }
        function createProjectNameFactoryWithCounter(nameFactory) {
            var nextId = 1;
            return function () { return nameFactory(nextId++); };
        }
        var ProjectService = /** @class */ (function () {
            function ProjectService(opts) {
                var _this = this;
                /**
                 * Container of all known scripts
                 */
                /*@internal*/
                this.filenameToScriptInfo = new ts.Map();
                this.nodeModulesWatchers = new ts.Map();
                /**
                 * Contains all the deleted script info's version information so that
                 * it does not reset when creating script info again
                 * (and could have potentially collided with version where contents mismatch)
                 */
                this.filenameToScriptInfoVersion = new ts.Map();
                // Set of all '.js' files ever opened.
                this.allJsFilesForOpenFileTelemetry = new ts.Map();
                /**
                 * maps external project file name to list of config files that were the part of this project
                 */
                this.externalProjectToConfiguredProjectMap = new ts.Map();
                /**
                 * external projects (configuration and list of root files is not controlled by tsserver)
                 */
                this.externalProjects = [];
                /**
                 * projects built from openFileRoots
                 */
                this.inferredProjects = [];
                /**
                 * projects specified by a tsconfig.json file
                 */
                this.configuredProjects = new ts.Map();
                /*@internal*/
                this.newInferredProjectName = createProjectNameFactoryWithCounter(server.makeInferredProjectName);
                /*@internal*/
                this.newAutoImportProviderProjectName = createProjectNameFactoryWithCounter(server.makeAutoImportProviderProjectName);
                /**
                 * Open files: with value being project root path, and key being Path of the file that is open
                 */
                this.openFiles = new ts.Map();
                /* @internal */
                this.configFileForOpenFiles = new ts.Map();
                /**
                 * Map of open files that are opened without complete path but have projectRoot as current directory
                 */
                this.openFilesWithNonRootedDiskPath = new ts.Map();
                this.compilerOptionsForInferredProjectsPerProjectRoot = new ts.Map();
                this.watchOptionsForInferredProjectsPerProjectRoot = new ts.Map();
                this.typeAcquisitionForInferredProjectsPerProjectRoot = new ts.Map();
                /**
                 * Project size for configured or external projects
                 */
                this.projectToSizeMap = new ts.Map();
                /**
                 * This is a map of config file paths existence that doesnt need query to disk
                 * - The entry can be present because there is inferred project that needs to watch addition of config file to directory
                 *   In this case the exists could be true/false based on config file is present or not
                 * - Or it is present if we have configured project open with config file at that location
                 *   In this case the exists property is always true
                 */
                /*@internal*/ this.configFileExistenceInfoCache = new ts.Map();
                this.safelist = defaultTypeSafeList;
                this.legacySafelist = new ts.Map();
                this.pendingProjectUpdates = new ts.Map();
                /* @internal */
                this.pendingEnsureProjectForOpenFiles = false;
                /** Tracks projects that we have already sent telemetry for. */
                this.seenProjects = new ts.Map();
                /*@internal*/
                this.sharedExtendedConfigFileWatchers = new ts.Map();
                /*@internal*/
                this.extendedConfigCache = new ts.Map();
                this.host = opts.host;
                this.logger = opts.logger;
                this.cancellationToken = opts.cancellationToken;
                this.useSingleInferredProject = opts.useSingleInferredProject;
                this.useInferredProjectPerProjectRoot = opts.useInferredProjectPerProjectRoot;
                this.typingsInstaller = opts.typingsInstaller || server.nullTypingsInstaller;
                this.throttleWaitMilliseconds = opts.throttleWaitMilliseconds;
                this.eventHandler = opts.eventHandler;
                this.suppressDiagnosticEvents = opts.suppressDiagnosticEvents;
                this.globalPlugins = opts.globalPlugins || server.emptyArray;
                this.pluginProbeLocations = opts.pluginProbeLocations || server.emptyArray;
                this.allowLocalPluginLoads = !!opts.allowLocalPluginLoads;
                this.typesMapLocation = (opts.typesMapLocation === undefined) ? ts.combinePaths(ts.getDirectoryPath(this.getExecutingFilePath()), "typesMap.json") : opts.typesMapLocation;
                this.session = opts.session;
                if (opts.serverMode !== undefined) {
                    this.serverMode = opts.serverMode;
                    this.syntaxOnly = this.serverMode === ts.LanguageServiceMode.Syntactic;
                }
                else if (opts.syntaxOnly) {
                    this.serverMode = ts.LanguageServiceMode.Syntactic;
                    this.syntaxOnly = true;
                }
                else {
                    this.serverMode = ts.LanguageServiceMode.Semantic;
                    this.syntaxOnly = false;
                }
                if (this.host.realpath) {
                    this.realpathToScriptInfos = ts.createMultiMap();
                }
                this.currentDirectory = server.toNormalizedPath(this.host.getCurrentDirectory());
                this.toCanonicalFileName = ts.createGetCanonicalFileName(this.host.useCaseSensitiveFileNames);
                this.globalCacheLocationDirectoryPath = this.typingsInstaller.globalTypingsCacheLocation
                    ? ts.ensureTrailingDirectorySeparator(this.toPath(this.typingsInstaller.globalTypingsCacheLocation))
                    : undefined;
                this.throttledOperations = new server.ThrottledOperations(this.host, this.logger);
                if (this.typesMapLocation) {
                    this.loadTypesMap();
                }
                else {
                    this.logger.info("No types map provided; using the default");
                }
                this.typingsInstaller.attach(this);
                this.typingsCache = new server.TypingsCache(this.typingsInstaller);
                this.hostConfiguration = {
                    formatCodeOptions: ts.getDefaultFormatCodeSettings(this.host.newLine),
                    preferences: ts.emptyOptions,
                    hostInfo: "Unknown host",
                    extraFileExtensions: [],
                };
                this.documentRegistry = ts.createDocumentRegistryInternal(this.host.useCaseSensitiveFileNames, this.currentDirectory, this);
                var watchLogLevel = this.logger.hasLevel(server.LogLevel.verbose) ? ts.WatchLogLevel.Verbose :
                    this.logger.loggingEnabled() ? ts.WatchLogLevel.TriggerOnly : ts.WatchLogLevel.None;
                var log = watchLogLevel !== ts.WatchLogLevel.None ? (function (s) { return _this.logger.info(s); }) : ts.noop;
                this.packageJsonCache = server.createPackageJsonCache(this);
                this.watchFactory = this.serverMode !== ts.LanguageServiceMode.Semantic ?
                    {
                        watchFile: ts.returnNoopFileWatcher,
                        watchDirectory: ts.returnNoopFileWatcher,
                    } :
                    ts.getWatchFactory(this.host, watchLogLevel, log, getDetailWatchInfo);
            }
            ProjectService.prototype.toPath = function (fileName) {
                return ts.toPath(fileName, this.currentDirectory, this.toCanonicalFileName);
            };
            /*@internal*/
            ProjectService.prototype.getExecutingFilePath = function () {
                return this.getNormalizedAbsolutePath(this.host.getExecutingFilePath());
            };
            /*@internal*/
            ProjectService.prototype.getNormalizedAbsolutePath = function (fileName) {
                return ts.getNormalizedAbsolutePath(fileName, this.host.getCurrentDirectory());
            };
            /*@internal*/
            ProjectService.prototype.setDocument = function (key, path, sourceFile) {
                var info = ts.Debug.checkDefined(this.getScriptInfoForPath(path));
                info.cacheSourceFile = { key: key, sourceFile: sourceFile };
            };
            /*@internal*/
            ProjectService.prototype.getDocument = function (key, path) {
                var info = this.getScriptInfoForPath(path);
                return info && info.cacheSourceFile && info.cacheSourceFile.key === key ? info.cacheSourceFile.sourceFile : undefined;
            };
            /* @internal */
            ProjectService.prototype.ensureInferredProjectsUpToDate_TestOnly = function () {
                this.ensureProjectStructuresUptoDate();
            };
            /* @internal */
            ProjectService.prototype.getCompilerOptionsForInferredProjects = function () {
                return this.compilerOptionsForInferredProjects;
            };
            /* @internal */
            ProjectService.prototype.onUpdateLanguageServiceStateForProject = function (project, languageServiceEnabled) {
                if (!this.eventHandler) {
                    return;
                }
                var event = {
                    eventName: server.ProjectLanguageServiceStateEvent,
                    data: { project: project, languageServiceEnabled: languageServiceEnabled }
                };
                this.eventHandler(event);
            };
            ProjectService.prototype.loadTypesMap = function () {
                try {
                    var fileContent = this.host.readFile(this.typesMapLocation); // TODO: GH#18217
                    if (fileContent === undefined) {
                        this.logger.info("Provided types map file \"" + this.typesMapLocation + "\" doesn't exist");
                        return;
                    }
                    var raw = JSON.parse(fileContent);
                    // Parse the regexps
                    for (var _i = 0, _a = Object.keys(raw.typesMap); _i < _a.length; _i++) {
                        var k = _a[_i];
                        raw.typesMap[k].match = new RegExp(raw.typesMap[k].match, "i");
                    }
                    // raw is now fixed and ready
                    this.safelist = raw.typesMap;
                    for (var key in raw.simpleMap) {
                        if (raw.simpleMap.hasOwnProperty(key)) {
                            this.legacySafelist.set(key, raw.simpleMap[key].toLowerCase());
                        }
                    }
                }
                catch (e) {
                    this.logger.info("Error loading types map: " + e);
                    this.safelist = defaultTypeSafeList;
                    this.legacySafelist.clear();
                }
            };
            ProjectService.prototype.updateTypingsForProject = function (response) {
                var project = this.findProject(response.projectName);
                if (!project) {
                    return;
                }
                switch (response.kind) {
                    case server.ActionSet:
                        // Update the typing files and update the project
                        project.updateTypingFiles(this.typingsCache.updateTypingsForProject(response.projectName, response.compilerOptions, response.typeAcquisition, response.unresolvedImports, response.typings));
                        return;
                    case server.ActionInvalidate:
                        // Do not clear resolution cache, there was changes detected in typings, so enque typing request and let it get us correct results
                        this.typingsCache.enqueueInstallTypingsForProject(project, project.lastCachedUnresolvedImportsList, /*forceRefresh*/ true);
                        return;
                }
            };
            /*@internal*/
            ProjectService.prototype.delayEnsureProjectForOpenFiles = function () {
                var _this = this;
                if (!this.openFiles.size)
                    return;
                this.pendingEnsureProjectForOpenFiles = true;
                this.throttledOperations.schedule(ensureProjectForOpenFileSchedule, /*delay*/ 2500, function () {
                    if (_this.pendingProjectUpdates.size !== 0) {
                        _this.delayEnsureProjectForOpenFiles();
                    }
                    else {
                        if (_this.pendingEnsureProjectForOpenFiles) {
                            _this.ensureProjectForOpenFiles();
                            // Send the event to notify that there were background project updates
                            // send current list of open files
                            _this.sendProjectsUpdatedInBackgroundEvent();
                        }
                    }
                });
            };
            ProjectService.prototype.delayUpdateProjectGraph = function (project) {
                var _this = this;
                project.markAsDirty();
                var projectName = project.getProjectName();
                this.pendingProjectUpdates.set(projectName, project);
                this.throttledOperations.schedule(projectName, /*delay*/ 250, function () {
                    if (_this.pendingProjectUpdates.delete(projectName)) {
                        updateProjectIfDirty(project);
                    }
                });
            };
            /*@internal*/
            ProjectService.prototype.hasPendingProjectUpdate = function (project) {
                return this.pendingProjectUpdates.has(project.getProjectName());
            };
            /* @internal */
            ProjectService.prototype.sendProjectsUpdatedInBackgroundEvent = function () {
                var _this = this;
                if (!this.eventHandler) {
                    return;
                }
                var event = {
                    eventName: server.ProjectsUpdatedInBackgroundEvent,
                    data: {
                        openFiles: ts.arrayFrom(this.openFiles.keys(), function (path) { return _this.getScriptInfoForPath(path).fileName; })
                    }
                };
                this.eventHandler(event);
            };
            /* @internal */
            ProjectService.prototype.sendLargeFileReferencedEvent = function (file, fileSize) {
                if (!this.eventHandler) {
                    return;
                }
                var event = {
                    eventName: server.LargeFileReferencedEvent,
                    data: { file: file, fileSize: fileSize, maxFileSize: server.maxFileSize }
                };
                this.eventHandler(event);
            };
            /* @internal */
            ProjectService.prototype.sendProjectLoadingStartEvent = function (project, reason) {
                if (!this.eventHandler) {
                    return;
                }
                project.sendLoadingProjectFinish = true;
                var event = {
                    eventName: server.ProjectLoadingStartEvent,
                    data: { project: project, reason: reason }
                };
                this.eventHandler(event);
            };
            /* @internal */
            ProjectService.prototype.sendProjectLoadingFinishEvent = function (project) {
                if (!this.eventHandler || !project.sendLoadingProjectFinish) {
                    return;
                }
                project.sendLoadingProjectFinish = false;
                var event = {
                    eventName: server.ProjectLoadingFinishEvent,
                    data: { project: project }
                };
                this.eventHandler(event);
            };
            /* @internal */
            ProjectService.prototype.sendPerformanceEvent = function (kind, durationMs) {
                if (this.performanceEventHandler) {
                    this.performanceEventHandler({ kind: kind, durationMs: durationMs });
                }
            };
            /* @internal */
            ProjectService.prototype.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles = function (project) {
                this.delayUpdateProjectGraph(project);
                this.delayEnsureProjectForOpenFiles();
            };
            ProjectService.prototype.delayUpdateProjectGraphs = function (projects, clearSourceMapperCache) {
                if (projects.length) {
                    for (var _i = 0, projects_2 = projects; _i < projects_2.length; _i++) {
                        var project = projects_2[_i];
                        // Even if program doesnt change, clear the source mapper cache
                        if (clearSourceMapperCache)
                            project.clearSourceMapperCache();
                        this.delayUpdateProjectGraph(project);
                    }
                    this.delayEnsureProjectForOpenFiles();
                }
            };
            ProjectService.prototype.setCompilerOptionsForInferredProjects = function (projectCompilerOptions, projectRootPath) {
                ts.Debug.assert(projectRootPath === undefined || this.useInferredProjectPerProjectRoot, "Setting compiler options per project root path is only supported when useInferredProjectPerProjectRoot is enabled");
                var compilerOptions = convertCompilerOptions(projectCompilerOptions);
                var watchOptions = convertWatchOptions(projectCompilerOptions, projectRootPath);
                var typeAcquisition = convertTypeAcquisition(projectCompilerOptions);
                // always set 'allowNonTsExtensions' for inferred projects since user cannot configure it from the outside
                // previously we did not expose a way for user to change these settings and this option was enabled by default
                compilerOptions.allowNonTsExtensions = true;
                var canonicalProjectRootPath = projectRootPath && this.toCanonicalFileName(projectRootPath);
                if (canonicalProjectRootPath) {
                    this.compilerOptionsForInferredProjectsPerProjectRoot.set(canonicalProjectRootPath, compilerOptions);
                    this.watchOptionsForInferredProjectsPerProjectRoot.set(canonicalProjectRootPath, watchOptions || false);
                    this.typeAcquisitionForInferredProjectsPerProjectRoot.set(canonicalProjectRootPath, typeAcquisition);
                }
                else {
                    this.compilerOptionsForInferredProjects = compilerOptions;
                    this.watchOptionsForInferredProjects = watchOptions;
                    this.typeAcquisitionForInferredProjects = typeAcquisition;
                }
                for (var _i = 0, _a = this.inferredProjects; _i < _a.length; _i++) {
                    var project = _a[_i];
                    // Only update compiler options in the following cases:
                    // - Inferred projects without a projectRootPath, if the new options do not apply to
                    //   a workspace root
                    // - Inferred projects with a projectRootPath, if the new options do not apply to a
                    //   workspace root and there is no more specific set of options for that project's
                    //   root path
                    // - Inferred projects with a projectRootPath, if the new options apply to that
                    //   project root path.
                    if (canonicalProjectRootPath ?
                        project.projectRootPath === canonicalProjectRootPath :
                        !project.projectRootPath || !this.compilerOptionsForInferredProjectsPerProjectRoot.has(project.projectRootPath)) {
                        project.setCompilerOptions(compilerOptions);
                        project.setTypeAcquisition(typeAcquisition);
                        project.setWatchOptions(watchOptions === null || watchOptions === void 0 ? void 0 : watchOptions.watchOptions);
                        project.setProjectErrors(watchOptions === null || watchOptions === void 0 ? void 0 : watchOptions.errors);
                        project.compileOnSaveEnabled = compilerOptions.compileOnSave;
                        project.markAsDirty();
                        this.delayUpdateProjectGraph(project);
                    }
                }
                this.delayEnsureProjectForOpenFiles();
            };
            ProjectService.prototype.findProject = function (projectName) {
                if (projectName === undefined) {
                    return undefined;
                }
                if (server.isInferredProjectName(projectName)) {
                    return findProjectByName(projectName, this.inferredProjects);
                }
                return this.findExternalProjectByProjectName(projectName) || this.findConfiguredProjectByProjectName(server.toNormalizedPath(projectName));
            };
            /* @internal */
            ProjectService.prototype.forEachProject = function (cb) {
                this.externalProjects.forEach(cb);
                this.configuredProjects.forEach(cb);
                this.inferredProjects.forEach(cb);
            };
            /* @internal */
            ProjectService.prototype.forEachEnabledProject = function (cb) {
                this.forEachProject(function (project) {
                    if (!project.isOrphan() && project.languageServiceEnabled) {
                        cb(project);
                    }
                });
            };
            ProjectService.prototype.getDefaultProjectForFile = function (fileName, ensureProject) {
                return ensureProject ? this.ensureDefaultProjectForFile(fileName) : this.tryGetDefaultProjectForFile(fileName);
            };
            /* @internal */
            ProjectService.prototype.tryGetDefaultProjectForFile = function (fileName) {
                var scriptInfo = this.getScriptInfoForNormalizedPath(fileName);
                return scriptInfo && !scriptInfo.isOrphan() ? scriptInfo.getDefaultProject() : undefined;
            };
            /* @internal */
            ProjectService.prototype.ensureDefaultProjectForFile = function (fileName) {
                return this.tryGetDefaultProjectForFile(fileName) || this.doEnsureDefaultProjectForFile(fileName);
            };
            ProjectService.prototype.doEnsureDefaultProjectForFile = function (fileName) {
                this.ensureProjectStructuresUptoDate();
                var scriptInfo = this.getScriptInfoForNormalizedPath(fileName);
                return scriptInfo ? scriptInfo.getDefaultProject() : (this.logErrorForScriptInfoNotFound(fileName), server.Errors.ThrowNoProject());
            };
            ProjectService.prototype.getScriptInfoEnsuringProjectsUptoDate = function (uncheckedFileName) {
                this.ensureProjectStructuresUptoDate();
                return this.getScriptInfo(uncheckedFileName);
            };
            /**
             * Ensures the project structures are upto date
             * This means,
             * - we go through all the projects and update them if they are dirty
             * - if updates reflect some change in structure or there was pending request to ensure projects for open files
             *   ensure that each open script info has project
             */
            ProjectService.prototype.ensureProjectStructuresUptoDate = function () {
                var hasChanges = this.pendingEnsureProjectForOpenFiles;
                this.pendingProjectUpdates.clear();
                var updateGraph = function (project) {
                    hasChanges = updateProjectIfDirty(project) || hasChanges;
                };
                this.externalProjects.forEach(updateGraph);
                this.configuredProjects.forEach(updateGraph);
                this.inferredProjects.forEach(updateGraph);
                if (hasChanges) {
                    this.ensureProjectForOpenFiles();
                }
            };
            ProjectService.prototype.getFormatCodeOptions = function (file) {
                var info = this.getScriptInfoForNormalizedPath(file);
                return info && info.getFormatCodeSettings() || this.hostConfiguration.formatCodeOptions;
            };
            ProjectService.prototype.getPreferences = function (file) {
                var info = this.getScriptInfoForNormalizedPath(file);
                return __assign(__assign({}, this.hostConfiguration.preferences), info && info.getPreferences());
            };
            ProjectService.prototype.getHostFormatCodeOptions = function () {
                return this.hostConfiguration.formatCodeOptions;
            };
            ProjectService.prototype.getHostPreferences = function () {
                return this.hostConfiguration.preferences;
            };
            ProjectService.prototype.onSourceFileChanged = function (info, eventKind) {
                if (eventKind === ts.FileWatcherEventKind.Deleted) {
                    // File was deleted
                    this.handleDeletedFile(info);
                }
                else if (!info.isScriptOpen()) {
                    // file has been changed which might affect the set of referenced files in projects that include
                    // this file and set of inferred projects
                    info.delayReloadNonMixedContentFile();
                    this.delayUpdateProjectGraphs(info.containingProjects, /*clearSourceMapperCache*/ false);
                    this.handleSourceMapProjects(info);
                }
            };
            ProjectService.prototype.handleSourceMapProjects = function (info) {
                // Change in d.ts, update source projects as well
                if (info.sourceMapFilePath) {
                    if (ts.isString(info.sourceMapFilePath)) {
                        var sourceMapFileInfo = this.getScriptInfoForPath(info.sourceMapFilePath);
                        this.delayUpdateSourceInfoProjects(sourceMapFileInfo && sourceMapFileInfo.sourceInfos);
                    }
                    else {
                        this.delayUpdateSourceInfoProjects(info.sourceMapFilePath.sourceInfos);
                    }
                }
                // Change in mapInfo, update declarationProjects and source projects
                this.delayUpdateSourceInfoProjects(info.sourceInfos);
                if (info.declarationInfoPath) {
                    this.delayUpdateProjectsOfScriptInfoPath(info.declarationInfoPath);
                }
            };
            ProjectService.prototype.delayUpdateSourceInfoProjects = function (sourceInfos) {
                var _this = this;
                if (sourceInfos) {
                    sourceInfos.forEach(function (_value, path) { return _this.delayUpdateProjectsOfScriptInfoPath(path); });
                }
            };
            ProjectService.prototype.delayUpdateProjectsOfScriptInfoPath = function (path) {
                var info = this.getScriptInfoForPath(path);
                if (info) {
                    this.delayUpdateProjectGraphs(info.containingProjects, /*clearSourceMapperCache*/ true);
                }
            };
            ProjectService.prototype.handleDeletedFile = function (info) {
                this.stopWatchingScriptInfo(info);
                if (!info.isScriptOpen()) {
                    this.deleteScriptInfo(info);
                    // capture list of projects since detachAllProjects will wipe out original list
                    var containingProjects = info.containingProjects.slice();
                    info.detachAllProjects();
                    // update projects to make sure that set of referenced files is correct
                    this.delayUpdateProjectGraphs(containingProjects, /*clearSourceMapperCache*/ false);
                    this.handleSourceMapProjects(info);
                    info.closeSourceMapFileWatcher();
                    // need to recalculate source map from declaration file
                    if (info.declarationInfoPath) {
                        var declarationInfo = this.getScriptInfoForPath(info.declarationInfoPath);
                        if (declarationInfo) {
                            declarationInfo.sourceMapFilePath = undefined;
                        }
                    }
                }
            };
            /**
             * This is to watch whenever files are added or removed to the wildcard directories
             */
            /*@internal*/
            ProjectService.prototype.watchWildcardDirectory = function (directory, flags, configFileName, config) {
                var _this = this;
                return this.watchFactory.watchDirectory(directory, function (fileOrDirectory) {
                    var fileOrDirectoryPath = _this.toPath(fileOrDirectory);
                    var fsResult = config.cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                    if (ts.getBaseFileName(fileOrDirectoryPath) === "package.json" && !ts.isInsideNodeModules(fileOrDirectoryPath) &&
                        (fsResult && fsResult.fileExists || !fsResult && _this.host.fileExists(fileOrDirectoryPath))) {
                        _this.logger.info("Config: " + configFileName + " Detected new package.json: " + fileOrDirectory);
                        _this.onAddPackageJson(fileOrDirectoryPath);
                    }
                    var configuredProjectForConfig = _this.findConfiguredProjectByProjectName(configFileName);
                    if (ts.isIgnoredFileFromWildCardWatching({
                        watchedDirPath: directory,
                        fileOrDirectory: fileOrDirectory,
                        fileOrDirectoryPath: fileOrDirectoryPath,
                        configFileName: configFileName,
                        extraFileExtensions: _this.hostConfiguration.extraFileExtensions,
                        currentDirectory: _this.currentDirectory,
                        options: config.parsedCommandLine.options,
                        program: (configuredProjectForConfig === null || configuredProjectForConfig === void 0 ? void 0 : configuredProjectForConfig.getCurrentProgram()) || config.parsedCommandLine.fileNames,
                        useCaseSensitiveFileNames: _this.host.useCaseSensitiveFileNames,
                        writeLog: function (s) { return _this.logger.info(s); },
                        toPath: function (s) { return _this.toPath(s); }
                    }))
                        return;
                    // Reload is pending, do the reload
                    if (config.reloadLevel !== ts.ConfigFileProgramReloadLevel.Full)
                        config.reloadLevel = ts.ConfigFileProgramReloadLevel.Partial;
                    config.projects.forEach(function (watchWildcardDirectories, projectCanonicalPath) {
                        if (!watchWildcardDirectories)
                            return;
                        var project = _this.getConfiguredProjectByCanonicalConfigFilePath(projectCanonicalPath);
                        if (!project)
                            return;
                        // Load root file names for configured project with the config file name
                        // But only schedule update if project references this config file
                        var reloadLevel = configuredProjectForConfig === project ? ts.ConfigFileProgramReloadLevel.Partial : ts.ConfigFileProgramReloadLevel.None;
                        if (project.pendingReload !== undefined && project.pendingReload > reloadLevel)
                            return;
                        // don't trigger callback on open, existing files
                        if (_this.openFiles.has(fileOrDirectoryPath)) {
                            var info = ts.Debug.checkDefined(_this.getScriptInfoForPath(fileOrDirectoryPath));
                            if (info.isAttached(project)) {
                                var loadLevelToSet = Math.max(reloadLevel, project.openFileWatchTriggered.get(fileOrDirectoryPath) || ts.ConfigFileProgramReloadLevel.None);
                                project.openFileWatchTriggered.set(fileOrDirectoryPath, loadLevelToSet);
                            }
                            else {
                                project.pendingReload = reloadLevel;
                                _this.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(project);
                            }
                        }
                        else {
                            project.pendingReload = reloadLevel;
                            _this.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(project);
                        }
                    });
                }, flags, this.getWatchOptionsFromProjectWatchOptions(config.parsedCommandLine.watchOptions), ts.WatchType.WildcardDirectory, configFileName);
            };
            /*@internal*/
            ProjectService.prototype.delayUpdateProjectsFromParsedConfigOnConfigFileChange = function (canonicalConfigFilePath, reloadReason) {
                var _this = this;
                var configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath);
                if (!(configFileExistenceInfo === null || configFileExistenceInfo === void 0 ? void 0 : configFileExistenceInfo.config))
                    return false;
                var scheduledAnyProjectUpdate = false;
                // Update projects watching cached config
                configFileExistenceInfo.config.reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
                configFileExistenceInfo.config.projects.forEach(function (_watchWildcardDirectories, projectCanonicalPath) {
                    var project = _this.getConfiguredProjectByCanonicalConfigFilePath(projectCanonicalPath);
                    if (!project)
                        return;
                    scheduledAnyProjectUpdate = true;
                    if (projectCanonicalPath === canonicalConfigFilePath) {
                        // Skip refresh if project is not yet loaded
                        if (project.isInitialLoadPending())
                            return;
                        project.pendingReload = ts.ConfigFileProgramReloadLevel.Full;
                        project.pendingReloadReason = reloadReason;
                        _this.delayUpdateProjectGraph(project);
                    }
                    else {
                        // Change in referenced project config file
                        project.resolutionCache.removeResolutionsFromProjectReferenceRedirects(_this.toPath(canonicalConfigFilePath));
                        _this.delayUpdateProjectGraph(project);
                    }
                });
                return scheduledAnyProjectUpdate;
            };
            /*@internal*/
            ProjectService.prototype.onConfigFileChanged = function (canonicalConfigFilePath, eventKind) {
                var _a;
                var configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath);
                if (eventKind === ts.FileWatcherEventKind.Deleted) {
                    // Update the cached status
                    // We arent updating or removing the cached config file presence info as that will be taken care of by
                    // releaseParsedConfig when the project is closed or doesnt need this config any more (depending on tracking open files)
                    configFileExistenceInfo.exists = false;
                    // Remove the configured project for this config file
                    var project = ((_a = configFileExistenceInfo.config) === null || _a === void 0 ? void 0 : _a.projects.has(canonicalConfigFilePath)) ?
                        this.getConfiguredProjectByCanonicalConfigFilePath(canonicalConfigFilePath) :
                        undefined;
                    if (project)
                        this.removeProject(project);
                }
                else {
                    // Update the cached status
                    configFileExistenceInfo.exists = true;
                }
                // Update projects watching config
                this.delayUpdateProjectsFromParsedConfigOnConfigFileChange(canonicalConfigFilePath, "Change in config file detected");
                // Reload the configured projects for the open files in the map as they are affected by this config file
                // If the configured project was deleted, we want to reload projects for all the open files including files
                // that are not root of the inferred project
                // Otherwise, we scheduled the update on configured project graph,
                // we would need to schedule the project reload for only the root of inferred projects
                // Get open files to reload projects for
                this.reloadConfiguredProjectForFiles(configFileExistenceInfo.openFilesImpactedByConfigFile, 
                /*clearSemanticCache*/ false, 
                /*delayReload*/ true, eventKind !== ts.FileWatcherEventKind.Deleted ?
                    ts.identity : // Reload open files if they are root of inferred project
                    ts.returnTrue, // Reload all the open files impacted by config file
                "Change in config file detected");
                this.delayEnsureProjectForOpenFiles();
            };
            ProjectService.prototype.removeProject = function (project) {
                var _this = this;
                this.logger.info("`remove Project::");
                project.print(/*writeProjectFileNames*/ true);
                project.close();
                if (ts.Debug.shouldAssert(1 /* Normal */)) {
                    this.filenameToScriptInfo.forEach(function (info) { return ts.Debug.assert(!info.isAttached(project), "Found script Info still attached to project", function () { return project.projectName + ": ScriptInfos still attached: " + JSON.stringify(ts.arrayFrom(ts.mapDefinedIterator(_this.filenameToScriptInfo.values(), function (info) { return info.isAttached(project) ?
                        {
                            fileName: info.fileName,
                            projects: info.containingProjects.map(function (p) { return p.projectName; }),
                            hasMixedContent: info.hasMixedContent
                        } : undefined; })), 
                    /*replacer*/ undefined, " "); }); });
                }
                // Remove the project from pending project updates
                this.pendingProjectUpdates.delete(project.getProjectName());
                switch (project.projectKind) {
                    case server.ProjectKind.External:
                        ts.unorderedRemoveItem(this.externalProjects, project);
                        this.projectToSizeMap.delete(project.getProjectName());
                        break;
                    case server.ProjectKind.Configured:
                        this.configuredProjects.delete(project.canonicalConfigFilePath);
                        this.projectToSizeMap.delete(project.canonicalConfigFilePath);
                        break;
                    case server.ProjectKind.Inferred:
                        ts.unorderedRemoveItem(this.inferredProjects, project);
                        break;
                }
            };
            /*@internal*/
            ProjectService.prototype.assignOrphanScriptInfoToInferredProject = function (info, projectRootPath) {
                ts.Debug.assert(info.isOrphan());
                var project = this.getOrCreateInferredProjectForProjectRootPathIfEnabled(info, projectRootPath) ||
                    this.getOrCreateSingleInferredProjectIfEnabled() ||
                    this.getOrCreateSingleInferredWithoutProjectRoot(info.isDynamic ?
                        projectRootPath || this.currentDirectory :
                        ts.getDirectoryPath(ts.isRootedDiskPath(info.fileName) ?
                            info.fileName :
                            ts.getNormalizedAbsolutePath(info.fileName, projectRootPath ?
                                this.getNormalizedAbsolutePath(projectRootPath) :
                                this.currentDirectory)));
                project.addRoot(info);
                if (info.containingProjects[0] !== project) {
                    // Ensure this is first project, we could be in this scenario because info could be part of orphan project
                    info.detachFromProject(project);
                    info.containingProjects.unshift(project);
                }
                project.updateGraph();
                if (!this.useSingleInferredProject && !project.projectRootPath) {
                    var _loop_2 = function (inferredProject) {
                        if (inferredProject === project || inferredProject.isOrphan()) {
                            return "continue";
                        }
                        // Remove the inferred project if the root of it is now part of newly created inferred project
                        // e.g through references
                        // Which means if any root of inferred project is part of more than 1 project can be removed
                        // This logic is same as iterating over all open files and calling
                        // this.removeRootOfInferredProjectIfNowPartOfOtherProject(f);
                        // Since this is also called from refreshInferredProject and closeOpen file
                        // to update inferred projects of the open file, this iteration might be faster
                        // instead of scanning all open files
                        var roots = inferredProject.getRootScriptInfos();
                        ts.Debug.assert(roots.length === 1 || !!inferredProject.projectRootPath);
                        if (roots.length === 1 && ts.forEach(roots[0].containingProjects, function (p) { return p !== roots[0].containingProjects[0] && !p.isOrphan(); })) {
                            inferredProject.removeFile(roots[0], /*fileExists*/ true, /*detachFromProject*/ true);
                        }
                    };
                    // Note that we need to create a copy of the array since the list of project can change
                    for (var _i = 0, _a = this.inferredProjects; _i < _a.length; _i++) {
                        var inferredProject = _a[_i];
                        _loop_2(inferredProject);
                    }
                }
                return project;
            };
            ProjectService.prototype.assignOrphanScriptInfosToInferredProject = function () {
                var _this = this;
                // collect orphaned files and assign them to inferred project just like we treat open of a file
                this.openFiles.forEach(function (projectRootPath, path) {
                    var info = _this.getScriptInfoForPath(path);
                    // collect all orphaned script infos from open files
                    if (info.isOrphan()) {
                        _this.assignOrphanScriptInfoToInferredProject(info, projectRootPath);
                    }
                });
            };
            /**
             * Remove this file from the set of open, non-configured files.
             * @param info The file that has been closed or newly configured
             */
            ProjectService.prototype.closeOpenFile = function (info, skipAssignOrphanScriptInfosToInferredProject) {
                // Closing file should trigger re-reading the file content from disk. This is
                // because the user may chose to discard the buffer content before saving
                // to the disk, and the server's version of the file can be out of sync.
                var fileExists = info.isDynamic ? false : this.host.fileExists(info.fileName);
                info.close(fileExists);
                this.stopWatchingConfigFilesForClosedScriptInfo(info);
                var canonicalFileName = this.toCanonicalFileName(info.fileName);
                if (this.openFilesWithNonRootedDiskPath.get(canonicalFileName) === info) {
                    this.openFilesWithNonRootedDiskPath.delete(canonicalFileName);
                }
                // collect all projects that should be removed
                var ensureProjectsForOpenFiles = false;
                for (var _i = 0, _a = info.containingProjects; _i < _a.length; _i++) {
                    var p = _a[_i];
                    if (server.isConfiguredProject(p)) {
                        if (info.hasMixedContent) {
                            info.registerFileUpdate();
                        }
                        // Do not remove the project so that we can reuse this project
                        // if it would need to be re-created with next file open
                        // If project had open file affecting
                        // Reload the root Files from config if its not already scheduled
                        var reloadLevel = p.openFileWatchTriggered.get(info.path);
                        if (reloadLevel !== undefined) {
                            p.openFileWatchTriggered.delete(info.path);
                            if (p.pendingReload !== undefined && p.pendingReload < reloadLevel) {
                                p.pendingReload = reloadLevel;
                                p.markFileAsDirty(info.path);
                            }
                        }
                    }
                    else if (server.isInferredProject(p) && p.isRoot(info)) {
                        // If this was the last open root file of inferred project
                        if (p.isProjectWithSingleRoot()) {
                            ensureProjectsForOpenFiles = true;
                        }
                        p.removeFile(info, fileExists, /*detachFromProject*/ true);
                        // Do not remove the project even if this was last root of the inferred project
                        // so that we can reuse this project, if it would need to be re-created with next file open
                    }
                    if (!p.languageServiceEnabled) {
                        // if project language service is disabled then we create a program only for open files.
                        // this means that project should be marked as dirty to force rebuilding of the program
                        // on the next request
                        p.markAsDirty();
                    }
                }
                this.openFiles.delete(info.path);
                this.configFileForOpenFiles.delete(info.path);
                if (!skipAssignOrphanScriptInfosToInferredProject && ensureProjectsForOpenFiles) {
                    this.assignOrphanScriptInfosToInferredProject();
                }
                // Cleanup script infos that arent part of any project (eg. those could be closed script infos not referenced by any project)
                // is postponed to next file open so that if file from same project is opened,
                // we wont end up creating same script infos
                // If the current info is being just closed - add the watcher file to track changes
                // But if file was deleted, handle that part
                if (fileExists) {
                    this.watchClosedScriptInfo(info);
                }
                else {
                    this.handleDeletedFile(info);
                }
                return ensureProjectsForOpenFiles;
            };
            ProjectService.prototype.deleteScriptInfo = function (info) {
                this.filenameToScriptInfo.delete(info.path);
                this.filenameToScriptInfoVersion.set(info.path, info.getVersion());
                var realpath = info.getRealpathIfDifferent();
                if (realpath) {
                    this.realpathToScriptInfos.remove(realpath, info); // TODO: GH#18217
                }
            };
            ProjectService.prototype.configFileExists = function (configFileName, canonicalConfigFilePath, info) {
                var _a;
                var configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath);
                if (configFileExistenceInfo) {
                    // By default the info would get impacted by presence of config file since its in the detection path
                    // Only adding the info as a root to inferred project will need the existence to be watched by file watcher
                    if (isOpenScriptInfo(info) && !((_a = configFileExistenceInfo.openFilesImpactedByConfigFile) === null || _a === void 0 ? void 0 : _a.has(info.path))) {
                        (configFileExistenceInfo.openFilesImpactedByConfigFile || (configFileExistenceInfo.openFilesImpactedByConfigFile = new ts.Map())).set(info.path, false);
                    }
                    return configFileExistenceInfo.exists;
                }
                // Theoretically we should be adding watch for the directory here itself.
                // In practice there will be very few scenarios where the config file gets added
                // somewhere inside the another config file directory.
                // And technically we could handle that case in configFile's directory watcher in some cases
                // But given that its a rare scenario it seems like too much overhead. (we werent watching those directories earlier either)
                // So what we are now watching is: configFile if the configured project corresponding to it is open
                // Or the whole chain of config files for the roots of the inferred projects
                // Cache the host value of file exists and add the info to map of open files impacted by this config file
                var exists = this.host.fileExists(configFileName);
                var openFilesImpactedByConfigFile;
                if (isOpenScriptInfo(info)) {
                    (openFilesImpactedByConfigFile || (openFilesImpactedByConfigFile = new ts.Map())).set(info.path, false);
                }
                configFileExistenceInfo = { exists: exists, openFilesImpactedByConfigFile: openFilesImpactedByConfigFile };
                this.configFileExistenceInfoCache.set(canonicalConfigFilePath, configFileExistenceInfo);
                return exists;
            };
            /*@internal*/
            ProjectService.prototype.createConfigFileWatcherForParsedConfig = function (configFileName, canonicalConfigFilePath, forProject) {
                var _this = this;
                var _a, _b;
                var configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath);
                // When watching config file for parsed config, remove the noopFileWatcher that can be created for open files impacted by config file and watch for real
                if (!configFileExistenceInfo.watcher || configFileExistenceInfo.watcher === noopConfigFileWatcher) {
                    configFileExistenceInfo.watcher = this.watchFactory.watchFile(configFileName, function (_fileName, eventKind) { return _this.onConfigFileChanged(canonicalConfigFilePath, eventKind); }, ts.PollingInterval.High, this.getWatchOptionsFromProjectWatchOptions((_b = (_a = configFileExistenceInfo === null || configFileExistenceInfo === void 0 ? void 0 : configFileExistenceInfo.config) === null || _a === void 0 ? void 0 : _a.parsedCommandLine) === null || _b === void 0 ? void 0 : _b.watchOptions), ts.WatchType.ConfigFile, forProject);
                }
                // Watching config file for project, update the map
                var projects = configFileExistenceInfo.config.projects;
                projects.set(forProject.canonicalConfigFilePath, projects.get(forProject.canonicalConfigFilePath) || false);
            };
            /**
             * Returns true if the configFileExistenceInfo is needed/impacted by open files that are root of inferred project
             */
            ProjectService.prototype.configFileExistenceImpactsRootOfInferredProject = function (configFileExistenceInfo) {
                return configFileExistenceInfo.openFilesImpactedByConfigFile &&
                    ts.forEachEntry(configFileExistenceInfo.openFilesImpactedByConfigFile, ts.identity);
            };
            /* @internal */
            ProjectService.prototype.releaseParsedConfig = function (canonicalConfigFilePath, forProject) {
                var _a, _b, _c;
                var configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath);
                if (!((_a = configFileExistenceInfo.config) === null || _a === void 0 ? void 0 : _a.projects.delete(forProject.canonicalConfigFilePath)))
                    return;
                // If there are still projects watching this config file existence and config, there is nothing to do
                if ((_b = configFileExistenceInfo.config) === null || _b === void 0 ? void 0 : _b.projects.size)
                    return;
                configFileExistenceInfo.config = undefined;
                ts.clearSharedExtendedConfigFileWatcher(canonicalConfigFilePath, this.sharedExtendedConfigFileWatchers);
                ts.Debug.checkDefined(configFileExistenceInfo.watcher);
                if ((_c = configFileExistenceInfo.openFilesImpactedByConfigFile) === null || _c === void 0 ? void 0 : _c.size) {
                    // If there are open files that are impacted by this config file existence
                    // but none of them are root of inferred project, the config file watcher will be
                    // created when any of the script infos are added as root of inferred project
                    if (this.configFileExistenceImpactsRootOfInferredProject(configFileExistenceInfo)) {
                        // If we cannot watch config file existence without configured project, close the configured file watcher
                        if (!ts.canWatchDirectory(ts.getDirectoryPath(canonicalConfigFilePath))) {
                            configFileExistenceInfo.watcher.close();
                            configFileExistenceInfo.watcher = noopConfigFileWatcher;
                        }
                    }
                    else {
                        // Close existing watcher
                        configFileExistenceInfo.watcher.close();
                        configFileExistenceInfo.watcher = undefined;
                    }
                }
                else {
                    // There is not a single file open thats tracking the status of this config file. Remove from cache
                    configFileExistenceInfo.watcher.close();
                    this.configFileExistenceInfoCache.delete(canonicalConfigFilePath);
                }
            };
            /**
             * Close the config file watcher in the cached ConfigFileExistenceInfo
             *   if there arent any open files that are root of inferred project and there is no parsed config held by any project
             */
            /*@internal*/
            ProjectService.prototype.closeConfigFileWatcherOnReleaseOfOpenFile = function (configFileExistenceInfo) {
                // Close the config file watcher if there are no more open files that are root of inferred project
                // or if there are no projects that need to watch this config file existence info
                if (configFileExistenceInfo.watcher &&
                    !configFileExistenceInfo.config &&
                    !this.configFileExistenceImpactsRootOfInferredProject(configFileExistenceInfo)) {
                    configFileExistenceInfo.watcher.close();
                    configFileExistenceInfo.watcher = undefined;
                }
            };
            /**
             * This is called on file close, so that we stop watching the config file for this script info
             */
            ProjectService.prototype.stopWatchingConfigFilesForClosedScriptInfo = function (info) {
                var _this = this;
                ts.Debug.assert(!info.isScriptOpen());
                this.forEachConfigFileLocation(info, function (canonicalConfigFilePath) {
                    var _a, _b, _c;
                    var configFileExistenceInfo = _this.configFileExistenceInfoCache.get(canonicalConfigFilePath);
                    if (configFileExistenceInfo) {
                        var infoIsRootOfInferredProject = (_a = configFileExistenceInfo.openFilesImpactedByConfigFile) === null || _a === void 0 ? void 0 : _a.get(info.path);
                        // Delete the info from map, since this file is no more open
                        (_b = configFileExistenceInfo.openFilesImpactedByConfigFile) === null || _b === void 0 ? void 0 : _b.delete(info.path);
                        // If the script info was not root of inferred project,
                        // there wont be config file watch open because of this script info
                        if (infoIsRootOfInferredProject) {
                            // But if it is a root, it could be the last script info that is root of inferred project
                            // and hence we would need to close the config file watcher
                            _this.closeConfigFileWatcherOnReleaseOfOpenFile(configFileExistenceInfo);
                        }
                        // If there are no open files that are impacted by configFileExistenceInfo after closing this script info
                        // and there is are no projects that need the config file existence or parsed config,
                        // remove the cached existence info
                        if (!((_c = configFileExistenceInfo.openFilesImpactedByConfigFile) === null || _c === void 0 ? void 0 : _c.size) &&
                            !configFileExistenceInfo.config) {
                            ts.Debug.assert(!configFileExistenceInfo.watcher);
                            _this.configFileExistenceInfoCache.delete(canonicalConfigFilePath);
                        }
                    }
                });
            };
            /**
             * This is called by inferred project whenever script info is added as a root
             */
            /* @internal */
            ProjectService.prototype.startWatchingConfigFilesForInferredProjectRoot = function (info) {
                var _this = this;
                ts.Debug.assert(info.isScriptOpen());
                this.forEachConfigFileLocation(info, function (canonicalConfigFilePath, configFileName) {
                    var configFileExistenceInfo = _this.configFileExistenceInfoCache.get(canonicalConfigFilePath);
                    if (!configFileExistenceInfo) {
                        // Create the cache
                        configFileExistenceInfo = { exists: _this.host.fileExists(configFileName) };
                        _this.configFileExistenceInfoCache.set(canonicalConfigFilePath, configFileExistenceInfo);
                    }
                    // Set this file as the root of inferred project
                    (configFileExistenceInfo.openFilesImpactedByConfigFile || (configFileExistenceInfo.openFilesImpactedByConfigFile = new ts.Map())).set(info.path, true);
                    // If there is no configured project for this config file, add the file watcher
                    configFileExistenceInfo.watcher || (configFileExistenceInfo.watcher = ts.canWatchDirectory(ts.getDirectoryPath(canonicalConfigFilePath)) ?
                        _this.watchFactory.watchFile(configFileName, function (_filename, eventKind) { return _this.onConfigFileChanged(canonicalConfigFilePath, eventKind); }, ts.PollingInterval.High, _this.hostConfiguration.watchOptions, ts.WatchType.ConfigFileForInferredRoot) :
                        noopConfigFileWatcher);
                });
            };
            /**
             * This is called by inferred project whenever root script info is removed from it
             */
            /* @internal */
            ProjectService.prototype.stopWatchingConfigFilesForInferredProjectRoot = function (info) {
                var _this = this;
                this.forEachConfigFileLocation(info, function (canonicalConfigFilePath) {
                    var _a;
                    var configFileExistenceInfo = _this.configFileExistenceInfoCache.get(canonicalConfigFilePath);
                    if ((_a = configFileExistenceInfo === null || configFileExistenceInfo === void 0 ? void 0 : configFileExistenceInfo.openFilesImpactedByConfigFile) === null || _a === void 0 ? void 0 : _a.has(info.path)) {
                        ts.Debug.assert(info.isScriptOpen());
                        // Info is not root of inferred project any more
                        configFileExistenceInfo.openFilesImpactedByConfigFile.set(info.path, false);
                        // Close the config file watcher
                        _this.closeConfigFileWatcherOnReleaseOfOpenFile(configFileExistenceInfo);
                    }
                });
            };
            /**
             * This function tries to search for a tsconfig.json for the given file.
             * This is different from the method the compiler uses because
             * the compiler can assume it will always start searching in the
             * current directory (the directory in which tsc was invoked).
             * The server must start searching from the directory containing
             * the newly opened file.
             */
            ProjectService.prototype.forEachConfigFileLocation = function (info, action) {
                var _this = this;
                if (this.serverMode !== ts.LanguageServiceMode.Semantic) {
                    return undefined;
                }
                ts.Debug.assert(!isOpenScriptInfo(info) || this.openFiles.has(info.path));
                var projectRootPath = this.openFiles.get(info.path);
                var scriptInfo = ts.Debug.checkDefined(this.getScriptInfo(info.path));
                if (scriptInfo.isDynamic)
                    return undefined;
                var searchPath = server.asNormalizedPath(ts.getDirectoryPath(info.fileName));
                var isSearchPathInProjectRoot = function () { return ts.containsPath(projectRootPath, searchPath, _this.currentDirectory, !_this.host.useCaseSensitiveFileNames); };
                // If projectRootPath doesn't contain info.path, then do normal search for config file
                var anySearchPathOk = !projectRootPath || !isSearchPathInProjectRoot();
                // For ancestor of config file always ignore its own directory since its going to result in itself
                var searchInDirectory = !isAncestorConfigFileInfo(info);
                do {
                    if (searchInDirectory) {
                        var canonicalSearchPath = server.normalizedPathToPath(searchPath, this.currentDirectory, this.toCanonicalFileName);
                        var tsconfigFileName = server.asNormalizedPath(ts.combinePaths(searchPath, "tsconfig.json"));
                        var result = action(ts.combinePaths(canonicalSearchPath, "tsconfig.json"), tsconfigFileName);
                        if (result)
                            return tsconfigFileName;
                        var jsconfigFileName = server.asNormalizedPath(ts.combinePaths(searchPath, "jsconfig.json"));
                        result = action(ts.combinePaths(canonicalSearchPath, "jsconfig.json"), jsconfigFileName);
                        if (result)
                            return jsconfigFileName;
                        // If we started within node_modules, don't look outside node_modules.
                        // Otherwise, we might pick up a very large project and pull in the world,
                        // causing an editor delay.
                        if (ts.isNodeModulesDirectory(canonicalSearchPath)) {
                            break;
                        }
                    }
                    var parentPath = server.asNormalizedPath(ts.getDirectoryPath(searchPath));
                    if (parentPath === searchPath)
                        break;
                    searchPath = parentPath;
                    searchInDirectory = true;
                } while (anySearchPathOk || isSearchPathInProjectRoot());
                return undefined;
            };
            /*@internal*/
            ProjectService.prototype.findDefaultConfiguredProject = function (info) {
                if (!info.isScriptOpen())
                    return undefined;
                var configFileName = this.getConfigFileNameForFile(info);
                var project = configFileName &&
                    this.findConfiguredProjectByProjectName(configFileName);
                return project && projectContainsInfoDirectly(project, info) ?
                    project :
                    project === null || project === void 0 ? void 0 : project.getDefaultChildProjectFromProjectWithReferences(info);
            };
            /**
             * This function tries to search for a tsconfig.json for the given file.
             * This is different from the method the compiler uses because
             * the compiler can assume it will always start searching in the
             * current directory (the directory in which tsc was invoked).
             * The server must start searching from the directory containing
             * the newly opened file.
             * If script info is passed in, it is asserted to be open script info
             * otherwise just file name
             */
            ProjectService.prototype.getConfigFileNameForFile = function (info) {
                var _this = this;
                if (isOpenScriptInfo(info)) {
                    ts.Debug.assert(info.isScriptOpen());
                    var result = this.configFileForOpenFiles.get(info.path);
                    if (result !== undefined)
                        return result || undefined;
                }
                this.logger.info("Search path: " + ts.getDirectoryPath(info.fileName));
                var configFileName = this.forEachConfigFileLocation(info, function (canonicalConfigFilePath, configFileName) {
                    return _this.configFileExists(configFileName, canonicalConfigFilePath, info);
                });
                if (configFileName) {
                    this.logger.info("For info: " + info.fileName + " :: Config file name: " + configFileName);
                }
                else {
                    this.logger.info("For info: " + info.fileName + " :: No config files found.");
                }
                if (isOpenScriptInfo(info)) {
                    this.configFileForOpenFiles.set(info.path, configFileName || false);
                }
                return configFileName;
            };
            ProjectService.prototype.printProjects = function () {
                var _this = this;
                if (!this.logger.hasLevel(server.LogLevel.normal)) {
                    return;
                }
                this.logger.startGroup();
                this.externalProjects.forEach(printProjectWithoutFileNames);
                this.configuredProjects.forEach(printProjectWithoutFileNames);
                this.inferredProjects.forEach(printProjectWithoutFileNames);
                this.logger.info("Open files: ");
                this.openFiles.forEach(function (projectRootPath, path) {
                    var info = _this.getScriptInfoForPath(path);
                    _this.logger.info("\tFileName: " + info.fileName + " ProjectRootPath: " + projectRootPath);
                    _this.logger.info("\t\tProjects: " + info.containingProjects.map(function (p) { return p.getProjectName(); }));
                });
                this.logger.endGroup();
            };
            /*@internal*/
            ProjectService.prototype.findConfiguredProjectByProjectName = function (configFileName) {
                // make sure that casing of config file name is consistent
                var canonicalConfigFilePath = server.asNormalizedPath(this.toCanonicalFileName(configFileName));
                return this.getConfiguredProjectByCanonicalConfigFilePath(canonicalConfigFilePath);
            };
            ProjectService.prototype.getConfiguredProjectByCanonicalConfigFilePath = function (canonicalConfigFilePath) {
                return this.configuredProjects.get(canonicalConfigFilePath);
            };
            ProjectService.prototype.findExternalProjectByProjectName = function (projectFileName) {
                return findProjectByName(projectFileName, this.externalProjects);
            };
            /** Get a filename if the language service exceeds the maximum allowed program size; otherwise returns undefined. */
            ProjectService.prototype.getFilenameForExceededTotalSizeLimitForNonTsFiles = function (name, options, fileNames, propertyReader) {
                var _this = this;
                if (options && options.disableSizeLimit || !this.host.getFileSize) {
                    return;
                }
                var availableSpace = server.maxProgramSizeForNonTsFiles;
                this.projectToSizeMap.set(name, 0);
                this.projectToSizeMap.forEach(function (val) { return (availableSpace -= (val || 0)); });
                var totalNonTsFileSize = 0;
                for (var _i = 0, fileNames_1 = fileNames; _i < fileNames_1.length; _i++) {
                    var f = fileNames_1[_i];
                    var fileName = propertyReader.getFileName(f);
                    if (ts.hasTSFileExtension(fileName)) {
                        continue;
                    }
                    totalNonTsFileSize += this.host.getFileSize(fileName);
                    if (totalNonTsFileSize > server.maxProgramSizeForNonTsFiles || totalNonTsFileSize > availableSpace) {
                        var top5LargestFiles = fileNames.map(function (f) { return propertyReader.getFileName(f); })
                            .filter(function (name) { return !ts.hasTSFileExtension(name); })
                            .map(function (name) { return ({ name: name, size: _this.host.getFileSize(name) }); })
                            .sort(function (a, b) { return b.size - a.size; })
                            .slice(0, 5);
                        this.logger.info("Non TS file size exceeded limit (" + totalNonTsFileSize + "). Largest files: " + top5LargestFiles.map(function (file) { return file.name + ":" + file.size; }).join(", "));
                        // Keep the size as zero since it's disabled
                        return fileName;
                    }
                }
                this.projectToSizeMap.set(name, totalNonTsFileSize);
            };
            ProjectService.prototype.createExternalProject = function (projectFileName, files, options, typeAcquisition, excludedFiles) {
                var compilerOptions = convertCompilerOptions(options);
                var watchOptionsAndErrors = convertWatchOptions(options, ts.getDirectoryPath(ts.normalizeSlashes(projectFileName)));
                var project = new server.ExternalProject(projectFileName, this, this.documentRegistry, compilerOptions, 
                /*lastFileExceededProgramSize*/ this.getFilenameForExceededTotalSizeLimitForNonTsFiles(projectFileName, compilerOptions, files, externalFilePropertyReader), options.compileOnSave === undefined ? true : options.compileOnSave, 
                /*projectFilePath*/ undefined, this.currentPluginConfigOverrides, watchOptionsAndErrors === null || watchOptionsAndErrors === void 0 ? void 0 : watchOptionsAndErrors.watchOptions);
                project.setProjectErrors(watchOptionsAndErrors === null || watchOptionsAndErrors === void 0 ? void 0 : watchOptionsAndErrors.errors);
                project.excludedFiles = excludedFiles;
                this.addFilesToNonInferredProject(project, files, externalFilePropertyReader, typeAcquisition);
                this.externalProjects.push(project);
                return project;
            };
            /*@internal*/
            ProjectService.prototype.sendProjectTelemetry = function (project) {
                if (this.seenProjects.has(project.projectName)) {
                    setProjectOptionsUsed(project);
                    return;
                }
                this.seenProjects.set(project.projectName, true);
                if (!this.eventHandler || !this.host.createSHA256Hash) {
                    setProjectOptionsUsed(project);
                    return;
                }
                var projectOptions = server.isConfiguredProject(project) ? project.projectOptions : undefined;
                setProjectOptionsUsed(project);
                var data = {
                    projectId: this.host.createSHA256Hash(project.projectName),
                    fileStats: server.countEachFileTypes(project.getScriptInfos(), /*includeSizes*/ true),
                    compilerOptions: ts.convertCompilerOptionsForTelemetry(project.getCompilationSettings()),
                    typeAcquisition: convertTypeAcquisition(project.getTypeAcquisition()),
                    extends: projectOptions && projectOptions.configHasExtendsProperty,
                    files: projectOptions && projectOptions.configHasFilesProperty,
                    include: projectOptions && projectOptions.configHasIncludeProperty,
                    exclude: projectOptions && projectOptions.configHasExcludeProperty,
                    compileOnSave: project.compileOnSaveEnabled,
                    configFileName: configFileName(),
                    projectType: project instanceof server.ExternalProject ? "external" : "configured",
                    languageServiceEnabled: project.languageServiceEnabled,
                    version: ts.version, // eslint-disable-line @typescript-eslint/no-unnecessary-qualifier
                };
                this.eventHandler({ eventName: server.ProjectInfoTelemetryEvent, data: data });
                function configFileName() {
                    if (!server.isConfiguredProject(project)) {
                        return "other";
                    }
                    return server.getBaseConfigFileName(project.getConfigFilePath()) || "other";
                }
                function convertTypeAcquisition(_a) {
                    var enable = _a.enable, include = _a.include, exclude = _a.exclude;
                    return {
                        enable: enable,
                        include: include !== undefined && include.length !== 0,
                        exclude: exclude !== undefined && exclude.length !== 0,
                    };
                }
            };
            ProjectService.prototype.addFilesToNonInferredProject = function (project, files, propertyReader, typeAcquisition) {
                this.updateNonInferredProjectFiles(project, files, propertyReader);
                project.setTypeAcquisition(typeAcquisition);
            };
            /* @internal */
            ProjectService.prototype.createConfiguredProject = function (configFileName) {
                this.logger.info("Creating configuration project " + configFileName);
                var canonicalConfigFilePath = server.asNormalizedPath(this.toCanonicalFileName(configFileName));
                var configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath);
                // We could be in this scenario if project is the configured project tracked by external project
                // Since that route doesnt check if the config file is present or not
                if (!configFileExistenceInfo) {
                    this.configFileExistenceInfoCache.set(canonicalConfigFilePath, configFileExistenceInfo = { exists: true });
                }
                else {
                    configFileExistenceInfo.exists = true;
                }
                if (!configFileExistenceInfo.config) {
                    configFileExistenceInfo.config = {
                        cachedDirectoryStructureHost: ts.createCachedDirectoryStructureHost(this.host, this.host.getCurrentDirectory(), this.host.useCaseSensitiveFileNames),
                        projects: new ts.Map(),
                        reloadLevel: ts.ConfigFileProgramReloadLevel.Full
                    };
                }
                var project = new server.ConfiguredProject(configFileName, canonicalConfigFilePath, this, this.documentRegistry, configFileExistenceInfo.config.cachedDirectoryStructureHost);
                this.configuredProjects.set(canonicalConfigFilePath, project);
                this.createConfigFileWatcherForParsedConfig(configFileName, canonicalConfigFilePath, project);
                return project;
            };
            /* @internal */
            ProjectService.prototype.createConfiguredProjectWithDelayLoad = function (configFileName, reason) {
                var project = this.createConfiguredProject(configFileName);
                project.pendingReload = ts.ConfigFileProgramReloadLevel.Full;
                project.pendingReloadReason = reason;
                return project;
            };
            /* @internal */
            ProjectService.prototype.createAndLoadConfiguredProject = function (configFileName, reason) {
                var project = this.createConfiguredProject(configFileName);
                this.loadConfiguredProject(project, reason);
                return project;
            };
            /* @internal */
            ProjectService.prototype.createLoadAndUpdateConfiguredProject = function (configFileName, reason) {
                var project = this.createAndLoadConfiguredProject(configFileName, reason);
                project.updateGraph();
                return project;
            };
            /**
             * Read the config file of the project, and update the project root file names.
             */
            /* @internal */
            ProjectService.prototype.loadConfiguredProject = function (project, reason) {
                var _this = this;
                this.sendProjectLoadingStartEvent(project, reason);
                // Read updated contents from disk
                var configFilename = server.asNormalizedPath(ts.normalizePath(project.getConfigFilePath()));
                var configFileExistenceInfo = this.ensureParsedConfigUptoDate(configFilename, project.canonicalConfigFilePath, this.configFileExistenceInfoCache.get(project.canonicalConfigFilePath), project);
                var parsedCommandLine = configFileExistenceInfo.config.parsedCommandLine;
                ts.Debug.assert(!!parsedCommandLine.fileNames);
                var compilerOptions = parsedCommandLine.options;
                // Update the project
                if (!project.projectOptions) {
                    project.projectOptions = {
                        configHasExtendsProperty: parsedCommandLine.raw.extends !== undefined,
                        configHasFilesProperty: parsedCommandLine.raw.files !== undefined,
                        configHasIncludeProperty: parsedCommandLine.raw.include !== undefined,
                        configHasExcludeProperty: parsedCommandLine.raw.exclude !== undefined
                    };
                }
                project.canConfigFileJsonReportNoInputFiles = ts.canJsonReportNoInputFiles(parsedCommandLine.raw);
                project.setProjectErrors(parsedCommandLine.options.configFile.parseDiagnostics);
                project.updateReferences(parsedCommandLine.projectReferences);
                var lastFileExceededProgramSize = this.getFilenameForExceededTotalSizeLimitForNonTsFiles(project.canonicalConfigFilePath, compilerOptions, parsedCommandLine.fileNames, fileNamePropertyReader);
                if (lastFileExceededProgramSize) {
                    project.disableLanguageService(lastFileExceededProgramSize);
                    this.configFileExistenceInfoCache.forEach(function (_configFileExistenceInfo, canonicalConfigFilePath) {
                        return _this.stopWatchingWildCards(canonicalConfigFilePath, project);
                    });
                }
                else {
                    project.setCompilerOptions(compilerOptions);
                    project.setWatchOptions(parsedCommandLine.watchOptions);
                    project.enableLanguageService();
                    this.watchWildcards(configFilename, configFileExistenceInfo, project);
                }
                project.enablePluginsWithOptions(compilerOptions, this.currentPluginConfigOverrides);
                var filesToAdd = parsedCommandLine.fileNames.concat(project.getExternalFiles());
                this.updateRootAndOptionsOfNonInferredProject(project, filesToAdd, fileNamePropertyReader, compilerOptions, parsedCommandLine.typeAcquisition, parsedCommandLine.compileOnSave, parsedCommandLine.watchOptions);
            };
            /*@internal*/
            ProjectService.prototype.ensureParsedConfigUptoDate = function (configFilename, canonicalConfigFilePath, configFileExistenceInfo, forProject) {
                var _this = this;
                var _a, _b, _c;
                if (configFileExistenceInfo.config) {
                    if (!configFileExistenceInfo.config.reloadLevel)
                        return configFileExistenceInfo;
                    if (configFileExistenceInfo.config.reloadLevel === ts.ConfigFileProgramReloadLevel.Partial) {
                        this.reloadFileNamesOfParsedConfig(configFilename, configFileExistenceInfo.config);
                        return configFileExistenceInfo;
                    }
                }
                // Parse the config file and ensure its cached
                var cachedDirectoryStructureHost = ((_a = configFileExistenceInfo.config) === null || _a === void 0 ? void 0 : _a.cachedDirectoryStructureHost) ||
                    ts.createCachedDirectoryStructureHost(this.host, this.host.getCurrentDirectory(), this.host.useCaseSensitiveFileNames);
                // Read updated contents from disk
                var configFileContent = ts.tryReadFile(configFilename, function (fileName) { return _this.host.readFile(fileName); });
                var configFile = ts.parseJsonText(configFilename, ts.isString(configFileContent) ? configFileContent : "");
                var configFileErrors = configFile.parseDiagnostics;
                if (!ts.isString(configFileContent))
                    configFileErrors.push(configFileContent);
                var parsedCommandLine = ts.parseJsonSourceFileConfigFileContent(configFile, cachedDirectoryStructureHost, ts.getDirectoryPath(configFilename), 
                /*existingOptions*/ {}, configFilename, 
                /*resolutionStack*/ [], this.hostConfiguration.extraFileExtensions, this.extendedConfigCache);
                if (parsedCommandLine.errors.length) {
                    configFileErrors.push.apply(configFileErrors, parsedCommandLine.errors);
                }
                this.logger.info("Config: " + configFilename + " : " + JSON.stringify({
                    rootNames: parsedCommandLine.fileNames,
                    options: parsedCommandLine.options,
                    watchOptions: parsedCommandLine.watchOptions,
                    projectReferences: parsedCommandLine.projectReferences
                }, /*replacer*/ undefined, " "));
                var oldCommandLine = (_b = configFileExistenceInfo.config) === null || _b === void 0 ? void 0 : _b.parsedCommandLine;
                if (!configFileExistenceInfo.config) {
                    configFileExistenceInfo.config = { parsedCommandLine: parsedCommandLine, cachedDirectoryStructureHost: cachedDirectoryStructureHost, projects: new ts.Map() };
                }
                else {
                    configFileExistenceInfo.config.parsedCommandLine = parsedCommandLine;
                    configFileExistenceInfo.config.watchedDirectoriesStale = true;
                    configFileExistenceInfo.config.reloadLevel = undefined;
                }
                // If watch options different than older options when setting for the first time, update the config file watcher
                if (!oldCommandLine && !ts.isJsonEqual(
                // Old options
                this.getWatchOptionsFromProjectWatchOptions(/*projectOptions*/ undefined), 
                // New options
                this.getWatchOptionsFromProjectWatchOptions(parsedCommandLine.watchOptions))) {
                    // Reset the config file watcher
                    (_c = configFileExistenceInfo.watcher) === null || _c === void 0 ? void 0 : _c.close();
                    configFileExistenceInfo.watcher = undefined;
                }
                // Ensure there is watcher for this config file
                this.createConfigFileWatcherForParsedConfig(configFilename, canonicalConfigFilePath, forProject);
                // Watch extended config files
                ts.updateSharedExtendedConfigFileWatcher(canonicalConfigFilePath, parsedCommandLine.options, this.sharedExtendedConfigFileWatchers, function (extendedConfigFileName, extendedConfigFilePath) { return _this.watchFactory.watchFile(extendedConfigFileName, function () {
                    var _a;
                    // Update extended config cache
                    ts.cleanExtendedConfigCache(_this.extendedConfigCache, extendedConfigFilePath, function (fileName) { return _this.toPath(fileName); });
                    // Update projects
                    var ensureProjectsForOpenFiles = false;
                    (_a = _this.sharedExtendedConfigFileWatchers.get(extendedConfigFilePath)) === null || _a === void 0 ? void 0 : _a.projects.forEach(function (canonicalPath) {
                        ensureProjectsForOpenFiles = _this.delayUpdateProjectsFromParsedConfigOnConfigFileChange(canonicalPath, "Change in extended config file " + extendedConfigFileName + " detected") || ensureProjectsForOpenFiles;
                    });
                    if (ensureProjectsForOpenFiles)
                        _this.delayEnsureProjectForOpenFiles();
                }, ts.PollingInterval.High, _this.hostConfiguration.watchOptions, ts.WatchType.ExtendedConfigFile, configFilename); }, function (fileName) { return _this.toPath(fileName); });
                return configFileExistenceInfo;
            };
            /*@internal*/
            ProjectService.prototype.watchWildcards = function (configFileName, _a, forProject) {
                var _this = this;
                var _b;
                var exists = _a.exists, config = _a.config;
                config.projects.set(forProject.canonicalConfigFilePath, true);
                if (exists) {
                    if (config.watchedDirectories && !config.watchedDirectoriesStale)
                        return;
                    config.watchedDirectoriesStale = false;
                    ts.updateWatchingWildcardDirectories((_b = config).watchedDirectories || (_b.watchedDirectories = new ts.Map()), new ts.Map(ts.getEntries(config.parsedCommandLine.wildcardDirectories)), 
                    // Create new directory watcher
                    function (directory, flags) { return _this.watchWildcardDirectory(directory, flags, configFileName, config); });
                }
                else {
                    config.watchedDirectoriesStale = false;
                    if (!config.watchedDirectories)
                        return;
                    ts.clearMap(config.watchedDirectories, ts.closeFileWatcherOf);
                    config.watchedDirectories = undefined;
                }
            };
            /*@internal*/
            ProjectService.prototype.stopWatchingWildCards = function (canonicalConfigFilePath, forProject) {
                var configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath);
                if (!configFileExistenceInfo.config ||
                    !configFileExistenceInfo.config.projects.get(forProject.canonicalConfigFilePath)) {
                    return;
                }
                configFileExistenceInfo.config.projects.set(forProject.canonicalConfigFilePath, false);
                // If any of the project is still watching wild cards dont close the watcher
                if (ts.forEachEntry(configFileExistenceInfo.config.projects, ts.identity))
                    return;
                if (configFileExistenceInfo.config.watchedDirectories) {
                    ts.clearMap(configFileExistenceInfo.config.watchedDirectories, ts.closeFileWatcherOf);
                    configFileExistenceInfo.config.watchedDirectories = undefined;
                }
                configFileExistenceInfo.config.watchedDirectoriesStale = undefined;
            };
            ProjectService.prototype.updateNonInferredProjectFiles = function (project, files, propertyReader) {
                var projectRootFilesMap = project.getRootFilesMap();
                var newRootScriptInfoMap = new ts.Map();
                for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                    var f = files_1[_i];
                    var newRootFile = propertyReader.getFileName(f);
                    var fileName = server.toNormalizedPath(newRootFile);
                    var isDynamic = server.isDynamicFileName(fileName);
                    var path = void 0;
                    // Use the project's fileExists so that it can use caching instead of reaching to disk for the query
                    if (!isDynamic && !project.fileExists(newRootFile)) {
                        path = server.normalizedPathToPath(fileName, this.currentDirectory, this.toCanonicalFileName);
                        var existingValue = projectRootFilesMap.get(path);
                        if (existingValue) {
                            if (existingValue.info) {
                                project.removeFile(existingValue.info, /*fileExists*/ false, /*detachFromProject*/ true);
                                existingValue.info = undefined;
                            }
                            existingValue.fileName = fileName;
                        }
                        else {
                            projectRootFilesMap.set(path, { fileName: fileName });
                        }
                    }
                    else {
                        var scriptKind = propertyReader.getScriptKind(f, this.hostConfiguration.extraFileExtensions);
                        var hasMixedContent = propertyReader.hasMixedContent(f, this.hostConfiguration.extraFileExtensions);
                        var scriptInfo = ts.Debug.checkDefined(this.getOrCreateScriptInfoNotOpenedByClientForNormalizedPath(fileName, project.currentDirectory, scriptKind, hasMixedContent, project.directoryStructureHost));
                        path = scriptInfo.path;
                        var existingValue = projectRootFilesMap.get(path);
                        // If this script info is not already a root add it
                        if (!existingValue || existingValue.info !== scriptInfo) {
                            project.addRoot(scriptInfo, fileName);
                            if (scriptInfo.isScriptOpen()) {
                                // if file is already root in some inferred project
                                // - remove the file from that project and delete the project if necessary
                                this.removeRootOfInferredProjectIfNowPartOfOtherProject(scriptInfo);
                            }
                        }
                        else {
                            // Already root update the fileName
                            existingValue.fileName = fileName;
                        }
                    }
                    newRootScriptInfoMap.set(path, true);
                }
                // project's root file map size is always going to be same or larger than new roots map
                // as we have already all the new files to the project
                if (projectRootFilesMap.size > newRootScriptInfoMap.size) {
                    projectRootFilesMap.forEach(function (value, path) {
                        if (!newRootScriptInfoMap.has(path)) {
                            if (value.info) {
                                project.removeFile(value.info, project.fileExists(path), /*detachFromProject*/ true);
                            }
                            else {
                                projectRootFilesMap.delete(path);
                            }
                        }
                    });
                }
                // Just to ensure that even if root files dont change, the changes to the non root file are picked up,
                // mark the project as dirty unconditionally
                project.markAsDirty();
            };
            ProjectService.prototype.updateRootAndOptionsOfNonInferredProject = function (project, newUncheckedFiles, propertyReader, newOptions, newTypeAcquisition, compileOnSave, watchOptions) {
                project.setCompilerOptions(newOptions);
                project.setWatchOptions(watchOptions);
                // VS only set the CompileOnSaveEnabled option in the request if the option was changed recently
                // therefore if it is undefined, it should not be updated.
                if (compileOnSave !== undefined) {
                    project.compileOnSaveEnabled = compileOnSave;
                }
                this.addFilesToNonInferredProject(project, newUncheckedFiles, propertyReader, newTypeAcquisition);
            };
            /**
             * Reload the file names from config file specs and update the project graph
             */
            /*@internal*/
            ProjectService.prototype.reloadFileNamesOfConfiguredProject = function (project) {
                var fileNames = this.reloadFileNamesOfParsedConfig(project.getConfigFilePath(), this.configFileExistenceInfoCache.get(project.canonicalConfigFilePath).config);
                project.updateErrorOnNoInputFiles(fileNames);
                this.updateNonInferredProjectFiles(project, fileNames.concat(project.getExternalFiles()), fileNamePropertyReader);
                return project.updateGraph();
            };
            /*@internal*/
            ProjectService.prototype.reloadFileNamesOfParsedConfig = function (configFileName, config) {
                if (config.reloadLevel === undefined)
                    return config.parsedCommandLine.fileNames;
                ts.Debug.assert(config.reloadLevel === ts.ConfigFileProgramReloadLevel.Partial);
                var configFileSpecs = config.parsedCommandLine.options.configFile.configFileSpecs;
                var fileNames = ts.getFileNamesFromConfigSpecs(configFileSpecs, ts.getDirectoryPath(configFileName), config.parsedCommandLine.options, config.cachedDirectoryStructureHost, this.hostConfiguration.extraFileExtensions);
                config.parsedCommandLine = __assign(__assign({}, config.parsedCommandLine), { fileNames: fileNames });
                return fileNames;
            };
            /*@internal*/
            ProjectService.prototype.setFileNamesOfAutoImportProviderProject = function (project, fileNames) {
                this.updateNonInferredProjectFiles(project, fileNames, fileNamePropertyReader);
            };
            /**
             * Read the config file of the project again by clearing the cache and update the project graph
             */
            /* @internal */
            ProjectService.prototype.reloadConfiguredProject = function (project, reason, isInitialLoad, clearSemanticCache) {
                // At this point, there is no reason to not have configFile in the host
                var host = project.getCachedDirectoryStructureHost();
                if (clearSemanticCache)
                    this.clearSemanticCache(project);
                // Clear the cache since we are reloading the project from disk
                host.clearCache();
                var configFileName = project.getConfigFilePath();
                this.logger.info((isInitialLoad ? "Loading" : "Reloading") + " configured project " + configFileName);
                // Load project from the disk
                this.loadConfiguredProject(project, reason);
                project.updateGraph();
                this.sendConfigFileDiagEvent(project, configFileName);
            };
            /* @internal */
            ProjectService.prototype.clearSemanticCache = function (project) {
                project.resolutionCache.clear();
                project.getLanguageService(/*ensureSynchronized*/ false).cleanupSemanticCache();
                project.markAsDirty();
            };
            ProjectService.prototype.sendConfigFileDiagEvent = function (project, triggerFile) {
                if (!this.eventHandler || this.suppressDiagnosticEvents) {
                    return;
                }
                var diagnostics = project.getLanguageService().getCompilerOptionsDiagnostics();
                diagnostics.push.apply(diagnostics, project.getAllProjectErrors());
                this.eventHandler({
                    eventName: server.ConfigFileDiagEvent,
                    data: { configFileName: project.getConfigFilePath(), diagnostics: diagnostics, triggerFile: triggerFile }
                });
            };
            ProjectService.prototype.getOrCreateInferredProjectForProjectRootPathIfEnabled = function (info, projectRootPath) {
                if (!this.useInferredProjectPerProjectRoot ||
                    // Its a dynamic info opened without project root
                    (info.isDynamic && projectRootPath === undefined)) {
                    return undefined;
                }
                if (projectRootPath) {
                    var canonicalProjectRootPath = this.toCanonicalFileName(projectRootPath);
                    // if we have an explicit project root path, find (or create) the matching inferred project.
                    for (var _i = 0, _a = this.inferredProjects; _i < _a.length; _i++) {
                        var project = _a[_i];
                        if (project.projectRootPath === canonicalProjectRootPath) {
                            return project;
                        }
                    }
                    return this.createInferredProject(projectRootPath, /*isSingleInferredProject*/ false, projectRootPath);
                }
                // we don't have an explicit root path, so we should try to find an inferred project
                // that more closely contains the file.
                var bestMatch;
                for (var _b = 0, _c = this.inferredProjects; _b < _c.length; _b++) {
                    var project = _c[_b];
                    // ignore single inferred projects (handled elsewhere)
                    if (!project.projectRootPath)
                        continue;
                    // ignore inferred projects that don't contain the root's path
                    if (!ts.containsPath(project.projectRootPath, info.path, this.host.getCurrentDirectory(), !this.host.useCaseSensitiveFileNames))
                        continue;
                    // ignore inferred projects that are higher up in the project root.
                    // TODO(rbuckton): Should we add the file as a root to these as well?
                    if (bestMatch && bestMatch.projectRootPath.length > project.projectRootPath.length)
                        continue;
                    bestMatch = project;
                }
                return bestMatch;
            };
            ProjectService.prototype.getOrCreateSingleInferredProjectIfEnabled = function () {
                if (!this.useSingleInferredProject) {
                    return undefined;
                }
                // If `useInferredProjectPerProjectRoot` is not enabled, then there will only be one
                // inferred project for all files. If `useInferredProjectPerProjectRoot` is enabled
                // then we want to put all files that are not opened with a `projectRootPath` into
                // the same inferred project.
                //
                // To avoid the cost of searching through the array and to optimize for the case where
                // `useInferredProjectPerProjectRoot` is not enabled, we will always put the inferred
                // project for non-rooted files at the front of the array.
                if (this.inferredProjects.length > 0 && this.inferredProjects[0].projectRootPath === undefined) {
                    return this.inferredProjects[0];
                }
                // Single inferred project does not have a project root and hence no current directory
                return this.createInferredProject(/*currentDirectory*/ undefined, /*isSingleInferredProject*/ true);
            };
            ProjectService.prototype.getOrCreateSingleInferredWithoutProjectRoot = function (currentDirectory) {
                ts.Debug.assert(!this.useSingleInferredProject);
                var expectedCurrentDirectory = this.toCanonicalFileName(this.getNormalizedAbsolutePath(currentDirectory || ""));
                // Reuse the project with same current directory but no roots
                for (var _i = 0, _a = this.inferredProjects; _i < _a.length; _i++) {
                    var inferredProject = _a[_i];
                    if (!inferredProject.projectRootPath &&
                        inferredProject.isOrphan() &&
                        inferredProject.canonicalCurrentDirectory === expectedCurrentDirectory) {
                        return inferredProject;
                    }
                }
                return this.createInferredProject(currentDirectory);
            };
            ProjectService.prototype.createInferredProject = function (currentDirectory, isSingleInferredProject, projectRootPath) {
                var compilerOptions = projectRootPath && this.compilerOptionsForInferredProjectsPerProjectRoot.get(projectRootPath) || this.compilerOptionsForInferredProjects; // TODO: GH#18217
                var watchOptionsAndErrors;
                var typeAcquisition;
                if (projectRootPath) {
                    watchOptionsAndErrors = this.watchOptionsForInferredProjectsPerProjectRoot.get(projectRootPath);
                    typeAcquisition = this.typeAcquisitionForInferredProjectsPerProjectRoot.get(projectRootPath);
                }
                if (watchOptionsAndErrors === undefined) {
                    watchOptionsAndErrors = this.watchOptionsForInferredProjects;
                }
                if (typeAcquisition === undefined) {
                    typeAcquisition = this.typeAcquisitionForInferredProjects;
                }
                watchOptionsAndErrors = watchOptionsAndErrors || undefined;
                var project = new server.InferredProject(this, this.documentRegistry, compilerOptions, watchOptionsAndErrors === null || watchOptionsAndErrors === void 0 ? void 0 : watchOptionsAndErrors.watchOptions, projectRootPath, currentDirectory, this.currentPluginConfigOverrides, typeAcquisition);
                project.setProjectErrors(watchOptionsAndErrors === null || watchOptionsAndErrors === void 0 ? void 0 : watchOptionsAndErrors.errors);
                if (isSingleInferredProject) {
                    this.inferredProjects.unshift(project);
                }
                else {
                    this.inferredProjects.push(project);
                }
                return project;
            };
            /*@internal*/
            ProjectService.prototype.getOrCreateScriptInfoNotOpenedByClient = function (uncheckedFileName, currentDirectory, hostToQueryFileExistsOn) {
                return this.getOrCreateScriptInfoNotOpenedByClientForNormalizedPath(server.toNormalizedPath(uncheckedFileName), currentDirectory, /*scriptKind*/ undefined, 
                /*hasMixedContent*/ undefined, hostToQueryFileExistsOn);
            };
            ProjectService.prototype.getScriptInfo = function (uncheckedFileName) {
                return this.getScriptInfoForNormalizedPath(server.toNormalizedPath(uncheckedFileName));
            };
            /* @internal */
            ProjectService.prototype.getScriptInfoOrConfig = function (uncheckedFileName) {
                var path = server.toNormalizedPath(uncheckedFileName);
                var info = this.getScriptInfoForNormalizedPath(path);
                if (info)
                    return info;
                var configProject = this.configuredProjects.get(this.toPath(uncheckedFileName));
                return configProject && configProject.getCompilerOptions().configFile;
            };
            /* @internal */
            ProjectService.prototype.logErrorForScriptInfoNotFound = function (fileName) {
                var names = ts.arrayFrom(this.filenameToScriptInfo.entries()).map(function (_a) {
                    var path = _a[0], scriptInfo = _a[1];
                    return ({ path: path, fileName: scriptInfo.fileName });
                });
                this.logger.msg("Could not find file " + JSON.stringify(fileName) + ".\nAll files are: " + JSON.stringify(names), server.Msg.Err);
            };
            /**
             * Returns the projects that contain script info through SymLink
             * Note that this does not return projects in info.containingProjects
             */
            /*@internal*/
            ProjectService.prototype.getSymlinkedProjects = function (info) {
                var projects;
                if (this.realpathToScriptInfos) {
                    var realpath = info.getRealpathIfDifferent();
                    if (realpath) {
                        ts.forEach(this.realpathToScriptInfos.get(realpath), combineProjects);
                    }
                    ts.forEach(this.realpathToScriptInfos.get(info.path), combineProjects);
                }
                return projects;
                function combineProjects(toAddInfo) {
                    if (toAddInfo !== info) {
                        var _loop_3 = function (project) {
                            // Add the projects only if they can use symLink targets and not already in the list
                            if (project.languageServiceEnabled &&
                                !project.isOrphan() &&
                                !project.getCompilerOptions().preserveSymlinks &&
                                !info.isAttached(project)) {
                                if (!projects) {
                                    projects = ts.createMultiMap();
                                    projects.add(toAddInfo.path, project);
                                }
                                else if (!ts.forEachEntry(projects, function (projs, path) { return path === toAddInfo.path ? false : ts.contains(projs, project); })) {
                                    projects.add(toAddInfo.path, project);
                                }
                            }
                        };
                        for (var _i = 0, _a = toAddInfo.containingProjects; _i < _a.length; _i++) {
                            var project = _a[_i];
                            _loop_3(project);
                        }
                    }
                }
            };
            ProjectService.prototype.watchClosedScriptInfo = function (info) {
                var _this = this;
                ts.Debug.assert(!info.fileWatcher);
                // do not watch files with mixed content - server doesn't know how to interpret it
                // do not watch files in the global cache location
                if (!info.isDynamicOrHasMixedContent() &&
                    (!this.globalCacheLocationDirectoryPath ||
                        !ts.startsWith(info.path, this.globalCacheLocationDirectoryPath))) {
                    var indexOfNodeModules = info.path.indexOf("/node_modules/");
                    if (!this.host.getModifiedTime || indexOfNodeModules === -1) {
                        info.fileWatcher = this.watchFactory.watchFile(info.fileName, function (_fileName, eventKind) { return _this.onSourceFileChanged(info, eventKind); }, ts.PollingInterval.Medium, this.hostConfiguration.watchOptions, ts.WatchType.ClosedScriptInfo);
                    }
                    else {
                        info.mTime = this.getModifiedTime(info);
                        info.fileWatcher = this.watchClosedScriptInfoInNodeModules(info.path.substr(0, indexOfNodeModules));
                    }
                }
            };
            ProjectService.prototype.createNodeModulesWatcher = function (dir) {
                var _this = this;
                var watcher = this.watchFactory.watchDirectory(dir, function (fileOrDirectory) {
                    var _a;
                    var fileOrDirectoryPath = ts.removeIgnoredPath(_this.toPath(fileOrDirectory));
                    if (!fileOrDirectoryPath)
                        return;
                    // Clear module specifier cache for any projects whose cache was affected by
                    // dependency package.jsons in this node_modules directory
                    var basename = ts.getBaseFileName(fileOrDirectoryPath);
                    if (((_a = result.affectedModuleSpecifierCacheProjects) === null || _a === void 0 ? void 0 : _a.size) && (basename === "package.json" || basename === "node_modules")) {
                        result.affectedModuleSpecifierCacheProjects.forEach(function (projectName) {
                            var _a, _b;
                            (_b = (_a = _this.findProject(projectName)) === null || _a === void 0 ? void 0 : _a.getModuleSpecifierCache()) === null || _b === void 0 ? void 0 : _b.clear();
                        });
                    }
                    // Refresh closed script info after an npm install
                    if (result.refreshScriptInfoRefCount) {
                        if (dir === fileOrDirectoryPath) {
                            _this.refreshScriptInfosInDirectory(dir);
                        }
                        else {
                            var info = _this.getScriptInfoForPath(fileOrDirectoryPath);
                            if (info) {
                                if (isScriptInfoWatchedFromNodeModules(info)) {
                                    _this.refreshScriptInfo(info);
                                }
                            }
                            // Folder
                            else if (!ts.hasExtension(fileOrDirectoryPath)) {
                                _this.refreshScriptInfosInDirectory(fileOrDirectoryPath);
                            }
                        }
                    }
                }, 1 /* Recursive */, this.hostConfiguration.watchOptions, ts.WatchType.NodeModules);
                var result = {
                    refreshScriptInfoRefCount: 0,
                    affectedModuleSpecifierCacheProjects: undefined,
                    close: function () {
                        var _a;
                        if (!result.refreshScriptInfoRefCount && !((_a = result.affectedModuleSpecifierCacheProjects) === null || _a === void 0 ? void 0 : _a.size)) {
                            watcher.close();
                            _this.nodeModulesWatchers.delete(dir);
                        }
                    },
                };
                this.nodeModulesWatchers.set(dir, result);
                return result;
            };
            /*@internal*/
            ProjectService.prototype.watchPackageJsonsInNodeModules = function (dir, project) {
                var watcher = this.nodeModulesWatchers.get(dir) || this.createNodeModulesWatcher(dir);
                (watcher.affectedModuleSpecifierCacheProjects || (watcher.affectedModuleSpecifierCacheProjects = new ts.Set())).add(project.getProjectName());
                return {
                    close: function () {
                        var _a;
                        (_a = watcher.affectedModuleSpecifierCacheProjects) === null || _a === void 0 ? void 0 : _a.delete(project.getProjectName());
                        watcher.close();
                    },
                };
            };
            ProjectService.prototype.watchClosedScriptInfoInNodeModules = function (dir) {
                var watchDir = dir + "/node_modules";
                var watcher = this.nodeModulesWatchers.get(watchDir) || this.createNodeModulesWatcher(watchDir);
                watcher.refreshScriptInfoRefCount++;
                return {
                    close: function () {
                        watcher.refreshScriptInfoRefCount--;
                        watcher.close();
                    },
                };
            };
            ProjectService.prototype.getModifiedTime = function (info) {
                return (this.host.getModifiedTime(info.path) || ts.missingFileModifiedTime).getTime();
            };
            ProjectService.prototype.refreshScriptInfo = function (info) {
                var mTime = this.getModifiedTime(info);
                if (mTime !== info.mTime) {
                    var eventKind = ts.getFileWatcherEventKind(info.mTime, mTime);
                    info.mTime = mTime;
                    this.onSourceFileChanged(info, eventKind);
                }
            };
            ProjectService.prototype.refreshScriptInfosInDirectory = function (dir) {
                var _this = this;
                dir = dir + ts.directorySeparator;
                this.filenameToScriptInfo.forEach(function (info) {
                    if (isScriptInfoWatchedFromNodeModules(info) && ts.startsWith(info.path, dir)) {
                        _this.refreshScriptInfo(info);
                    }
                });
            };
            ProjectService.prototype.stopWatchingScriptInfo = function (info) {
                if (info.fileWatcher) {
                    info.fileWatcher.close();
                    info.fileWatcher = undefined;
                }
            };
            ProjectService.prototype.getOrCreateScriptInfoNotOpenedByClientForNormalizedPath = function (fileName, currentDirectory, scriptKind, hasMixedContent, hostToQueryFileExistsOn) {
                if (ts.isRootedDiskPath(fileName) || server.isDynamicFileName(fileName)) {
                    return this.getOrCreateScriptInfoWorker(fileName, currentDirectory, /*openedByClient*/ false, /*fileContent*/ undefined, scriptKind, hasMixedContent, hostToQueryFileExistsOn);
                }
                // This is non rooted path with different current directory than project service current directory
                // Only paths recognized are open relative file paths
                var info = this.openFilesWithNonRootedDiskPath.get(this.toCanonicalFileName(fileName));
                if (info) {
                    return info;
                }
                // This means triple slash references wont be resolved in dynamic and unsaved files
                // which is intentional since we dont know what it means to be relative to non disk files
                return undefined;
            };
            ProjectService.prototype.getOrCreateScriptInfoOpenedByClientForNormalizedPath = function (fileName, currentDirectory, fileContent, scriptKind, hasMixedContent) {
                return this.getOrCreateScriptInfoWorker(fileName, currentDirectory, /*openedByClient*/ true, fileContent, scriptKind, hasMixedContent);
            };
            ProjectService.prototype.getOrCreateScriptInfoForNormalizedPath = function (fileName, openedByClient, fileContent, scriptKind, hasMixedContent, hostToQueryFileExistsOn) {
                return this.getOrCreateScriptInfoWorker(fileName, this.currentDirectory, openedByClient, fileContent, scriptKind, hasMixedContent, hostToQueryFileExistsOn);
            };
            ProjectService.prototype.getOrCreateScriptInfoWorker = function (fileName, currentDirectory, openedByClient, fileContent, scriptKind, hasMixedContent, hostToQueryFileExistsOn) {
                var _this = this;
                ts.Debug.assert(fileContent === undefined || openedByClient, "ScriptInfo needs to be opened by client to be able to set its user defined content");
                var path = server.normalizedPathToPath(fileName, currentDirectory, this.toCanonicalFileName);
                var info = this.getScriptInfoForPath(path);
                if (!info) {
                    var isDynamic = server.isDynamicFileName(fileName);
                    ts.Debug.assert(ts.isRootedDiskPath(fileName) || isDynamic || openedByClient, "", function () { return JSON.stringify({ fileName: fileName, currentDirectory: currentDirectory, hostCurrentDirectory: _this.currentDirectory, openKeys: ts.arrayFrom(_this.openFilesWithNonRootedDiskPath.keys()) }) + "\nScript info with non-dynamic relative file name can only be open script info or in context of host currentDirectory"; });
                    ts.Debug.assert(!ts.isRootedDiskPath(fileName) || this.currentDirectory === currentDirectory || !this.openFilesWithNonRootedDiskPath.has(this.toCanonicalFileName(fileName)), "", function () { return JSON.stringify({ fileName: fileName, currentDirectory: currentDirectory, hostCurrentDirectory: _this.currentDirectory, openKeys: ts.arrayFrom(_this.openFilesWithNonRootedDiskPath.keys()) }) + "\nOpen script files with non rooted disk path opened with current directory context cannot have same canonical names"; });
                    ts.Debug.assert(!isDynamic || this.currentDirectory === currentDirectory || this.useInferredProjectPerProjectRoot, "", function () { return JSON.stringify({ fileName: fileName, currentDirectory: currentDirectory, hostCurrentDirectory: _this.currentDirectory, openKeys: ts.arrayFrom(_this.openFilesWithNonRootedDiskPath.keys()) }) + "\nDynamic files must always be opened with service's current directory or service should support inferred project per projectRootPath."; });
                    // If the file is not opened by client and the file doesnot exist on the disk, return
                    if (!openedByClient && !isDynamic && !(hostToQueryFileExistsOn || this.host).fileExists(fileName)) {
                        return;
                    }
                    info = new server.ScriptInfo(this.host, fileName, scriptKind, !!hasMixedContent, path, this.filenameToScriptInfoVersion.get(path)); // TODO: GH#18217
                    this.filenameToScriptInfo.set(info.path, info);
                    this.filenameToScriptInfoVersion.delete(info.path);
                    if (!openedByClient) {
                        this.watchClosedScriptInfo(info);
                    }
                    else if (!ts.isRootedDiskPath(fileName) && (!isDynamic || this.currentDirectory !== currentDirectory)) {
                        // File that is opened by user but isn't rooted disk path
                        this.openFilesWithNonRootedDiskPath.set(this.toCanonicalFileName(fileName), info);
                    }
                }
                if (openedByClient) {
                    // Opening closed script info
                    // either it was created just now, or was part of projects but was closed
                    this.stopWatchingScriptInfo(info);
                    info.open(fileContent);
                    if (hasMixedContent) {
                        info.registerFileUpdate();
                    }
                }
                return info;
            };
            /**
             * This gets the script info for the normalized path. If the path is not rooted disk path then the open script info with project root context is preferred
             */
            ProjectService.prototype.getScriptInfoForNormalizedPath = function (fileName) {
                return !ts.isRootedDiskPath(fileName) && this.openFilesWithNonRootedDiskPath.get(this.toCanonicalFileName(fileName)) ||
                    this.getScriptInfoForPath(server.normalizedPathToPath(fileName, this.currentDirectory, this.toCanonicalFileName));
            };
            ProjectService.prototype.getScriptInfoForPath = function (fileName) {
                return this.filenameToScriptInfo.get(fileName);
            };
            /*@internal*/
            ProjectService.prototype.getDocumentPositionMapper = function (project, generatedFileName, sourceFileName) {
                var _this = this;
                // Since declaration info and map file watches arent updating project's directory structure host (which can cache file structure) use host
                var declarationInfo = this.getOrCreateScriptInfoNotOpenedByClient(generatedFileName, project.currentDirectory, this.host);
                if (!declarationInfo) {
                    if (sourceFileName) {
                        // Project contains source file and it generates the generated file name
                        project.addGeneratedFileWatch(generatedFileName, sourceFileName);
                    }
                    return undefined;
                }
                // Try to get from cache
                declarationInfo.getSnapshot(); // Ensure synchronized
                if (ts.isString(declarationInfo.sourceMapFilePath)) {
                    // Ensure mapper is synchronized
                    var sourceMapFileInfo_1 = this.getScriptInfoForPath(declarationInfo.sourceMapFilePath);
                    if (sourceMapFileInfo_1) {
                        sourceMapFileInfo_1.getSnapshot();
                        if (sourceMapFileInfo_1.documentPositionMapper !== undefined) {
                            sourceMapFileInfo_1.sourceInfos = this.addSourceInfoToSourceMap(sourceFileName, project, sourceMapFileInfo_1.sourceInfos);
                            return sourceMapFileInfo_1.documentPositionMapper ? sourceMapFileInfo_1.documentPositionMapper : undefined;
                        }
                    }
                    declarationInfo.sourceMapFilePath = undefined;
                }
                else if (declarationInfo.sourceMapFilePath) {
                    declarationInfo.sourceMapFilePath.sourceInfos = this.addSourceInfoToSourceMap(sourceFileName, project, declarationInfo.sourceMapFilePath.sourceInfos);
                    return undefined;
                }
                else if (declarationInfo.sourceMapFilePath !== undefined) {
                    // Doesnt have sourceMap
                    return undefined;
                }
                // Create the mapper
                var sourceMapFileInfo;
                var mapFileNameFromDeclarationInfo;
                var readMapFile = function (mapFileName, mapFileNameFromDts) {
                    var mapInfo = _this.getOrCreateScriptInfoNotOpenedByClient(mapFileName, project.currentDirectory, _this.host);
                    if (!mapInfo) {
                        mapFileNameFromDeclarationInfo = mapFileNameFromDts;
                        return undefined;
                    }
                    sourceMapFileInfo = mapInfo;
                    var snap = mapInfo.getSnapshot();
                    if (mapInfo.documentPositionMapper !== undefined)
                        return mapInfo.documentPositionMapper;
                    return ts.getSnapshotText(snap);
                };
                var projectName = project.projectName;
                var documentPositionMapper = ts.getDocumentPositionMapper({ getCanonicalFileName: this.toCanonicalFileName, log: function (s) { return _this.logger.info(s); }, getSourceFileLike: function (f) { return _this.getSourceFileLike(f, projectName, declarationInfo); } }, declarationInfo.fileName, declarationInfo.getLineInfo(), readMapFile);
                readMapFile = undefined; // Remove ref to project
                if (sourceMapFileInfo) {
                    declarationInfo.sourceMapFilePath = sourceMapFileInfo.path;
                    sourceMapFileInfo.declarationInfoPath = declarationInfo.path;
                    sourceMapFileInfo.documentPositionMapper = documentPositionMapper || false;
                    sourceMapFileInfo.sourceInfos = this.addSourceInfoToSourceMap(sourceFileName, project, sourceMapFileInfo.sourceInfos);
                }
                else if (mapFileNameFromDeclarationInfo) {
                    declarationInfo.sourceMapFilePath = {
                        watcher: this.addMissingSourceMapFile(project.currentDirectory === this.currentDirectory ?
                            mapFileNameFromDeclarationInfo :
                            ts.getNormalizedAbsolutePath(mapFileNameFromDeclarationInfo, project.currentDirectory), declarationInfo.path),
                        sourceInfos: this.addSourceInfoToSourceMap(sourceFileName, project)
                    };
                }
                else {
                    declarationInfo.sourceMapFilePath = false;
                }
                return documentPositionMapper;
            };
            ProjectService.prototype.addSourceInfoToSourceMap = function (sourceFileName, project, sourceInfos) {
                if (sourceFileName) {
                    // Attach as source
                    var sourceInfo = this.getOrCreateScriptInfoNotOpenedByClient(sourceFileName, project.currentDirectory, project.directoryStructureHost);
                    (sourceInfos || (sourceInfos = new ts.Set())).add(sourceInfo.path);
                }
                return sourceInfos;
            };
            ProjectService.prototype.addMissingSourceMapFile = function (mapFileName, declarationInfoPath) {
                var _this = this;
                var fileWatcher = this.watchFactory.watchFile(mapFileName, function () {
                    var declarationInfo = _this.getScriptInfoForPath(declarationInfoPath);
                    if (declarationInfo && declarationInfo.sourceMapFilePath && !ts.isString(declarationInfo.sourceMapFilePath)) {
                        // Update declaration and source projects
                        _this.delayUpdateProjectGraphs(declarationInfo.containingProjects, /*clearSourceMapperCache*/ true);
                        _this.delayUpdateSourceInfoProjects(declarationInfo.sourceMapFilePath.sourceInfos);
                        declarationInfo.closeSourceMapFileWatcher();
                    }
                }, ts.PollingInterval.High, this.hostConfiguration.watchOptions, ts.WatchType.MissingSourceMapFile);
                return fileWatcher;
            };
            /*@internal*/
            ProjectService.prototype.getSourceFileLike = function (fileName, projectNameOrProject, declarationInfo) {
                var project = projectNameOrProject.projectName ? projectNameOrProject : this.findProject(projectNameOrProject);
                if (project) {
                    var path = project.toPath(fileName);
                    var sourceFile = project.getSourceFile(path);
                    if (sourceFile && sourceFile.resolvedPath === path)
                        return sourceFile;
                }
                // Need to look for other files.
                var info = this.getOrCreateScriptInfoNotOpenedByClient(fileName, (project || this).currentDirectory, project ? project.directoryStructureHost : this.host);
                if (!info)
                    return undefined;
                // Attach as source
                if (declarationInfo && ts.isString(declarationInfo.sourceMapFilePath) && info !== declarationInfo) {
                    var sourceMapInfo = 