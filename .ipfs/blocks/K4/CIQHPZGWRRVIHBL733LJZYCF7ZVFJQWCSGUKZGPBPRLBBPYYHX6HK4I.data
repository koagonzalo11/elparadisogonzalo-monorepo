eTag(node) : undefined;
            if (tag) {
                return checkAssertionWorker(tag.typeExpression.type, tag.typeExpression.type, node.expression, checkMode);
            }
            return checkExpression(node.expression, checkMode);
        }
        function checkExpressionWorker(node, checkMode, forceTuple) {
            var kind = node.kind;
            if (cancellationToken) {
                // Only bother checking on a few construct kinds.  We don't want to be excessively
                // hitting the cancellation token on every node we check.
                switch (kind) {
                    case 224 /* ClassExpression */:
                    case 211 /* FunctionExpression */:
                    case 212 /* ArrowFunction */:
                        cancellationToken.throwIfCancellationRequested();
                }
            }
            switch (kind) {
                case 79 /* Identifier */:
                    return checkIdentifier(node, checkMode);
                case 108 /* ThisKeyword */:
                    return checkThisExpression(node);
                case 106 /* SuperKeyword */:
                    return checkSuperExpression(node);
                case 104 /* NullKeyword */:
                    return nullWideningType;
                case 14 /* NoSubstitutionTemplateLiteral */:
                case 10 /* StringLiteral */:
                    return getFreshTypeOfLiteralType(getStringLiteralType(node.text));
                case 8 /* NumericLiteral */:
                    checkGrammarNumericLiteral(node);
                    return getFreshTypeOfLiteralType(getNumberLiteralType(+node.text));
                case 9 /* BigIntLiteral */:
                    checkGrammarBigIntLiteral(node);
                    return getFreshTypeOfLiteralType(getBigIntLiteralType({
                        negative: false,
                        base10Value: ts.parsePseudoBigInt(node.text)
                    }));
                case 110 /* TrueKeyword */:
                    return trueType;
                case 95 /* FalseKeyword */:
                    return falseType;
                case 221 /* TemplateExpression */:
                    return checkTemplateExpression(node);
                case 13 /* RegularExpressionLiteral */:
                    return globalRegExpType;
                case 202 /* ArrayLiteralExpression */:
                    return checkArrayLiteral(node, checkMode, forceTuple);
                case 203 /* ObjectLiteralExpression */:
                    return checkObjectLiteral(node, checkMode);
                case 204 /* PropertyAccessExpression */:
                    return checkPropertyAccessExpression(node, checkMode);
                case 159 /* QualifiedName */:
                    return checkQualifiedName(node, checkMode);
                case 205 /* ElementAccessExpression */:
                    return checkIndexedAccess(node, checkMode);
                case 206 /* CallExpression */:
                    if (node.expression.kind === 100 /* ImportKeyword */) {
                        return checkImportCallExpression(node);
                    }
                // falls through
                case 207 /* NewExpression */:
                    return checkCallExpression(node, checkMode);
                case 208 /* TaggedTemplateExpression */:
                    return checkTaggedTemplateExpression(node);
                case 210 /* ParenthesizedExpression */:
                    return checkParenthesizedExpression(node, checkMode);
                case 224 /* ClassExpression */:
                    return checkClassExpression(node);
                case 211 /* FunctionExpression */:
                case 212 /* ArrowFunction */:
                    return checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
                case 214 /* TypeOfExpression */:
                    return checkTypeOfExpression(node);
                case 209 /* TypeAssertionExpression */:
                case 227 /* AsExpression */:
                    return checkAssertion(node);
                case 228 /* NonNullExpression */:
                    return checkNonNullAssertion(node);
                case 229 /* MetaProperty */:
                    return checkMetaProperty(node);
                case 213 /* DeleteExpression */:
                    return checkDeleteExpression(node);
                case 215 /* VoidExpression */:
                    return checkVoidExpression(node);
                case 216 /* AwaitExpression */:
                    return checkAwaitExpression(node);
                case 217 /* PrefixUnaryExpression */:
                    return checkPrefixUnaryExpression(node);
                case 218 /* PostfixUnaryExpression */:
                    return checkPostfixUnaryExpression(node);
                case 219 /* BinaryExpression */:
                    return checkBinaryExpression(node, checkMode);
                case 220 /* ConditionalExpression */:
                    return checkConditionalExpression(node, checkMode);
                case 223 /* SpreadElement */:
                    return checkSpreadExpression(node, checkMode);
                case 225 /* OmittedExpression */:
                    return undefinedWideningType;
                case 222 /* YieldExpression */:
                    return checkYieldExpression(node);
                case 230 /* SyntheticExpression */:
                    return checkSyntheticExpression(node);
                case 286 /* JsxExpression */:
                    return checkJsxExpression(node, checkMode);
                case 276 /* JsxElement */:
                    return checkJsxElement(node, checkMode);
                case 277 /* JsxSelfClosingElement */:
                    return checkJsxSelfClosingElement(node, checkMode);
                case 280 /* JsxFragment */:
                    return checkJsxFragment(node);
                case 284 /* JsxAttributes */:
                    return checkJsxAttributes(node, checkMode);
                case 278 /* JsxOpeningElement */:
                    ts.Debug.fail("Shouldn't ever directly check a JsxOpeningElement");
            }
            return errorType;
        }
        // DECLARATION AND STATEMENT TYPE CHECKING
        function checkTypeParameter(node) {
            // Grammar Checking
            if (node.expression) {
                grammarErrorOnFirstToken(node.expression, ts.Diagnostics.Type_expected);
            }
            checkSourceElement(node.constraint);
            checkSourceElement(node.default);
            var typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node));
            // Resolve base constraint to reveal circularity errors
            getBaseConstraintOfType(typeParameter);
            if (!hasNonCircularTypeParameterDefault(typeParameter)) {
                error(node.default, ts.Diagnostics.Type_parameter_0_has_a_circular_default, typeToString(typeParameter));
            }
            var constraintType = getConstraintOfTypeParameter(typeParameter);
            var defaultType = getDefaultFromTypeParameter(typeParameter);
            if (constraintType && defaultType) {
                checkTypeAssignableTo(defaultType, getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType), node.default, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
            }
            if (produceDiagnostics) {
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_parameter_name_cannot_be_0);
            }
        }
        function checkParameter(node) {
            // Grammar checking
            // It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs as the
            // Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code
            // or if its FunctionBody is strict code(11.1.5).
            checkGrammarDecoratorsAndModifiers(node);
            checkVariableLikeDeclaration(node);
            var func = ts.getContainingFunction(node);
            if (ts.hasSyntacticModifier(node, 16476 /* ParameterPropertyModifier */)) {
                if (!(func.kind === 169 /* Constructor */ && ts.nodeIsPresent(func.body))) {
                    error(node, ts.Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
                }
                if (func.kind === 169 /* Constructor */ && ts.isIdentifier(node.name) && node.name.escapedText === "constructor") {
                    error(node.name, ts.Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name);
                }
            }
            if (node.questionToken && ts.isBindingPattern(node.name) && func.body) {
                error(node, ts.Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature);
            }
            if (node.name && ts.isIdentifier(node.name) && (node.name.escapedText === "this" || node.name.escapedText === "new")) {
                if (func.parameters.indexOf(node) !== 0) {
                    error(node, ts.Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.escapedText);
                }
                if (func.kind === 169 /* Constructor */ || func.kind === 173 /* ConstructSignature */ || func.kind === 178 /* ConstructorType */) {
                    error(node, ts.Diagnostics.A_constructor_cannot_have_a_this_parameter);
                }
                if (func.kind === 212 /* ArrowFunction */) {
                    error(node, ts.Diagnostics.An_arrow_function_cannot_have_a_this_parameter);
                }
                if (func.kind === 170 /* GetAccessor */ || func.kind === 171 /* SetAccessor */) {
                    error(node, ts.Diagnostics.get_and_set_accessors_cannot_declare_this_parameters);
                }
            }
            // Only check rest parameter type if it's not a binding pattern. Since binding patterns are
            // not allowed in a rest parameter, we already have an error from checkGrammarParameterList.
            if (node.dotDotDotToken && !ts.isBindingPattern(node.name) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol(node.symbol)), anyReadonlyArrayType)) {
                error(node, ts.Diagnostics.A_rest_parameter_must_be_of_an_array_type);
            }
        }
        function checkTypePredicate(node) {
            var parent = getTypePredicateParent(node);
            if (!parent) {
                // The parent must not be valid.
                error(node, ts.Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
                return;
            }
            var signature = getSignatureFromDeclaration(parent);
            var typePredicate = getTypePredicateOfSignature(signature);
            if (!typePredicate) {
                return;
            }
            checkSourceElement(node.type);
            var parameterName = node.parameterName;
            if (typePredicate.kind === 0 /* This */ || typePredicate.kind === 2 /* AssertsThis */) {
                getTypeFromThisTypeNode(parameterName);
            }
            else {
                if (typePredicate.parameterIndex >= 0) {
                    if (signatureHasRestParameter(signature) && typePredicate.parameterIndex === signature.parameters.length - 1) {
                        error(parameterName, ts.Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter);
                    }
                    else {
                        if (typePredicate.type) {
                            var leadingError = function () { return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type); };
                            checkTypeAssignableTo(typePredicate.type, getTypeOfSymbol(signature.parameters[typePredicate.parameterIndex]), node.type, 
                            /*headMessage*/ undefined, leadingError);
                        }
                    }
                }
                else if (parameterName) {
                    var hasReportedError = false;
                    for (var _i = 0, _a = parent.parameters; _i < _a.length; _i++) {
                        var name = _a[_i].name;
                        if (ts.isBindingPattern(name) &&
                            checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName)) {
                            hasReportedError = true;
                            break;
                        }
                    }
                    if (!hasReportedError) {
                        error(node.parameterName, ts.Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName);
                    }
                }
            }
        }
        function getTypePredicateParent(node) {
            switch (node.parent.kind) {
                case 212 /* ArrowFunction */:
                case 172 /* CallSignature */:
                case 254 /* FunctionDeclaration */:
                case 211 /* FunctionExpression */:
                case 177 /* FunctionType */:
                case 167 /* MethodDeclaration */:
                case 166 /* MethodSignature */:
                    var parent = node.parent;
                    if (node === parent.type) {
                        return parent;
                    }
            }
        }
        function checkIfTypePredicateVariableIsDeclaredInBindingPattern(pattern, predicateVariableNode, predicateVariableName) {
            for (var _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                if (ts.isOmittedExpression(element)) {
                    continue;
                }
                var name = element.name;
                if (name.kind === 79 /* Identifier */ && name.escapedText === predicateVariableName) {
                    error(predicateVariableNode, ts.Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName);
                    return true;
                }
                else if (name.kind === 200 /* ArrayBindingPattern */ || name.kind === 199 /* ObjectBindingPattern */) {
                    if (checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, predicateVariableNode, predicateVariableName)) {
                        return true;
                    }
                }
            }
        }
        function checkSignatureDeclaration(node) {
            // Grammar checking
            if (node.kind === 174 /* IndexSignature */) {
                checkGrammarIndexSignature(node);
            }
            // TODO (yuisu): Remove this check in else-if when SyntaxKind.Construct is moved and ambient context is handled
            else if (node.kind === 177 /* FunctionType */ || node.kind === 254 /* FunctionDeclaration */ || node.kind === 178 /* ConstructorType */ ||
                node.kind === 172 /* CallSignature */ || node.kind === 169 /* Constructor */ ||
                node.kind === 173 /* ConstructSignature */) {
                checkGrammarFunctionLikeDeclaration(node);
            }
            var functionFlags = ts.getFunctionFlags(node);
            if (!(functionFlags & 4 /* Invalid */)) {
                // Async generators prior to ESNext require the __await and __asyncGenerator helpers
                if ((functionFlags & 3 /* AsyncGenerator */) === 3 /* AsyncGenerator */ && languageVersion < 99 /* ESNext */) {
                    checkExternalEmitHelpers(node, 6144 /* AsyncGeneratorIncludes */);
                }
                // Async functions prior to ES2017 require the __awaiter helper
                if ((functionFlags & 3 /* AsyncGenerator */) === 2 /* Async */ && languageVersion < 4 /* ES2017 */) {
                    checkExternalEmitHelpers(node, 64 /* Awaiter */);
                }
                // Generator functions, Async functions, and Async Generator functions prior to
                // ES2015 require the __generator helper
                if ((functionFlags & 3 /* AsyncGenerator */) !== 0 /* Normal */ && languageVersion < 2 /* ES2015 */) {
                    checkExternalEmitHelpers(node, 128 /* Generator */);
                }
            }
            checkTypeParameters(node.typeParameters);
            ts.forEach(node.parameters, checkParameter);
            // TODO(rbuckton): Should we start checking JSDoc types?
            if (node.type) {
                checkSourceElement(node.type);
            }
            if (produceDiagnostics) {
                checkCollisionWithArgumentsInGeneratedCode(node);
                var returnTypeNode = ts.getEffectiveReturnTypeNode(node);
                if (noImplicitAny && !returnTypeNode) {
                    switch (node.kind) {
                        case 173 /* ConstructSignature */:
                            error(node, ts.Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                        case 172 /* CallSignature */:
                            error(node, ts.Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                    }
                }
                if (returnTypeNode) {
                    var functionFlags_1 = ts.getFunctionFlags(node);
                    if ((functionFlags_1 & (4 /* Invalid */ | 1 /* Generator */)) === 1 /* Generator */) {
                        var returnType = getTypeFromTypeNode(returnTypeNode);
                        if (returnType === voidType) {
                            error(returnTypeNode, ts.Diagnostics.A_generator_cannot_have_a_void_type_annotation);
                        }
                        else {
                            // Naively, one could check that Generator<any, any, any> is assignable to the return type annotation.
                            // However, that would not catch the error in the following case.
                            //
                            //    interface BadGenerator extends Iterable<number>, Iterator<string> { }
                            //    function* g(): BadGenerator { } // Iterable and Iterator have different types!
                            //
                            var generatorYieldType = getIterationTypeOfGeneratorFunctionReturnType(0 /* Yield */, returnType, (functionFlags_1 & 2 /* Async */) !== 0) || anyType;
                            var generatorReturnType = getIterationTypeOfGeneratorFunctionReturnType(1 /* Return */, returnType, (functionFlags_1 & 2 /* Async */) !== 0) || generatorYieldType;
                            var generatorNextType = getIterationTypeOfGeneratorFunctionReturnType(2 /* Next */, returnType, (functionFlags_1 & 2 /* Async */) !== 0) || unknownType;
                            var generatorInstantiation = createGeneratorReturnType(generatorYieldType, generatorReturnType, generatorNextType, !!(functionFlags_1 & 2 /* Async */));
                            checkTypeAssignableTo(generatorInstantiation, returnType, returnTypeNode);
                        }
                    }
                    else if ((functionFlags_1 & 3 /* AsyncGenerator */) === 2 /* Async */) {
                        checkAsyncFunctionReturnType(node, returnTypeNode);
                    }
                }
                if (node.kind !== 174 /* IndexSignature */ && node.kind !== 312 /* JSDocFunctionType */) {
                    registerForUnusedIdentifiersCheck(node);
                }
            }
        }
        function checkClassForDuplicateDeclarations(node) {
            var instanceNames = new ts.Map();
            var staticNames = new ts.Map();
            // instance and static private identifiers share the same scope
            var privateIdentifiers = new ts.Map();
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (member.kind === 169 /* Constructor */) {
                    for (var _b = 0, _c = member.parameters; _b < _c.length; _b++) {
                        var param = _c[_b];
                        if (ts.isParameterPropertyDeclaration(param, member) && !ts.isBindingPattern(param.name)) {
                            addName(instanceNames, param.name, param.name.escapedText, 3 /* GetOrSetAccessor */);
                        }
                    }
                }
                else {
                    var isStaticMember = ts.isStatic(member);
                    var name = member.name;
                    if (!name) {
                        continue;
                    }
                    var isPrivate = ts.isPrivateIdentifier(name);
                    var privateStaticFlags = isPrivate && isStaticMember ? 16 /* PrivateStatic */ : 0;
                    var names = isPrivate ? privateIdentifiers :
                        isStaticMember ? staticNames :
                            instanceNames;
                    var memberName = name && ts.getPropertyNameForPropertyNameNode(name);
                    if (memberName) {
                        switch (member.kind) {
                            case 170 /* GetAccessor */:
                                addName(names, name, memberName, 1 /* GetAccessor */ | privateStaticFlags);
                                break;
                            case 171 /* SetAccessor */:
                                addName(names, name, memberName, 2 /* SetAccessor */ | privateStaticFlags);
                                break;
                            case 165 /* PropertyDeclaration */:
                                addName(names, name, memberName, 3 /* GetOrSetAccessor */ | privateStaticFlags);
                                break;
                            case 167 /* MethodDeclaration */:
                                addName(names, name, memberName, 8 /* Method */ | privateStaticFlags);
                                break;
                        }
                    }
                }
            }
            function addName(names, location, name, meaning) {
                var prev = names.get(name);
                if (prev) {
                    // For private identifiers, do not allow mixing of static and instance members with the same name
                    if ((prev & 16 /* PrivateStatic */) !== (meaning & 16 /* PrivateStatic */)) {
                        error(location, ts.Diagnostics.Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name, ts.getTextOfNode(location));
                    }
                    else {
                        var prevIsMethod = !!(prev & 8 /* Method */);
                        var isMethod = !!(meaning & 8 /* Method */);
                        if (prevIsMethod || isMethod) {
                            if (prevIsMethod !== isMethod) {
                                error(location, ts.Diagnostics.Duplicate_identifier_0, ts.getTextOfNode(location));
                            }
                            // If this is a method/method duplication is might be an overload, so this will be handled when overloads are considered
                        }
                        else if (prev & meaning & ~16 /* PrivateStatic */) {
                            error(location, ts.Diagnostics.Duplicate_identifier_0, ts.getTextOfNode(location));
                        }
                        else {
                            names.set(name, prev | meaning);
                        }
                    }
                }
                else {
                    names.set(name, meaning);
                }
            }
        }
        /**
         * Static members being set on a constructor function may conflict with built-in properties
         * of Function. Esp. in ECMAScript 5 there are non-configurable and non-writable
         * built-in properties. This check issues a transpile error when a class has a static
         * member with the same name as a non-writable built-in property.
         *
         * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.3
         * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.5
         * @see http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-the-function-constructor
         * @see http://www.ecma-international.org/ecma-262/6.0/#sec-function-instances
         */
        function checkClassForStaticPropertyNameConflicts(node) {
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                var memberNameNode = member.name;
                var isStaticMember = ts.isStatic(member);
                if (isStaticMember && memberNameNode) {
                    var memberName = ts.getPropertyNameForPropertyNameNode(memberNameNode);
                    switch (memberName) {
                        case "name":
                        case "length":
                        case "caller":
                        case "arguments":
                        case "prototype":
                            var message = ts.Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1;
                            var className = getNameOfSymbolAsWritten(getSymbolOfNode(node));
                            error(memberNameNode, message, memberName, className);
                            break;
                    }
                }
            }
        }
        function checkObjectTypeForDuplicateDeclarations(node) {
            var names = new ts.Map();
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (member.kind === 164 /* PropertySignature */) {
                    var memberName = void 0;
                    var name = member.name;
                    switch (name.kind) {
                        case 10 /* StringLiteral */:
                        case 8 /* NumericLiteral */:
                            memberName = name.text;
                            break;
                        case 79 /* Identifier */:
                            memberName = ts.idText(name);
                            break;
                        default:
                            continue;
                    }
                    if (names.get(memberName)) {
                        error(ts.getNameOfDeclaration(member.symbol.valueDeclaration), ts.Diagnostics.Duplicate_identifier_0, memberName);
                        error(member.name, ts.Diagnostics.Duplicate_identifier_0, memberName);
                    }
                    else {
                        names.set(memberName, true);
                    }
                }
            }
        }
        function checkTypeForDuplicateIndexSignatures(node) {
            if (node.kind === 256 /* InterfaceDeclaration */) {
                var nodeSymbol = getSymbolOfNode(node);
                // in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration
                // to prevent this run check only for the first declaration of a given kind
                if (nodeSymbol.declarations && nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {
                    return;
                }
            }
            // TypeScript 1.0 spec (April 2014)
            // 3.7.4: An object type can contain at most one string index signature and one numeric index signature.
            // 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration
            var indexSymbol = getIndexSymbol(getSymbolOfNode(node));
            if (indexSymbol === null || indexSymbol === void 0 ? void 0 : indexSymbol.declarations) {
                var indexSignatureMap_1 = new ts.Map();
                var _loop_26 = function (declaration) {
                    if (declaration.parameters.length === 1 && declaration.parameters[0].type) {
                        forEachType(getTypeFromTypeNode(declaration.parameters[0].type), function (type) {
                            var entry = indexSignatureMap_1.get(getTypeId(type));
                            if (entry) {
                                entry.declarations.push(declaration);
                            }
                            else {
                                indexSignatureMap_1.set(getTypeId(type), { type: type, declarations: [declaration] });
                            }
                        });
                    }
                };
                for (var _i = 0, _a = indexSymbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    _loop_26(declaration);
                }
                indexSignatureMap_1.forEach(function (entry) {
                    if (entry.declarations.length > 1) {
                        for (var _i = 0, _a = entry.declarations; _i < _a.length; _i++) {
                            var declaration = _a[_i];
                            error(declaration, ts.Diagnostics.Duplicate_index_signature_for_type_0, typeToString(entry.type));
                        }
                    }
                });
            }
        }
        function checkPropertyDeclaration(node) {
            // Grammar checking
            if (!checkGrammarDecoratorsAndModifiers(node) && !checkGrammarProperty(node))
                checkGrammarComputedPropertyName(node.name);
            checkVariableLikeDeclaration(node);
            setNodeLinksForPrivateIdentifierScope(node);
            if (ts.isPrivateIdentifier(node.name) && ts.hasStaticModifier(node) && node.initializer && languageVersion === 99 /* ESNext */ && !compilerOptions.useDefineForClassFields) {
                error(node.initializer, ts.Diagnostics.Static_fields_with_private_names_can_t_have_initializers_when_the_useDefineForClassFields_flag_is_not_specified_with_a_target_of_esnext_Consider_adding_the_useDefineForClassFields_flag);
            }
            // property signatures already report "initializer not allowed in ambient context" elsewhere
            if (ts.hasSyntacticModifier(node, 128 /* Abstract */) && node.kind === 165 /* PropertyDeclaration */ && node.initializer) {
                error(node, ts.Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract, ts.declarationNameToString(node.name));
            }
        }
        function checkPropertySignature(node) {
            if (ts.isPrivateIdentifier(node.name)) {
                error(node, ts.Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
            }
            return checkPropertyDeclaration(node);
        }
        function checkMethodDeclaration(node) {
            // Grammar checking
            if (!checkGrammarMethod(node))
                checkGrammarComputedPropertyName(node.name);
            // Grammar checking for modifiers is done inside the function checkGrammarFunctionLikeDeclaration
            checkFunctionOrMethodDeclaration(node);
            // method signatures already report "implementation not allowed in ambient context" elsewhere
            if (ts.hasSyntacticModifier(node, 128 /* Abstract */) && node.kind === 167 /* MethodDeclaration */ && node.body) {
                error(node, ts.Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, ts.declarationNameToString(node.name));
            }
            // Private named methods are only allowed in class declarations
            if (ts.isPrivateIdentifier(node.name) && !ts.getContainingClass(node)) {
                error(node, ts.Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
            }
            setNodeLinksForPrivateIdentifierScope(node);
        }
        function setNodeLinksForPrivateIdentifierScope(node) {
            if (ts.isPrivateIdentifier(node.name) && languageVersion < 99 /* ESNext */) {
                for (var lexicalScope = ts.getEnclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = ts.getEnclosingBlockScopeContainer(lexicalScope)) {
                    getNodeLinks(lexicalScope).flags |= 67108864 /* ContainsClassWithPrivateIdentifiers */;
                }
                // If this is a private element in a class expression inside the body of a loop,
                // then we must use a block-scoped binding to store the additional variables required
                // to transform private elements.
                if (ts.isClassExpression(node.parent)) {
                    var enclosingIterationStatement = getEnclosingIterationStatement(node.parent);
                    if (enclosingIterationStatement) {
                        getNodeLinks(node.name).flags |= 524288 /* BlockScopedBindingInLoop */;
                        getNodeLinks(enclosingIterationStatement).flags |= 65536 /* LoopWithCapturedBlockScopedBinding */;
                    }
                }
            }
        }
        function checkClassStaticBlockDeclaration(node) {
            checkGrammarDecoratorsAndModifiers(node);
            ts.forEachChild(node, checkSourceElement);
        }
        function checkConstructorDeclaration(node) {
            // Grammar check on signature of constructor and modifier of the constructor is done in checkSignatureDeclaration function.
            checkSignatureDeclaration(node);
            // Grammar check for checking only related to constructorDeclaration
            if (!checkGrammarConstructorTypeParameters(node))
                checkGrammarConstructorTypeAnnotation(node);
            checkSourceElement(node.body);
            var symbol = getSymbolOfNode(node);
            var firstDeclaration = ts.getDeclarationOfKind(symbol, node.kind);
            // Only type check the symbol once
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(symbol);
            }
            // exit early in the case of signature - super checks are not relevant to them
            if (ts.nodeIsMissing(node.body)) {
                return;
            }
            if (!produceDiagnostics) {
                return;
            }
            function isInstancePropertyWithInitializerOrPrivateIdentifierProperty(n) {
                if (ts.isPrivateIdentifierClassElementDeclaration(n)) {
                    return true;
                }
                return n.kind === 165 /* PropertyDeclaration */ &&
                    !ts.isStatic(n) &&
                    !!n.initializer;
            }
            // TS 1.0 spec (April 2014): 8.3.2
            // Constructors of classes with no extends clause may not contain super calls, whereas
            // constructors of derived classes must contain at least one super call somewhere in their function body.
            var containingClassDecl = node.parent;
            if (ts.getClassExtendsHeritageElement(containingClassDecl)) {
                captureLexicalThis(node.parent, containingClassDecl);
                var classExtendsNull = classDeclarationExtendsNull(containingClassDecl);
                var superCall = findFirstSuperCall(node.body);
                if (superCall) {
                    if (classExtendsNull) {
                        error(superCall, ts.Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null);
                    }
                    // The first statement in the body of a constructor (excluding prologue directives) must be a super call
                    // if both of the following are true:
                    // - The containing class is a derived class.
                    // - The constructor declares parameter properties
                    //   or the containing class declares instance member variables with initializers.
                    var superCallShouldBeFirst = (compilerOptions.target !== 99 /* ESNext */ || !useDefineForClassFields) &&
                        (ts.some(node.parent.members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) ||
                            ts.some(node.parameters, function (p) { return ts.hasSyntacticModifier(p, 16476 /* ParameterPropertyModifier */); }));
                    // Skip past any prologue directives to find the first statement
                    // to ensure that it was a super call.
                    if (superCallShouldBeFirst) {
                        var statements = node.body.statements;
                        var superCallStatement = void 0;
                        for (var _i = 0, statements_4 = statements; _i < statements_4.length; _i++) {
                            var statement = statements_4[_i];
                            if (statement.kind === 236 /* ExpressionStatement */ && ts.isSuperCall(statement.expression)) {
                                superCallStatement = statement;
                                break;
                            }
                            if (!ts.isPrologueDirective(statement)) {
                                break;
                            }
                        }
                        if (!superCallStatement) {
                            error(node, ts.Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_parameter_properties_or_private_identifiers);
                        }
                    }
                }
                else if (!classExtendsNull) {
                    error(node, ts.Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call);
                }
            }
        }
        function checkAccessorDeclaration(node) {
            if (produceDiagnostics) {
                // Grammar checking accessors
                if (!checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(node))
                    checkGrammarComputedPropertyName(node.name);
                checkDecorators(node);
                checkSignatureDeclaration(node);
                if (node.kind === 170 /* GetAccessor */) {
                    if (!(node.flags & 8388608 /* Ambient */) && ts.nodeIsPresent(node.body) && (node.flags & 256 /* HasImplicitReturn */)) {
                        if (!(node.flags & 512 /* HasExplicitReturn */)) {
                            error(node.name, ts.Diagnostics.A_get_accessor_must_return_a_value);
                        }
                    }
                }
                // Do not use hasDynamicName here, because that returns false for well known symbols.
                // We want to perform checkComputedPropertyName for all computed properties, including
                // well known symbols.
                if (node.name.kind === 160 /* ComputedPropertyName */) {
                    checkComputedPropertyName(node.name);
                }
                if (hasBindableName(node)) {
                    // TypeScript 1.0 spec (April 2014): 8.4.3
                    // Accessors for the same member name must specify the same accessibility.
                    var symbol = getSymbolOfNode(node);
                    var getter = ts.getDeclarationOfKind(symbol, 170 /* GetAccessor */);
                    var setter = ts.getDeclarationOfKind(symbol, 171 /* SetAccessor */);
                    if (getter && setter && !(getNodeCheckFlags(getter) & 1 /* TypeChecked */)) {
                        getNodeLinks(getter).flags |= 1 /* TypeChecked */;
                        var getterFlags = ts.getEffectiveModifierFlags(getter);
                        var setterFlags = ts.getEffectiveModifierFlags(setter);
                        if ((getterFlags & 128 /* Abstract */) !== (setterFlags & 128 /* Abstract */)) {
                            error(getter.name, ts.Diagnostics.Accessors_must_both_be_abstract_or_non_abstract);
                            error(setter.name, ts.Diagnostics.Accessors_must_both_be_abstract_or_non_abstract);
                        }
                        if (((getterFlags & 16 /* Protected */) && !(setterFlags & (16 /* Protected */ | 8 /* Private */))) ||
                            ((getterFlags & 8 /* Private */) && !(setterFlags & 8 /* Private */))) {
                            error(getter.name, ts.Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter);
                            error(setter.name, ts.Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter);
                        }
                        var getterType = getAnnotatedAccessorType(getter);
                        var setterType = getAnnotatedAccessorType(setter);
                        if (getterType && setterType) {
                            checkTypeAssignableTo(getterType, setterType, getter, ts.Diagnostics.The_return_type_of_a_get_accessor_must_be_assignable_to_its_set_accessor_type);
                        }
                    }
                }
                var returnType = getTypeOfAccessors(getSymbolOfNode(node));
                if (node.kind === 170 /* GetAccessor */) {
                    checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
                }
            }
            checkSourceElement(node.body);
            setNodeLinksForPrivateIdentifierScope(node);
        }
        function checkMissingDeclaration(node) {
            checkDecorators(node);
        }
        function getEffectiveTypeArguments(node, typeParameters) {
            return fillMissingTypeArguments(ts.map(node.typeArguments, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), ts.isInJSFile(node));
        }
        function checkTypeArgumentConstraints(node, typeParameters) {
            var typeArguments;
            var mapper;
            var result = true;
            for (var i = 0; i < typeParameters.length; i++) {
                var constraint = getConstraintOfTypeParameter(typeParameters[i]);
                if (constraint) {
                    if (!typeArguments) {
                        typeArguments = getEffectiveTypeArguments(node, typeParameters);
                        mapper = createTypeMapper(typeParameters, typeArguments);
                    }
                    result = result && checkTypeAssignableTo(typeArguments[i], instantiateType(constraint, mapper), node.typeArguments[i], ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
                }
            }
            return result;
        }
        function getTypeParametersForTypeReference(node) {
            var type = getTypeFromTypeReference(node);
            if (type !== errorType) {
                var symbol = getNodeLinks(node).resolvedSymbol;
                if (symbol) {
                    return symbol.flags & 524288 /* TypeAlias */ && getSymbolLinks(symbol).typeParameters ||
                        (ts.getObjectFlags(type) & 4 /* Reference */ ? type.target.localTypeParameters : undefined);
                }
            }
            return undefined;
        }
        function checkTypeReferenceNode(node) {
            checkGrammarTypeArguments(node, node.typeArguments);
            if (node.kind === 176 /* TypeReference */ && node.typeName.jsdocDotPos !== undefined && !ts.isInJSFile(node) && !ts.isInJSDoc(node)) {
                grammarErrorAtPos(node, node.typeName.jsdocDotPos, 1, ts.Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments);
            }
            ts.forEach(node.typeArguments, checkSourceElement);
            var type = getTypeFromTypeReference(node);
            if (type !== errorType) {
                if (node.typeArguments && produceDiagnostics) {
                    var typeParameters = getTypeParametersForTypeReference(node);
                    if (typeParameters) {
                        checkTypeArgumentConstraints(node, typeParameters);
                    }
                }
                var symbol = getNodeLinks(node).resolvedSymbol;
                if (symbol) {
                    if (ts.some(symbol.declarations, function (d) { return isTypeDeclaration(d) && !!(d.flags & 134217728 /* Deprecated */); })) {
                        addDeprecatedSuggestion(getDeprecatedSuggestionNode(node), symbol.declarations, symbol.escapedName);
                    }
                    if (type.flags & 32 /* Enum */ && symbol.flags & 8 /* EnumMember */) {
                        error(node, ts.Diagnostics.Enum_type_0_has_members_with_initializers_that_are_not_literals, typeToString(type));
                    }
                }
            }
        }
        function getTypeArgumentConstraint(node) {
            var typeReferenceNode = ts.tryCast(node.parent, ts.isTypeReferenceType);
            if (!typeReferenceNode)
                return undefined;
            var typeParameters = getTypeParametersForTypeReference(typeReferenceNode); // TODO: GH#18217
            var constraint = getConstraintOfTypeParameter(typeParameters[typeReferenceNode.typeArguments.indexOf(node)]);
            return constraint && instantiateType(constraint, createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReferenceNode, typeParameters)));
        }
        function checkTypeQuery(node) {
            getTypeFromTypeQueryNode(node);
        }
        function checkTypeLiteral(node) {
            ts.forEach(node.members, checkSourceElement);
            if (produceDiagnostics) {
                var type = getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
                checkIndexConstraints(type);
                checkTypeForDuplicateIndexSignatures(node);
                checkObjectTypeForDuplicateDeclarations(node);
            }
        }
        function checkArrayType(node) {
            checkSourceElement(node.elementType);
        }
        function checkTupleType(node) {
            var elementTypes = node.elements;
            var seenOptionalElement = false;
            var seenRestElement = false;
            var hasNamedElement = ts.some(elementTypes, ts.isNamedTupleMember);
            for (var _i = 0, elementTypes_1 = elementTypes; _i < elementTypes_1.length; _i++) {
                var e = elementTypes_1[_i];
                if (e.kind !== 195 /* NamedTupleMember */ && hasNamedElement) {
                    grammarErrorOnNode(e, ts.Diagnostics.Tuple_members_must_all_have_names_or_all_not_have_names);
                    break;
                }
                var flags = getTupleElementFlags(e);
                if (flags & 8 /* Variadic */) {
                    var type = getTypeFromTypeNode(e.type);
                    if (!isArrayLikeType(type)) {
                        error(e, ts.Diagnostics.A_rest_element_type_must_be_an_array_type);
                        break;
                    }
                    if (isArrayType(type) || isTupleType(type) && type.target.combinedFlags & 4 /* Rest */) {
                        seenRestElement = true;
                    }
                }
                else if (flags & 4 /* Rest */) {
                    if (seenRestElement) {
                        grammarErrorOnNode(e, ts.Diagnostics.A_rest_element_cannot_follow_another_rest_element);
                        break;
                    }
                    seenRestElement = true;
                }
                else if (flags & 2 /* Optional */) {
                    if (seenRestElement) {
                        grammarErrorOnNode(e, ts.Diagnostics.An_optional_element_cannot_follow_a_rest_element);
                        break;
                    }
                    seenOptionalElement = true;
                }
                else if (seenOptionalElement) {
                    grammarErrorOnNode(e, ts.Diagnostics.A_required_element_cannot_follow_an_optional_element);
                    break;
                }
            }
            ts.forEach(node.elements, checkSourceElement);
            getTypeFromTypeNode(node);
        }
        function checkUnionOrIntersectionType(node) {
            ts.forEach(node.types, checkSourceElement);
            getTypeFromTypeNode(node);
        }
        function checkIndexedAccessIndexType(type, accessNode) {
            if (!(type.flags & 8388608 /* IndexedAccess */)) {
                return type;
            }
            // Check if the index type is assignable to 'keyof T' for the object type.
            var objectType = type.objectType;
            var indexType = type.indexType;
            if (isTypeAssignableTo(indexType, getIndexType(objectType, /*stringsOnly*/ false))) {
                if (accessNode.kind === 205 /* ElementAccessExpression */ && ts.isAssignmentTarget(accessNode) &&
                    ts.getObjectFlags(objectType) & 32 /* Mapped */ && getMappedTypeModifiers(objectType) & 1 /* IncludeReadonly */) {
                    error(accessNode, ts.Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
                }
                return type;
            }
            // Check if we're indexing with a numeric type and if either object or index types
            // is a generic type with a constraint that has a numeric index signature.
            var apparentObjectType = getApparentType(objectType);
            if (getIndexInfoOfType(apparentObjectType, numberType) && isTypeAssignableToKind(indexType, 296 /* NumberLike */)) {
                return type;
            }
            if (isGenericObjectType(objectType)) {
                var propertyName_1 = getPropertyNameFromIndex(indexType, accessNode);
                if (propertyName_1) {
                    var propertySymbol = forEachType(apparentObjectType, function (t) { return getPropertyOfType(t, propertyName_1); });
                    if (propertySymbol && ts.getDeclarationModifierFlagsFromSymbol(propertySymbol) & 24 /* NonPublicAccessibilityModifier */) {
                        error(accessNode, ts.Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, ts.unescapeLeadingUnderscores(propertyName_1));
                        return errorType;
                    }
                }
            }
            error(accessNode, ts.Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType));
            return errorType;
        }
        function checkIndexedAccessType(node) {
            checkSourceElement(node.objectType);
            checkSourceElement(node.indexType);
            checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node);
        }
        function checkMappedType(node) {
            checkSourceElement(node.typeParameter);
            checkSourceElement(node.nameType);
            checkSourceElement(node.type);
            if (!node.type) {
                reportImplicitAny(node, anyType);
            }
            var type = getTypeFromMappedTypeNode(node);
            var nameType = getNameTypeFromMappedType(type);
            if (nameType) {
                checkTypeAssignableTo(nameType, keyofConstraintType, node.nameType);
            }
            else {
                var constraintType = getConstraintTypeFromMappedType(type);
                checkTypeAssignableTo(constraintType, keyofConstraintType, ts.getEffectiveConstraintOfTypeParameter(node.typeParameter));
            }
        }
        function checkThisType(node) {
            getTypeFromThisTypeNode(node);
        }
        function checkTypeOperator(node) {
            checkGrammarTypeOperatorNode(node);
            checkSourceElement(node.type);
        }
        function checkConditionalType(node) {
            ts.forEachChild(node, checkSourceElement);
        }
        function checkInferType(node) {
            if (!ts.findAncestor(node, function (n) { return n.parent && n.parent.kind === 187 /* ConditionalType */ && n.parent.extendsType === n; })) {
                grammarErrorOnNode(node, ts.Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type);
            }
            checkSourceElement(node.typeParameter);
            registerForUnusedIdentifiersCheck(node);
        }
        function checkTemplateLiteralType(node) {
            for (var _i = 0, _a = node.templateSpans; _i < _a.length; _i++) {
                var span = _a[_i];
                checkSourceElement(span.type);
                var type = getTypeFromTypeNode(span.type);
                checkTypeAssignableTo(type, templateConstraintType, span.type);
            }
            getTypeFromTypeNode(node);
        }
        function checkImportType(node) {
            checkSourceElement(node.argument);
            getTypeFromTypeNode(node);
        }
        function checkNamedTupleMember(node) {
            if (node.dotDotDotToken && node.questionToken) {
                grammarErrorOnNode(node, ts.Diagnostics.A_tuple_member_cannot_be_both_optional_and_rest);
            }
            if (node.type.kind === 183 /* OptionalType */) {
                grammarErrorOnNode(node.type, ts.Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type);
            }
            if (node.type.kind === 184 /* RestType */) {
                grammarErrorOnNode(node.type, ts.Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type);
            }
            checkSourceElement(node.type);
            getTypeFromTypeNode(node);
        }
        function isPrivateWithinAmbient(node) {
            return (ts.hasEffectiveModifier(node, 8 /* Private */) || ts.isPrivateIdentifierClassElementDeclaration(node)) && !!(node.flags & 8388608 /* Ambient */);
        }
        function getEffectiveDeclarationFlags(n, flagsToCheck) {
            var flags = ts.getCombinedModifierFlags(n);
            // children of classes (even ambient classes) should not be marked as ambient or export
            // because those flags have no useful semantics there.
            if (n.parent.kind !== 256 /* InterfaceDeclaration */ &&
                n.parent.kind !== 255 /* ClassDeclaration */ &&
                n.parent.kind !== 224 /* ClassExpression */ &&
                n.flags & 8388608 /* Ambient */) {
                if (!(flags & 2 /* Ambient */) && !(ts.isModuleBlock(n.parent) && ts.isModuleDeclaration(n.parent.parent) && ts.isGlobalScopeAugmentation(n.parent.parent))) {
                    // It is nested in an ambient context, which means it is automatically exported
                    flags |= 1 /* Export */;
                }
                flags |= 2 /* Ambient */;
            }
            return flags & flagsToCheck;
        }
        function checkFunctionOrConstructorSymbol(symbol) {
            if (!produceDiagnostics) {
                return;
            }
            function getCanonicalOverload(overloads, implementation) {
                // Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration
                // Error on all deviations from this canonical set of flags
                // The caveat is that if some overloads are defined in lib.d.ts, we don't want to
                // report the errors on those. To achieve this, we will say that the implementation is
                // the canonical signature only if it is in the same container as the first overload
                var implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;
                return implementationSharesContainerWithFirstOverload ? implementation : overloads[0];
            }
            function checkFlagAgreementBetweenOverloads(overloads, implementation, flagsToCheck, someOverloadFlags, allOverloadFlags) {
                // Error if some overloads have a flag that is not shared by all overloads. To find the
                // deviations, we XOR someOverloadFlags with allOverloadFlags
                var someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
                if (someButNotAllOverloadFlags !== 0) {
                    var canonicalFlags_1 = getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck);
                    ts.forEach(overloads, function (o) {
                        var deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags_1;
                        if (deviation & 1 /* Export */) {
                            error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported);
                        }
                        else if (deviation & 2 /* Ambient */) {
                            error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);
                        }
                        else if (deviation & (8 /* Private */ | 16 /* Protected */)) {
                            error(ts.getNameOfDeclaration(o) || o, ts.Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);
                        }
                        else if (deviation & 128 /* Abstract */) {
                            error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract);
                        }
                    });
                }
            }
            function checkQuestionTokenAgreementBetweenOverloads(overloads, implementation, someHaveQuestionToken, allHaveQuestionToken) {
                if (someHaveQuestionToken !== allHaveQuestionToken) {
                    var canonicalHasQuestionToken_1 = ts.hasQuestionToken(getCanonicalOverload(overloads, implementation));
                    ts.forEach(overloads, function (o) {
                        var deviation = ts.hasQuestionToken(o) !== canonicalHasQuestionToken_1;
                        if (deviation) {
                            error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_optional_or_required);
                        }
                    });
                }
            }
            var flagsToCheck = 1 /* Export */ | 2 /* Ambient */ | 8 /* Private */ | 16 /* Protected */ | 128 /* Abstract */;
            var someNodeFlags = 0 /* None */;
            var allNodeFlags = flagsToCheck;
            var someHaveQuestionToken = false;
            var allHaveQuestionToken = true;
            var hasOverloads = false;
            var bodyDeclaration;
            var lastSeenNonAmbientDeclaration;
            var previousDeclaration;
            var declarations = symbol.declarations;
            var isConstructor = (symbol.flags & 16384 /* Constructor */) !== 0;
            function reportImplementationExpectedError(node) {
                if (node.name && ts.nodeIsMissing(node.name)) {
                    return;
                }
                var seen = false;
                var subsequentNode = ts.forEachChild(node.parent, function (c) {
                    if (seen) {
                        return c;
                    }
                    else {
                        seen = c === node;
                    }
                });
                // We may be here because of some extra nodes between overloads that could not be parsed into a valid node.
                // In this case the subsequent node is not really consecutive (.pos !== node.end), and we must ignore it here.
                if (subsequentNode && subsequentNode.pos === node.end) {
                    if (subsequentNode.kind === node.kind) {
                        var errorNode_1 = subsequentNode.name || subsequentNode;
                        var subsequentName = subsequentNode.name;
                        if (node.name && subsequentName && (
                        // both are private identifiers
                        ts.isPrivateIdentifier(node.name) && ts.isPrivateIdentifier(subsequentName) && node.name.escapedText === subsequentName.escapedText ||
                            // Both are computed property names
                            // TODO: GH#17345: These are methods, so handle computed name case. (`Always allowing computed property names is *not* the correct behavior!)
                            ts.isComputedPropertyName(node.name) && ts.isComputedPropertyName(subsequentName) ||
                            // Both are literal property names that are the same.
                            ts.isPropertyNameLiteral(node.name) && ts.isPropertyNameLiteral(subsequentName) &&
                                ts.getEscapedTextOfIdentifierOrLiteral(node.name) === ts.getEscapedTextOfIdentifierOrLiteral(subsequentName))) {
                            var reportError = (node.kind === 167 /* MethodDeclaration */ || node.kind === 166 /* MethodSignature */) &&
                                ts.isStatic(node) !== ts.isStatic(subsequentNode);
                            // we can get here in two cases
                            // 1. mixed static and instance class members
                            // 2. something with the same name was defined before the set of overloads that prevents them from merging
                            // here we'll report error only for the first case since for second we should already report error in binder
                            if (reportError) {
                                var diagnostic = ts.isStatic(node) ? ts.Diagnostics.Function_overload_must_be_static : ts.Diagnostics.Function_overload_must_not_be_static;
                                error(errorNode_1, diagnostic);
                            }
                            return;
                        }
                        if (ts.nodeIsPresent(subsequentNode.body)) {
                            error(errorNode_1, ts.Diagnostics.Function_implementation_name_must_be_0, ts.declarationNameToString(node.name));
                            return;
                        }
                    }
                }
                var errorNode = node.name || node;
                if (isConstructor) {
                    error(errorNode, ts.Diagnostics.Constructor_implementation_is_missing);
                }
                else {
                    // Report different errors regarding non-consecutive blocks of declarations depending on whether
                    // the node in question is abstract.
                    if (ts.hasSyntacticModifier(node, 128 /* Abstract */)) {
                        error(errorNode, ts.Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive);
                    }
                    else {
                        error(errorNode, ts.Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
                    }
                }
            }
            var duplicateFunctionDeclaration = false;
            var multipleConstructorImplementation = false;
            var hasNonAmbientClass = false;
            var functionDeclarations = [];
            if (declarations) {
                for (var _i = 0, declarations_4 = declarations; _i < declarations_4.length; _i++) {
                    var current = declarations_4[_i];
                    var node = current;
                    var inAmbientContext = node.flags & 8388608 /* Ambient */;
                    var inAmbientContextOrInterface = node.parent && (node.parent.kind === 256 /* InterfaceDeclaration */ || node.parent.kind === 180 /* TypeLiteral */) || inAmbientContext;
                    if (inAmbientContextOrInterface) {
                        // check if declarations are consecutive only if they are non-ambient
                        // 1. ambient declarations can be interleaved
                        // i.e. this is legal
                        //     declare function foo();
                        //     declare function bar();
                        //     declare function foo();
                        // 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one
                        previousDeclaration = undefined;
                    }
                    if ((node.kind === 255 /* ClassDeclaration */ || node.kind === 224 /* ClassExpression */) && !inAmbientContext) {
                        hasNonAmbientClass = true;
                    }
                    if (node.kind === 254 /* FunctionDeclaration */ || node.kind === 167 /* MethodDeclaration */ || node.kind === 166 /* MethodSignature */ || node.kind === 169 /* Constructor */) {
                        functionDeclarations.push(node);
                        var currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);
                        someNodeFlags |= currentNodeFlags;
                        allNodeFlags &= currentNodeFlags;
                        someHaveQuestionToken = someHaveQuestionToken || ts.hasQuestionToken(node);
                        allHaveQuestionToken = allHaveQuestionToken && ts.hasQuestionToken(node);
                        var bodyIsPresent = ts.nodeIsPresent(node.body);
                        if (bodyIsPresent && bodyDeclaration) {
                            if (isConstructor) {
                                multipleConstructorImplementation = true;
                            }
                            else {
                                duplicateFunctionDeclaration = true;
                            }
                        }
                        else if ((previousDeclaration === null || previousDeclaration === void 0 ? void 0 : previousDeclaration.parent) === node.parent && previousDeclaration.end !== node.pos) {
                            reportImplementationExpectedError(previousDeclaration);
                        }
                        if (bodyIsPresent) {
                            if (!bodyDeclaration) {
                                bodyDeclaration = node;
                            }
                        }
                        else {
                            hasOverloads = true;
                        }
                        previousDeclaration = node;
                        if (!inAmbientContextOrInterface) {
                            lastSeenNonAmbientDeclaration = node;
                        }
                    }
                }
            }
            if (multipleConstructorImplementation) {
                ts.forEach(functionDeclarations, function (declaration) {
                    error(declaration, ts.Diagnostics.Multiple_constructor_implementations_are_not_allowed);
                });
            }
            if (duplicateFunctionDeclaration) {
                ts.forEach(functionDeclarations, function (declaration) {
                    error(ts.getNameOfDeclaration(declaration) || declaration, ts.Diagnostics.Duplicate_function_implementation);
                });
            }
            if (hasNonAmbientClass && !isConstructor && symbol.flags & 16 /* Function */ && declarations) {
                var relatedDiagnostics_1 = ts.filter(declarations, function (d) { return d.kind === 255 /* ClassDeclaration */; })
                    .map(function (d) { return ts.createDiagnosticForNode(d, ts.Diagnostics.Consider_adding_a_declare_modifier_to_this_class); });
                ts.forEach(declarations, function (declaration) {
                    var diagnostic = declaration.kind === 255 /* ClassDeclaration */
                        ? ts.Diagnostics.Class_declaration_cannot_implement_overload_list_for_0
                        : declaration.kind === 254 /* FunctionDeclaration */
                            ? ts.Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient
                            : undefined;
                    if (diagnostic) {
                        ts.addRelatedInfo.apply(void 0, __spreadArray([error(ts.getNameOfDeclaration(declaration) || declaration, diagnostic, ts.symbolName(symbol))], relatedDiagnostics_1, false));
                    }
                });
            }
            // Abstract methods can't have an implementation -- in particular, they don't need one.
            if (lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body &&
                !ts.hasSyntacticModifier(lastSeenNonAmbientDeclaration, 128 /* Abstract */) && !lastSeenNonAmbientDeclaration.questionToken) {
                reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
            }
            if (hasOverloads) {
                if (declarations) {
                    checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
                    checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken);
                }
                if (bodyDeclaration) {
                    var signatures = getSignaturesOfSymbol(symbol);
                    var bodySignature = getSignatureFromDeclaration(bodyDeclaration);
                    for (var _a = 0, signatures_10 = signatures; _a < signatures_10.length; _a++) {
                        var signature = signatures_10[_a];
                        if (!isImplementationCompatibleWithOverload(bodySignature, signature)) {
                            ts.addRelatedInfo(error(signature.declaration, ts.Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature), ts.createDiagnosticForNode(bodyDeclaration, ts.Diagnostics.The_implementation_signature_is_declared_here));
                            break;
                        }
                    }
                }
            }
        }
        function checkExportsOnMergedDeclarations(node) {
            if (!produceDiagnostics) {
                return;
            }
            // if localSymbol is defined on node then node itself is exported - check is required
            var symbol = node.localSymbol;
            if (!symbol) {
                // local symbol is undefined => this declaration is non-exported.
                // however symbol might contain other declarations that are exported
                symbol = getSymbolOfNode(node);
                if (!symbol.exportSymbol) {
                    // this is a pure local symbol (all declarations are non-exported) - no need to check anything
                    return;
                }
            }
            // run the check only for the first declaration in the list
            if (ts.getDeclarationOfKind(symbol, node.kind) !== node) {
                return;
            }
            var exportedDeclarationSpaces = 0 /* None */;
            var nonExportedDeclarationSpaces = 0 /* None */;
            var defaultExportedDeclarationSpaces = 0 /* None */;
            for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                var d = _a[_i];
                var declarationSpaces = getDeclarationSpaces(d);
                var effectiveDeclarationFlags = getEffectiveDeclarationFlags(d, 1 /* Export */ | 512 /* Default */);
                if (effectiveDeclarationFlags & 1 /* Export */) {
                    if (effectiveDeclarationFlags & 512 /* Default */) {
                        defaultExportedDeclarationSpaces |= declarationSpaces;
                    }
                    else {
                        exportedDeclarationSpaces |= declarationSpaces;
                    }
                }
                else {
                    nonExportedDeclarationSpaces |= declarationSpaces;
                }
            }
            // Spaces for anything not declared a 'default export'.
            var nonDefaultExportedDeclarationSpaces = exportedDeclarationSpaces | nonExportedDeclarationSpaces;
            var commonDeclarationSpacesForExportsAndLocals = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
            var commonDeclarationSpacesForDefaultAndNonDefault = defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces;
            if (commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault) {
                // declaration spaces for exported and non-exported declarations intersect
                for (var _b = 0, _c = symbol.declarations; _b < _c.length; _b++) {
                    var d = _c[_b];
                    var declarationSpaces = getDeclarationSpaces(d);
                    var name = ts.getNameOfDeclaration(d);
                    // Only error on the declarations that contributed to the intersecting spaces.
                    if (declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault) {
                        error(name, ts.Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, ts.declarationNameToString(name));
                    }
                    else if (declarationSpaces & commonDeclarationSpacesForExportsAndLocals) {
                        error(name, ts.Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, ts.declarationNameToString(name));
                    }
                }
            }
            function getDeclarationSpaces(decl) {
                var d = decl;
                switch (d.kind) {
                    case 256 /* InterfaceDeclaration */:
                    case 257 /* TypeAliasDeclaration */:
                    // A jsdoc typedef and callback are, by definition, type aliases.
                    // falls through
                    case 340 /* JSDocTypedefTag */:
                    case 333 /* JSDocCallbackTag */:
                    case 334 /* JSDocEnumTag */:
                        return 2 /* ExportType */;
                    case 259 /* ModuleDeclaration */:
                        return ts.isAmbientModule(d) || ts.getModuleInstanceState(d) !== 0 /* NonInstantiated */
                            ? 4 /* ExportNamespace */ | 1 /* ExportValue */
                            : 4 /* ExportNamespace */;
                    case 255 /* ClassDeclaration */:
                    case 258 /* EnumDeclaration */:
                    case 294 /* EnumMember */:
                        return 2 /* ExportType */ | 1 /* ExportValue */;
                    case 300 /* SourceFile */:
                        return 2 /* ExportType */ | 1 /* ExportValue */ | 4 /* ExportNamespace */;
                    case 269 /* ExportAssignment */:
                    case 219 /* BinaryExpression */:
                        var node_2 = d;
                        var expression = ts.isExportAssignment(node_2) ? node_2.expression : node_2.right;
                        // Export assigned entity name expressions act as aliases and should fall through, otherwise they export values
                        if (!ts.isEntityNameExpression(expression)) {
                            return 1 /* ExportValue */;
                        }
                        d = expression;
                    // The below options all declare an Alias, which is allowed to merge with other values within the importing module.
                    // falls through
                    case 263 /* ImportEqualsDeclaration */:
                    case 266 /* NamespaceImport */:
                    case 265 /* ImportClause */:
                        var result_12 = 0 /* None */;
                        var target = resolveAlias(getSymbolOfNode(d));
                        ts.forEach(target.declarations, function (d) { result_12 |= getDeclarationSpaces(d); });
                        return result_12;
                    case 252 /* VariableDeclaration */:
                    case 201 /* BindingElement */:
                    case 254 /* FunctionDeclaration */:
                    case 268 /* ImportSpecifier */: // https://github.com/Microsoft/TypeScript/pull/7591
                    case 79 /* Identifier */: // https://github.com/microsoft/TypeScript/issues/36098
                        // Identifiers are used as declarations of assignment declarations whose parents may be
                        // SyntaxKind.CallExpression - `Object.defineProperty(thing, "aField", {value: 42});`
                        // SyntaxKind.ElementAccessExpression - `thing["aField"] = 42;` or `thing["aField"];` (with a doc comment on it)
                        // or SyntaxKind.PropertyAccessExpression - `thing.aField = 42;`
                        // all of which are pretty much always values, or at least imply a value meaning.
                        // It may be apprpriate to treat these as aliases in the future.
                        return 1 /* ExportValue */;
                    default:
                        return ts.Debug.failBadSyntaxKind(d);
                }
            }
        }
        function getAwaitedTypeOfPromise(type, errorNode, diagnosticMessage, arg0) {
            var promisedType = getPromisedTypeOfPromise(type, errorNode);
            return promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage, arg0);
        }
        /**
         * Gets the "promised type" of a promise.
         * @param type The type of the promise.
         * @remarks The "promised type" of a type is the type of the "value" parameter of the "onfulfilled" callback.
         */
        function getPromisedTypeOfPromise(type, errorNode) {
            //
            //  { // type
            //      then( // thenFunction
            //          onfulfilled: ( // onfulfilledParameterType
            //              value: T // valueParameterType
            //          ) => any
            //      ): any;
            //  }
            //
            if (isTypeAny(type)) {
                return undefined;
            }
            var typeAsPromise = type;
            if (typeAsPromise.promisedTypeOfPromise) {
                return typeAsPromise.promisedTypeOfPromise;
            }
            if (isReferenceToType(type, getGlobalPromiseType(/*reportErrors*/ false))) {
                return typeAsPromise.promisedTypeOfPromise = getTypeArguments(type)[0];
            }
            var thenFunction = getTypeOfPropertyOfType(type, "then"); // TODO: GH#18217
            if (isTypeAny(thenFunction)) {
                return undefined;
            }
            var thenSignatures = thenFunction ? getSignaturesOfType(thenFunction, 0 /* Call */) : ts.emptyArray;
            if (thenSignatures.length === 0) {
                if (errorNode) {
                    error(errorNode, ts.Diagnostics.A_promise_must_have_a_then_method);
                }
                return undefined;
            }
            var onfulfilledParameterType = getTypeWithFacts(getUnionType(ts.map(thenSignatures, getTypeOfFirstParameterOfSignature)), 2097152 /* NEUndefinedOrNull */);
            if (isTypeAny(onfulfilledParameterType)) {
                return undefined;
            }
            var onfulfilledParameterSignatures = getSignaturesOfType(onfulfilledParameterType, 0 /* Call */);
            if (onfulfilledParameterSignatures.length === 0) {
                if (errorNode) {
                    error(errorNode, ts.Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback);
                }
                return undefined;
            }
            return typeAsPromise.promisedTypeOfPromise = getUnionType(ts.map(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), 2 /* Subtype */);
        }
        /**
         * Gets the "awaited type" of a type.
         * @param type The type to await.
         * @remarks The "awaited type" of an expression is its "promised type" if the expression is a
         * Promise-like type; otherwise, it is the type of the expression. This is used to reflect
         * The runtime behavior of the `await` keyword.
         */
        function checkAwaitedType(type, errorNode, diagnosticMessage, arg0) {
            var awaitedType = getAwaitedType(type, errorNode, diagnosticMessage, arg0);
            return awaitedType || errorType;
        }
        /**
         * Determines whether a type has a callable `then` member.
         */
        function isThenableType(type) {
            var thenFunction = getTypeOfPropertyOfType(type, "then");
            return !!thenFunction && getSignaturesOfType(getTypeWithFacts(thenFunction, 2097152 /* NEUndefinedOrNull */), 0 /* Call */).length > 0;
        }
        /**
         * Gets the "awaited type" of a type.
         *
         * The "awaited type" of an expression is its "promised type" if the expression is a
         * Promise-like type; otherwise, it is the type of the expression. If the "promised
         * type" is itself a Promise-like, the "promised type" is recursively unwrapped until a
         * non-promise type is found.
         *
         * This is used to reflect the runtime behavior of the `await` keyword.
         */
        function getAwaitedType(type, errorNode, diagnosticMessage, arg0) {
            if (isTypeAny(type)) {
                return type;
            }
            var typeAsAwaitable = type;
            if (typeAsAwaitable.awaitedTypeOfType) {
                return typeAsAwaitable.awaitedTypeOfType;
            }
            // For a union, get a union of the awaited types of each constituent.
            //
            return typeAsAwaitable.awaitedTypeOfType =
                mapType(type, errorNode ? function (constituentType) { return getAwaitedTypeWorker(constituentType, errorNode, diagnosticMessage, arg0); } : getAwaitedTypeWorker);
        }
        function getAwaitedTypeWorker(type, errorNode, diagnosticMessage, arg0) {
            var typeAsAwaitable = type;
            if (typeAsAwaitable.awaitedTypeOfType) {
                return typeAsAwaitable.awaitedTypeOfType;
            }
            var promisedType = getPromisedTypeOfPromise(type);
            if (promisedType) {
                if (type.id === promisedType.id || awaitedTypeStack.lastIndexOf(promisedType.id) >= 0) {
                    // Verify that we don't have a bad actor in the form of a promise whose
                    // promised type is the same as the promise type, or a mutually recursive
                    // promise. If so, we return undefined as we cannot guess the shape. If this
                    // were the actual case in the JavaScript, this Promise would never resolve.
                    //
                    // An example of a bad actor with a singly-recursive promise type might
                    // be:
                    //
                    //  interface BadPromise {
                    //      then(
                    //          onfulfilled: (value: BadPromise) => any,
                    //          onrejected: (error: any) => any): BadPromise;
                    //  }
                    //
                    // The above interface will pass the PromiseLike check, and return a
                    // promised type of `BadPromise`. Since this is a self reference, we
                    // don't want to keep recursing ad infinitum.
                    //
                    // An example of a bad actor in the form of a mutually-recursive
                    // promise type might be:
                    //
                    //  interface BadPromiseA {
                    //      then(
                    //          onfulfilled: (value: BadPromiseB) => any,
                    //          onrejected: (error: any) => any): BadPromiseB;
                    //  }
                    //
                    //  interface BadPromiseB {
                    //      then(
                    //          onfulfilled: (value: BadPromiseA) => any,
                    //          onrejected: (error: any) => any): BadPromiseA;
                    //  }
                    //
                    if (errorNode) {
                        error(errorNode, ts.Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method);
                    }
                    return undefined;
                }
                // Keep track of the type we're about to unwrap to avoid bad recursive promise types.
                // See the comments above for more information.
                awaitedTypeStack.push(type.id);
                var awaitedType = getAwaitedType(promisedType, errorNode, diagnosticMessage, arg0);
                awaitedTypeStack.pop();
                if (!awaitedType) {
                    return undefined;
                }
                return typeAsAwaitable.awaitedTypeOfType = awaitedType;
            }
            // The type was not a promise, so it could not be unwrapped any further.
            // As long as the type does not have a callable "then" property, it is
            // safe to return the type; otherwise, an error is reported and we return
            // undefined.
            //
            // An example of a non-promise "thenable" might be:
            //
            //  await { then(): void {} }
            //
            // The "thenable" does not match the minimal definition for a promise. When
            // a Promise/A+-compatible or ES6 promise tries to adopt this value, the promise
            // will never settle. We treat this as an error to help flag an early indicator
            // of a runtime problem. If the user wants to return this value from an async
            // function, they would need to wrap it in some other value. If they want it to
            // be treated as a promise, they can cast to <any>.
            if (isThenableType(type)) {
                if (errorNode) {
                    if (!diagnosticMessage)
                        return ts.Debug.fail();
                    error(errorNode, diagnosticMessage, arg0);
                }
                return undefined;
            }
            return typeAsAwaitable.awaitedTypeOfType = type;
        }
        /**
         * Checks the return type of an async function to ensure it is a compatible
         * Promise implementation.
         *
         * This checks that an async function has a valid Promise-compatible return type.
         * An async function has a valid Promise-compatible return type if the resolved value
         * of the return type has a construct signature that takes in an `initializer` function
         * that in turn supplies a `resolve` function as one of its arguments and results in an
         * object with a callable `then` signature.
         *
         * @param node The signature to check
         */
        function checkAsyncFunctionReturnType(node, returnTypeNode) {
            // As part of our emit for an async function, we will need to emit the entity name of
            // the return type annotation as an expression. To meet the necessary runtime semantics
            // for __awaiter, we must also check that the type of the declaration (e.g. the static
            // side or "constructor" of the promise type) is compatible `PromiseConstructorLike`.
            //
            // An example might be (from lib.es6.d.ts):
            //
            //  interface Promise<T> { ... }
            //  interface PromiseConstructor {
            //      new <T>(...): Promise<T>;
            //  }
            //  declare var Promise: PromiseConstructor;
            //
            // When an async function declares a return type annotation of `Promise<T>`, we
            // need to get the type of the `Promise` variable declaration above, which would
            // be `PromiseConstructor`.
            //
            // The same case applies to a class:
            //
            //  declare class Promise<T> {
            //      constructor(...);
            //      then<U>(...): Promise<U>;
            //  }
            //
            var returnType = getTypeFromTypeNode(returnTypeNode);
            if (languageVersion >= 2 /* ES2015 */) {
                if (returnType === errorType) {
                    return;
                }
                var globalPromiseType = getGlobalPromiseType(/*reportErrors*/ true);
                if (globalPromiseType !== emptyGenericType && !isReferenceToType(returnType, globalPromiseType)) {
                    // The promise type was not a valid type reference to the global promise type, so we
                    // report an error and return the unknown type.
                    error(returnTypeNode, ts.Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0, typeToString(getAwaitedType(returnType) || voidType));
                    return;
                }
            }
            else {
                // Always mark the type node as referenced if it points to a value
                markTypeNodeAsReferenced(returnTypeNode);
                if (returnType === errorType) {
                    return;
                }
                var promiseConstructorName = ts.getEntityNameFromTypeNode(returnTypeNode);
                if (promiseConstructorName === undefined) {
                    error(returnTypeNode, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, typeToString(returnType));
                    return;
                }
                var promiseConstructorSymbol = resolveEntityName(promiseConstructorName, 111551 /* Value */, /*ignoreErrors*/ true);
                var promiseConstructorType = promiseConstructorSymbol ? getTypeOfSymbol(promiseConstructorSymbol) : errorType;
                if (promiseConstructorType === errorType) {
                    if (promiseConstructorName.kind === 79 /* Identifier */ && promiseConstructorName.escapedText === "Promise" && getTargetType(returnType) === getGlobalPromiseType(/*reportErrors*/ false)) {
                        error(returnTypeNode, ts.Diagnostics.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option);
                    }
                    else {
                        error(returnTypeNode, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, ts.entityNameToString(promiseConstructorName));
                    }
                    return;
                }
                var globalPromiseConstructorLikeType = getGlobalPromiseConstructorLikeType(/*reportErrors*/ true);
                if (globalPromiseConstructorLikeType === emptyObjectType) {
                    // If we couldn't resolve the global PromiseConstructorLike type we cannot verify
                    // compatibility with __awaiter.
                    error(returnTypeNode, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, ts.entityNameToString(promiseConstructorName));
                    return;
                }
                if (!checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, returnTypeNode, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value)) {
                    return;
                }
                // Verify there is no local declaration that could collide with the promise constructor.
                var rootName = promiseConstructorName && ts.getFirstIdentifier(promiseConstructorName);
                var collidingSymbol = getSymbol(node.locals, rootName.escapedText, 111551 /* Value */);
                if (collidingSymbol) {
                    error(collidingSymbol.valueDeclaration, ts.Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, ts.idText(rootName), ts.entityNameToString(promiseConstructorName));
                    return;
                }
            }
            checkAwaitedType(returnType, node, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
        }
        /** Check a decorator */
        function checkDecorator(node) {
            var signature = getResolvedSignature(node);
            checkDeprecatedSignature(signature, node);
            var returnType = getReturnTypeOfSignature(signature);
            if (returnType.flags & 1 /* Any */) {
                return;
            }
            var expectedReturnType;
            var headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
            var errorInfo;
            switch (node.parent.kind) {
                case 255 /* ClassDeclaration */:
                    var classSymbol = getSymbolOfNode(node.parent);
                    var classConstructorType = getTypeOfSymbol(classSymbol);
                    expectedReturnType = getUnionType([classConstructorType, voidType]);
                    break;
                case 162 /* Parameter */:
                    expectedReturnType = voidType;
                    errorInfo = ts.chainDiagnosticMessages(
                    /*details*/ undefined, ts.Diagnostics.The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any);
                    break;
                case 165 /* PropertyDeclaration */:
                    expectedReturnType = voidType;
                    errorInfo = ts.chainDiagnosticMessages(
                    /*details*/ undefined, ts.Diagnostics.The_return_type_of_a_property_decorator_function_must_be_either_void_or_any);
                    break;
                case 167 /* MethodDeclaration */:
                case 170 /* GetAccessor */:
                case 171 /* SetAccessor */:
                    var methodType = getTypeOfNode(node.parent);
                    var descriptorType = createTypedPropertyDescriptorType(methodType);
                    expectedReturnType = getUnionType([descriptorType, voidType]);
                    break;
                default:
                    return ts.Debug.fail();
            }
            checkTypeAssignableTo(returnType, expectedReturnType, node, headMessage, function () { return errorInfo; });
        }
        /**
         * If a TypeNode can be resolved to a value symbol imported from an external module, it is
         * marked as referenced to prevent import elision.
         */
        function markTypeNodeAsReferenced(node) {
            markEntityNameOrEntityExpressionAsReference(node && ts.getEntityNameFromTypeNode(node));
        }
        function markEntityNameOrEntityExpressionAsReference(typeName) {
            if (!typeName)
                return;
            var rootName = ts.getFirstIdentifier(typeName);
            var meaning = (typeName.kind === 79 /* Identifier */ ? 788968 /* Type */ : 1920 /* Namespace */) | 2097152 /* Alias */;
            var rootSymbol = resolveName(rootName, rootName.escapedText, meaning, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isReference*/ true);
            if (rootSymbol
                && rootSymbol.flags & 2097152 /* Alias */
                && symbolIsValue(rootSymbol)
                && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol))
                && !getTypeOnlyAliasDeclaration(rootSymbol)) {
                markAliasSymbolAsReferenced(rootSymbol);
            }
        }
        /**
         * This function marks the type used for metadata decorator as referenced if it is import
         * from external module.
         * This is different from markTypeNodeAsReferenced because it tries to simplify type nodes in
         * union and intersection type
         * @param node
         */
        function markDecoratorMedataDataTypeNodeAsReferenced(node) {
            var entityName = getEntityNameForDecoratorMetadata(node);
            if (entityName && ts.isEntityName(entityName)) {
                markEntityNameOrEntityExpressionAsReference(entityName);
            }
        }
        function getEntityNameForDecoratorMetadata(node) {
            if (node) {
                switch (node.kind) {
                    case 186 /* IntersectionType */:
                    case 185 /* UnionType */:
                        return getEntityNameForDecoratorMetadataFromTypeList(node.types);
                    case 187 /* ConditionalType */:
                        return getEntityNameForDecoratorMetadataFromTypeList([node.trueType, node.falseType]);
                    case 189 /* ParenthesizedType */:
                    case 195 /* NamedTupleMember */:
                        return getEntityNameForDecoratorMetadata(node.type);
                    case 176 /* TypeReference */:
                        return node.typeName;
                }
            }
        }
        function getEntityNameForDecoratorMetadataFromTypeList(types) {
            var commonEntityName;
            for (var _i = 0, types_22 = types; _i < types_22.length; _i++) {
                var typeNode = types_22[_i];
                while (typeNode.kind === 189 /* ParenthesizedType */ || typeNode.kind === 195 /* NamedTupleMember */) {
                    typeNode = typeNode.type; // Skip parens if need be
                }
                if (typeNode.kind === 142 /* NeverKeyword */) {
                    continue; // Always elide `never` from the union/intersection if possible
                }
                if (!strictNullChecks && (typeNode.kind === 194 /* LiteralType */ && typeNode.literal.kind === 104 /* NullKeyword */ || typeNode.kind === 151 /* UndefinedKeyword */)) {
                    continue; // Elide null and undefined from unions for metadata, just like what we did prior to the implementation of strict null checks
                }
                var individualEntityName = getEntityNameForDecoratorMetadata(typeNode);
                if (!individualEntityName) {
                    // Individual is something like string number
                    // So it would be serialized to either that type or object
                    // Safe to return here
                    return undefined;
                }
                if (commonEntityName) {
                    // Note this is in sync with the transformation that happens for type node.
                    // Keep this in sync with serializeUnionOrIntersectionType
                    // Verify if they refer to same entity and is identifier
                    // return undefined if they dont match because we would emit object
                    if (!ts.isIdentifier(commonEntityName) ||
                        !ts.isIdentifier(individualEntityName) ||
                        commonEntityName.escapedText !== individualEntityName.escapedText) {
                        return undefined;
                    }
                }
                else {
                    commonEntityName = individualEntityName;
                }
            }
            return commonEntityName;
        }
        function getParameterTypeNodeForDecoratorCheck(node) {
            var typeNode = ts.getEffectiveTypeAnnotationNode(node);
            return ts.isRestParameter(node) ? ts.getRestParameterElementType(typeNode) : typeNode;
        }
        /** Check the decorators of a node */
        function checkDecorators(node) {
            if (!node.decorators) {
                return;
            }
            // skip this check for nodes that cannot have decorators. These should have already had an error reported by
            // checkGrammarDecorators.
            if (!ts.nodeCanBeDecorated(node, node.parent, node.parent.parent)) {
                return;
            }
            if (!compilerOptions.experimentalDecorators) {
                error(node, ts.Diagnostics.Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_in_your_tsconfig_or_jsconfig_to_remove_this_warning);
            }
            var firstDecorator = node.decorators[0];
            checkExternalEmitHelpers(firstDecorator, 8 /* Decorate */);
            if (node.kind === 162 /* Parameter */) {
                checkExternalEmitHelpers(firstDecorator, 32 /* Param */);
            }
            if (compilerOptions.emitDecoratorMetadata) {
                checkExternalEmitHelpers(firstDecorator, 16 /* Metadata */);
                // we only need to perform these checks if we are emitting serialized type metadata for the target of a decorator.
                switch (node.kind) {
                    case 255 /* ClassDeclaration */:
                        var constructor = ts.getFirstConstructorWithBody(node);
                        if (constructor) {
                            for (var _i = 0, _a = constructor.parameters; _i < _a.length; _i++) {
                                var parameter = _a[_i];
                                markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                            }
                        }
                        break;
                    case 170 /* GetAccessor */:
                    case 171 /* SetAccessor */:
                        var otherKind = node.kind === 170 /* GetAccessor */ ? 171 /* SetAccessor */ : 170 /* GetAccessor */;
                        var otherAccessor = ts.getDeclarationOfKind(getSymbolOfNode(node), otherKind);
                        markDecoratorMedataDataTypeNodeAsReferenced(getAnnotatedAccessorTypeNode(node) || otherAccessor && getAnnotatedAccessorTypeNode(otherAccessor));
                        break;
                    case 167 /* MethodDeclaration */:
                        for (var _b = 0, _c = node.parameters; _b < _c.length; _b++) {
                            var parameter = _c[_b];
                            markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                        }
                        markDecoratorMedataDataTypeNodeAsReferenced(ts.getEffectiveReturnTypeNode(node));
                        break;
                    case 165 /* PropertyDeclaration */:
                        markDecoratorMedataDataTypeNodeAsReferenced(ts.getEffectiveTypeAnnotationNode(node));
                        break;
                    case 162 /* Parameter */:
                        markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(node));
                        var containingSignature = node.parent;
                        for (var _d = 0, _e = containingSignature.parameters; _d < _e.length; _d++) {
                            var parameter = _e[_d];
                            markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                        }
                        break;
                }
            }
            ts.forEach(node.decorators, checkDecorator);
        }
        function checkFunctionDeclaration(node) {
            if (produceDiagnostics) {
                checkFunctionOrMethodDeclaration(node);
                checkGrammarForGenerator(node);
                checkCollisionsForDeclarationName(node, node.name);
            }
        }
        function checkJSDocTypeAliasTag(node) {
            if (!node.typeExpression) {
                // If the node had `@property` tags, `typeExpression` would have been set to the first property tag.
                error(node.name, ts.Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags);
            }
            if (node.name) {
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_alias_name_cannot_be_0);
            }
            checkSourceElement(node.typeExpression);
        }
        function checkJSDocTemplateTag(node) {
            checkSourceElement(node.constraint);
            for (var _i = 0, _a = node.typeParameters; _i < _a.length; _i++) {
                var tp = _a[_i];
                checkSourceElement(tp);
            }
        }
        function checkJSDocTypeTag(node) {
            checkSourceElement(node.typeExpression);
        }
        function checkJSDocParameterTag(node) {
            checkSourceElement(node.typeExpression);
            if (!ts.getParameterSymbolFromJSDoc(node)) {
                var decl = ts.getHostSignatureFromJSDoc(node);
                // don't issue an error for invalid hosts -- just functions --
                // and give a better error message when the host function mentions `arguments`
                // but the tag doesn't have an array type
                if (decl) {
                    var i = ts.getJSDocTags(decl).filter(ts.isJSDocParameterTag).indexOf(node);
                    if (i > -1 && i < decl.parameters.length && ts.isBindingPattern(decl.parameters[i].name)) {
                        return;
                    }
                    if (!containsArgumentsReference(decl)) {
                        if (ts.isQualifiedName(node.name)) {
                            error(node.name, ts.Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, ts.entityNameToString(node.name), ts.entityNameToString(node.name.left));
                        }
                        else {
                            error(node.name, ts.Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, ts.idText(node.name));
                        }
                    }
                    else if (ts.findLast(ts.getJSDocTags(decl), ts.isJSDocParameterTag) === node &&
                        node.typeExpression && node.typeExpression.type &&
                        !isArrayType(getTypeFromTypeNode(node.typeExpression.type))) {
                        error(node.name, ts.Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type, ts.idText(node.name.kind === 159 /* QualifiedName */ ? node.name.right : node.name));
                    }
                }
            }
        }
        function checkJSDocPropertyTag(node) {
            checkSourceElement(node.typeExpression);
        }
        function checkJSDocFunctionType(node) {
            if (produceDiagnostics && !node.type && !ts.isJSDocConstructSignature(node)) {
                reportImplicitAny(node, anyType);
            }
            checkSignatureDeclaration(node);
        }
        function checkJSDocImplementsTag(node) {
            var classLike = ts.getEffectiveJSDocHost(node);
            if (!classLike || !ts.isClassDeclaration(classLike) && !ts.isClassExpression(classLike)) {
                error(classLike, ts.Diagnostics.JSDoc_0_is_not_attached_to_a_class, ts.idText(node.tagName));
            }
        }
        function checkJSDocAugmentsTag(node) {
            var classLike = ts.getEffectiveJSDocHost(node);
            if (!classLike || !ts.isClassDeclaration(classLike) && !ts.isClassExpression(classLike)) {
                error(classLike, ts.Diagnostics.JSDoc_0_is_not_attached_to_a_class, ts.idText(node.tagName));
                return;
            }
            var augmentsTags = ts.getJSDocTags(classLike).filter(ts.isJSDocAugmentsTag);
            ts.Debug.assert(augmentsTags.length > 0);
            if (augmentsTags.length > 1) {
                error(augmentsTags[1], ts.Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag);
            }
            var name = getIdentifierFromEntityNameExpression(node.class.expression);
            var extend = ts.getClassExtendsHeritageElement(classLike);
            if (extend) {
                var className = getIdentifierFromEntityNameExpression(extend.expression);
                if (className && name.escapedText !== className.escapedText) {
                    error(name, ts.Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause, ts.idText(node.tagName), ts.idText(name), ts.idText(className));
                }
            }
        }
        function getIdentifierFromEntityNameExpression(node) {
            switch (node.kind) {
                case 79 /* Identifier */:
                    return node;
                case 204 /* PropertyAccessExpression */:
                    return node.name;
                default:
                    return undefined;
            }
        }
        function checkFunctionOrMethodDeclaration(node) {
            var _a;
            checkDecorators(node);
            checkSignatureDeclaration(node);
            var functionFlags = ts.getFunctionFlags(node);
            // Do not use hasDynamicName here, because that returns false for well known symbols.
            // We want to perform checkComputedPropertyName for all computed properties, including
            // well known symbols.
            if (node.name && node.name.kind === 160 /* ComputedPropertyName */) {
                // This check will account for methods in class/interface declarations,
                // as well as accessors in classes/object literals
                checkComputedPropertyName(node.name);
            }
            if (hasBindableName(node)) {
                // first we want to check the local symbol that contain this declaration
                // - if node.localSymbol !== undefined - this is current declaration is exported and localSymbol points to the local symbol
                // - if node.localSymbol === undefined - this node is non-exported so we can just pick the result of getSymbolOfNode
                var symbol = getSymbolOfNode(node);
                var localSymbol = node.localSymbol || symbol;
                // Since the javascript won't do semantic analysis like typescript,
                // if the javascript file comes before the typescript file and both contain same name functions,
                // checkFunctionOrConstructorSymbol wouldn't be called if we didnt ignore javascript function.
                var firstDeclaration = (_a = localSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(
                // Get first non javascript function declaration
                function (declaration) { return declaration.kind === node.kind && !(declaration.flags & 131072 /* JavaScriptFile */); });
                // Only type check the symbol once
                if (node === firstDeclaration) {
                    checkFunctionOrConstructorSymbol(localSymbol);
                }
                if (symbol.parent) {
                    // run check on export symbol to check that modifiers agree across all exported declarations
                    checkFunctionOrConstructorSymbol(symbol);
                }
            }
            var body = node.kind === 166 /* MethodSignature */ ? undefined : node.body;
            checkSourceElement(body);
            checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node));
            if (produceDiagnostics && !ts.getEffectiveReturnTypeNode(node)) {
                // Report an implicit any error if there is no body, no explicit return type, and node is not a private method
                // in an ambient context
                if (ts.nodeIsMissing(body) && !isPrivateWithinAmbient(node)) {
                    reportImplicitAny(node, anyType);
                }
                if (functionFlags & 1 /* Generator */ && ts.nodeIsPresent(body)) {
                    // A generator with a body and no type annotation can still cause errors. It can error if the
                    // yielded values have no common supertype, or it can give an implicit any error if it has no
                    // yielded values. The only way to trigger these errors is to try checking its return type.
                    getReturnTypeOfSignature(getSignatureFromDeclaration(node));
                }
            }
            // A js function declaration can have a @type tag instead of a return type node, but that type must have a call signature
            if (ts.isInJSFile(node)) {
                var typeTag = ts.getJSDocTypeTag(node);
                if (typeTag && typeTag.typeExpression && !getContextualCallSignature(getTypeFromTypeNode(typeTag.typeExpression), node)) {
                    error(typeTag.typeExpression.type, ts.Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature);
                }
            }
        }
        function registerForUnusedIdentifiersCheck(node) {
            // May be in a call such as getTypeOfNode that happened to call this. But potentiallyUnusedIdentifiers is only defined in the scope of `checkSourceFile`.
            if (produceDiagnostics) {
                var sourceFile = ts.getSourceFileOfNode(node);
                var potentiallyUnusedIdentifiers = allPotentiallyUnusedIdentifiers.get(sourceFile.path);
                if (!potentiallyUnusedIdentifiers) {
                    potentiallyUnusedIdentifiers = [];
                    allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers);
                }
                // TODO: GH#22580
                // Debug.assert(addToSeen(seenPotentiallyUnusedIdentifiers, getNodeId(node)), "Adding potentially-unused identifier twice");
                potentiallyUnusedIdentifiers.push(node);
            }
        }
        function checkUnusedIdentifiers(potentiallyUnusedIdentifiers, addDiagnostic) {
            for (var _i = 0, potentiallyUnusedIdentifiers_1 = potentiallyUnusedIdentifiers; _i < potentiallyUnusedIdentifiers_1.length; _i++) {
                var node = potentiallyUnusedIdentifiers_1[_i];
                switch (node.kind) {
                    case 255 /* ClassDeclaration */:
                    case 224 /* ClassExpression */:
                        checkUnusedClassMembers(node, addDiagnostic);
                        checkUnusedTypeParameters(node, addDiagnostic);
                        break;
                    case 300 /* SourceFile */:
                    case 259 /* ModuleDeclaration */:
                    case 233 /* Block */:
                    case 261 /* CaseBlock */:
                    case 240 /* ForStatement */:
                    case 241 /* ForInStatement */:
                    case 242 /* ForOfStatement */:
                        checkUnusedLocalsAndParameters(node, addDiagnostic);
                        break;
                    case 169 /* Constructor */:
                    case 211 /* FunctionExpression */:
                    case 254 /* FunctionDeclaration */:
                    case 212 /* ArrowFunction */:
                    case 167 /* MethodDeclaration */:
                    case 170 /* GetAccessor */:
                    case 171 /* SetAccessor */:
                        if (node.body) { // Don't report unused parameters in overloads
                            checkUnusedLocalsAndParameters(node, addDiagnostic);
                        }
                        checkUnusedTypeParameters(node, addDiagnostic);
                        break;
                    case 166 /* MethodSignature */:
                    case 172 /* CallSignature */:
                    case 173 /* ConstructSignature */:
                    case 177 /* FunctionType */:
                    case 178 /* ConstructorType */:
                    case 257 /* TypeAliasDeclaration */:
                    case 256 /* InterfaceDeclaration */:
                        checkUnusedTypeParameters(node, addDiagnostic);
                        break;
                    case 188 /* InferType */:
                        checkUnusedInferTypeParameter(node, addDiagnostic);
                        break;
                    default:
                        ts.Debug.assertNever(node, "Node should not have been registered for unused identifiers check");
                }
            }
        }
        function errorUnusedLocal(declaration, name, addDiagnostic) {
            var node = ts.getNameOfDeclaration(declaration) || declaration;
            var message = isTypeDeclaration(declaration) ? ts.Diagnostics._0_is_declared_but_never_used : ts.Diagnostics._0_is_declared_but_its_value_is_never_read;
            addDiagnostic(declaration, 0 /* Local */, ts.createDiagnosticForNode(node, message, name));
        }
        function isIdentifierThatStartsWithUnderscore(node) {
            return ts.isIdentifier(node) && ts.idText(node).charCodeAt(0) === 95 /* _ */;
        }
        function checkUnusedClassMembers(node, addDiagnostic) {
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                switch (member.kind) {
                    case 167 /* MethodDeclaration */:
                    case 165 /* PropertyDeclaration */:
                    case 170 /* GetAccessor */:
                    case 171 /* SetAccessor */:
                        if (member.kind === 171 /* SetAccessor */ && member.symbol.flags & 32768 /* GetAccessor */) {
                            // Already would have reported an error on the getter.
                            break;
                        }
                        var symbol = getSymbolOfNode(member);
                        if (!symbol.isReferenced
                            && (ts.hasEffectiveModifier(member, 8 /* Private */) || ts.isNamedDeclaration(member) && ts.isPrivateIdentifier(member.name))
                            && !(member.flags & 8388608 /* Ambient */)) {
                            addDiagnostic(member, 0 /* Local */, ts.createDiagnosticForNode(member.name, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, symbolToString(symbol)));
                        }
                        break;
                    case 169 /* Constructor */:
                        for (var _b = 0, _c = member.parameters; _b < _c.length; _b++) {
                            var parameter = _c[_b];
                            if (!parameter.symbol.isReferenced && ts.hasSyntacticModifier(parameter, 8 /* Private */)) {
                                addDiagnostic(parameter, 0 /* Local */, ts.createDiagnosticForNode(parameter.name, ts.Diagnostics.Property_0_is_declared_but_its_value_is_never_read, ts.symbolName(parameter.symbol)));
                            }
                        }
                        break;
                    case 174 /* IndexSignature */:
                    case 232 /* SemicolonClassElement */:
                    case 168 /* ClassStaticBlockDeclaration */:
                        // Can't be private
                        break;
                    default:
                        ts.Debug.fail("Unexpected class member");
                }
            }
        }
        function checkUnusedInferTypeParameter(node, addDiagnostic) {
            var typeParameter = node.typeParameter;
            if (isTypeParameterUnused(typeParameter)) {
                addDiagnostic(node, 1 /* Parameter */, ts.createDiagnosticForNode(node, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, ts.idText(typeParameter.name)));
            }
        }
        function checkUnusedTypeParameters(node, addDiagnostic) {
            // Only report errors on the last declaration for the type parameter container;
            // this ensures that all uses have been accounted for.
            var declarations = getSymbolOfNode(node).declarations;
            if (!declarations || ts.last(declarations) !== node)
                return;
            var typeParameters = ts.getEffectiveTypeParameterDeclarations(node);
            var seenParentsWithEveryUnused = new ts.Set();
            for (var _i = 0, typeParameters_3 = typeParameters; _i < typeParameters_3.length; _i++) {
                var typeParameter = typeParameters_3[_i];
                if (!isTypeParameterUnused(typeParameter))
                    continue;
                var name = ts.idText(typeParameter.name);
                var parent = typeParameter.parent;
                if (parent.kind !== 188 /* InferType */ && parent.typeParameters.every(isTypeParameterUnused)) {
                    if (ts.tryAddToSet(seenParentsWithEveryUnused, parent)) {
                        var sourceFile = ts.getSourceFileOfNode(parent);
                        var range = ts.isJSDocTemplateTag(parent)
                            // Whole @template tag
                            ? ts.rangeOfNode(parent)
                            // Include the `<>` in the error message
                            : ts.rangeOfTypeParameters(sourceFile, parent.typeParameters);
                        var only = parent.typeParameters.length === 1;
                        //TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
                        var message = only ? ts.Diagnostics._0_is_declared_but_its_value_is_never_read : ts.Diagnostics.All_type_parameters_are_unused;
                        var arg0 = only ? name : undefined;
                        addDiagnostic(typeParameter, 1 /* Parameter */, ts.createFileDiagnostic(sourceFile, range.pos, range.end - range.pos, message, arg0));
                    }
                }
                else {
                    //TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
                    addDiagnostic(typeParameter, 1 /* Parameter */, ts.createDiagnosticForNode(typeParameter, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, name));
                }
            }
        }
        function isTypeParameterUnused(typeParameter) {
            return !(getMergedSymbol(typeParameter.symbol).isReferenced & 262144 /* TypeParameter */) && !isIdentifierThatStartsWithUnderscore(typeParameter.name);
        }
        function addToGroup(map, key, value, getKey) {
            var keyString = String(getKey(key));
            var group = map.get(keyString);
            if (group) {
                group[1].push(value);
            }
            else {
                map.set(keyString, [key, [value]]);
            }
        }
        function tryGetRootParameterDeclaration(node) {
            return ts.tryCast(ts.getRootDeclaration(node), ts.isParameter);
        }
        function isValidUnusedLocalDeclaration(declaration) {
            if (ts.isBindingElement(declaration)) {
                if (ts.isObjectBindingPattern(declaration.parent)) {
                    /**
                     * ignore starts with underscore names _
                     * const { a: _a } = { a: 1 }
                     */
                    return !!(declaration.propertyName && isIdentifierThatStartsWithUnderscore(declaration.name));
                }
                return isIdentifierThatStartsWithUnderscore(declaration.name);
            }
            return ts.isAmbientModule(declaration) ||
                (ts.isVariableDeclaration(declaration) && ts.isForInOrOfStatement(declaration.parent.parent) || isImportedDeclaration(declaration)) && isIdentifierThatStartsWithUnderscore(declaration.name);
        }
        function checkUnusedLocalsAndParameters(nodeWithLocals, addDiagnostic) {
            // Ideally we could use the ImportClause directly as a key, but must wait until we have full ES6 maps. So must store key along with value.
            var unusedImports = new ts.Map();
            var unusedDestructures = new ts.Map();
            var unusedVariables = new ts.Map();
            nodeWithLocals.locals.forEach(function (local) {
                // If it's purely a type parameter, ignore, will be checked in `checkUnusedTypeParameters`.
                // If it's a type parameter merged with a parameter, check if the parameter-side is used.
                if (local.flags & 262144 /* TypeParameter */ ? !(local.flags & 3 /* Variable */ && !(local.isReferenced & 3 /* Variable */)) : local.isReferenced || local.exportSymbol) {
                    return;
                }
                if (local.declarations) {
                    for (var _i = 0, _a = local.declarations; _i < _a.length; _i++) {
                        var declaration = _a[_i];
                        if (isValidUnusedLocalDeclaration(declaration)) {
                            continue;
                        }
                        if (isImportedDeclaration(declaration)) {
                            addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId);
                        }
                        else if (ts.isBindingElement(declaration) && ts.isObjectBindingPattern(declaration.parent)) {
                            // In `{ a, ...b }, `a` is considered used since it removes a property from `b`. `b` may still be unused though.
                            var lastElement = ts.last(declaration.parent.elements);
                            if (declaration === lastElement || !ts.last(declaration.parent.elements).dotDotDotToken) {
                                addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
                            }
                        }
                        else if (ts.isVariableDeclaration(declaration)) {
                            addToGroup(unusedVariables, declaration.parent, declaration, getNodeId);
                        }
                        else {
                            var parameter = local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration);
                            var name = local.valueDeclaration && ts.getNameOfDeclaration(local.valueDeclaration);
                            if (parameter && name) {
                                if (!ts.isParameterPropertyDeclaration(parameter, parameter.parent) && !ts.parameterIsThisKeyword(parameter) && !isIdentifierThatStartsWithUnderscore(name)) {
                                    if (ts.isBindingElement(declaration) && ts.isArrayBindingPattern(declaration.parent)) {
                                        addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
                                    }
                                    else {
                                        addDiagnostic(parameter, 1 /* Parameter */, ts.createDiagnosticForNode(name, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, ts.symbolName(local)));
                                    }
                                }
                            }
                            else {
                                errorUnusedLocal(declaration, ts.symbolName(local), addDiagnostic);
                            }
                        }
                    }
                }
            });
            unusedImports.forEach(function (_a) {
                var importClause = _a[0], unuseds = _a[1];
                var importDecl = importClause.parent;
                var nDeclarations = (importClause.name ? 1 : 0) +
                    (importClause.namedBindings ?
                        (importClause.namedBindings.kind === 266 /* NamespaceImport */ ? 1 : importClause.namedBindings.elements.length)
                        : 0);
                if (nDeclarations === unuseds.length) {
                    addDiagnostic(importDecl, 0 /* Local */, unuseds.length === 1
                        ? ts.createDiagnosticForNode(importDecl, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, ts.idText(ts.first(unuseds).name))
                        : ts.createDiagnosticForNode(importDecl, ts.Diagnostics.All_imports_in_import_declaration_are_unused));
                }
                else {
                    for (var _i = 0, unuseds_1 = unuseds; _i < unuseds_1.length; _i++) {
                        var unused = unuseds_1[_i];
                        errorUnusedLocal(unused, ts.idText(unused.name), addDiagnostic);
                    }
                }
            });
            unusedDestructures.forEach(function (_a) {
                var bindingPattern = _a[0], bindingElements = _a[1];
                var kind = tryGetRootParameterDeclaration(bindingPattern.parent) ? 1 /* Parameter */ : 0 /* Local */;
                if (bindingPattern.elements.length === bindingElements.length) {
                    if (bindingElements.length === 1 && bindingPattern.parent.kind === 252 /* VariableDeclaration */ && bindingPattern.parent.parent.kind === 253 /* VariableDeclarationList */) {
                        addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId);
                    }
                    else {
                        addDiagnostic(bindingPattern, kind, bindingElements.length === 1
                            ? ts.createDiagnosticForNode(bindingPattern, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(ts.first(bindingElements).name))
                            : ts.createDiagnosticForNode(bindingPattern, ts.Diagnostics.All_destructured_elements_are_unused));
                    }
                }
                else {
                    for (var _i = 0, bindingElements_1 = bindingElements; _i < bindingElements_1.length; _i++) {
                        var e = bindingElements_1[_i];
                        addDiagnostic(e, kind, ts.createDiagnosticForNode(e, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(e.name)));
                    }
                }
            });
            unusedVariables.forEach(function (_a) {
                var declarationList = _a[0], declarations = _a[1];
                if (declarationList.declarations.length === declarations.length) {
                    addDiagnostic(declarationList, 0 /* Local */, declarations.length === 1
                        ? ts.createDiagnosticForNode(ts.first(declarations).name, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(ts.first(declarations).name))
                        : ts.createDiagnosticForNode(declarationList.parent.kind === 235 /* VariableStatement */ ? declarationList.parent : declarationList, ts.Diagnostics.All_variables_are_unused));
                }
                else {
                    for (var _i = 0, declarations_5 = declarations; _i < declarations_5.length; _i++) {
                        var decl = declarations_5[_i];
                        addDiagnostic(decl, 0 /* Local */, ts.createDiagnosticForNode(decl, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)));
                    }
                }
            });
        }
        function bindingNameText(name) {
            switch (name.kind) {
                case 79 /* Identifier */:
                    return ts.idText(name);
                case 200 /* ArrayBindingPattern */:
                case 199 /* ObjectBindingPattern */:
                    return bindingNameText(ts.cast(ts.first(name.elements), ts.isBindingElement).name);
                default:
                    return ts.Debug.assertNever(name);
            }
        }
        function isImportedDeclaration(node) {
            return node.kind === 265 /* ImportClause */ || node.kind === 268 /* ImportSpecifier */ || node.kind === 266 /* NamespaceImport */;
        }
        function importClauseFromImported(decl) {
            return decl.kind === 265 /* ImportClause */ ? decl : decl.kind === 266 /* NamespaceImport */ ? decl.parent : decl.parent.parent;
        }
        function checkBlock(node) {
            // Grammar checking for SyntaxKind.Block
            if (node.kind === 233 /* Block */) {
                checkGrammarStatementInAmbientContext(node);
            }
            if (ts.isFunctionOrModuleBlock(node)) {
                var saveFlowAnalysisDisabled = flowAnalysisDisabled;
                ts.forEach(node.statements, checkSourceElement);
                flowAnalysisDisabled = saveFlowAnalysisDisabled;
            }
            else {
                ts.forEach(node.statements, checkSourceElement);
            }
            if (node.locals) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkCollisionWithArgumentsInGeneratedCode(node) {
            // no rest parameters \ declaration context \ overload - no codegen impact
            if (languageVersion >= 2 /* ES2015 */ || !ts.hasRestParameter(node) || node.flags & 8388608 /* Ambient */ || ts.nodeIsMissing(node.body)) {
                return;
            }
            ts.forEach(node.parameters, function (p) {
                if (p.name && !ts.isBindingPattern(p.name) && p.name.escapedText === argumentsSymbol.escapedName) {
                    errorSkippedOn("noEmit", p, ts.Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);
                }
            });
        }
        /**
         * Checks whether an {@link Identifier}, in the context of another {@link Node}, would collide with a runtime value
         * of {@link name} in an outer scope. This is used to check for collisions for downlevel transformations that
         * require names like `Object`, `Promise`, `Reflect`, `require`, `exports`, etc.
         */
        function needCollisionCheckForIdentifier(node, identifier, name) {
            if ((identifier === null || identifier === void 0 ? void 0 : identifier.escapedText) !== name) {
                return false;
            }
            if (node.kind === 165 /* PropertyDeclaration */ ||
                node.kind === 164 /* PropertySignature */ ||
                node.kind === 167 /* MethodDeclaration */ ||
                node.kind === 166 /* MethodSignature */ ||
                node.kind === 170 /* GetAccessor */ ||
                node.kind === 171 /* SetAccessor */ ||
                node.kind === 291 /* PropertyAssignment */) {
                // it is ok to have member named '_super', '_this', `Promise`, etc. - member access is always qualified
                return false;
            }
            if (node.flags & 8388608 /* Ambient */) {
                // ambient context - no codegen impact
                return false;
            }
            if (ts.isImportClause(node) || ts.isImportEqualsDeclaration(node) || ts.isImportSpecifier(node)) {
                // type-only imports do not require collision checks against runtime values.
                if (ts.isTypeOnlyImportOrExportDeclaration(node)) {
                    return false;
                }
            }
            var root = ts.getRootDeclaration(node);
            if (ts.isParameter(root) && ts.nodeIsMissing(root.parent.body)) {
                // just an overload - no codegen impact
                return false;
            }
            return true;
        }
        // this function will run after checking the source file so 'CaptureThis' is correct for all nodes
        function checkIfThisIsCapturedInEnclosingScope(node) {
            ts.findAncestor(node, function (current) {
                if (getNodeCheckFlags(current) & 4 /* CaptureThis */) {
                    var isDeclaration_1 = node.kind !== 79 /* Identifier */;
                    if (isDeclaration_1) {
                        error(ts.getNameOfDeclaration(node), ts.Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);
                    }
                    else {
                        error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);
                    }
                    return true;
                }
                return false;
            });
        }
        function checkIfNewTargetIsCapturedInEnclosingScope(node) {
            ts.findAncestor(node, function (current) {
                if (getNodeCheckFlags(current) & 8 /* CaptureNewTarget */) {
                    var isDeclaration_2 = node.kind !== 79 /* Identifier */;
                    if (isDeclaration_2) {
                        error(ts.getNameOfDeclaration(node), ts.Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference);
                    }
                    else {
                        error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference);
                    }
                    return true;
                }
                return false;
            });
        }
        function checkCollisionWithRequireExportsInGeneratedCode(node, name) {
            // No need to check for require or exports for ES6 modules and later
            if (moduleKind >= ts.ModuleKind.ES2015) {
                return;
            }
            if (!name || !needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports")) {
                return;
            }
            // Uninstantiated modules shouldnt do this check
            if (ts.isModuleDeclaration(node) && ts.getModuleInstanceState(node) !== 1 /* Instantiated */) {
                return;
            }
            // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
            var parent = getDeclarationContainer(node);
            if (parent.kind === 300 /* SourceFile */ && ts.isExternalOrCommonJsModule(parent)) {
                // If the declaration happens to be in external module, report error that require and exports are reserved keywords
                errorSkippedOn("noEmit", name, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, ts.declarationNameToString(name), ts.declarationNameToString(name));
            }
        }
        function checkCollisionWithGlobalPromiseInGeneratedCode(node, name) {
            if (!name || languageVersion >= 4 /* ES2017 */ || !needCollisionCheckForIdentifier(node, name, "Promise")) {
                return;
            }
            // Uninstantiated modules shouldnt do this check
            if (ts.isModuleDeclaration(node) && ts.getModuleInstanceState(node) !== 1 /* Instantiated */) {
                return;
            }
            // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
            var parent = getDeclarationContainer(node);
            if (parent.kind === 300 /* SourceFile */ && ts.isExternalOrCommonJsModule(parent) && parent.flags & 2048 /* HasAsyncFunctions */) {
                // If the declaration happens to be in external module, report error that Promise is a reserved identifier.
                errorSkippedOn("noEmit", name, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, ts.declarationNameToString(name), ts.declarationNameToString(name));
            }
        }
        function recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name) {
            if (languageVersion <= 8 /* ES2021 */
                && (needCollisionCheckForIdentifier(node, name, "WeakMap") || needCollisionCheckForIdentifier(node, name, "WeakSet"))) {
                potentialWeakMapSetCollisions.push(node);
            }
        }
        function checkWeakMapSetCollision(node) {
            var enclosingBlockScope = ts.getEnclosingBlockScopeContainer(node);
            if (getNodeCheckFlags(enclosingBlockScope) & 67108864 /* ContainsClassWithPrivateIdentifiers */) {
                ts.Debug.assert(ts.isNamedDeclaration(node) && ts.isIdentifier(node.name) && typeof node.name.escapedText === "string", "The target of a WeakMap/WeakSet collision check should be an identifier");
                errorSkippedOn("noEmit", node, ts.Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel, node.name.escapedText);
            }
        }
        function recordPotentialCollisionWithReflectInGeneratedCode(node, name) {
            if (name && languageVersion >= 2 /* ES2015 */ && languageVersion <= 8 /* ES2021 */
                && needCollisionCheckForIdentifier(node, name, "Reflect")) {
                potentialReflectCollisions.push(node);
            }
        }
        function checkReflectCollision(node) {
            var hasCollision = false;
            if (ts.isClassExpression(node)) {
                // ClassExpression names don't contribute to their containers, but do matter for any of their block-scoped members.
                for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                    var member = _a[_i];
                    if (getNodeCheckFlags(member) & 134217728 /* ContainsSuperPropertyInStaticInitializer */) {
                        hasCollision = true;
                        break;
                    }
                }
            }
            else if (ts.isFunctionExpression(node)) {
                // FunctionExpression names don't contribute to their containers, but do matter for their contents
                if (getNodeCheckFlags(node) & 134217728 /* ContainsSuperPropertyInStaticInitializer */) {
                    hasCollision = true;
                }
            }
            else {
                var container = ts.getEnclosingBlockScopeContainer(node);
                if (container && getNodeCheckFlags(container) & 134217728 /* ContainsSuperPropertyInStaticInitializer */) {
                    hasCollision = true;
                }
            }
            if (hasCollision) {
                ts.Debug.assert(ts.isNamedDeclaration(node) && ts.isIdentifier(node.name), "The target of a Reflect collision check should be an identifier");
                errorSkippedOn("noEmit", node, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers, ts.declarationNameToString(node.name), "Reflect");
            }
        }
        function checkCollisionsForDeclarationName(node, name) {
            if (!name)
                return;
            checkCollisionWithRequireExportsInGeneratedCode(node, name);
            checkCollisionWithGlobalPromiseInGeneratedCode(node, name);
            recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name);
            recordPotentialCollisionWithReflectInGeneratedCode(node, name);
            if (ts.isClassLike(node)) {
                checkTypeNameIsReserved(name, ts.Diagnostics.Class_name_cannot_be_0);
                if (!(node.flags & 8388608 /* Ambient */)) {
                    checkClassNameCollisionWithObject(name);
                }
            }
            else if (ts.isEnumDeclaration(node)) {
                checkTypeNameIsReserved(name, ts.Diagnostics.Enum_name_cannot_be_0);
            }
        }
        function checkVarDeclaredNamesNotShadowed(node) {
            // - ScriptBody : StatementList
            // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
            // also occurs in the VarDeclaredNames of StatementList.
            // - Block : { StatementList }
            // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
            // also occurs in the VarDeclaredNames of StatementList.
            // Variable declarations are hoisted to the top of their function scope. They can shadow
            // block scoped declarations, which bind tighter. this will not be flagged as duplicate definition
            // by the binder as the declaration scope is different.
            // A non-initialized declaration is a no-op as the block declaration will resolve before the var
            // declaration. the problem is if the declaration has an initializer. this will act as a write to the
            // block declared value. this is fine for let, but not const.
            // Only consider declarations with initializers, uninitialized const declarations will not
            // step on a let/const variable.
            // Do not consider const and const declarations, as duplicate block-scoped declarations
            // are handled by the binder.
            // We are only looking for const declarations that step on let\const declarations from a
            // different scope. e.g.:
            //      {
            //          const x = 0; // localDeclarationSymbol obtained after name resolution will correspond to this declaration
            //          const x = 0; // symbol for this declaration will be 'symbol'
            //      }
            // skip block-scoped variables and parameters
            if ((ts.getCombinedNodeFlags(node) & 3 /* BlockScoped */) !== 0 || ts.isParameterDeclaration(node)) {
                return;
            }
            // skip variable declarations that don't have initializers
            // NOTE: in ES6 spec initializer is required in variable declarations where name is binding pattern
            // so we'll always treat binding elements as initialized
            if (node.kind === 252 /* VariableDeclaration */ && !node.initializer) {
                return;
            }
            var symbol = getSymbolOfNode(node);
            if (symbol.flags & 1 /* FunctionScopedVariable */) {
                if (!ts.isIdentifier(node.name))
                    return ts.Debug.fail();
                var localDeclarationSymbol = resolveName(node, node.name.escapedText, 3 /* Variable */, /*nodeNotFoundErrorMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false);
                if (localDeclarationSymbol &&
                    localDeclarationSymbol !== symbol &&
                    localDeclarationSymbol.flags & 2 /* BlockScopedVariable */) {
                    if (getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & 3 /* BlockScoped */) {
                        var varDeclList = ts.getAncestor(localDeclarationSymbol.valueDeclaration, 253 /* VariableDeclarationList */);
                        var container = varDeclList.parent.kind === 235 /* VariableStatement */ && varDeclList.parent.parent
                            ? varDeclList.parent.parent
                            : undefined;
                        // names of block-scoped and function scoped variables can collide only
                        // if block scoped variable is defined in the function\module\source file scope (because of variable hoisting)
                        var namesShareScope = container &&
                            (container.kind === 233 /* Block */ && ts.isFunctionLike(container.parent) ||
                                container.kind === 260 /* ModuleBlock */ ||
                                container.kind === 259 /* ModuleDeclaration */ ||
                                container.kind === 300 /* SourceFile */);
                        // here we know that function scoped variable is shadowed by block scoped one
                        // if they are defined in the same scope - binder has already reported redeclaration error
                        // otherwise if variable has an initializer - show error that initialization will fail
                        // since LHS will be block scoped name instead of function scoped
                        if (!namesShareScope) {
                            var name = symbolToString(localDeclarationSymbol);
                            error(node, ts.Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name);
                        }
                    }
                }
            }
        }
        function convertAutoToAny(type) {
            return type === autoType ? anyType : type === autoArrayType ? anyArrayType : type;
        }
        // Check variable, parameter, or property declaration
        function checkVariableLikeDeclaration(node) {
            var _a;
            checkDecorators(node);
            if (!ts.isBindingElement(node)) {
                checkSourceElement(node.type);
            }
            // JSDoc `function(string, string): string` syntax results in parameters with no name
            if (!node.name) {
                return;
            }
            // For a computed property, just check the initializer and exit
            // Do not use hasDynamicName here, because that returns false for well known symbols.
            // We want to perform checkComputedPropertyName for all computed properties, including
            // well known symbols.
            if (node.name.kind === 160 /* ComputedPropertyName */) {
                checkComputedPropertyName(node.name);
                if (node.initializer) {
                    checkExpressionCached(node.initializer);
                }
            }
            if (ts.isBindingElement(node)) {
                if (ts.isObjectBindingPattern(node.parent) && node.dotDotDotToken && languageVersion < 5 /* ES2018 */) {
                    checkExternalEmitHelpers(node, 4 /* Rest */);
                }
                // check computed properties inside property names of binding elements
                if (node.propertyName && node.propertyName.kind === 160 /* ComputedPropertyName */) {
                    checkComputedPropertyName(node.propertyName);
                }
                // check private/protected variable access
                var parent = node.parent.parent;
                var parentType = getTypeForBindingElementParent(parent);
                var name = node.propertyName || node.name;
                if (parentType && !ts.isBindingPattern(name)) {
                    var exprType = getLiteralTypeFromPropertyName(name);
                    if (isTypeUsableAsPropertyName(exprType)) {
                        var nameText = getPropertyNameFromType(exprType);
                        var property = getPropertyOfType(parentType, nameText);
                        if (property) {
                            markPropertyAsReferenced(property, /*nodeForCheckWriteOnly*/ undefined, /*isSelfTypeAccess*/ false); // A destructuring is never a write-only reference.
                            checkPropertyAccessibility(node, !!parent.initializer && parent.initializer.kind === 106 /* SuperKeyword */, /*writing*/ false, parentType, property);
                        }
                    }
                }
            }
            // For a binding pattern, check contained binding elements
            if (ts.isBindingPattern(node.name)) {
                if (node.name.kind === 200 /* ArrayBindingPattern */ && languageVersion < 2 /* ES2015 */ && compilerOptions.downlevelIteration) {
                    checkExternalEmitHelpers(node, 512 /* Read */);
                }
                ts.forEach(node.name.elements, checkSourceElement);
            }
            // For a parameter declaration with an initializer, error and exit if the containing function doesn't have a body
            if (node.initializer && ts.isParameterDeclaration(node) && ts.nodeIsMissing(ts.getContainingFunction(node).body)) {
                error(node, ts.Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
                return;
            }
            // For a binding pattern, validate the initializer and exit
            if (ts.isBindingPattern(node.name)) {
                var needCheckInitializer = node.initializer && node.parent.parent.kind !== 241 /* ForInStatement */;
                var needCheckWidenedType = node.name.elements.length === 0;
                if (needCheckInitializer || needCheckWidenedType) {
                    // Don't validate for-in initializer as it is already an error
                    var widenedType = getWidenedTypeForVariableLikeDeclaration(node);
                    if (needCheckInitializer) {
                        var initializerType = checkExpressionCached(node.initializer);
                        if (strictNullChecks && needCheckWidenedType) {
                            checkNonNullNonVoidType(initializerType, node);
                        }
                        else {
                            checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer);
                        }
                    }
                    // check the binding pattern with empty elements
                    if (needCheckWidenedType) {
                        if (ts.isArrayBindingPattern(node.name)) {
                            checkIteratedTypeOrElementType(65 /* Destructuring */, widenedType, undefinedType, node);
                        }
                        else if (strictNullChecks) {
                            checkNonNullNonVoidType(widenedType, node);
                        }
                    }
                }
                return;
            }
            // For a commonjs `const x = require`, validate the alias and exit
            var symbol = getSymbolOfNode(node);
            if (symbol.flags & 2097152 /* Alias */ && ts.isRequireVariableDeclaration(node)) {
                checkAliasSymbol(node);
                return;
            }
            var type = convertAutoToAny(getTypeOfSymbol(symbol));
            if (node === symbol.valueDeclaration) {
                // Node is the primary declaration of the symbol, just validate the initializer
                // Don't validate for-in initializer as it is already an error
                var initializer = ts.getEffectiveInitializer(node);
                if (initializer) {
                    var isJSObjectLiteralInitializer = ts.isInJSFile(node) &&
                        ts.isObjectLiteralExpression(initializer) &&
                        (initializer.properties.length === 0 || ts.isPrototypeAccess(node.name)) &&
                        !!((_a = symbol.exports) === null || _a === void 0 ? void 0 : _a.size);
                    if (!isJSObjectLiteralInitializer && node.parent.parent.kind !== 241 /* ForInStatement */) {
                        checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(initializer), type, node, initializer, /*headMessage*/ undefined);
                    }
                }
                if (symbol.declarations && symbol.declarations.length > 1) {
                    if (ts.some(symbol.declarations, function (d) { return d !== node && ts.isVariableLike(d) && !areDeclarationFlagsIdentical(d, node); })) {
                        error(node.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_modifiers, ts.declarationNameToString(node.name));
                    }
                }
            }
            else {
                // Node is a secondary declaration, check that type is identical to primary declaration and check that
                // initializer is consistent with type associated with the node
                var declarationType = convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node));
                if (type !== errorType && declarationType !== errorType &&
                    !isTypeIdenticalTo(type, declarationType) &&
                    !(symbol.flags & 67108864 /* Assignment */)) {
                    errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type, node, declarationType);
                }
                if (node.initializer) {
                    checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(node.initializer), declarationType, node, node.initializer, /*headMessage*/ undefined);
                }
                if (symbol.valueDeclaration && !areDeclarationFlagsIdentical(node, symbol.valueDeclaration)) {
                    error(node.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_modifiers, ts.declarationNameToString(node.name));
                }
            }
            if (node.kind !== 165 /* PropertyDeclaration */ && node.kind !== 164 /* PropertySignature */) {
                // We know we don't have a binding pattern or computed name here
                checkExportsOnMergedDeclarations(node);
                if (node.kind === 252 /* VariableDeclaration */ || node.kind === 201 /* BindingElement */) {
                    checkVarDeclaredNamesNotShadowed(node);
                }
                checkCollisionsForDeclarationName(node, node.name);
            }
        }
        function errorNextVariableOrPropertyDeclarationMustHaveSameType(firstDeclaration, firstType, nextDeclaration, nextType) {
            var nextDeclarationName = ts.getNameOfDeclaration(nextDeclaration);
            var message = nextDeclaration.kind === 165 /* PropertyDeclaration */ || nextDeclaration.kind === 164 /* PropertySignature */
                ? ts.Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2
                : ts.Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2;
            var declName = ts.declarationNameToString(nextDeclarationName);
            var err = error(nextDeclarationName, message, declName, typeToString(firstType), typeToString(nextType));
            if (firstDeclaration) {
                ts.addRelatedInfo(err, ts.createDiagnosticForNode(firstDeclaration, ts.Diagnostics._0_was_also_declared_here, declName));
            }
        }
        function areDeclarationFlagsIdentical(left, right) {
            if ((left.kind === 162 /* Parameter */ && right.kind === 252 /* VariableDeclaration */) ||
                (left.kind === 252 /* VariableDeclaration */ && right.kind === 162 /* Parameter */)) {
                // Differences in optionality between parameters and variables are allowed.
                return true;
            }
            if (ts.hasQuestionToken(left) !== ts.hasQuestionToken(right)) {
                return false;
            }
            var interestingFlags = 8 /* Private */ |
                16 /* Protected */ |
                256 /* Async */ |
                128 /* Abstract */ |
                64 /* Readonly */ |
                32 /* Static */;
            return ts.getSelectedEffectiveModifierFlags(left, interestingFlags) === ts.getSelectedEffectiveModifierFlags(right, interestingFlags);
        }
        function checkVariableDeclaration(node) {
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("check" /* Check */, "checkVariableDeclaration", { kind: node.kind, pos: node.pos, end: node.end });
            checkGrammarVariableDeclaration(node);
            checkVariableLikeDeclaration(node);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        }
        function checkBindingElement(node) {
            checkGrammarBindingElement(node);
            return checkVariableLikeDeclaration(node);
        }
        function checkVariableStatement(node) {
            // Grammar checking
            if (!checkGrammarDecoratorsAndModifiers(node) && !checkGrammarVariableDeclarationList(node.declarationList))
                checkGrammarForDisallowedLetOrConstStatement(node);
            ts.forEach(node.declarationList.declarations, checkSourceElement);
        }
        function checkExpressionStatement(node) {
            // Grammar checking
            checkGrammarStatementInAmbientContext(node);
            checkExpression(node.expression);
        }
        function checkIfStatement(node) {
            // Grammar checking
            checkGrammarStatementInAmbientContext(node);
            var type = checkTruthinessExpression(node.expression);
            checkTestingKnownTruthyCallableOrAwaitableType(node.expression, type, node.thenStatement);
            checkSourceElement(node.thenStatement);
            if (node.thenStatement.kind === 234 /* EmptyStatement */) {
                error(node.thenStatement, ts.Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement);
            }
            checkSourceElement(node.elseStatement);
        }
        function checkTestingKnownTruthyCallableOrAwaitableType(condExpr, type, body) {
            if (!strictNullChecks)
                return;
            if (getFalsyFlags(type))
                return;
            var location = ts.isBinaryExpression(condExpr) ? condExpr.right : condExpr;
            if (ts.isPropertyAccessExpression(location) && ts.isAssertionExpression(ts.skipParentheses(location.expression))) {
                return;
            }
            var testedNode = ts.isIdentifier(location) ? location
                : ts.isPropertyAccessExpression(location) ? location.name
                    : ts.isBinaryExpression(location) && ts.isIdentifier(location.right) ? location.right
                        : undefined;
            // While it technically should be invalid for any known-truthy value
            // to be tested, we de-scope to functions and Promises unreferenced in
            // the block as a heuristic to identify the most common bugs. There
            // are too many false positives for values sourced from type
            // definitions without strictNullChecks otherwise.
            var callSignatures = getSignaturesOfType(type, 0 /* Call */);
            var isPromise = !!getAwaitedTypeOfPromise(type);
            if (callSignatures.length === 0 && !isPromise) {
                return;
            }
            var testedSymbol = testedNode && getSymbolAtLocation(testedNode);
            if (!testedSymbol && !isPromise) {
                return;
            }
            var isUsed = testedSymbol && ts.isBinaryExpression(condExpr.parent) && isSymbolUsedInBinaryExpressionChain(condExpr.parent, testedSymbol)
                || testedSymbol && body && isSymbolUsedInConditionBody(condExpr, body, testedNode, testedSymbol);
            if (!isUsed) {
                if (isPromise) {
                    errorAndMaybeSuggestAwait(location, 
                    /*maybeMissingAwait*/ true, ts.Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined, getTypeNameForErrorDisplay(type));
                }
                else {
                    error(location, ts.Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead);
                }
            }
        }
        function isSymbolUsedInConditionBody(expr, body, testedNode, testedSymbol) {
            return !!ts.forEachChild(body, function check(childNode) {
                if (ts.isIdentifier(childNode)) {
                    var childSymbol = getSymbolAtLocation(childNode);
                    if (childSymbol && childSymbol === testedSymbol) {
                        // If the test was a simple identifier, the above check is sufficient
                        if (ts.isIdentifier(expr)) {
                            return true;
                        }
                        // Otherwise we need to ensure the symbol is called on the same target
                        var testedExpression = testedNode.parent;
                        var childExpression = childNode.parent;
                        while (testedExpression && childExpression) {
                            if (ts.isIdentifier(testedExpression) && ts.isIdentifier(childExpression) ||
                                testedExpression.kind === 108 /* ThisKeyword */ && childExpression.kind === 108 /* ThisKeyword */) {
                                return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(childExpression);
                            }
                            else if (ts.isPropertyAccessExpression(testedExpression) && ts.isPropertyAccessExpression(childExpression)) {
                                if (getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(childExpression.name)) {
                                    return false;
                                }
                                childExpression = childExpression.expression;
                                testedExpression = testedExpression.expression;
                            }
                            else if (ts.isCallExpression(testedExpression) && ts.isCallExpression(childExpression)) {
                                childExpression = childExpression.expression;
                                testedExpression = testedExpression.expression;
                            }
                            else {
                                return false;
                            }
                        }
                    }
                }
                return ts.forEachChild(childNode, check);
            });
        }
        function isSymbolUsedInBinaryExpressionChain(node, testedSymbol) {
            while (ts.isBinaryExpression(node) && node.operatorToken.kind === 55 /* AmpersandAmpersandToken */) {
                var isUsed = ts.forEachChild(node.right, function visit(child) {
                    if (ts.isIdentifier(child)) {
                        var symbol = getSymbolAtLocation(child);
                        if (symbol && symbol === testedSymbol) {
                            return true;
                        }
                    }
                    return ts.forEachChild(child, visit);
                });
                if (isUsed) {
                    return true;
                }
                node = node.parent;
            }
            return false;
        }
        function checkDoStatement(node) {
            // Grammar checking
            checkGrammarStatementInAmbientContext(node);
            checkSourceElement(node.statement);
            checkTruthinessExpression(node.expression);
        }
        function checkWhileStatement(node) {
            // Grammar checking
            checkGrammarStatementInAmbientContext(node);
            checkTruthinessExpression(node.expression);
            checkSourceElement(node.statement);
        }
        function checkTruthinessOfType(type, node) {
            if (type.flags & 16384 /* Void */) {
                error(node, ts.Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness);
            }
            return type;
        }
        function checkTruthinessExpression(node, checkMode) {
            return checkTruthinessOfType(checkExpression(node, checkMode), node);
        }
        function checkForStatement(node) {
            // Grammar checking
            if (!checkGrammarStatementInAmbientContext(node)) {
                if (node.initializer && node.initializer.kind === 253 /* VariableDeclarationList */) {
                    checkGrammarVariableDeclarationList(node.initializer);
                }
            }
            if (node.initializer) {
                if (node.initializer.kind === 253 /* VariableDeclarationList */) {
                    ts.forEach(node.initializer.declarations, checkVariableDeclaration);
                }
                else {
                    checkExpression(node.initializer);
                }
            }
            if (node.condition)
                checkTruthinessExpression(node.condition);
            if (node.incrementor)
                checkExpression(node.incrementor);
            checkSourceElement(node.statement);
            if (node.locals) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkForOfStatement(node) {
            checkGrammarForInOrForOfStatement(node);
            var container = ts.getContainingFunctionOrClassStaticBlock(node);
            if (node.awaitModifier) {
                if (container && ts.isClassStaticBlockDeclaration(container)) {
                    grammarErrorOnNode(node.awaitModifier, ts.Diagnostics.For_await_loops_cannot_be_used_inside_a_class_static_block);
                }
                else {
                    var functionFlags = ts.getFunctionFlags(container);
                    if ((functionFlags & (4 /* Invalid */ | 2 /* Async */)) === 2 /* Async */ && languageVersion < 99 /* ESNext */) {
                        // for..await..of in an async function or async generator function prior to ESNext requires the __asyncValues helper
                        checkExternalEmitHelpers(node, 16384 /* ForAwaitOfIncludes */);
                    }
                }
            }
            else if (compilerOptions.downlevelIteration && languageVersion < 2 /* ES2015 */) {
                // for..of prior to ES2015 requires the __values helper when downlevelIteration is enabled
                checkExternalEmitHelpers(node, 256 /* ForOfIncludes */);
            }
            // Check the LHS and RHS
            // If the LHS is a declaration, just check it as a variable declaration, which will in turn check the RHS
            // via checkRightHandSideOfForOf.
            // If the LHS is an expression, check the LHS, as a destructuring assignment or as a reference.
            // Then check that the RHS is assignable to it.
            if (node.initializer.kind === 253 /* VariableDeclarationList */) {
                checkForInOrForOfVariableDeclaration(node);
            }
            else {
                var varExpr = node.initializer;
                var iteratedType = checkRightHandSideOfForOf(node);
                // There may be a destructuring assignment on the left side
                if (varExpr.kind === 202 /* ArrayLiteralExpression */ || varExpr.kind === 203 /* ObjectLiteralExpression */) {
                    // iteratedType may be undefined. In this case, we still want to check the structure of
                    // varExpr, in particular making sure it's a valid LeftHandSideExpression. But we'd like
                    // to short circuit the type relation checking as much as possible, so we pass the unknownType.
                    checkDestructuringAssignment(varExpr, iteratedType || errorType);
                }
                else {
                    var leftType = checkExpression(varExpr);
                    checkReferenceExpression(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access, ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access);
                    // iteratedType will be undefined if the rightType was missing properties/signatures
                    // required to get its iteratedType (like [Symbol.iterator] or next). This may be
                    // because we accessed properties from anyType, or it may have led to an error inside
                    // getElementTypeOfIterable.
                    if (iteratedType) {
                        checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression);
                    }
                }
            }
            checkSourceElement(node.statement);
            if (node.locals) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkForInStatement(node) {
            // Grammar checking
            checkGrammarForInOrForOfStatement(node);
            var rightType = getNonNullableTypeIfNeeded(checkExpression(node.expression));
            // TypeScript 1.0 spec (April 2014): 5.4
            // In a 'for-in' statement of the form
            // for (let VarDecl in Expr) Statement
            //   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,
            //   and Expr must be an expression of type Any, an object type, or a type parameter type.
            if (node.initializer.kind === 253 /* VariableDeclarationList */) {
                var variable = node.initializer.declarations[0];
                if (variable && ts.isBindingPattern(variable.name)) {
                    error(variable.name, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
                }
                checkForInOrForOfVariableDeclaration(node);
            }
            else {
                // In a 'for-in' statement of the form
                // for (Var in Expr) Statement
                //   Var must be an expression classified as a reference of type Any or the String primitive type,
                //   and Expr must be an expression of type Any, an object type, or a type parameter type.
                var varExpr = node.initializer;
                var leftType = checkExpression(varExpr);
                if (varExpr.kind === 202 /* ArrayLiteralExpression */ || varExpr.kind === 203 /* ObjectLiteralExpression */) {
                    error(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
                }
                else if (!isTypeAssignableTo(getIndexTypeOrString(rightType), leftType)) {
                    error(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);
                }
                else {
                    // run check only former check succeeded to avoid cascading errors
                    checkReferenceExpression(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access);
                }
            }
            // unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved
            // in this case error about missing name is already reported - do not report extra one
            if (rightType === neverType || !isTypeAssignableToKind(rightType, 67108864 /* NonPrimitive */ | 58982400 /* InstantiableNonPrimitive */)) {
                error(node.expression, ts.Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, typeToString(rightType));
            }
            checkSourceElement(node.statement);
            if (node.locals) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkForInOrForOfVariableDeclaration(iterationStatement) {
            var variableDeclarationList = iterationStatement.initializer;
            // checkGrammarForInOrForOfStatement will check that there is exactly one declaration.
            if (variableDeclarationList.declarations.length >= 1) {
                var decl = variableDeclarationList.declarations[0];
                checkVariableDeclaration(decl);
            }
        }
        function checkRightHandSideOfForOf(statement) {
            var use = statement.awaitModifier ? 15 /* ForAwaitOf */ : 13 /* ForOf */;
            return checkIteratedTypeOrElementType(use, checkNonNullExpression(statement.expression), undefinedType, statement.expression);
        }
        function checkIteratedTypeOrElementType(use, inputType, sentType, errorNode) {
            if (isTypeAny(inputType)) {
                return inputType;
            }
            return getIteratedTypeOrElementType(use, inputType, sentType, errorNode, /*checkAssignability*/ true) || anyType;
        }
        /**
         * When consuming an iterable type in a for..of, spread, or iterator destructuring assignment
         * we want to get the iterated type of an iterable for ES2015 or later, or the iterated type
         * of a iterable (if defined globally) or element type of an array like for ES2015 or earlier.
         */
        function getIteratedTypeOrElementType(use, inputType, sentType, errorNode, checkAssignability) {
            var allowAsyncIterables = (use & 2 /* AllowsAsyncIterablesFlag */) !== 0;
            if (inputType === neverType) {
                reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables); // TODO: GH#18217
                return undefined;
            }
            var uplevelIteration = languageVersion >= 2 /* ES2015 */;
            var downlevelIteration = !uplevelIteration && compilerOptions.downlevelIteration;
            var possibleOutOfBounds = compilerOptions.noUncheckedIndexedAccess && !!(use & 128 /* PossiblyOutOfBounds */);
            // Get the iterated type of an `Iterable<T>` or `IterableIterator<T>` only in ES2015
            // or higher, when inside of an async generator or for-await-if, or when
            // downlevelIteration is requested.
            if (uplevelIteration || downlevelIteration || allowAsyncIterables) {
                // We only report errors for an invalid iterable type in ES2015 or higher.
                var iterationTypes = getIterationTypesOfIterable(inputType, use, uplevelIteration ? errorNode : undefined);
                if (checkAssignability) {
                    if (iterationTypes) {
                        var diagnostic = use & 8 /* ForOfFlag */ ? ts.Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 :
                            use & 32 /* SpreadFlag */ ? ts.Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 :
                                use & 64 /* DestructuringFlag */ ? ts.Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 :
                                    use & 16 /* YieldStarFlag */ ? ts.Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 :
                                        undefined;
                        if (diagnostic) {
                            checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic);
                        }
                    }
                }
                if (iterationTypes || uplevelIteration) {
                    return possibleOutOfBounds ? includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType) : (iterationTypes && iterationTypes.yieldType);
                }
            }
            var arrayType = inputType;
            var reportedError = false;
            var hasStringConstituent = false;
            // If strings are permitted, remove any string-like constituents from the array type.
            // This allows us to find other non-string element types from an array unioned with
            // a string.
            if (use & 4 /* AllowsStringInputFlag */) {
                if (arrayType.flags & 1048576 /* Union */) {
                    // After we remove all types that are StringLike, we will know if there was a string constituent
                    // based on whether the result of filter is a new array.
                    var arrayTypes = inputType.types;
                    var filteredTypes = ts.filter(arrayTypes, function (t) { return !(t.flags & 402653316 /* StringLike */); });
                    if (filteredTypes !== arrayTypes) {
                        arrayType = getUnionType(filteredTypes, 2 /* Subtype */);
                    }
                }
                else if (arrayType.flags & 402653316 /* StringLike */) {
                    arrayType = neverType;
                }
                hasStringConstituent = arrayType !== inputType;
                if (hasStringConstituent) {
                    if (languageVersion < 1 /* ES5 */) {
                        if (errorNode) {
                            error(errorNode, ts.Diagnostics.Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher);
                            reportedError = true;
                        }
                    }
                    // Now that we've removed all the StringLike types, if no constituents remain, then the entire
                    // arrayOrStringType was a string.
                    if (arrayType.flags & 131072 /* Never */) {
                        return possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType;
                    }
                }
            }
            if (!isArrayLikeType(arrayType)) {
                if (errorNode && !reportedError) {
                    // Which error we report depends on whether we allow strings or if there was a
                    // string constituent. For example, if the input type is number | string, we
                    // want to say that number is not an array type. But if the input was just
                    // number and string input is allowed, we want to say that number is not an
                    // array type or a string type.
                    var allowsStrings = !!(use & 4 /* AllowsStringInputFlag */) && !hasStringConstituent;
                    var _a = getIterationDiagnosticDetails(allowsStrings, downlevelIteration), defaultDiagnostic = _a[0], maybeMissingAwait = _a[1];
                    errorAndMaybeSuggestAwait(errorNode, maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType), defaultDiagnostic, typeToString(arrayType));
                }
                return hasStringConstituent ? possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType : undefined;
            }
            var arrayElementType = getIndexTypeOfType(arrayType, numberType);
            if (hasStringConstituent && arrayElementType) {
                // This is just an optimization for the case where arrayOrStringType is string | string[]
                if (arrayElementType.flags & 402653316 /* StringLike */ && !compilerOptions.noUncheckedIndexedAccess) {
                    return stringType;
                }
                return getUnionType(possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [arrayElementType, stringType], 2 /* Subtype */);
            }
            return (use & 128 /* PossiblyOutOfBounds */) ? includeUndefinedInIndexSignature(arrayElementType) : arrayElementType;
            function getIterationDiagnosticDetails(allowsStrings, downlevelIteration) {
                var _a;
                if (downlevelIteration) {
                    return allowsStrings
                        ? [ts.Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true]
                        : [ts.Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true];
                }
                var yieldType = getIterationTypeOfIterable(use, 0 /* Yield */, inputType, /*errorNode*/ undefined);
                if (yieldType) {
                    return [ts.Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_Use_compiler_option_downlevelIteration_to_allow_iterating_of_iterators, false];
                }
                if (isES2015OrLaterIterable((_a = inputType.symbol) === null || _a === void 0 ? void 0 : _a.escapedName)) {
                    return [ts.Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true];
                }
                return allowsStrings
                    ? [ts.Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true]
                    : [ts.Diagnostics.Type_0_is_not_an_array_type, true];
            }
        }
        function isES2015OrLaterIterable(n) {
            switch (n) {
                case "Float32Array":
                case "Float64Array":
                case "Int16Array":
                case "Int32Array":
                case "Int8Array":
                case "NodeList":
                case "Uint16Array":
                case "Uint32Array":
                case "Uint8Array":
                case "Uint8ClampedArray":
                    return true;
            }
            return false;
        }
        /**
         * Gets the requested "iteration type" from an `Iterable`-like or `AsyncIterable`-like type.
         */
        function getIterationTypeOfIterable(use, typeKind, inputType, errorNode) {
            if (isTypeAny(inputType)) {
                return undefined;
            }
            var iterationTypes = getIterationTypesOfIterable(inputType, use, errorNode);
            return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)];
        }
        function createIterationTypes(yieldType, returnType, nextType) {
            // `yieldType` and `returnType` are defaulted to `neverType` they each will be combined
            // via `getUnionType` when merging iteration types. `nextType` is defined as `unknownType`
            // as it is combined via `getIntersectionType` when merging iteration types.
            if (yieldType === void 0) { yieldType = neverType; }
            if (returnType === void 0) { returnType = neverType; }
            if (nextType === void 0) { nextType = unknownType; }
            // Use the cache only for intrinsic types to keep it small as they are likely to be
            // more frequently created (i.e. `Iterator<number, void, unknown>`). Iteration types
            // are also cached on the type they are requested for, so we shouldn't need to maintain
            // the cache for less-frequently used types.
            if (yieldType.flags & 67359327 /* Intrinsic */ &&
                returnType.flags & (1 /* Any */ | 131072 /* Never */ | 2 /* Unknown */ | 16384 /* Void */ | 32768 /* Undefined */) &&
                nextType.flags & (1 /* Any */ | 131072 /* Never */ | 2 /* Unknown */ | 16384 /* Void */ | 32768 /* Undefined */)) {
                var id = getTypeListId([yieldType, returnType, nextType]);
                var iterationTypes = iterationTypesCache.get(id);
                if (!iterationTypes) {
                    iterationTypes = { yieldType: yieldType, returnType: returnType, nextType: nextType };
                    iterationTypesCache.set(id, iterationTypes);
                }
                return iterationTypes;
            }
            return { yieldType: yieldType, returnType: returnType, nextType: nextType };
        }
        /**
         * Combines multiple `IterationTypes` records.
         *
         * If `array` is empty or all elements are missing or are references to `noIterationTypes`,
         * then `noIterationTypes` is returned. Otherwise, an `IterationTypes` record is returned
         * for the combined iteration types.
         */
        function combineIterationTypes(array) {
            var yieldTypes;
            var returnTypes;
            var nextTypes;
            for (var _i = 0, array_11 = array; _i < array_11.length; _i++) {
                var iterationTypes = array_11[_i];
                if (iterationTypes === undefined || iterationTypes === noIterationTypes) {
                    continue;
                }
                if (iterationTypes === anyIterationTypes) {
                    return anyIterationTypes;
                }
                yieldTypes = ts.append(yieldTypes, iterationTypes.yieldType);
                returnTypes = ts.append(returnTypes, iterationTypes.returnType);
                nextTypes = ts.append(nextTypes, iterationTypes.nextType);
            }
            if (yieldTypes || returnTypes || nextTypes) {
                return createIterationTypes(yieldTypes && getUnionType(yieldTypes), returnTypes && getUnionType(returnTypes), nextTypes && getIntersectionType(nextTypes));
            }
            return noIterationTypes;
        }
        function getCachedIterationTypes(type, cacheKey) {
            return type[cacheKey];
        }
        function setCachedIterationTypes(type, cacheKey, cachedTypes) {
            return type[cacheKey] = cachedTypes;
        }
        /**
         * Gets the *yield*, *return*, and *next* types from an `Iterable`-like or `AsyncIterable`-like type.
         *
         * At every level that involves analyzing return types of signatures, we union the return types of all the signatures.
         *
         * Another thing to note is that at any step of this process, we could run into a dead end,
         * meaning either the property is missing, or we run into the anyType. If either of these things
         * happens, we return `undefined` to signal that we could not find the iteration type. If a property
         * is missing, and the previous step did not result in `any`, then we also give an error if the
         * caller requested it. Then the caller can decide what to do in the case where there is no iterated
         * type.
         *
         * For a **for-of** statement, `yield*` (in a normal generator), spread, array
         * destructuring, or normal generator we will only ever look for a `[Symbol.iterator]()`
         * method.
         *
         * For an async generator we will only ever look at the `[Symbol.asyncIterator]()` method.
         *
         * For a **for-await-of** statement or a `yield*` in an async generator we will look for
         * the `[Symbol.asyncIterator]()` method first, and then the `[Symbol.iterator]()` method.
         */
        function getIterationTypesOfIterable(type, use, errorNode) {
            if (isTypeAny(type)) {
                return anyIterationTypes;
            }
            if (!(type.flags & 1048576 /* Union */)) {
                var iterationTypes_1 = getIterationTypesOfIterableWorker(type, use, errorNode);
                if (iterationTypes_1 === noIterationTypes) {
                    if (errorNode) {
                        reportTypeNotIterableError(errorNode, type, !!(use & 2 /* AllowsAsyncIterablesFlag */));
                    }
                    return undefined;
                }
                return iterationTypes_1;
            }
            var cacheKey = use & 2 /* AllowsAsyncIterablesFlag */ ? "iterationTypesOfAsyncIterable" : "iterationTypesOfIterable";
            var cachedTypes = getCachedIterationTypes(type, cacheKey);
            if (cachedTypes)
                return cachedTypes === noIterationTypes ? undefined : cachedTypes;
            var allIterationTypes;
            for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
                var constituent = _a[_i];
                var iterationTypes_2 = getIterationTypesOfIterableWorker(constituent, use, errorNode);
                if (iterationTypes_2 === noIterationTypes) {
                    if (errorNode) {
                        reportTypeNotIterableError(errorNode, type, !!(use & 2 /* AllowsAsyncIterablesFlag */));
                    }
                    setCachedIterationTypes(type, cacheKey, noIterationTypes);
                    return undefined;
                }
                else {
                    allIterationTypes = ts.append(allIterationTypes, iterationTypes_2);
                }
            }
            var iterationTypes = allIterationTypes ? combineIterationTypes(allIterationTypes) : noIterationTypes;
            setCachedIterationTypes(type, cacheKey, iterationTypes);
            return iterationTypes === noIterationTypes ? undefined : iterationTypes;
        }
        function getAsyncFromSyncIterationTypes(iterationTypes, errorNode) {
            if (iterationTypes === noIterationTypes)
                return noIterationTypes;
            if (iterationTypes === anyIterationTypes)
                return anyIterationTypes;
            var yieldType = iterationTypes.yieldType, returnType = iterationTypes.returnType, nextType = iterationTypes.nextType;
            return createIterationTypes(getAwaitedType(yieldType, errorNode) || anyType, getAwaitedType(returnType, errorNode) || anyType, nextType);
        }
        /**
         * Gets the *yield*, *return*, and *next* types from a non-union type.
         *
         * If we are unable to find the *yield*, *return*, and *next* types, `noIterationTypes` is
         * returned to indicate to the caller that it should report an error. Otherwise, an
         * `IterationTypes` record is returned.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterable` instead.
         */
        function getIterationTypesOfIterableWorker(type, use, errorNode) {
            if (isTypeAny(type)) {
                return anyIterationTypes;
            }
            if (use & 2 /* AllowsAsyncIterablesFlag */) {
                var iterationTypes = getIterationTypesOfIterableCached(type, asyncIterationTypesResolver) ||
                    getIterationTypesOfIterableFast(type, asyncIterationTypesResolver);
                if (iterationTypes) {
                    return iterationTypes;
                }
            }
            if (use & 1 /* AllowsSyncIterablesFlag */) {
                var iterationTypes = getIterationTypesOfIterableCached(type, syncIterationTypesResolver) ||
                    getIterationTypesOfIterableFast(type, syncIterationTypesResolver);
                if (iterationTypes) {
                    if (use & 2 /* AllowsAsyncIterablesFlag */) {
                        // for a sync iterable in an async context, only use the cached types if they are valid.
                        if (iterationTypes !== noIterationTypes) {
                            return setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", getAsyncFromSyncIterationTypes(iterationTypes, errorNode));
                        }
                    }
                    else {
                        return iterationTypes;
                    }
                }
            }
            if (use & 2 /* AllowsAsyncIterablesFlag */) {
                var iterationTypes = getIterationTypesOfIterableSlow(type, asyncIterationTypesResolver, errorNode);
                if (iterationTypes !== noIterationTypes) {
                    return iterationTypes;
                }
            }
            if (use & 1 /* AllowsSyncIterablesFlag */) {
                var iterationTypes = getIterationTypesOfIterableSlow(type, syncIterationTypesResolver, errorNode);
                if (iterationTypes !== noIterationTypes) {
                    if (use & 2 /* AllowsAsyncIterablesFlag */) {
                        return setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes
                            ? getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
                            : noIterationTypes);
                    }
                    else {
                        return iterationTypes;
                    }
                }
            }
            return noIterationTypes;
        }
        /**
         * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or
         * `AsyncIterable`-like type from the cache.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterable` instead.
         */
        function getIterationTypesOfIterableCached(type, resolver) {
            return getCachedIterationTypes(type, resolver.iterableCacheKey);
        }
        function getIterationTypesOfGlobalIterableType(globalType, resolver) {
            var globalIterationTypes = getIterationTypesOfIterableCached(globalType, resolver) ||
                getIterationTypesOfIterableSlow(globalType, resolver, /*errorNode*/ undefined);
            return globalIterationTypes === noIterationTypes ? defaultIterationTypes : globalIterationTypes;
        }
        /**
         * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or `AsyncIterable`-like
         * type from from common heuristics.
         *
         * If we previously analyzed this type and found no iteration types, `noIterationTypes` is
         * returned. If we found iteration types, an `IterationTypes` record is returned.
         * Otherwise, we return `undefined` to indicate to the caller it should perform a more
         * exhaustive analysis.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterable` instead.
         */
        function getIterationTypesOfIterableFast(type, resolver) {
            // As an optimization, if the type is an instantiation of one of the following global types, then
            // just grab its related type argument:
            // - `Iterable<T>` or `AsyncIterable<T>`
            // - `IterableIterator<T>` or `AsyncIterableIterator<T>`
            var globalType;
            if (isReferenceToType(type, globalType = resolver.getGlobalIterableType(/*reportErrors*/ false)) ||
                isReferenceToType(type, globalType = resolver.getGlobalIterableIteratorType(/*reportErrors*/ false))) {
                var yieldType = getTypeArguments(type)[0];
                // The "return" and "next" types of `Iterable` and `IterableIterator` are defined by the
                // iteration types of their `[Symbol.iterator]()` method. The same is true for their async cousins.
                // While we define these as `any` and `undefined` in our libs by default, a custom lib *could* use
                // different definitions.
                var _a = getIterationTypesOfGlobalIterableType(globalType, resolver), returnType = _a.returnType, nextType = _a.nextType;
                return setCachedIterationTypes(type, resolver.iterableCacheKey, createIterationTypes(yieldType, returnType, nextType));
            }
            // As an optimization, if the type is an instantiation of the following global type, then
            // just grab its related type arguments:
            // - `Generator<T, TReturn, TNext>` or `AsyncGenerator<T, TReturn, TNext>`
            if (isReferenceToType(type, resolver.getGlobalGeneratorType(/*reportErrors*/ false))) {
                var _b = getTypeArguments(type), yieldType = _b[0], returnType = _b[1], nextType = _b[2];
                return setCachedIterationTypes(type, resolver.iterableCacheKey, createIterationTypes(yieldType, returnType, nextType));
            }
        }
        function getPropertyNameForKnownSymbolName(symbolName) {
            var ctorType = getGlobalESSymbolConstructorSymbol(/*reportErrors*/ false);
            var uniqueType = ctorType && getTypeOfPropertyOfType(getTypeOfSymbol(ctorType), ts.escapeLeadingUnderscores(symbolName));
            return uniqueType && isTypeUsableAsPropertyName(uniqueType) ? getPropertyNameFromType(uniqueType) : "__@" + symbolName;
        }
        /**
         * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or `AsyncIterable`-like
         * type from its members.
         *
         * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
         * record is returned. Otherwise, `noIterationTypes` is returned.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterable` instead.
         */
        function getIterationTypesOfIterableSlow(type, resolver, errorNode) {
            var _a;
            var method = getPropertyOfType(type, getPropertyNameForKnownSymbolName(resolver.iteratorSymbolName));
            var methodType = method && !(method.flags & 16777216 /* Optional */) ? getTypeOfSymbol(method) : undefined;
            if (isTypeAny(methodType)) {
                return setCachedIterationTypes(type, resolver.iterableCacheKey, anyIterationTypes);
            }
            var signatures = methodType ? getSignaturesOfType(methodType, 0 /* Call */) : undefined;
            if (!ts.some(signatures)) {
                return setCachedIterationTypes(type, resolver.iterableCacheKey, noIterationTypes);
            }
            var iteratorType = getIntersectionType(ts.map(signatures, getReturnTypeOfSignature));
            var iterationTypes = (_a = getIterationTypesOfIterator(iteratorType, resolver, errorNode)) !== null && _a !== void 0 ? _a : noIterationTypes;
            return setCachedIterationTypes(type, resolver.iterableCacheKey, iterationTypes);
        }
        function reportTypeNotIterableError(errorNode, type, allowAsyncIterables) {
            var message = allowAsyncIterables
                ? ts.Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator
                : ts.Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator;
            errorAndMaybeSuggestAwait(errorNode, !!getAwaitedTypeOfPromise(type), message, typeToString(type));
        }
        /**
         * Gets the *yield*, *return*, and *next* types from an `Iterator`-like or `AsyncIterator`-like type.
         *
         * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
         * record is returned. Otherwise, `undefined` is returned.
         */
        function getIterationTypesOfIterator(type, resolver, errorNode) {
            if (isTypeAny(type)) {
                return anyIterationTypes;
            }
            var iterationTypes = getIterationTypesOfIteratorCached(type, resolver) ||
                getIterationTypesOfIteratorFast(type, resolver) ||
                getIterationTypesOfIteratorSlow(type, resolver, errorNode);
            return iterationTypes === noIterationTypes ? undefined : iterationTypes;
        }
        /**
         * Gets the iteration types of an `Iterator`-like or `AsyncIterator`-like type from the
         * cache.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterator` instead.
         */
        function getIterationTypesOfIteratorCached(type, resolver) {
            return getCachedIterationTypes(type, resolver.iteratorCacheKey);
        }
        /**
         * Gets the iteration types of an `Iterator`-like or `AsyncIterator`-like type from the
         * cache or from common heuristics.
         *
         * If we previously analyzed this type and found no iteration types, `noIterationTypes` is
         * returned. If we found iteration types, an `IterationTypes` record is returned.
         * Otherwise, we return `undefined` to indicate to the caller it should perform a more
         * exhaustive analysis.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterator` instead.
         */
        function getIterationTypesOfIteratorFast(type, resolver) {
            // As an optimization, if the type is an instantiation of one of the following global types,
            // then just grab its related type argument:
            // - `IterableIterator<T>` or `AsyncIterableIterator<T>`
            // - `Iterator<T, TReturn, TNext>` or `AsyncIterator<T, TReturn, TNext>`
            // - `Generator<T, TReturn, TNext>` or `AsyncGenerator<T, TReturn, TNext>`
            var globalType = resolver.getGlobalIterableIteratorType(/*reportErrors*/ false);
            if (isReferenceToType(type, globalType)) {
                var yieldType = getTypeArguments(type)[0];
                // The "return" and "next" types of `IterableIterator` and `AsyncIterableIterator` are defined by the
                // iteration types of their `next`, `return`, and `throw` methods. While we define these as `any`
                // and `undefined` in our libs by default, a custom lib *could* use different definitions.
                var globalIterationTypes = getIterationTypesOfIteratorCached(globalType, resolver) ||
                    getIterationTypesOfIteratorSlow(globalType, resolver, /*errorNode*/ undefined);
                var _a = globalIterationTypes === noIterationTypes ? defaultIterationTypes : globalIterationTypes, returnType = _a.returnType, nextType = _a.nextType;
                return setCachedIterationTypes(type, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType));
            }
            if (isReferenceToType(type, resolver.getGlobalIteratorType(/*reportErrors*/ false)) ||
                isReferenceToType(type, resolver.getGlobalGeneratorType(/*reportErrors*/ false))) {
                var _b = getTypeArguments(type), yieldType = _b[0], returnType = _b[1], nextType = _b[2];
                return setCachedIterationTypes(type, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType));
            }
        }
        function isIteratorResult(type, kind) {
            // From https://tc39.github.io/ecma262/#sec-iteratorresult-interface:
            // > [done] is the result status of an iterator `next` method call. If the end of the iterator was reached `done` is `true`.
            // > If the end was not reached `done` is `false` and a value is available.
            // > If a `done` property (either own or inherited) does not exist, it is consider to have the value `false`.
            var doneType = getTypeOfPropertyOfType(type, "done") || falseType;
            return isTypeAssignableTo(kind === 0 /* Yield */ ? falseType : trueType, doneType);
        }
        function isYieldIteratorResult(type) {
            return isIteratorResult(type, 0 /* Yield */);
        }
        function isReturnIteratorResult(type) {
            return isIteratorResult(type, 1 /* Return */);
        }
        /**
         * Gets the *yield* and *return* types of an `IteratorResult`-like type.
         *
         * If we are unable to determine a *yield* or a *return* type, `noIterationTypes` is
         * returned to indicate to the caller that it should handle the error. Otherwise, an
         * `IterationTypes` record is returned.
         */
        function getIterationTypesOfIteratorResult(type) {
            if (isTypeAny(type)) {
                return anyIterationTypes;
            }
            var cachedTypes = getCachedIterationTypes(type, "iterationTypesOfIteratorResult");
            if (cachedTypes) {
                return cachedTypes;
            }
            // As an optimization, if the type is an instantiation of one of the global `IteratorYieldResult<T>`
            // or `IteratorReturnResult<TReturn>` types, then just grab its type argument.
            if (isReferenceToType(type, getGlobalIteratorYieldResultType(/*reportErrors*/ false))) {
                var yieldType_1 = getTypeArguments(type)[0];
                return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(yieldType_1, /*returnType*/ undefined, /*nextType*/ undefined));
            }
            if (isReferenceToType(type, getGlobalIteratorReturnResultType(/*reportErrors*/ false))) {
                var returnType_1 = getTypeArguments(type)[0];
                return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(/*yieldType*/ undefined, returnType_1, /*nextType*/ undefined));
            }
            // Choose any constituents that can produce the requested iteration type.
            var yieldIteratorResult = filterType(type, isYieldIteratorResult);
            var yieldType = yieldIteratorResult !== neverType ? getTypeOfPropertyOfType(yieldIteratorResult, "value") : undefined;
            var returnIteratorResult = filterType(type, isReturnIteratorResult);
            var returnType = returnIteratorResult !== neverType ? getTypeOfPropertyOfType(returnIteratorResult, "value") : undefined;
            if (!yieldType && !returnType) {
                return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", noIterationTypes);
            }
            // From https://tc39.github.io/ecma262/#sec-iteratorresult-interface
            // > ... If the iterator does not have a return value, `value` is `undefined`. In that case, the
            // > `value` property may be absent from the conforming object if it does not inherit an explicit
            // > `value` property.
            return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, returnType || voidType, /*nextType*/ undefined));
        }
        /**
         * Gets the *yield*, *return*, and *next* types of a the `next()`, `return()`, or
         * `throw()` method of an `Iterator`-like or `AsyncIterator`-like type.
         *
         * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
         * record is returned. Otherwise, we return `undefined`.
         */
        function getIterationTypesOfMethod(type, resolver, methodName, errorNode) {
            var _a, _b, _c, _d;
            var method = getPropertyOfType(type, methodName);
            // Ignore 'return' or 'throw' if they are missing.
            if (!method && methodName !== "next") {
                return undefined;
            }
            var methodType = method && !(methodName === "next" && (method.flags & 16777216 /* Optional */))
                ? methodName === "next" ? getTypeOfSymbol(method) : getTypeWithFacts(getTypeOfSymbol(method), 2097152 /* NEUndefinedOrNull */)
                : undefined;
            if (isTypeAny(methodType)) {
                // `return()` and `throw()` don't provide a *next* type.
                return methodName === "next" ? anyIterationTypes : anyIterationTypesExceptNext;
            }
            // Both async and non-async iterators *must* have a `next` method.
            var methodSignatures = methodType ? getSignaturesOfType(methodType, 0 /* Call */) : ts.emptyArray;
            if (methodSignatures.length === 0) {
                if (errorNode) {
                    var diagnostic = methodName === "next"
                        ? resolver.mustHaveANextMethodDiagnostic
                        : resolver.mustBeAMethodDiagnostic;
                    error(errorNode, diagnostic, methodName);
                }
                return methodName === "next" ? anyIterationTypes : undefined;
            }
            // If the method signature comes exclusively from the global iterator or generator type,
            // create iteration types from its type arguments like `getIterationTypesOfIteratorFast`
            // does (so as to remove `undefined` from the next and return types). We arrive here when
            // a contextual type for a generator was not a direct reference to one of those global types,
            // but looking up `methodType` referred to one of them (and nothing else). E.g., in
            // `interface SpecialIterator extends Iterator<number> {}`, `SpecialIterator` is not a
            // reference to `Iterator`, but its `next` member derives exclusively from `Iterator`.
            if ((methodType === null || methodType === void 0 ? void 0 : methodType.symbol) && methodSignatures.length === 1) {
                var globalGeneratorType = resolver.getGlobalGeneratorType(/*reportErrors*/ false);
                var globalIteratorType = resolver.getGlobalIteratorType(/*reportErrors*/ false);
                var isGeneratorMethod = ((_b = (_a = globalGeneratorType.symbol) === null || _a === void 0 ? void 0 : _a.members) === null || _b === void 0 ? void 0 : _b.get(methodName)) === methodType.symbol;
                var isIteratorMethod = !isGeneratorMethod && ((_d = (_c = globalIteratorType.symbol) === null || _c === void 0 ? void 0 : _c.members) === null || _d === void 0 ? void 0 : _d.get(methodName)) === methodType.symbol;
                if (isGeneratorMethod || isIteratorMethod) {
                    var globalType = isGeneratorMethod ? globalGeneratorType : globalIteratorType;
                    var mapper = methodType.mapper;
                    return createIterationTypes(getMappedType(globalType.typeParameters[0], mapper), getMappedType(globalType.typeParameters[1], mapper), methodName === "next" ? getMappedType(globalType.typeParameters[2], mapper) : undefined);
                }
            }
            // Extract the first parameter and return type of each signature.
            var methodParameterTypes;
            var methodReturnTypes;
            for (var _i = 0, methodSignatures_1 = methodSignatures; _i < methodSignatures_1.length; _i++) {
                var signature = methodSignatures_1[_i];
                if (methodName !== "throw" && ts.some(signature.parameters)) {
                    methodParameterTypes = ts.append(methodParameterTypes, getTypeAtPosition(signature, 0));
                }
                methodReturnTypes = ts.append(methodReturnTypes, getReturnTypeOfSignature(signature));
            }
            // Resolve the *next* or *return* type from the first parameter of a `next()` or
            // `return()` method, respectively.
            var returnTypes;
            var nextType;
            if (methodName !== "throw") {
                var methodParameterType = methodParameterTypes ? getUnionType(methodParameterTypes) : unknownType;
                if (methodName === "next") {
                    // The value of `next(value)` is *not* awaited by async generators
                    nextType = methodParameterType;
                }
                else if (methodName === "return") {
                    // The value of `return(value)` *is* awaited by async generators
                    var resolvedMethodParameterType = resolver.resolveIterationType(methodParameterType, errorNode) || anyType;
                    returnTypes = ts.append(returnTypes, resolvedMethodParameterType);
                }
            }
            // Resolve the *yield* and *return* types from the return type of the method (i.e. `IteratorResult`)
            var yieldType;
            var methodReturnType = methodReturnTypes ? getIntersectionType(methodReturnTypes) : neverType;
            var resolvedMethodReturnType = resolver.resolveIterationType(methodReturnType, errorNode) || anyType;
            var iterationTypes = getIterationTypesOfIteratorResult(resolvedMethodReturnType);
            if (iterationTypes === noIterationTypes) {
                if (errorNode) {
                    error(errorNode, resolver.mustHaveAValueDiagnostic, methodName);
                }
                yieldType = anyType;
                returnTypes = ts.append(returnTypes, anyType);
            }
            else {
                yieldType = iterationTypes.yieldType;
                returnTypes = ts.append(returnTypes, iterationTypes.returnType);
            }
            return createIterationTypes(yieldType, getUnionType(returnTypes), nextType);
        }
        /**
         * Gets the *yield*, *return*, and *next* types of an `Iterator`-like or `AsyncIterator`-like
         * type from its members.
         *
         * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
         * record is returned. Otherwise, `noIterationTypes` is returned.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterator` instead.
         */
        function getIterationTypesOfIteratorSlow(type, resolver, errorNode) {
            var iterationTypes = combineIterationTypes([
                getIterationTypesOfMethod(type, resolver, "next", errorNode),
                getIterationTypesOfMethod(type, resolver, "return", errorNode),
                getIterationTypesOfMethod(type, resolver, "throw", errorNode),
            ]);
            return setCachedIterationTypes(type, resolver.iteratorCacheKey, iterationTypes);
        }
        /**
         * Gets the requested "iteration type" from a type that is either `Iterable`-like, `Iterator`-like,
         * `IterableIterator`-like, or `Generator`-like (for a non-async generator); or `AsyncIterable`-like,
         * `AsyncIterator`-like, `AsyncIterableIterator`-like, or `AsyncGenerator`-like (for an async generator).
         */
        function getIterationTypeOfGeneratorFunctionReturnType(kind, returnType, isAsyncGenerator) {
            if (isTypeAny(returnType)) {
                return undefined;
            }
            var iterationTypes = getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator);
            return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)];
        }
        function getIterationTypesOfGeneratorFunctionReturnType(type, isAsyncGenerator) {
            if (isTypeAny(type)) {
                return anyIterationTypes;
            }
            var use = isAsyncGenerator ? 2 /* AsyncGeneratorReturnType */ : 1 /* GeneratorReturnType */;
            var resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
            return getIterationTypesOfIterable(type, use, /*errorNode*/ undefined) ||
                getIterationTypesOfIterator(type, resolver, /*errorNode*/ undefined);
        }
        function checkBreakOrContinueStatement(node) {
            // Grammar checking
            if (!checkGrammarStatementInAmbientContext(node))
                checkGrammarBreakOrContinueStatement(node);
            // TODO: Check that target label is valid
        }
        function unwrapReturnType(returnType, functionFlags) {
            var _a, _b;
            var isGenerator = !!(functionFlags & 1 /* Generator */);
            var isAsync = !!(functionFlags & 2 /* Async */);
            return isGenerator ? (_a = getIterationTypeOfGeneratorFunctionReturnType(1 /* Return */, returnType, isAsync)) !== null && _a !== void 0 ? _a : errorType :
                isAsync ? (_b = getAwaitedType(returnType)) !== null && _b !== void 0 ? _b : errorType :
                    returnType;
        }
        function isUnwrappedReturnTypeVoidOrAny(func, returnType) {
            var unwrappedReturnType = unwrapReturnType(returnType, ts.getFunctionFlags(func));
            return !!unwrappedReturnType && maybeTypeOfKind(unwrappedReturnType, 16384 /* Void */ | 3 /* AnyOrUnknown */);
        }
        function checkReturnStatement(node) {
            var _a;
            // Grammar checking
            if (checkGrammarStatementInAmbientContext(node)) {
                return;
            }
            var container = ts.getContainingFunctionOrClassStaticBlock(node);
            if (container && ts.isClassStaticBlockDeclaration(container)) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block);
                return;
            }
            if (!container) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);
                return;
            }
            var signature = getSignatureFromDeclaration(container);
            var returnType = getReturnTypeOfSignature(signature);
            var functionFlags = ts.getFunctionFlags(container);
            if (strictNullChecks || node.expression || returnType.flags & 131072 /* Never */) {
                var exprType = node.expression ? checkExpressionCached(node.expression) : undefinedType;
                if (container.kind === 171 /* SetAccessor */) {
                    if (node.expression) {
                        error(node, ts.Diagnostics.Setters_cannot_return_a_value);
                    }
                }
                else if (container.kind === 169 /* Constructor */) {
                    if (node.expression && !checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node, node.expression)) {
                        error(node, ts.Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);
                    }
                }
                else if (getReturnTypeFromAnnotation(container)) {
                    var unwrappedReturnType = (_a = unwrapReturnType(returnType, functionFlags)) !== null && _a !== void 0 ? _a : returnType;
                    var unwrappedExprType = functionFlags & 2 /* Async */
                        ? checkAwaitedType(exprType, node, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
                        : exprType;
                    if (unwrappedReturnType) {
                        // If the function has a return type, but promisedType is
                        // undefined, an error will be reported in checkAsyncFunctionReturnType
                        // so we don't need to report one here.
                        checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node, node.expression);
                    }
                }
            }
            else if (container.kind !== 169 /* Constructor */ && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeVoidOrAny(container, returnType)) {
                // The function has a return type, but the return statement doesn't have an expression.
                error(node, ts.Diagnostics.Not_all_code_paths_return_a_value);
            }
        }
        function checkWithStatement(node) {
            // Grammar checking for withStatement
            if (!checkGrammarStatementInAmbientContext(node)) {
                if (node.flags & 32768 /* AwaitContext */) {
                    grammarErrorOnFirstToken(node, ts.Diagnostics.with_statements_are_not_allowed_in_an_async_function_block);
                }
            }
            checkExpression(node.expression);
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                var start = ts.getSpanOfTokenAtPosition(sourceFile, node.pos).start;
                var end = node.statement.pos;
                grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any);
            }
        }
        function checkSwitchStatement(node) {
            // Grammar checking
            checkGrammarStatementInAmbientContext(node);
            var firstDefaultClause;
            var hasDuplicateDefaultClause = false;
            var expressionType = checkExpression(node.expression);
            var expressionIsLiteral = isLiteralType(expressionType);
            ts.forEach(node.caseBlock.clauses, function (clause) {
                // Grammar check for duplicate default clauses, skip if we already report duplicate default clause
                if (clause.kind === 288 /* DefaultClause */ && !hasDuplicateDefaultClause) {
                    if (firstDefaultClause === undefined) {
                        firstDefaultClause = clause;
                    }
                    else {
                        grammarErrorOnNode(clause, ts.Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
                        hasDuplicateDefaultClause = true;
                    }
                }
                if (produceDiagnostics && clause.kind === 287 /* CaseClause */) {
                    // TypeScript 1.0 spec (April 2014): 5.9
                    // In a 'switch' statement, each 'case' expression must be of a type that is comparable
                    // to or from the type of the 'switch' expression.
                    var caseType = checkExpression(clause.expression);
                    var caseIsLiteral = isLiteralType(caseType);
                    var comparedExpressionType = expressionType;
                    if (!caseIsLiteral || !expressionIsLiteral) {
                        caseType = caseIsLiteral ? getBaseTypeOfLiteralType(caseType) : caseType;
                        comparedExpressionType = getBaseTypeOfLiteralType(expressionType);
                    }
                    if (!isTypeEqualityComparableTo(comparedExpressionType, caseType)) {
                        // expressionType is not comparable to caseType, try the reversed check and report errors if it fails
                        checkTypeComparableTo(caseType, comparedExpressionType, clause.expression, /*headMessage*/ undefined);
                    }
                }
                ts.forEach(clause.statements, checkSourceElement);
                if (compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode)) {
                    error(clause, ts.Diagnostics.Fallthrough_case_in_switch);
                }
            });
            if (node.caseBlock.locals) {
                registerForUnusedIdentifiersCheck(node.caseBlock);
            }
        }
        function checkLabeledStatement(node) {
            // Grammar checking
            if (!checkGrammarStatementInAmbientContext(node)) {
                ts.findAncestor(node.parent, function (current) {
                    if (ts.isFunctionLike(current)) {
                        return "quit";
                    }
                    if (current.kind === 248 /* LabeledStatement */ && current.label.escapedText === node.label.escapedText) {
                        grammarErrorOnNode(node.label, ts.Diagnostics.Duplicate_label_0, ts.getTextOfNode(node.label));
                        return true;
                    }
                    return false;
                });
            }
            // ensure that label is unique
            checkSourceElement(node.statement);
        }
        function checkThrowStatement(node) {
            // Grammar checking
            if (!checkGrammarStatementInAmbientContext(node)) {
                if (ts.isIdentifier(node.expression) && !node.expression.escapedText) {
                    grammarErrorAfterFirstToken(node, ts.Diagnostics.Line_break_not_permitted_here);
                }
            }
            if (node.expression) {
                checkExpression(node.expression);
            }
        }
        function checkTryStatement(node) {
            // Grammar checking
            checkGrammarStatementInAmbientContext(node);
            checkBlock(node.tryBlock);
            var catchClause = node.catchClause;
            if (catchClause) {
                // Grammar checking
                if (catchClause.variableDeclaration) {
                    var declaration = catchClause.variableDeclaration;
                    var typeNode = ts.getEffectiveTypeAnnotationNode(ts.getRootDeclaration(declaration));
                    if (typeNode) {
                        var type = getTypeForVariableLikeDeclaration(declaration, /*includeOptionality*/ false);
                        if (type && !(type.flags & 3 /* AnyOrUnknown */)) {
                            grammarErrorOnFirstToken(typeNode, ts.Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified);
                        }
                    }
                    else if (declaration.initializer) {
                        grammarErrorOnFirstToken(declaration.initializer, ts.Diagnostics.Catch_clause_variable_cannot_have_an_initializer);
                    }
                    else {
                        var blockLocals_1 = catchClause.block.locals;
                        if (blockLocals_1) {
                            ts.forEachKey(catchClause.locals, function (caughtName) {
                                var blockLocal = blockLocals_1.get(caughtName);
                                if ((blockLocal === null || blockLocal === void 0 ? void 0 : blockLocal.valueDeclaration) && (blockLocal.flags & 2 /* BlockScopedVariable */) !== 0) {
                                    grammarErrorOnNode(blockLocal.valueDeclaration, ts.Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, caughtName);
                                }
                            });
                        }
                    }
                }
                checkBlock(catchClause.block);
            }
            if (node.finallyBlock) {
                checkBlock(node.finallyBlock);
            }
        }
        function checkIndexConstraints(type, isStaticIndex) {
            var indexInfos = getIndexInfosOfType(type);
            if (indexInfos.length === 0) {
                return;
            }
            for (var _i = 0, _a = getPropertiesOfObjectType(type); _i < _a.length; _i++) {
                var prop = _a[_i];
                if (!(isStaticIndex && prop.flags & 4194304 /* Prototype */)) {
                    checkIndexConstraintForProperty(type, prop, getLiteralTypeFromProperty(prop, 8576 /* StringOrNumberLiteralOrUnique */, /*includeNonPublic*/ true), getNonMissingTypeOfSymbol(prop));
                }
            }
            var typeDeclaration = type.symbol.valueDeclaration;
            if (typeDeclaration && ts.isClassLike(typeDeclaration)) {
                for (var _b = 0, _c = typeDeclaration.members; _b < _c.length; _b++) {
                    var member = _c[_b];
                    // Only process instance properties with computed names here. Static properties cannot be in conflict with indexers,
                    // and properties with literal names were already checked.
                    if (!ts.isStatic(member) && !hasBindableName(member)) {
                        var symbol = getSymbolOfNode(member);
                        checkIndexConstraintForProperty(type, symbol, getTypeOfExpression(member.name.expression), getNonMissingTypeOfSymbol(symbol));
                    }
                }
            }
            if (indexInfos.length > 1) {
                for (var _d = 0, indexInfos_6 = indexInfos; _d < indexInfos_6.length; _d++) {
                    var info = indexInfos_6[_d];
                    checkIndexConstraintForIndexSignature(type, info);
                }
            }
        }
        function checkIndexConstraintForProperty(type, prop, propNameType, propType) {
            var declaration = prop.valueDeclaration;
            var name = ts.getNameOfDeclaration(declaration);
            if (name && ts.isPrivateIdentifier(name)) {
                return;
            }
            var indexInfos = getApplicableIndexInfos(type, propNameType);
            var interfaceDeclaration = ts.getObjectFlags(type) & 2 /* Interface */ ? ts.getDeclarationOfKind(type.symbol, 256 /* InterfaceDeclaration */) : undefined;
            var localPropDeclaration = declaration && declaration.kind === 219 /* BinaryExpression */ ||
                name && name.kind === 160 /* ComputedPropertyName */ || getParentOfSymbol(prop) === type.symbol ? declaration : undefined;
            var _loop_27 = function (info) {
                var localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfNode(info.declaration)) === type.symbol ? info.declaration : undefined;
                // We check only when (a) the property is declared in the containing type, or (b) the applicable index signature is declared
                // in the containing type, or (c) the containing type is an interface and no base interface contains both the property and
                // the index signature (i.e. property and index signature are declared in separate inherited interfaces).
                var errorNode = localPropDeclaration || localIndexDeclaration ||
                    (interfaceDeclaration && !ts.some(getBaseTypes(type), function (base) { return !!getPropertyOfObjectType(base, prop.escapedName) && !!getIndexTypeOfType(base, info.keyType); }) ? interfaceDeclaration : undefined);
                if (errorNode && !isTypeAssignableTo(propType, info.type)) {
                    error(errorNode, ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3, symbolToString(prop), typeToString(propType), typeToString(info.keyType), typeToString(info.type));
                }
            };
            for (var _i = 0, indexInfos_7 = indexInfos; _i < indexInfos_7.length; _i++) {
                var info = indexInfos_7[_i];
                _loop_27(info);
            }
        }
        function checkIndexConstraintForIndexSignature(type, checkInfo) {
            var declaration = checkInfo.declaration;
            var indexInfos = getApplicableIndexInfos(type, checkInfo.keyType);
            var interfaceDeclaration = ts.getObjectFlags(type) & 2 /* Interface */ ? ts.getDeclarationOfKind(type.symbol, 256 /* InterfaceDeclaration */) : undefined;
            var localCheckDeclaration = declaration && getParentOfSymbol(getSymbolOfNode(declaration)) === type.symbol ? declaration : undefined;
            var _loop_28 = function (info) {
                if (info === checkInfo)
                    return "continue";
                var localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfNode(info.declaration)) === type.symbol ? info.declaration : undefined;
                // We check only when (a) the check index signature is declared in the containing type, or (b) the applicable index
                // signature is declared in the containing type, or (c) the containing type is an interface and no base interface contains
                // both index signatures (i.e. the index signatures are declared in separate inherited interfaces).
                var errorNode = localCheckDeclaration || localIndexDeclaration ||
                    (interfaceDeclaration && !ts.some(getBaseTypes(type), function (base) { return !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(base, info.keyType); }) ? interfaceDeclaration : undefined);
                if (errorNode && !isTypeAssignableTo(checkInfo.type, info.type)) {
                    error(errorNode, ts.Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3, typeToString(checkInfo.keyType), typeToString(checkInfo.type), typeToString(info.keyType), typeToString(info.type));
                }
            };
            for (var _i = 0, indexInfos_8 = indexInfos; _i < indexInfos_8.length; _i++) {
                var info = indexInfos_8[_i];
                _loop_28(info);
            }
        }
        function checkTypeNameIsReserved(name, message) {
            // TS 1.0 spec (April 2014): 3.6.1
            // The predefined type keywords are reserved and cannot be used as names of user defined types.
            switch (name.escapedText) {
                case "any":
                case "unknown":
                case "never":
                case "number":
                case "bigint":
                case "boolean":
                case "string":
                case "symbol":
                case "void":
                case "object":
                    error(name, message, name.escapedText);
            }
        }
        /**
         * The name cannot be used as 'Object' of user defined types with special target.
         */
        function checkClassNameCollisionWithObject(name) {
            if (languageVersion === 1 /* ES5 */ && name.escapedText === "Object"
                && moduleKind < ts.ModuleKind.ES2015) {
                error(name, ts.Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0, ts.ModuleKind[moduleKind]); // https://github.com/Microsoft/TypeScript/issues/17494
            }
        }
        /**
         * Check each type parameter and check that type parameters have no duplicate type parameter declarations
         */
        function checkTypeParameters(typeParameterDeclarations) {
            if (typeParameterDeclarations) {
                var seenDefault = false;
                for (var i = 0; i < typeParameterDeclarations.length; i++) {
                    var node = typeParameterDeclarations[i];
                    checkTypeParameter(node);
                    if (produceDiagnostics) {
                        if (node.default) {
                            seenDefault = true;
                            checkTypeParametersNotReferenced(node.default, typeParameterDeclarations, i);
                        }
                        else if (seenDefault) {
                            error(node, ts.Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters);
                        }
                        for (var j = 0; j < i; j++) {
                            if (typeParameterDeclarations[j].symbol === node.symbol) {
                                error(node.name, ts.Diagnostics.Duplicate_identifier_0, ts.declarationNameToString(node.name));
                            }
                        }
                    }
                }
            }
        }
        /** Check that type parameter defaults only reference previously declared type parameters */
        function checkTypeParametersNotReferenced(root, typeParameters, index) {
            visit(root);
            function visit(node) {
                if (node.kind === 176 /* TypeReference */) {
                    var type = getTypeFromTypeReference(node);
                    if (type.flags & 262144 /* TypeParameter */) {
                        for (var i = index; i < typeParameters.length; i++) {
                            if (type.symbol === getSymbolOfNode(typeParameters[i])) {
                                error(node, ts.Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters);
                            }
                        }
                    }
                }
                ts.forEachChild(node, visit);
            }
        }
        /** Check that type parameter lists are identical across multiple declarations */
        function checkTypeParameterListsIdentical(symbol) {
            if (symbol.declarations && symbol.declarations.length === 1) {
                return;
            }
            var links = getSymbolLinks(symbol);
            if (!links.typeParametersChecked) {
                links.typeParametersChecked = true;
                var declarations = getClassOrInterfaceDeclarationsOfSymbol(symbol);
                if (!declarations || declarations.length <= 1) {
                    return;
                }
                var type = getDeclaredTypeOfSymbol(symbol);
                if (!areTypeParametersIdentical(declarations, type.localTypeParameters)) {
                    // Report an error on every conflicting declaration.
                    var name = symbolToString(symbol);
                    for (var _i = 0, declarations_6 = declarations; _i < declarations_6.length; _i++) {
                        var declaration = declarations_6[_i];
                        error(declaration.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name);
                    }
                }
            }
        }
        function areTypeParametersIdentical(declarations, targetParameters) {
            var maxTypeArgumentCount = ts.length(targetParameters);
            var minTypeArgumentCount = getMinTypeArgumentCount(targetParameters);
            for (var _i = 0, declarations_7 = declarations; _i < declarations_7.length; _i++) {
                var declaration = declarations_7[_i];
                // If this declaration has too few or too many type parameters, we report an error
                var sourceParameters = ts.getEffectiveTypeParameterDeclarations(declaration);
                var numTypeParameters = sourceParameters.length;
                if (numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount) {
                    return false;
                }
                for (var i = 0; i < numTypeParameters; i++) {
                    var source = sourceParameters[i];
                    var target = targetParameters[i];
                    // If the type parameter node does not have the same as the resolved type
                    // parameter at this position, we report an error.
                    if (source.name.escapedText !== target.symbol.escapedName) {
                        return false;
                    }
                    // If the type parameter node does not have an identical constraint as the resolved
                    // type parameter at this position, we report an error.
                    var constraint = ts.getEffectiveConstraintOfTypeParameter(source);
                    var sourceConstraint = constraint && getTypeFromTypeNode(constraint);
                    var targetConstraint = getConstraintOfTypeParameter(target);
                    // relax check if later interface augmentation has no constraint, it's more broad and is OK to merge with
                    // a more constrained interface (this could be generalized to a full hierarchy check, but that's maybe overkill)
                    if (sourceConstraint && targetConstraint && !isTypeIdenticalTo(sourceConstraint, targetConstraint)) {
                        return false;
                    }
                    // If the type parameter node has a default and it is not identical to the default
                    // for the type parameter at this position, we report an error.
                    var sourceDefault = source.default && getTypeFromTypeNode(source.default);
                    var targetDefault = getDefaultFromTypeParameter(target);
                    if (sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault)) {
                        return false;
                    }
                }
            }
            return true;
        }
        function checkClassExpression(node) {
            checkClassLikeDeclaration(node);
            checkNodeDeferred(node);
            return getTypeOfSymbol(getSymbolOfNode(node));
        }
        function checkClassExpressionDeferred(node) {
            ts.forEach(node.members, checkSourceElement);
            registerForUnusedIdentifiersCheck(node);
        }
        function checkClassDeclaration(node) {
            if (ts.some(node.decorators) && ts.some(node.members, function (p) { return ts.hasStaticModifier(p) && ts.isPrivateIdentifierClassElementDeclaration(p); })) {
                grammarErrorOnNode(node.decorators[0], ts.Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator);
            }
            if (!node.name && !ts.hasSyntacticModifier(node, 512 /* Default */)) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name);
            }
            checkClassLikeDeclaration(node);
            ts.forEach(node.members, checkSourceElement);
            registerForUnusedIdentifiersCheck(node);
        }
        function checkClassLikeDeclaration(node) {
            checkGrammarClassLikeDeclaration(node);
            checkDecorators(node);
            checkCollisionsForDeclarationName(node, node.name);
            checkTypeParameters(ts.getEffectiveTypeParameterDeclarations(node));
            checkExportsOnMergedDeclarations(node);
            var symbol = getSymbolOfNode(node);
            var type = getDeclaredTypeOfSymbol(symbol);
            var typeWithThis = getTypeWithThisArgument(type);
            var staticType = getTypeOfSymbol(symbol);
            checkTypeParameterListsIdentical(symbol);
            checkFunctionOrConstructorSymbol(symbol);
            checkClassForDuplicateDeclarations(node);
            // Only check for reserved static identifiers on non-ambient context.
            var nodeInAmbientContext = !!(node.flags & 8388608 /* Ambient */);
            if (!nodeInAmbientContext) {
                checkClassForStaticPropertyNameConflicts(node);
            }
            var baseTypeNode = ts.getEffectiveBaseTypeNode(node);
            if (baseTypeNode) {
                ts.forEach(baseTypeNode.typeArguments, checkSourceElement);
                if (languageVersion < 2 /* ES2015 */) {
                    checkExternalEmitHelpers(baseTypeNode.parent, 1 /* Extends */);
                }
                // check both @extends and extends if both are specified.
                var extendsNode = ts.getClassExtendsHeritageElement(node);
                if (extendsNode && extendsNode !== baseTypeNode) {
                    checkExpression(extendsNode.expression);
                }
                var baseTypes = getBaseTypes(type);
                if (baseTypes.length && produceDiagnostics) {
                    var baseType_1 = baseTypes[0];
                    var baseConstructorType = getBaseConstructorTypeOfClass(type);
                    var staticBaseType = getApparentType(baseConstructorType);
                    checkBaseTypeAccessibility(staticBaseType, baseTypeNode);
                    checkSourceElement(baseTypeNode.expression);
                    if (ts.some(baseTypeNode.typeArguments)) {
                        ts.forEach(baseTypeNode.typeArguments, checkSourceElement);
                        for (var _i = 0, _a = getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode); _i < _a.length; _i++) {
                            var constructor = _a[_i];
                            if (!checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters)) {
                                break;
                            }
                        }
                    }
                    var baseWithThis = getTypeWithThisArgument(baseType_1, type.thisType);
                    if (!checkTypeAssignableTo(typeWithThis, baseWithThis, /*errorNode*/ undefined)) {
                        issueMemberSpecificError(node, typeWithThis, baseWithThis, ts.Diagnostics.Class_0_incorrectly_extends_base_class_1);
                    }
                    else {
                        // Report static side error only when instance type is assignable
                        checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, ts.Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);
                    }
                    if (baseConstructorType.flags & 8650752 /* TypeVariable */) {
                        if (!isMixinConstructorType(staticType)) {
                            error(node.name || node, ts.Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any);
                        }
                        else {
                            var constructSignatures = getSignaturesOfType(baseConstructorType, 1 /* Construct */);
                            if (constructSignatures.some(function (signature) { return signature.flags & 4 /* Abstract */; }) && !ts.hasSyntacticModifier(node, 128 /* Abstract */)) {
                                error(node.name || node, ts.Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract);
                            }
                        }
                    }
                    if (!(staticBaseType.symbol && staticBaseType.symbol.flags & 32 /* Class */) && !(baseConstructorType.flags & 8650752 /* TypeVariable */)) {
                        // When the static base type is a "class-like" constructor function (but not actually a class), we verify
                        // that all instantiated base constructor signatures return the same type.
                        var constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode);
                        if (ts.forEach(constructors, function (sig) { return !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType_1); })) {
                            error(baseTypeNode.expression, ts.Diagnostics.Base_constructors_must_all_have_the_same_return_type);
                        }
                    }
                    checkKindsOfPropertyMemberOverrides(type, baseType_1);
                }
            }
            checkMembersForMissingOverrideModifier(node, type, typeWithThis, staticType);
            var implementedTypeNodes = ts.getEffectiveImplementsTypeNodes(node);
            if (implementedTypeNodes) {
                for (var _b = 0, implementedTypeNodes_1 = implementedTypeNodes; _b < implementedTypeNodes_1.length; _b++) {
                    var typeRefNode = implementedTypeNodes_1[_b];
                    if (!ts.isEntityNameExpression(typeRefNode.expression) || ts.isOptionalChain(typeRefNode.expression)) {
                        error(typeRefNode.expression, ts.Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments);
                    }
                    checkTypeReferenceNode(typeRefNode);
                    if (produceDiagnostics) {
                        var t = getReducedType(getTypeFromTypeNode(typeRefNode));
                        if (t !== errorType) {
                            if (isValidBaseType(t)) {
                                var genericDiag = t.symbol && t.symbol.flags & 32 /* Class */ ?
                                    ts.Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass :
                                    ts.Diagnostics.Class_0_incorrectly_implements_interface_1;
                                var baseWithThis = getTypeWithThisArgument(t, type.thisType);
                                if (!checkTypeAssignableTo(typeWithThis, baseWithThis, /*errorNode*/ undefined)) {
                                    issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag);
                                }
                            }
                            else {
                                error(typeRefNode, ts.Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members);
                            }
                        }
                    }
                }
            }
            if (produceDiagnostics) {
                checkIndexConstraints(type);
                checkIndexConstraints(staticType, /*isStaticIndex*/ true);
                checkTypeForDuplicateIndexSignatures(node);
                checkPropertyInitialization(node);
            }
        }
        function checkMembersForMissingOverrideModifier(node, type, typeWithThis, staticType) {
            var nodeInAmbientContext = !!(node.flags & 8388608 /* Ambient */);
            var baseTypeNode = ts.getEffectiveBaseTypeNode(node);
            var baseTypes = baseTypeNode && getBaseTypes(type);
            var baseWithThis = (baseTypes === null || baseTypes === void 0 ? void 0 : baseTypes.length) ? getTypeWithThisArgument(ts.first(baseTypes), type.thisType) : undefined;
            var baseStaticType = getBaseConstructorTypeOfClass(type);
            var _loop_29 = function (member) {
                if (ts.hasAmbientModifier(member)) {
                    return "continue";
                }
                if (ts.isConstructorDeclaration(member)) {
                    ts.forEach(member.parameters, function (param) {
                        if (ts.isParameterPropertyDeclaration(param, member)) {
                            checkClassMember(param, /*memberIsParameterProperty*/ true);
                        }
                    });
                }
                checkClassMember(member);
            };
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                _loop_29(member);
            }
            function checkClassMember(member, memberIsParameterProperty) {
                var hasOverride = ts.hasOverrideModifier(member);
                var hasStatic = ts.isStatic(member);
                if (baseWithThis && (hasOverride || compilerOptions.noImplicitOverride)) {
                    var declaredProp = member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member);
                    if (!declaredProp) {
                        return;
                    }
                    var thisType = hasStatic ? staticType : typeWithThis;
                    var baseType = hasStatic ? baseStaticType : baseWithThis;
                    var prop = getPropertyOfType(thisType, declaredProp.escapedName);
                    var baseProp = getPropertyOfType(baseType, declaredProp.escapedName);
                    var baseClassName = typeToString(baseWithThis);
                    if (prop && !baseProp && hasOverride) {
                        var suggestion = getSuggestedSymbolForNonexistentClassMember(ts.symbolName(declaredProp), baseType);
                        suggestion ?
                            error(member, ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1, baseClassName, symbolToString(suggestion)) :
                            error(member, ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0, baseClassName);
                    }
                    else if (prop && (baseProp === null || baseProp === void 0 ? void 0 : baseProp.declarations) && compilerOptions.noImplicitOverride && !nodeInAmbientContext) {
                        var baseHasAbstract = ts.some(baseProp.declarations, function (d) { return ts.hasAbstractModifier(d); });
                        if (hasOverride) {
                            return;
                        }
                        if (!baseHasAbstract) {
                            var diag = memberIsParameterProperty ?
                                ts.Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0 :
                                ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0;
                            error(member, diag, baseClassName);
                        }
                        else if (ts.hasAbstractModifier(member) && baseHasAbstract) {
                            error(member, ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0, baseClassName);
                        }
                    }
                }
                else if (hasOverride) {
                    var className = typeToString(type);
                    error(member, ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class, className);
                }
            }
        }
        function issueMemberSpecificError(node, typeWithThis, baseWithThis, broadDiag) {
            // iterate over all implemented properties and issue errors on each one which isn't compatible, rather than the class as a whole, if possible
            var issuedMemberError = false;
            var _loop_30 = function (member) {
                if (ts.isStatic(member)) {
                    return "continue";
                }
                var declaredProp = member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member);
                if (declaredProp) {
                    var prop = getPropertyOfType(typeWithThis, declaredProp.escapedName);
                    var baseProp = getPropertyOfType(baseWithThis, declaredProp.escapedName);
                    if (prop && baseProp) {
                        var rootChain = function () { return ts.chainDiagnosticMessages(
                        /*details*/ undefined, ts.Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2, symbolToString(declaredProp), typeToString(typeWithThis), typeToString(baseWithThis)); };
                        if (!checkTypeAssignableTo(getTypeOfSymbol(prop), getTypeOfSymbol(baseProp), member.name || member, /*message*/ undefined, rootChain)) {
                            issuedMemberError = true;
                        }
                    }
                }
            };
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                _loop_30(member);
            }
            if (!issuedMemberError) {
                // check again with diagnostics to generate a less-specific error
                checkTypeAssignableTo(typeWithThis, baseWithThis, node.name || node, broadDiag);
            }
        }
        function checkBaseTypeAccessibility(type, node) {
            var signatures = getSignaturesOfType(type, 1 /* Construct */);
            if (signatures.length) {
                var declaration = signatures[0].declaration;
                if (declaration && ts.hasEffectiveModifier(declaration, 8 /* Private */)) {
                    var typeClassDeclaration = ts.getClassLikeDeclarationOfSymbol(type.symbol);
                    if (!isNodeWithinClass(node, typeClassDeclaration)) {
                        error(node, ts.Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type.symbol));
                    }
                }
            }
        }
        function getTargetSymbol(s) {
            // if symbol is instantiated its flags are not copied from the 'target'
            // so we'll need to get back original 'target' symbol to work with correct set of flags
            return ts.getCheckFlags(s) & 1 /* Instantiated */ ? s.target : s;
        }
        function getClassOrInterfaceDeclarationsOfSymbol(symbol) {
            return ts.filter(symbol.declarations, function (d) {
                return d.kind === 255 /* ClassDeclaration */ || d.kind === 256 /* InterfaceDeclaration */;
            });
        }
        function checkKindsOfPropertyMemberOverrides(type, baseType) {
            // TypeScript 1.0 spec (April 2014): 8.2.3
            // A derived class inherits all members from its base class it doesn't override.
            // Inheritance means that a derived class implicitly contains all non - overridden members of the base class.
            // Both public and private property members are inherited, but only public property members can be overridden.
            // A property member in a derived class is said to override a property member in a base class
            // when the derived class property member has the same name and kind(instance or static)
            // as the base class property member.
            // The type of an overriding property member must be assignable(section 3.8.4)
            // to the type of the overridden property member, or otherwise a compile - time error occurs.
            // Base class instance member functions can be overridden by derived class instance member functions,
            // but not by other kinds of members.
            // Base class instance member variables and accessors can be overridden by
            // derived class instance member variables and accessors, but not by other kinds of members.
            var _a, _b;
            // NOTE: assignability is checked in checkClassDeclaration
            var baseProperties = getPropertiesOfType(baseType);
            basePropertyCheck: for (var _i = 0, baseProperties_1 = baseProperties; _i < baseProperties_1.length; _i++) {
                var baseProperty = baseProperties_1[_i];
                var base = getTargetSymbol(baseProperty);
                if (base.flags & 4194304 /* Prototype */) {
                    continue;
                }
                var baseSymbol = getPropertyOfObjectType(type, base.escapedName);
                if (!baseSymbol) {
                    continue;
                }
                var derived = getTargetSymbol(baseSymbol);
                var baseDeclarationFlags = ts.getDeclarationModifierFlagsFromSymbol(base);
                ts.Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.");
                // In order to resolve whether the inherited method was overridden in the base class or not,
                // we compare the Symbols obtained. Since getTargetSymbol returns the symbol on the *uninstantiated*
                // type declaration, derived and base resolve to the same symbol even in the case of generic classes.
                if (derived === base) {
                    // derived class inherits base without override/redeclaration
                    var derivedClassDecl = ts.getClassLikeDeclarationOfSymbol(type.symbol);
                    // It is an error to inherit an abstract member without implementing it or being declared abstract.
                    // If there is no declaration for the derived class (as in the case of class expressions),
                    // then the class cannot be declared abstract.
                    if (baseDeclarationFlags & 128 /* Abstract */ && (!derivedClassDecl || !ts.hasSyntacticModifier(derivedClassDecl, 128 /* Abstract */))) {
                        // Searches other base types for a declaration that would satisfy the inherited abstract member.
                        // (The class may have more than one base type via declaration merging with an interface with the
                        // same name.)
                        for (var _c = 0, _d = getBaseTypes(type); _c < _d.length; _c++) {
                            var otherBaseType = _d[_c];
                            if (otherBaseType === baseType)
                                continue;
                            var baseSymbol_1 = getPropertyOfObjectType(otherBaseType, base.escapedName