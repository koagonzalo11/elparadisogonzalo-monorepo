uses, members) {
            var node = createBaseClassLikeDeclaration(224 /* ClassExpression */, decorators, modifiers, name, typeParameters, heritageClauses, members);
            node.transformFlags |= 512 /* ContainsES2015 */;
            return node;
        }
        // @api
        function updateClassExpression(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createClassExpression(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        // @api
        function createOmittedExpression() {
            return createBaseExpression(225 /* OmittedExpression */);
        }
        // @api
        function createExpressionWithTypeArguments(expression, typeArguments) {
            var node = createBaseNode(226 /* ExpressionWithTypeArguments */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(typeArguments);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    512 /* ContainsES2015 */;
            return node;
        }
        // @api
        function updateExpressionWithTypeArguments(node, expression, typeArguments) {
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                ? update(createExpressionWithTypeArguments(expression, typeArguments), node)
                : node;
        }
        // @api
        function createAsExpression(expression, type) {
            var node = createBaseExpression(227 /* AsExpression */);
            node.expression = expression;
            node.type = type;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.type) |
                    1 /* ContainsTypeScript */;
            return node;
        }
        // @api
        function updateAsExpression(node, expression, type) {
            return node.expression !== expression
                || node.type !== type
                ? update(createAsExpression(expression, type), node)
                : node;
        }
        // @api
        function createNonNullExpression(expression) {
            var node = createBaseExpression(228 /* NonNullExpression */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 /* ContainsTypeScript */;
            return node;
        }
        // @api
        function updateNonNullExpression(node, expression) {
            if (ts.isNonNullChain(node)) {
                return updateNonNullChain(node, expression);
            }
            return node.expression !== expression
                ? update(createNonNullExpression(expression), node)
                : node;
        }
        // @api
        function createNonNullChain(expression) {
            var node = createBaseExpression(228 /* NonNullExpression */);
            node.flags |= 32 /* OptionalChain */;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 /* ContainsTypeScript */;
            return node;
        }
        // @api
        function updateNonNullChain(node, expression) {
            ts.Debug.assert(!!(node.flags & 32 /* OptionalChain */), "Cannot update a NonNullExpression using updateNonNullChain. Use updateNonNullExpression instead.");
            return node.expression !== expression
                ? update(createNonNullChain(expression), node)
                : node;
        }
        // @api
        function createMetaProperty(keywordToken, name) {
            var node = createBaseExpression(229 /* MetaProperty */);
            node.keywordToken = keywordToken;
            node.name = name;
            node.transformFlags |= propagateChildFlags(node.name);
            switch (keywordToken) {
                case 103 /* NewKeyword */:
                    node.transformFlags |= 512 /* ContainsES2015 */;
                    break;
                case 100 /* ImportKeyword */:
                    node.transformFlags |= 4 /* ContainsESNext */;
                    break;
                default:
                    return ts.Debug.assertNever(keywordToken);
            }
            return node;
        }
        // @api
        function updateMetaProperty(node, name) {
            return node.name !== name
                ? update(createMetaProperty(node.keywordToken, name), node)
                : node;
        }
        //
        // Misc
        //
        // @api
        function createTemplateSpan(expression, literal) {
            var node = createBaseNode(231 /* TemplateSpan */);
            node.expression = expression;
            node.literal = literal;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.literal) |
                    512 /* ContainsES2015 */;
            return node;
        }
        // @api
        function updateTemplateSpan(node, expression, literal) {
            return node.expression !== expression
                || node.literal !== literal
                ? update(createTemplateSpan(expression, literal), node)
                : node;
        }
        // @api
        function createSemicolonClassElement() {
            var node = createBaseNode(232 /* SemicolonClassElement */);
            node.transformFlags |= 512 /* ContainsES2015 */;
            return node;
        }
        //
        // Element
        //
        // @api
        function createBlock(statements, multiLine) {
            var node = createBaseNode(233 /* Block */);
            node.statements = createNodeArray(statements);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.statements);
            return node;
        }
        // @api
        function updateBlock(node, statements) {
            return node.statements !== statements
                ? update(createBlock(statements, node.multiLine), node)
                : node;
        }
        // @api
        function createVariableStatement(modifiers, declarationList) {
            var node = createBaseDeclaration(235 /* VariableStatement */, /*decorators*/ undefined, modifiers);
            node.declarationList = ts.isArray(declarationList) ? createVariableDeclarationList(declarationList) : declarationList;
            node.transformFlags |=
                propagateChildFlags(node.declarationList);
            if (ts.modifiersToFlags(node.modifiers) & 2 /* Ambient */) {
                node.transformFlags = 1 /* ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateVariableStatement(node, modifiers, declarationList) {
            return node.modifiers !== modifiers
                || node.declarationList !== declarationList
                ? update(createVariableStatement(modifiers, declarationList), node)
                : node;
        }
        // @api
        function createEmptyStatement() {
            return createBaseNode(234 /* EmptyStatement */);
        }
        // @api
        function createExpressionStatement(expression) {
            var node = createBaseNode(236 /* ExpressionStatement */);
            node.expression = parenthesizerRules().parenthesizeExpressionOfExpressionStatement(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateExpressionStatement(node, expression) {
            return node.expression !== expression
                ? update(createExpressionStatement(expression), node)
                : node;
        }
        // @api
        function createIfStatement(expression, thenStatement, elseStatement) {
            var node = createBaseNode(237 /* IfStatement */);
            node.expression = expression;
            node.thenStatement = asEmbeddedStatement(thenStatement);
            node.elseStatement = asEmbeddedStatement(elseStatement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.thenStatement) |
                    propagateChildFlags(node.elseStatement);
            return node;
        }
        // @api
        function updateIfStatement(node, expression, thenStatement, elseStatement) {
            return node.expression !== expression
                || node.thenStatement !== thenStatement
                || node.elseStatement !== elseStatement
                ? update(createIfStatement(expression, thenStatement, elseStatement), node)
                : node;
        }
        // @api
        function createDoStatement(statement, expression) {
            var node = createBaseNode(238 /* DoStatement */);
            node.statement = asEmbeddedStatement(statement);
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.statement) |
                    propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateDoStatement(node, statement, expression) {
            return node.statement !== statement
                || node.expression !== expression
                ? update(createDoStatement(statement, expression), node)
                : node;
        }
        // @api
        function createWhileStatement(expression, statement) {
            var node = createBaseNode(239 /* WhileStatement */);
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateWhileStatement(node, expression, statement) {
            return node.expression !== expression
                || node.statement !== statement
                ? update(createWhileStatement(expression, statement), node)
                : node;
        }
        // @api
        function createForStatement(initializer, condition, incrementor, statement) {
            var node = createBaseNode(240 /* ForStatement */);
            node.initializer = initializer;
            node.condition = condition;
            node.incrementor = incrementor;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.condition) |
                    propagateChildFlags(node.incrementor) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateForStatement(node, initializer, condition, incrementor, statement) {
            return node.initializer !== initializer
                || node.condition !== condition
                || node.incrementor !== incrementor
                || node.statement !== statement
                ? update(createForStatement(initializer, condition, incrementor, statement), node)
                : node;
        }
        // @api
        function createForInStatement(initializer, expression, statement) {
            var node = createBaseNode(241 /* ForInStatement */);
            node.initializer = initializer;
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateForInStatement(node, initializer, expression, statement) {
            return node.initializer !== initializer
                || node.expression !== expression
                || node.statement !== statement
                ? update(createForInStatement(initializer, expression, statement), node)
                : node;
        }
        // @api
        function createForOfStatement(awaitModifier, initializer, expression, statement) {
            var node = createBaseNode(242 /* ForOfStatement */);
            node.awaitModifier = awaitModifier;
            node.initializer = initializer;
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.awaitModifier) |
                    propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement) |
                    512 /* ContainsES2015 */;
            if (awaitModifier)
                node.transformFlags |= 64 /* ContainsES2018 */;
            return node;
        }
        // @api
        function updateForOfStatement(node, awaitModifier, initializer, expression, statement) {
            return node.awaitModifier !== awaitModifier
                || node.initializer !== initializer
                || node.expression !== expression
                || node.statement !== statement
                ? update(createForOfStatement(awaitModifier, initializer, expression, statement), node)
                : node;
        }
        // @api
        function createContinueStatement(label) {
            var node = createBaseNode(243 /* ContinueStatement */);
            node.label = asName(label);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    2097152 /* ContainsHoistedDeclarationOrCompletion */;
            return node;
        }
        // @api
        function updateContinueStatement(node, label) {
            return node.label !== label
                ? update(createContinueStatement(label), node)
                : node;
        }
        // @api
        function createBreakStatement(label) {
            var node = createBaseNode(244 /* BreakStatement */);
            node.label = asName(label);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    2097152 /* ContainsHoistedDeclarationOrCompletion */;
            return node;
        }
        // @api
        function updateBreakStatement(node, label) {
            return node.label !== label
                ? update(createBreakStatement(label), node)
                : node;
        }
        // @api
        function createReturnStatement(expression) {
            var node = createBaseNode(245 /* ReturnStatement */);
            node.expression = expression;
            // return in an ES2018 async generator must be awaited
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    64 /* ContainsES2018 */ |
                    2097152 /* ContainsHoistedDeclarationOrCompletion */;
            return node;
        }
        // @api
        function updateReturnStatement(node, expression) {
            return node.expression !== expression
                ? update(createReturnStatement(expression), node)
                : node;
        }
        // @api
        function createWithStatement(expression, statement) {
            var node = createBaseNode(246 /* WithStatement */);
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateWithStatement(node, expression, statement) {
            return node.expression !== expression
                || node.statement !== statement
                ? update(createWithStatement(expression, statement), node)
                : node;
        }
        // @api
        function createSwitchStatement(expression, caseBlock) {
            var node = createBaseNode(247 /* SwitchStatement */);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.caseBlock = caseBlock;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.caseBlock);
            return node;
        }
        // @api
        function updateSwitchStatement(node, expression, caseBlock) {
            return node.expression !== expression
                || node.caseBlock !== caseBlock
                ? update(createSwitchStatement(expression, caseBlock), node)
                : node;
        }
        // @api
        function createLabeledStatement(label, statement) {
            var node = createBaseNode(248 /* LabeledStatement */);
            node.label = asName(label);
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateLabeledStatement(node, label, statement) {
            return node.label !== label
                || node.statement !== statement
                ? update(createLabeledStatement(label, statement), node)
                : node;
        }
        // @api
        function createThrowStatement(expression) {
            var node = createBaseNode(249 /* ThrowStatement */);
            node.expression = expression;
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateThrowStatement(node, expression) {
            return node.expression !== expression
                ? update(createThrowStatement(expression), node)
                : node;
        }
        // @api
        function createTryStatement(tryBlock, catchClause, finallyBlock) {
            var node = createBaseNode(250 /* TryStatement */);
            node.tryBlock = tryBlock;
            node.catchClause = catchClause;
            node.finallyBlock = finallyBlock;
            node.transformFlags |=
                propagateChildFlags(node.tryBlock) |
                    propagateChildFlags(node.catchClause) |
                    propagateChildFlags(node.finallyBlock);
            return node;
        }
        // @api
        function updateTryStatement(node, tryBlock, catchClause, finallyBlock) {
            return node.tryBlock !== tryBlock
                || node.catchClause !== catchClause
                || node.finallyBlock !== finallyBlock
                ? update(createTryStatement(tryBlock, catchClause, finallyBlock), node)
                : node;
        }
        // @api
        function createDebuggerStatement() {
            return createBaseNode(251 /* DebuggerStatement */);
        }
        // @api
        function createVariableDeclaration(name, exclamationToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(252 /* VariableDeclaration */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, name, type, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.exclamationToken = exclamationToken;
            node.transformFlags |= propagateChildFlags(node.exclamationToken);
            if (exclamationToken) {
                node.transformFlags |= 1 /* ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateVariableDeclaration(node, name, exclamationToken, type, initializer) {
            return node.name !== name
                || node.type !== type
                || node.exclamationToken !== exclamationToken
                || node.initializer !== initializer
                ? update(createVariableDeclaration(name, exclamationToken, type, initializer), node)
                : node;
        }
        // @api
        function createVariableDeclarationList(declarations, flags) {
            if (flags === void 0) { flags = 0 /* None */; }
            var node = createBaseNode(253 /* VariableDeclarationList */);
            node.flags |= flags & 3 /* BlockScoped */;
            node.declarations = createNodeArray(declarations);
            node.transformFlags |=
                propagateChildrenFlags(node.declarations) |
                    2097152 /* ContainsHoistedDeclarationOrCompletion */;
            if (flags & 3 /* BlockScoped */) {
                node.transformFlags |=
                    512 /* ContainsES2015 */ |
                        131072 /* ContainsBlockScopedBinding */;
            }
            return node;
        }
        // @api
        function updateVariableDeclarationList(node, declarations) {
            return node.declarations !== declarations
                ? update(createVariableDeclarationList(declarations, node.flags), node)
                : node;
        }
        // @api
        function createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(254 /* FunctionDeclaration */, decorators, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            if (!node.body || ts.modifiersToFlags(node.modifiers) & 2 /* Ambient */) {
                node.transformFlags = 1 /* ContainsTypeScript */;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.asteriskToken) |
                        2097152 /* ContainsHoistedDeclarationOrCompletion */;
                if (ts.modifiersToFlags(node.modifiers) & 256 /* Async */) {
                    if (node.asteriskToken) {
                        node.transformFlags |= 64 /* ContainsES2018 */;
                    }
                    else {
                        node.transformFlags |= 128 /* ContainsES2017 */;
                    }
                }
                else if (node.asteriskToken) {
                    node.transformFlags |= 1024 /* ContainsGenerator */;
                }
            }
            return node;
        }
        // @api
        function updateFunctionDeclaration(node, decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body), node)
                : node;
        }
        // @api
        function createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseClassLikeDeclaration(255 /* ClassDeclaration */, decorators, modifiers, name, typeParameters, heritageClauses, members);
            if (ts.modifiersToFlags(node.modifiers) & 2 /* Ambient */) {
                node.transformFlags = 1 /* ContainsTypeScript */;
            }
            else {
                node.transformFlags |= 512 /* ContainsES2015 */;
                if (node.transformFlags & 4096 /* ContainsTypeScriptClassSyntax */) {
                    node.transformFlags |= 1 /* ContainsTypeScript */;
                }
            }
            return node;
        }
        // @api
        function updateClassDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        // @api
        function createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseInterfaceOrClassLikeDeclaration(256 /* InterfaceDeclaration */, decorators, modifiers, name, typeParameters, heritageClauses);
            node.members = createNodeArray(members);
            node.transformFlags = 1 /* ContainsTypeScript */;
            return node;
        }
        // @api
        function updateInterfaceDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        // @api
        function createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type) {
            var node = createBaseGenericNamedDeclaration(257 /* TypeAliasDeclaration */, decorators, modifiers, name, typeParameters);
            node.type = type;
            node.transformFlags = 1 /* ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeAliasDeclaration(node, decorators, modifiers, name, typeParameters, type) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.type !== type
                ? update(createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type), node)
                : node;
        }
        // @api
        function createEnumDeclaration(decorators, modifiers, name, members) {
            var node = createBaseNamedDeclaration(258 /* EnumDeclaration */, decorators, modifiers, name);
            node.members = createNodeArray(members);
            node.transformFlags |=
                propagateChildrenFlags(node.members) |
                    1 /* ContainsTypeScript */;
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // Enum declarations cannot contain `await`
            return node;
        }
        // @api
        function updateEnumDeclaration(node, decorators, modifiers, name, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.members !== members
                ? update(createEnumDeclaration(decorators, modifiers, name, members), node)
                : node;
        }
        // @api
        function createModuleDeclaration(decorators, modifiers, name, body, flags) {
            if (flags === void 0) { flags = 0 /* None */; }
            var node = createBaseDeclaration(259 /* ModuleDeclaration */, decorators, modifiers);
            node.flags |= flags & (16 /* Namespace */ | 4 /* NestedNamespace */ | 1024 /* GlobalAugmentation */);
            node.name = name;
            node.body = body;
            if (ts.modifiersToFlags(node.modifiers) & 2 /* Ambient */) {
                node.transformFlags = 1 /* ContainsTypeScript */;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.name) |
                        propagateChildFlags(node.body) |
                        1 /* ContainsTypeScript */;
            }
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // Module declarations cannot contain `await`.
            return node;
        }
        // @api
        function updateModuleDeclaration(node, decorators, modifiers, name, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.body !== body
                ? update(createModuleDeclaration(decorators, modifiers, name, body, node.flags), node)
                : node;
        }
        // @api
        function createModuleBlock(statements) {
            var node = createBaseNode(260 /* ModuleBlock */);
            node.statements = createNodeArray(statements);
            node.transformFlags |= propagateChildrenFlags(node.statements);
            return node;
        }
        // @api
        function updateModuleBlock(node, statements) {
            return node.statements !== statements
                ? update(createModuleBlock(statements), node)
                : node;
        }
        // @api
        function createCaseBlock(clauses) {
            var node = createBaseNode(261 /* CaseBlock */);
            node.clauses = createNodeArray(clauses);
            node.transformFlags |= propagateChildrenFlags(node.clauses);
            return node;
        }
        // @api
        function updateCaseBlock(node, clauses) {
            return node.clauses !== clauses
                ? update(createCaseBlock(clauses), node)
                : node;
        }
        // @api
        function createNamespaceExportDeclaration(name) {
            var node = createBaseNamedDeclaration(262 /* NamespaceExportDeclaration */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, name);
            node.transformFlags = 1 /* ContainsTypeScript */;
            return node;
        }
        // @api
        function updateNamespaceExportDeclaration(node, name) {
            return node.name !== name
                ? update(createNamespaceExportDeclaration(name), node)
                : node;
        }
        // @api
        function createImportEqualsDeclaration(decorators, modifiers, isTypeOnly, name, moduleReference) {
            var node = createBaseNamedDeclaration(263 /* ImportEqualsDeclaration */, decorators, modifiers, name);
            node.isTypeOnly = isTypeOnly;
            node.moduleReference = moduleReference;
            node.transformFlags |= propagateChildFlags(node.moduleReference);
            if (!ts.isExternalModuleReference(node.moduleReference))
                node.transformFlags |= 1 /* ContainsTypeScript */;
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // Import= declaration is always parsed in an Await context
            return node;
        }
        // @api
        function updateImportEqualsDeclaration(node, decorators, modifiers, isTypeOnly, name, moduleReference) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.isTypeOnly !== isTypeOnly
                || node.name !== name
                || node.moduleReference !== moduleReference
                ? update(createImportEqualsDeclaration(decorators, modifiers, isTypeOnly, name, moduleReference), node)
                : node;
        }
        // @api
        function createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier) {
            var node = createBaseDeclaration(264 /* ImportDeclaration */, decorators, modifiers);
            node.importClause = importClause;
            node.moduleSpecifier = moduleSpecifier;
            node.transformFlags |=
                propagateChildFlags(node.importClause) |
                    propagateChildFlags(node.moduleSpecifier);
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateImportDeclaration(node, decorators, modifiers, importClause, moduleSpecifier) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.importClause !== importClause
                || node.moduleSpecifier !== moduleSpecifier
                ? update(createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier), node)
                : node;
        }
        // @api
        function createImportClause(isTypeOnly, name, namedBindings) {
            var node = createBaseNode(265 /* ImportClause */);
            node.isTypeOnly = isTypeOnly;
            node.name = name;
            node.namedBindings = namedBindings;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.namedBindings);
            if (isTypeOnly) {
                node.transformFlags |= 1 /* ContainsTypeScript */;
            }
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateImportClause(node, isTypeOnly, name, namedBindings) {
            return node.isTypeOnly !== isTypeOnly
                || node.name !== name
                || node.namedBindings !== namedBindings
                ? update(createImportClause(isTypeOnly, name, namedBindings), node)
                : node;
        }
        // @api
        function createNamespaceImport(name) {
            var node = createBaseNode(266 /* NamespaceImport */);
            node.name = name;
            node.transformFlags |= propagateChildFlags(node.name);
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateNamespaceImport(node, name) {
            return node.name !== name
                ? update(createNamespaceImport(name), node)
                : node;
        }
        // @api
        function createNamespaceExport(name) {
            var node = createBaseNode(272 /* NamespaceExport */);
            node.name = name;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    4 /* ContainsESNext */;
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateNamespaceExport(node, name) {
            return node.name !== name
                ? update(createNamespaceExport(name), node)
                : node;
        }
        // @api
        function createNamedImports(elements) {
            var node = createBaseNode(267 /* NamedImports */);
            node.elements = createNodeArray(elements);
            node.transformFlags |= propagateChildrenFlags(node.elements);
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateNamedImports(node, elements) {
            return node.elements !== elements
                ? update(createNamedImports(elements), node)
                : node;
        }
        // @api
        function createImportSpecifier(propertyName, name) {
            var node = createBaseNode(268 /* ImportSpecifier */);
            node.propertyName = propertyName;
            node.name = name;
            node.transformFlags |=
                propagateChildFlags(node.propertyName) |
                    propagateChildFlags(node.name);
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateImportSpecifier(node, propertyName, name) {
            return node.propertyName !== propertyName
                || node.name !== name
                ? update(createImportSpecifier(propertyName, name), node)
                : node;
        }
        // @api
        function createExportAssignment(decorators, modifiers, isExportEquals, expression) {
            var node = createBaseDeclaration(269 /* ExportAssignment */, decorators, modifiers);
            node.isExportEquals = isExportEquals;
            node.expression = isExportEquals
                ? parenthesizerRules().parenthesizeRightSideOfBinary(63 /* EqualsToken */, /*leftSide*/ undefined, expression)
                : parenthesizerRules().parenthesizeExpressionOfExportDefault(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateExportAssignment(node, decorators, modifiers, expression) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.expression !== expression
                ? update(createExportAssignment(decorators, modifiers, node.isExportEquals, expression), node)
                : node;
        }
        // @api
        function createExportDeclaration(decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier) {
            var node = createBaseDeclaration(270 /* ExportDeclaration */, decorators, modifiers);
            node.isTypeOnly = isTypeOnly;
            node.exportClause = exportClause;
            node.moduleSpecifier = moduleSpecifier;
            node.transformFlags |=
                propagateChildFlags(node.exportClause) |
                    propagateChildFlags(node.moduleSpecifier);
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateExportDeclaration(node, decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.isTypeOnly !== isTypeOnly
                || node.exportClause !== exportClause
                || node.moduleSpecifier !== moduleSpecifier
                ? update(createExportDeclaration(decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier), node)
                : node;
        }
        // @api
        function createNamedExports(elements) {
            var node = createBaseNode(271 /* NamedExports */);
            node.elements = createNodeArray(elements);
            node.transformFlags |= propagateChildrenFlags(node.elements);
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateNamedExports(node, elements) {
            return node.elements !== elements
                ? update(createNamedExports(elements), node)
                : node;
        }
        // @api
        function createExportSpecifier(propertyName, name) {
            var node = createBaseNode(273 /* ExportSpecifier */);
            node.propertyName = asName(propertyName);
            node.name = asName(name);
            node.transformFlags |=
                propagateChildFlags(node.propertyName) |
                    propagateChildFlags(node.name);
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateExportSpecifier(node, propertyName, name) {
            return node.propertyName !== propertyName
                || node.name !== name
                ? update(createExportSpecifier(propertyName, name), node)
                : node;
        }
        // @api
        function createMissingDeclaration() {
            var node = createBaseDeclaration(274 /* MissingDeclaration */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined);
            return node;
        }
        //
        // Module references
        //
        // @api
        function createExternalModuleReference(expression) {
            var node = createBaseNode(275 /* ExternalModuleReference */);
            node.expression = expression;
            node.transformFlags |= propagateChildFlags(node.expression);
            node.transformFlags &= ~16777216 /* ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateExternalModuleReference(node, expression) {
            return node.expression !== expression
                ? update(createExternalModuleReference(expression), node)
                : node;
        }
        //
        // JSDoc
        //
        // @api
        // createJSDocAllType
        // createJSDocUnknownType
        function createJSDocPrimaryTypeWorker(kind) {
            return createBaseNode(kind);
        }
        // @api
        // createJSDocNonNullableType
        // createJSDocNullableType
        // createJSDocOptionalType
        // createJSDocVariadicType
        // createJSDocNamepathType
        function createJSDocUnaryTypeWorker(kind, type) {
            var node = createBaseNode(kind);
            node.type = type;
            return node;
        }
        // @api
        // updateJSDocNonNullableType
        // updateJSDocNullableType
        // updateJSDocOptionalType
        // updateJSDocVariadicType
        // updateJSDocNamepathType
        function updateJSDocUnaryTypeWorker(kind, node, type) {
            return node.type !== type
                ? update(createJSDocUnaryTypeWorker(kind, type), node)
                : node;
        }
        // @api
        function createJSDocFunctionType(parameters, type) {
            var node = createBaseSignatureDeclaration(312 /* JSDocFunctionType */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, parameters, type);
            return node;
        }
        // @api
        function updateJSDocFunctionType(node, parameters, type) {
            return node.parameters !== parameters
                || node.type !== type
                ? update(createJSDocFunctionType(parameters, type), node)
                : node;
        }
        // @api
        function createJSDocTypeLiteral(propertyTags, isArrayType) {
            if (isArrayType === void 0) { isArrayType = false; }
            var node = createBaseNode(317 /* JSDocTypeLiteral */);
            node.jsDocPropertyTags = asNodeArray(propertyTags);
            node.isArrayType = isArrayType;
            return node;
        }
        // @api
        function updateJSDocTypeLiteral(node, propertyTags, isArrayType) {
            return node.jsDocPropertyTags !== propertyTags
                || node.isArrayType !== isArrayType
                ? update(createJSDocTypeLiteral(propertyTags, isArrayType), node)
                : node;
        }
        // @api
        function createJSDocTypeExpression(type) {
            var node = createBaseNode(304 /* JSDocTypeExpression */);
            node.type = type;
            return node;
        }
        // @api
        function updateJSDocTypeExpression(node, type) {
            return node.type !== type
                ? update(createJSDocTypeExpression(type), node)
                : node;
        }
        // @api
        function createJSDocSignature(typeParameters, parameters, type) {
            var node = createBaseNode(318 /* JSDocSignature */);
            node.typeParameters = asNodeArray(typeParameters);
            node.parameters = createNodeArray(parameters);
            node.type = type;
            return node;
        }
        // @api
        function updateJSDocSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? update(createJSDocSignature(typeParameters, parameters, type), node)
                : node;
        }
        function getDefaultTagName(node) {
            var defaultTagName = getDefaultTagNameForKind(node.kind);
            return node.tagName.escapedText === ts.escapeLeadingUnderscores(defaultTagName)
                ? node.tagName
                : createIdentifier(defaultTagName);
        }
        // @api
        function createBaseJSDocTag(kind, tagName, comment) {
            var node = createBaseNode(kind);
            node.tagName = tagName;
            node.comment = comment;
            return node;
        }
        // @api
        function createJSDocTemplateTag(tagName, constraint, typeParameters, comment) {
            var node = createBaseJSDocTag(339 /* JSDocTemplateTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("template"), comment);
            node.constraint = constraint;
            node.typeParameters = createNodeArray(typeParameters);
            return node;
        }
        // @api
        function updateJSDocTemplateTag(node, tagName, constraint, typeParameters, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.constraint !== constraint
                || node.typeParameters !== typeParameters
                || node.comment !== comment
                ? update(createJSDocTemplateTag(tagName, constraint, typeParameters, comment), node)
                : node;
        }
        // @api
        function createJSDocTypedefTag(tagName, typeExpression, fullName, comment) {
            var node = createBaseJSDocTag(340 /* JSDocTypedefTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("typedef"), comment);
            node.typeExpression = typeExpression;
            node.fullName = fullName;
            node.name = ts.getJSDocTypeAliasName(fullName);
            return node;
        }
        // @api
        function updateJSDocTypedefTag(node, tagName, typeExpression, fullName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.fullName !== fullName
                || node.comment !== comment
                ? update(createJSDocTypedefTag(tagName, typeExpression, fullName, comment), node)
                : node;
        }
        // @api
        function createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            var node = createBaseJSDocTag(335 /* JSDocParameterTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("param"), comment);
            node.typeExpression = typeExpression;
            node.name = name;
            node.isNameFirst = !!isNameFirst;
            node.isBracketed = isBracketed;
            return node;
        }
        // @api
        function updateJSDocParameterTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.name !== name
                || node.isBracketed !== isBracketed
                || node.typeExpression !== typeExpression
                || node.isNameFirst !== isNameFirst
                || node.comment !== comment
                ? update(createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node)
                : node;
        }
        // @api
        function createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            var node = createBaseJSDocTag(342 /* JSDocPropertyTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("prop"), comment);
            node.typeExpression = typeExpression;
            node.name = name;
            node.isNameFirst = !!isNameFirst;
            node.isBracketed = isBracketed;
            return node;
        }
        // @api
        function updateJSDocPropertyTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.name !== name
                || node.isBracketed !== isBracketed
                || node.typeExpression !== typeExpression
                || node.isNameFirst !== isNameFirst
                || node.comment !== comment
                ? update(createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node)
                : node;
        }
        // @api
        function createJSDocCallbackTag(tagName, typeExpression, fullName, comment) {
            var node = createBaseJSDocTag(333 /* JSDocCallbackTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("callback"), comment);
            node.typeExpression = typeExpression;
            node.fullName = fullName;
            node.name = ts.getJSDocTypeAliasName(fullName);
            return node;
        }
        // @api
        function updateJSDocCallbackTag(node, tagName, typeExpression, fullName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.fullName !== fullName
                || node.comment !== comment
                ? update(createJSDocCallbackTag(tagName, typeExpression, fullName, comment), node)
                : node;
        }
        // @api
        function createJSDocAugmentsTag(tagName, className, comment) {
            var node = createBaseJSDocTag(323 /* JSDocAugmentsTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("augments"), comment);
            node.class = className;
            return node;
        }
        // @api
        function updateJSDocAugmentsTag(node, tagName, className, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.class !== className
                || node.comment !== comment
                ? update(createJSDocAugmentsTag(tagName, className, comment), node)
                : node;
        }
        // @api
        function createJSDocImplementsTag(tagName, className, comment) {
            var node = createBaseJSDocTag(324 /* JSDocImplementsTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("implements"), comment);
            node.class = className;
            return node;
        }
        // @api
        function createJSDocSeeTag(tagName, name, comment) {
            var node = createBaseJSDocTag(341 /* JSDocSeeTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("see"), comment);
            node.name = name;
            return node;
        }
        // @api
        function updateJSDocSeeTag(node, tagName, name, comment) {
            return node.tagName !== tagName
                || node.name !== name
                || node.comment !== comment
                ? update(createJSDocSeeTag(tagName, name, comment), node)
                : node;
        }
        // @api
        function createJSDocNameReference(name) {
            var node = createBaseNode(305 /* JSDocNameReference */);
            node.name = name;
            return node;
        }
        // @api
        function updateJSDocNameReference(node, name) {
            return node.name !== name
                ? update(createJSDocNameReference(name), node)
                : node;
        }
        // @api
        function createJSDocMemberName(left, right) {
            var node = createBaseNode(306 /* JSDocMemberName */);
            node.left = left;
            node.right = right;
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateChildFlags(node.right);
            return node;
        }
        // @api
        function updateJSDocMemberName(node, left, right) {
            return node.left !== left
                || node.right !== right
                ? update(createJSDocMemberName(left, right), node)
                : node;
        }
        // @api
        function createJSDocLink(name, text) {
            var node = createBaseNode(319 /* JSDocLink */);
            node.name = name;
            node.text = text;
            return node;
        }
        // @api
        function updateJSDocLink(node, name, text) {
            return node.name !== name
                ? update(createJSDocLink(name, text), node)
                : node;
        }
        // @api
        function createJSDocLinkCode(name, text) {
            var node = createBaseNode(320 /* JSDocLinkCode */);
            node.name = name;
            node.text = text;
            return node;
        }
        // @api
        function updateJSDocLinkCode(node, name, text) {
            return node.name !== name
                ? update(createJSDocLinkCode(name, text), node)
                : node;
        }
        // @api
        function createJSDocLinkPlain(name, text) {
            var node = createBaseNode(321 /* JSDocLinkPlain */);
            node.name = name;
            node.text = text;
            return node;
        }
        // @api
        function updateJSDocLinkPlain(node, name, text) {
            return node.name !== name
                ? update(createJSDocLinkPlain(name, text), node)
                : node;
        }
        // @api
        function updateJSDocImplementsTag(node, tagName, className, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.class !== className
                || node.comment !== comment
                ? update(createJSDocImplementsTag(tagName, className, comment), node)
                : node;
        }
        // @api
        // createJSDocAuthorTag
        // createJSDocClassTag
        // createJSDocPublicTag
        // createJSDocPrivateTag
        // createJSDocProtectedTag
        // createJSDocReadonlyTag
        // createJSDocDeprecatedTag
        function createJSDocSimpleTagWorker(kind, tagName, comment) {
            var node = createBaseJSDocTag(kind, tagName !== null && tagName !== void 0 ? tagName : createIdentifier(getDefaultTagNameForKind(kind)), comment);
            return node;
        }
        // @api
        // updateJSDocAuthorTag
        // updateJSDocClassTag
        // updateJSDocPublicTag
        // updateJSDocPrivateTag
        // updateJSDocProtectedTag
        // updateJSDocReadonlyTag
        // updateJSDocDeprecatedTag
        function updateJSDocSimpleTagWorker(kind, node, tagName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.comment !== comment
                ? update(createJSDocSimpleTagWorker(kind, tagName, comment), node) :
                node;
        }
        // @api
        // createJSDocTypeTag
        // createJSDocReturnTag
        // createJSDocThisTag
        // createJSDocEnumTag
        function createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment) {
            var node = createBaseJSDocTag(kind, tagName !== null && tagName !== void 0 ? tagName : createIdentifier(getDefaultTagNameForKind(kind)), comment);
            node.typeExpression = typeExpression;
            return node;
        }
        // @api
        // updateJSDocTypeTag
        // updateJSDocReturnTag
        // updateJSDocThisTag
        // updateJSDocEnumTag
        function updateJSDocTypeLikeTagWorker(kind, node, tagName, typeExpression, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.comment !== comment
                ? update(createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment), node)
                : node;
        }
        // @api
        function createJSDocUnknownTag(tagName, comment) {
            var node = createBaseJSDocTag(322 /* JSDocTag */, tagName, comment);
            return node;
        }
        // @api
        function updateJSDocUnknownTag(node, tagName, comment) {
            return node.tagName !== tagName
                || node.comment !== comment
                ? update(createJSDocUnknownTag(tagName, comment), node)
                : node;
        }
        // @api
        function createJSDocText(text) {
            var node = createBaseNode(316 /* JSDocText */);
            node.text = text;
            return node;
        }
        // @api
        function updateJSDocText(node, text) {
            return node.text !== text
                ? update(createJSDocText(text), node)
                : node;
        }
        // @api
        function createJSDocComment(comment, tags) {
            var node = createBaseNode(315 /* JSDocComment */);
            node.comment = comment;
            node.tags = asNodeArray(tags);
            return node;
        }
        // @api
        function updateJSDocComment(node, comment, tags) {
            return node.comment !== comment
                || node.tags !== tags
                ? update(createJSDocComment(comment, tags), node)
                : node;
        }
        //
        // JSX
        //
        // @api
        function createJsxElement(openingElement, children, closingElement) {
            var node = createBaseNode(276 /* JsxElement */);
            node.openingElement = openingElement;
            node.children = createNodeArray(children);
            node.closingElement = closingElement;
            node.transformFlags |=
                propagateChildFlags(node.openingElement) |
                    propagateChildrenFlags(node.children) |
                    propagateChildFlags(node.closingElement) |
                    2 /* ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxElement(node, openingElement, children, closingElement) {
            return node.openingElement !== openingElement
                || node.children !== children
                || node.closingElement !== closingElement
                ? update(createJsxElement(openingElement, children, closingElement), node)
                : node;
        }
        // @api
        function createJsxSelfClosingElement(tagName, typeArguments, attributes) {
            var node = createBaseNode(277 /* JsxSelfClosingElement */);
            node.tagName = tagName;
            node.typeArguments = asNodeArray(typeArguments);
            node.attributes = attributes;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.attributes) |
                    2 /* ContainsJsx */;
            if (node.typeArguments) {
                node.transformFlags |= 1 /* ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateJsxSelfClosingElement(node, tagName, typeArguments, attributes) {
            return node.tagName !== tagName
                || node.typeArguments !== typeArguments
                || node.attributes !== attributes
                ? update(createJsxSelfClosingElement(tagName, typeArguments, attributes), node)
                : node;
        }
        // @api
        function createJsxOpeningElement(tagName, typeArguments, attributes) {
            var node = createBaseNode(278 /* JsxOpeningElement */);
            node.tagName = tagName;
            node.typeArguments = asNodeArray(typeArguments);
            node.attributes = attributes;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.attributes) |
                    2 /* ContainsJsx */;
            if (typeArguments) {
                node.transformFlags |= 1 /* ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateJsxOpeningElement(node, tagName, typeArguments, attributes) {
            return node.tagName !== tagName
                || node.typeArguments !== typeArguments
                || node.attributes !== attributes
                ? update(createJsxOpeningElement(tagName, typeArguments, attributes), node)
                : node;
        }
        // @api
        function createJsxClosingElement(tagName) {
            var node = createBaseNode(279 /* JsxClosingElement */);
            node.tagName = tagName;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    2 /* ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxClosingElement(node, tagName) {
            return node.tagName !== tagName
                ? update(createJsxClosingElement(tagName), node)
                : node;
        }
        // @api
        function createJsxFragment(openingFragment, children, closingFragment) {
            var node = createBaseNode(280 /* JsxFragment */);
            node.openingFragment = openingFragment;
            node.children = createNodeArray(children);
            node.closingFragment = closingFragment;
            node.transformFlags |=
                propagateChildFlags(node.openingFragment) |
                    propagateChildrenFlags(node.children) |
                    propagateChildFlags(node.closingFragment) |
                    2 /* ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxFragment(node, openingFragment, children, closingFragment) {
            return node.openingFragment !== openingFragment
                || node.children !== children
                || node.closingFragment !== closingFragment
                ? update(createJsxFragment(openingFragment, children, closingFragment), node)
                : node;
        }
        // @api
        function createJsxText(text, containsOnlyTriviaWhiteSpaces) {
            var node = createBaseNode(11 /* JsxText */);
            node.text = text;
            node.containsOnlyTriviaWhiteSpaces = !!containsOnlyTriviaWhiteSpaces;
            node.transformFlags |= 2 /* ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxText(node, text, containsOnlyTriviaWhiteSpaces) {
            return node.text !== text
                || node.containsOnlyTriviaWhiteSpaces !== containsOnlyTriviaWhiteSpaces
                ? update(createJsxText(text, containsOnlyTriviaWhiteSpaces), node)
                : node;
        }
        // @api
        function createJsxOpeningFragment() {
            var node = createBaseNode(281 /* JsxOpeningFragment */);
            node.transformFlags |= 2 /* ContainsJsx */;
            return node;
        }
        // @api
        function createJsxJsxClosingFragment() {
            var node = createBaseNode(282 /* JsxClosingFragment */);
            node.transformFlags |= 2 /* ContainsJsx */;
            return node;
        }
        // @api
        function createJsxAttribute(name, initializer) {
            var node = createBaseNode(283 /* JsxAttribute */);
            node.name = name;
            node.initializer = initializer;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer) |
                    2 /* ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxAttribute(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? update(createJsxAttribute(name, initializer), node)
                : node;
        }
        // @api
        function createJsxAttributes(properties) {
            var node = createBaseNode(284 /* JsxAttributes */);
            node.properties = createNodeArray(properties);
            node.transformFlags |=
                propagateChildrenFlags(node.properties) |
                    2 /* ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxAttributes(node, properties) {
            return node.properties !== properties
                ? update(createJsxAttributes(properties), node)
                : node;
        }
        // @api
        function createJsxSpreadAttribute(expression) {
            var node = createBaseNode(285 /* JsxSpreadAttribute */);
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    2 /* ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxSpreadAttribute(node, expression) {
            return node.expression !== expression
                ? update(createJsxSpreadAttribute(expression), node)
                : node;
        }
        // @api
        function createJsxExpression(dotDotDotToken, expression) {
            var node = createBaseNode(286 /* JsxExpression */);
            node.dotDotDotToken = dotDotDotToken;
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.dotDotDotToken) |
                    propagateChildFlags(node.expression) |
                    2 /* ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxExpression(node, expression) {
            return node.expression !== expression
                ? update(createJsxExpression(node.dotDotDotToken, expression), node)
                : node;
        }
        //
        // Clauses
        //
        // @api
        function createCaseClause(expression, statements) {
            var node = createBaseNode(287 /* CaseClause */);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.statements = createNodeArray(statements);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.statements);
            return node;
        }
        // @api
        function updateCaseClause(node, expression, statements) {
            return node.expression !== expression
                || node.statements !== statements
                ? update(createCaseClause(expression, statements), node)
                : node;
        }
        // @api
        function createDefaultClause(statements) {
            var node = createBaseNode(288 /* DefaultClause */);
            node.statements = createNodeArray(statements);
            node.transformFlags = propagateChildrenFlags(node.statements);
            return node;
        }
        // @api
        function updateDefaultClause(node, statements) {
            return node.statements !== statements
                ? update(createDefaultClause(statements), node)
                : node;
        }
        // @api
        function createHeritageClause(token, types) {
            var node = createBaseNode(289 /* HeritageClause */);
            node.token = token;
            node.types = createNodeArray(types);
            node.transformFlags |= propagateChildrenFlags(node.types);
            switch (token) {
                case 94 /* ExtendsKeyword */:
                    node.transformFlags |= 512 /* ContainsES2015 */;
                    break;
                case 117 /* ImplementsKeyword */:
                    node.transformFlags |= 1 /* ContainsTypeScript */;
                    break;
                default:
                    return ts.Debug.assertNever(token);
            }
            return node;
        }
        // @api
        function updateHeritageClause(node, types) {
            return node.types !== types
                ? update(createHeritageClause(node.token, types), node)
                : node;
        }
        // @api
        function createCatchClause(variableDeclaration, block) {
            var node = createBaseNode(290 /* CatchClause */);
            variableDeclaration = !ts.isString(variableDeclaration) ? variableDeclaration : createVariableDeclaration(variableDeclaration, 
            /*exclamationToken*/ undefined, 
            /*type*/ undefined, 
            /*initializer*/ undefined);
            node.variableDeclaration = variableDeclaration;
            node.block = block;
            node.transformFlags |=
                propagateChildFlags(node.variableDeclaration) |
                    propagateChildFlags(node.block);
            if (!variableDeclaration)
                node.transformFlags |= 32 /* ContainsES2019 */;
            return node;
        }
        // @api
        function updateCatchClause(node, variableDeclaration, block) {
            return node.variableDeclaration !== variableDeclaration
                || node.block !== block
                ? update(createCatchClause(variableDeclaration, block), node)
                : node;
        }
        //
        // Property assignments
        //
        // @api
        function createPropertyAssignment(name, initializer) {
            var node = createBaseNamedDeclaration(291 /* PropertyAssignment */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, name);
            node.initializer = parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer);
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer);
            return node;
        }
        function finishUpdatePropertyAssignment(updated, original) {
            // copy children used only for error reporting
            if (original.decorators)
                updated.decorators = original.decorators;
            if (original.modifiers)
                updated.modifiers = original.modifiers;
            if (original.questionToken)
                updated.questionToken = original.questionToken;
            if (original.exclamationToken)
                updated.exclamationToken = original.exclamationToken;
            return update(updated, original);
        }
        // @api
        function updatePropertyAssignment(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? finishUpdatePropertyAssignment(createPropertyAssignment(name, initializer), node)
                : node;
        }
        // @api
        function createShorthandPropertyAssignment(name, objectAssignmentInitializer) {
            var node = createBaseNamedDeclaration(292 /* ShorthandPropertyAssignment */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, name);
            node.objectAssignmentInitializer = objectAssignmentInitializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(objectAssignmentInitializer);
            node.transformFlags |=
                propagateChildFlags(node.objectAssignmentInitializer) |
                    512 /* ContainsES2015 */;
            return node;
        }
        function finishUpdateShorthandPropertyAssignment(updated, original) {
            // copy children used only for error reporting
            if (original.decorators)
                updated.decorators = original.decorators;
            if (original.modifiers)
                updated.modifiers = original.modifiers;
            if (original.equalsToken)
                updated.equalsToken = original.equalsToken;
            if (original.questionToken)
                updated.questionToken = original.questionToken;
            if (original.exclamationToken)
                updated.exclamationToken = original.exclamationToken;
            return update(updated, original);
        }
        // @api
        function updateShorthandPropertyAssignment(node, name, objectAssignmentInitializer) {
            return node.name !== name
                || node.objectAssignmentInitializer !== objectAssignmentInitializer
                ? finishUpdateShorthandPropertyAssignment(createShorthandPropertyAssignment(name, objectAssignmentInitializer), node)
                : node;
        }
        // @api
        function createSpreadAssignment(expression) {
            var node = createBaseNode(293 /* SpreadAssignment */);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    64 /* ContainsES2018 */ |
                    32768 /* ContainsObjectRestOrSpread */;
            return node;
        }
        // @api
        function updateSpreadAssignment(node, expression) {
            return node.expression !== expression
                ? update(createSpreadAssignment(expression), node)
                : node;
        }
        //
        // Enum
        //
        // @api
        function createEnumMember(name, initializer) {
            var node = createBaseNode(294 /* EnumMember */);
            node.name = asName(name);
            node.initializer = initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer);
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer) |
                    1 /* ContainsTypeScript */;
            return node;
        }
        // @api
        function updateEnumMember(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? update(createEnumMember(name, initializer), node)
                : node;
        }
        //
        // Top-level nodes
        //
        // @api
        function createSourceFile(statements, endOfFileToken, flags) {
            var node = baseFactory.createBaseSourceFileNode(300 /* SourceFile */);
            node.statements = createNodeArray(statements);
            node.endOfFileToken = endOfFileToken;
            node.flags |= flags;
            node.fileName = "";
            node.text = "";
            node.languageVersion = 0;
            node.languageVariant = 0;
            node.scriptKind = 0;
            node.isDeclarationFile = false;
            node.hasNoDefaultLib = false;
            node.transformFlags |=
                propagateChildrenFlags(node.statements) |
                    propagateChildFlags(node.endOfFileToken);
            return node;
        }
        function cloneSourceFileWithChanges(source, statements, isDeclarationFile, referencedFiles, typeReferences, hasNoDefaultLib, libReferences) {
            var node = baseFactory.createBaseSourceFileNode(300 /* SourceFile */);
            for (var p in source) {
                if (p === "emitNode" || ts.hasProperty(node, p) || !ts.hasProperty(source, p))
                    continue;
                node[p] = source[p];
            }
            node.flags |= source.flags;
            node.statements = createNodeArray(statements);
            node.endOfFileToken = source.endOfFileToken;
            node.isDeclarationFile = isDeclarationFile;
            node.referencedFiles = referencedFiles;
            node.typeReferenceDirectives = typeReferences;
            node.hasNoDefaultLib = hasNoDefaultLib;
            node.libReferenceDirectives = libReferences;
            node.transformFlags =
                propagateChildrenFlags(node.statements) |
                    propagateChildFlags(node.endOfFileToken);
            return node;
        }
        // @api
        function updateSourceFile(node, statements, isDeclarationFile, referencedFiles, typeReferenceDirectives, hasNoDefaultLib, libReferenceDirectives) {
            if (isDeclarationFile === void 0) { isDeclarationFile = node.isDeclarationFile; }
            if (referencedFiles === void 0) { referencedFiles = node.referencedFiles; }
            if (typeReferenceDirectives === void 0) { typeReferenceDirectives = node.typeReferenceDirectives; }
            if (hasNoDefaultLib === void 0) { hasNoDefaultLib = node.hasNoDefaultLib; }
            if (libReferenceDirectives === void 0) { libReferenceDirectives = node.libReferenceDirectives; }
            return node.statements !== statements
                || node.isDeclarationFile !== isDeclarationFile
                || node.referencedFiles !== referencedFiles
                || node.typeReferenceDirectives !== typeReferenceDirectives
                || node.hasNoDefaultLib !== hasNoDefaultLib
                || node.libReferenceDirectives !== libReferenceDirectives
                ? update(cloneSourceFileWithChanges(node, statements, isDeclarationFile, referencedFiles, typeReferenceDirectives, hasNoDefaultLib, libReferenceDirectives), node)
                : node;
        }
        // @api
        function createBundle(sourceFiles, prepends) {
            if (prepends === void 0) { prepends = ts.emptyArray; }
            var node = createBaseNode(301 /* Bundle */);
            node.prepends = prepends;
            node.sourceFiles = sourceFiles;
            return node;
        }
        // @api
        function updateBundle(node, sourceFiles, prepends) {
            if (prepends === void 0) { prepends = ts.emptyArray; }
            return node.sourceFiles !== sourceFiles
                || node.prepends !== prepends
                ? update(createBundle(sourceFiles, prepends), node)
                : node;
        }
        // @api
        function createUnparsedSource(prologues, syntheticReferences, texts) {
            var node = createBaseNode(302 /* UnparsedSource */);
            node.prologues = prologues;
            node.syntheticReferences = syntheticReferences;
            node.texts = texts;
            node.fileName = "";
            node.text = "";
            node.referencedFiles = ts.emptyArray;
            node.libReferenceDirectives = ts.emptyArray;
            node.getLineAndCharacterOfPosition = function (pos) { return ts.getLineAndCharacterOfPosition(node, pos); };
            return node;
        }
        function createBaseUnparsedNode(kind, data) {
            var node = createBaseNode(kind);
            node.data = data;
            return node;
        }
        // @api
        function createUnparsedPrologue(data) {
            return createBaseUnparsedNode(295 /* UnparsedPrologue */, data);
        }
        // @api
        function createUnparsedPrepend(data, texts) {
            var node = createBaseUnparsedNode(296 /* UnparsedPrepend */, data);
            node.texts = texts;
            return node;
        }
        // @api
        function createUnparsedTextLike(data, internal) {
            return createBaseUnparsedNode(internal ? 298 /* UnparsedInternalText */ : 297 /* UnparsedText */, data);
        }
        // @api
        function createUnparsedSyntheticReference(section) {
            var node = createBaseNode(299 /* UnparsedSyntheticReference */);
            node.data = section.data;
            node.section = section;
            return node;
        }
        // @api
        function createInputFiles() {
            var node = createBaseNode(303 /* InputFiles */);
            node.javascriptText = "";
            node.declarationText = "";
            return node;
        }
        //
        // Synthetic Nodes (used by checker)
        //
        // @api
        function createSyntheticExpression(type, isSpread, tupleNameSource) {
            if (isSpread === void 0) { isSpread = false; }
            var node = createBaseNode(230 /* SyntheticExpression */);
            node.type = type;
            node.isSpread = isSpread;
            node.tupleNameSource = tupleNameSource;
            return node;
        }
        // @api
        function createSyntaxList(children) {
            var node = createBaseNode(343 /* SyntaxList */);
            node._children = children;
            return node;
        }
        //
        // Transformation nodes
        //
        /**
         * Creates a synthetic statement to act as a placeholder for a not-emitted statement in
         * order to preserve comments.
         *
         * @param original The original statement.
         */
        // @api
        function createNotEmittedStatement(original) {
            var node = createBaseNode(344 /* NotEmittedStatement */);
            node.original = original;
            ts.setTextRange(node, original);
            return node;
        }
        /**
         * Creates a synthetic expression to act as a placeholder for a not-emitted expression in
         * order to preserve comments or sourcemap positions.
         *
         * @param expression The inner expression to emit.
         * @param original The original outer expression.
         */
        // @api
        function createPartiallyEmittedExpression(expression, original) {
            var node = createBaseNode(345 /* PartiallyEmittedExpression */);
            node.expression = expression;
            node.original = original;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 /* ContainsTypeScript */;
            ts.setTextRange(node, original);
            return node;
        }
        // @api
        function updatePartiallyEmittedExpression(node, expression) {
            return node.expression !== expression
                ? update(createPartiallyEmittedExpression(expression, node.original), node)
                : node;
        }
        function flattenCommaElements(node) {
            if (ts.nodeIsSynthesized(node) && !ts.isParseTreeNode(node) && !node.original && !node.emitNode && !node.id) {
                if (ts.isCommaListExpression(node)) {
                    return node.elements;
                }
                if (ts.isBinaryExpression(node) && ts.isCommaToken(node.operatorToken)) {
                    return [node.left, node.right];
                }
            }
            return node;
        }
        // @api
        function createCommaListExpression(elements) {
            var node = createBaseNode(346 /* CommaListExpression */);
            node.elements = createNodeArray(ts.sameFlatMap(elements, flattenCommaElements));
            node.transformFlags |= propagateChildrenFlags(node.elements);
            return node;
        }
        // @api
        function updateCommaListExpression(node, elements) {
            return node.elements !== elements
                ? update(createCommaListExpression(elements), node)
                : node;
        }
        /**
         * Creates a synthetic element to act as a placeholder for the end of an emitted declaration in
         * order to properly emit exports.
         */
        // @api
        function createEndOfDeclarationMarker(original) {
            var node = createBaseNode(348 /* EndOfDeclarationMarker */);
            node.emitNode = {};
            node.original = original;
            return node;
        }
        /**
         * Creates a synthetic element to act as a placeholder for the beginning of a merged declaration in
         * order to properly emit exports.
         */
        // @api
        function createMergeDeclarationMarker(original) {
            var node = createBaseNode(347 /* MergeDeclarationMarker */);
            node.emitNode = {};
            node.original = original;
            return node;
        }
        // @api
        function createSyntheticReferenceExpression(expression, thisArg) {
            var node = createBaseNode(349 /* SyntheticReferenceExpression */);
            node.expression = expression;
            node.thisArg = thisArg;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.thisArg);
            return node;
        }
        // @api
        function updateSyntheticReferenceExpression(node, expression, thisArg) {
            return node.expression !== expression
                || node.thisArg !== thisArg
                ? update(createSyntheticReferenceExpression(expression, thisArg), node)
                : node;
        }
        function cloneNode(node) {
            // We don't use "clone" from core.ts here, as we need to preserve the prototype chain of
            // the original node. We also need to exclude specific properties and only include own-
            // properties (to skip members already defined on the shared prototype).
            if (node === undefined) {
                return node;
            }
            var clone = ts.isSourceFile(node) ? baseFactory.createBaseSourceFileNode(300 /* SourceFile */) :
                ts.isIdentifier(node) ? baseFactory.createBaseIdentifierNode(79 /* Identifier */) :
                    ts.isPrivateIdentifier(node) ? baseFactory.createBasePrivateIdentifierNode(80 /* PrivateIdentifier */) :
                        !ts.isNodeKind(node.kind) ? baseFactory.createBaseTokenNode(node.kind) :
                            baseFactory.createBaseNode(node.kind);
            clone.flags |= (node.flags & ~8 /* Synthesized */);
            clone.transformFlags = node.transformFlags;
            setOriginalNode(clone, node);
            for (var key in node) {
                if (clone.hasOwnProperty(key) || !node.hasOwnProperty(key)) {
                    continue;
                }
                clone[key] = node[key];
            }
            return clone;
        }
        function createImmediatelyInvokedFunctionExpression(statements, param, paramValue) {
            return createCallExpression(createFunctionExpression(
            /*modifiers*/ undefined, 
            /*asteriskToken*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, 
            /*parameters*/ param ? [param] : [], 
            /*type*/ undefined, createBlock(statements, /*multiLine*/ true)), 
            /*typeArguments*/ undefined, 
            /*argumentsArray*/ paramValue ? [paramValue] : []);
        }
        function createImmediatelyInvokedArrowFunction(statements, param, paramValue) {
            return createCallExpression(createArrowFunction(
            /*modifiers*/ undefined, 
            /*typeParameters*/ undefined, 
            /*parameters*/ param ? [param] : [], 
            /*type*/ undefined, 
            /*equalsGreaterThanToken*/ undefined, createBlock(statements, /*multiLine*/ true)), 
            /*typeArguments*/ undefined, 
            /*argumentsArray*/ paramValue ? [paramValue] : []);
        }
        function createVoidZero() {
            return createVoidExpression(createNumericLiteral("0"));
        }
        function createExportDefault(expression) {
            return createExportAssignment(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*isExportEquals*/ false, expression);
        }
        function createExternalModuleExport(exportName) {
            return createExportDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*isTypeOnly*/ false, createNamedExports([
                createExportSpecifier(/*propertyName*/ undefined, exportName)
            ]));
        }
        //
        // Utilities
        //
        function createTypeCheck(value, tag) {
            return tag === "undefined"
                ? factory.createStrictEquality(value, createVoidZero())
                : factory.createStrictEquality(createTypeOfExpression(value), createStringLiteral(tag));
        }
        function createMethodCall(object, methodName, argumentsList) {
            // Preserve the optionality of `object`.
            if (ts.isCallChain(object)) {
                return createCallChain(createPropertyAccessChain(object, /*questionDotToken*/ undefined, methodName), 
                /*questionDotToken*/ undefined, 
                /*typeArguments*/ undefined, argumentsList);
            }
            return createCallExpression(createPropertyAccessExpression(object, methodName), 
            /*typeArguments*/ undefined, argumentsList);
        }
        function createFunctionBindCall(target, thisArg, argumentsList) {
            return createMethodCall(target, "bind", __spreadArray([thisArg], argumentsList, true));
        }
        function createFunctionCallCall(target, thisArg, argumentsList) {
            return createMethodCall(target, "call", __spreadArray([thisArg], argumentsList, true));
        }
        function createFunctionApplyCall(target, thisArg, argumentsExpression) {
            return createMethodCall(target, "apply", [thisArg, argumentsExpression]);
        }
        function createGlobalMethodCall(globalObjectName, methodName, argumentsList) {
            return createMethodCall(createIdentifier(globalObjectName), methodName, argumentsList);
        }
        function createArraySliceCall(array, start) {
            return createMethodCall(array, "slice", start === undefined ? [] : [asExpression(start)]);
        }
        function createArrayConcatCall(array, argumentsList) {
            return createMethodCall(array, "concat", argumentsList);
        }
        function createObjectDefinePropertyCall(target, propertyName, attributes) {
            return createGlobalMethodCall("Object", "defineProperty", [target, asExpression(propertyName), attributes]);
        }
        function createReflectGetCall(target, propertyKey, receiver) {
            return createGlobalMethodCall("Reflect", "get", receiver ? [target, propertyKey, receiver] : [target, propertyKey]);
        }
        function createReflectSetCall(target, propertyKey, value, receiver) {
            return createGlobalMethodCall("Reflect", "set", receiver ? [target, propertyKey, value, receiver] : [target, propertyKey, value]);
        }
        function tryAddPropertyAssignment(properties, propertyName, expression) {
            if (expression) {
                properties.push(createPropertyAssignment(propertyName, expression));
                return true;
            }
            return false;
        }
        function createPropertyDescriptor(attributes, singleLine) {
            var properties = [];
            tryAddPropertyAssignment(properties, "enumerable", asExpression(attributes.enumerable));
            tryAddPropertyAssignment(properties, "configurable", asExpression(attributes.configurable));
            var isData = tryAddPropertyAssignment(properties, "writable", asExpression(attributes.writable));
            isData = tryAddPropertyAssignment(properties, "value", attributes.value) || isData;
            var isAccessor = tryAddPropertyAssignment(properties, "get", attributes.get);
            isAccessor = tryAddPropertyAssignment(properties, "set", attributes.set) || isAccessor;
            ts.Debug.assert(!(isData && isAccessor), "A PropertyDescriptor may not be both an accessor descriptor and a data descriptor.");
            return createObjectLiteralExpression(properties, !singleLine);
        }
        function updateOuterExpression(outerExpression, expression) {
            switch (outerExpression.kind) {
                case 210 /* ParenthesizedExpression */: return updateParenthesizedExpression(outerExpression, expression);
                case 209 /* TypeAssertionExpression */: return updateTypeAssertion(outerExpression, outerExpression.type, expression);
                case 227 /* AsExpression */: return updateAsExpression(outerExpression, expression, outerExpression.type);
                case 228 /* NonNullExpression */: return updateNonNullExpression(outerExpression, expression);
                case 345 /* PartiallyEmittedExpression */: return updatePartiallyEmittedExpression(outerExpression, expression);
            }
        }
        /**
         * Determines whether a node is a parenthesized expression that can be ignored when recreating outer expressions.
         *
         * A parenthesized expression can be ignored when all of the following are true:
         *
         * - It's `pos` and `end` are not -1
         * - It does not have a custom source map range
         * - It does not have a custom comment range
         * - It does not have synthetic leading or trailing comments
         *
         * If an outermost parenthesized expression is ignored, but the containing expression requires a parentheses around
         * the expression to maintain precedence, a new parenthesized expression should be created automatically when
         * the containing expression is created/updated.
         */
        function isIgnorableParen(node) {
            return ts.isParenthesizedExpression(node)
                && ts.nodeIsSynthesized(node)
                && ts.nodeIsSynthesized(ts.getSourceMapRange(node))
                && ts.nodeIsSynthesized(ts.getCommentRange(node))
                && !ts.some(ts.getSyntheticLeadingComments(node))
                && !ts.some(ts.getSyntheticTrailingComments(node));
        }
        function restoreOuterExpressions(outerExpression, innerExpression, kinds) {
            if (kinds === void 0) { kinds = 15 /* All */; }
            if (outerExpression && ts.isOuterExpression(outerExpression, kinds) && !isIgnorableParen(outerExpression)) {
                return updateOuterExpression(outerExpression, restoreOuterExpressions(outerExpression.expression, innerExpression));
            }
            return innerExpression;
        }
        function restoreEnclosingLabel(node, outermostLabeledStatement, afterRestoreLabelCallback) {
            if (!outermostLabeledStatement) {
                return node;
            }
            var updated = updateLabeledStatement(outermostLabeledStatement, outermostLabeledStatement.label, ts.isLabeledStatement(outermostLabeledStatement.statement)
                ? restoreEnclosingLabel(node, outermostLabeledStatement.statement)
                : node);
            if (afterRestoreLabelCallback) {
                afterRestoreLabelCallback(outermostLabeledStatement);
            }
            return updated;
        }
        function shouldBeCapturedInTempVariable(node, cacheIdentifiers) {
            var target = ts.skipParentheses(node);
            switch (target.kind) {
                case 79 /* Identifier */:
                    return cacheIdentifiers;
                case 108 /* ThisKeyword */:
                case 8 /* NumericLiteral */:
                case 9 /* BigIntLiteral */:
                case 10 /* StringLiteral */:
                    return false;
                case 202 /* ArrayLiteralExpression */:
                    var elements = target.elements;
                    if (elements.length === 0) {
                        return false;
                    }
                    return true;
                case 203 /* ObjectLiteralExpression */:
                    return target.properties.length > 0;
                default:
                    return true;
            }
        }
        function createCallBinding(expression, recordTempVariable, languageVersion, cacheIdentifiers) {
            if (cacheIdentifiers === void 0) { cacheIdentifiers = false; }
            var callee = ts.skipOuterExpressions(expression, 15 /* All */);
            var thisArg;
            var target;
            if (ts.isSuperProperty(callee)) {
                thisArg = createThis();
                target = callee;
            }
            else if (ts.isSuperKeyword(callee)) {
                thisArg = createThis();
                target = languageVersion !== undefined && languageVersion < 2 /* ES2015 */
                    ? ts.setTextRange(createIdentifier("_super"), callee)
                    : callee;
            }
            else if (ts.getEmitFlags(callee) & 4096 /* HelperName */) {
                thisArg = createVoidZero();
                target = parenthesizerRules().parenthesizeLeftSideOfAccess(callee);
            }
            else if (ts.isPropertyAccessExpression(callee)) {
                if (shouldBeCapturedInTempVariable(callee.expression, cacheIdentifiers)) {
                    // for `a.b()` target is `(_a = a).b` and thisArg is `_a`
                    thisArg = createTempVariable(recordTempVariable);
                    target = createPropertyAccessExpression(ts.setTextRange(factory.createAssignment(thisArg, callee.expression), callee.expression), callee.name);
                    ts.setTextRange(target, callee);
                }
                else {
                    thisArg = callee.expression;
                    target = callee;
                }
            }
            else if (ts.isElementAccessExpression(callee)) {
                if (shouldBeCapturedInTempVariable(callee.expression, cacheIdentifiers)) {
                    // for `a[b]()` target is `(_a = a)[b]` and thisArg is `_a`
                    thisArg = createTempVariable(recordTempVariable);
                    target = createElementAccessExpression(ts.setTextRange(factory.createAssignment(thisArg, callee.expression), callee.expression), callee.argumentExpression);
                    ts.setTextRange(target, callee);
                }
                else {
                    thisArg = callee.expression;
                    target = callee;
                }
            }
            else {
                // for `a()` target is `a` and thisArg is `void 0`
                thisArg = createVoidZero();
                target = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            }
            return { target: target, thisArg: thisArg };
        }
        function createAssignmentTargetWrapper(paramName, expression) {
            return createPropertyAccessExpression(
            // Explicit parens required because of v8 regression (https://bugs.chromium.org/p/v8/issues/detail?id=9560)
            createParenthesizedExpression(createObjectLiteralExpression([
                createSetAccessorDeclaration(
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, "value", [createParameterDeclaration(
                    /*decorators*/ undefined, 
                    /*modifiers*/ undefined, 
                    /*dotDotDotToken*/ undefined, paramName, 
                    /*questionToken*/ undefined, 
                    /*type*/ undefined, 
                    /*initializer*/ undefined)], createBlock([
                    createExpressionStatement(expression)
                ]))
            ])), "value");
        }
        function inlineExpressions(expressions) {
            // Avoid deeply nested comma expressions as traversing them during emit can result in "Maximum call
            // stack size exceeded" errors.
            return expressions.length > 10
                ? createCommaListExpression(expressions)
                : ts.reduceLeft(expressions, factory.createComma);
        }
        function getName(node, allowComments, allowSourceMaps, emitFlags) {
            if (emitFlags === void 0) { emitFlags = 0; }
            var nodeName = ts.getNameOfDeclaration(node);
            if (nodeName && ts.isIdentifier(nodeName) && !ts.isGeneratedIdentifier(nodeName)) {
                // TODO(rbuckton): Does this need to be parented?
                var name = ts.setParent(ts.setTextRange(cloneNode(nodeName), nodeName), nodeName.parent);
                emitFlags |= ts.getEmitFlags(nodeName);
                if (!allowSourceMaps)
                    emitFlags |= 48 /* NoSourceMap */;
                if (!allowComments)
                    emitFlags |= 1536 /* NoComments */;
                if (emitFlags)
                    ts.setEmitFlags(name, emitFlags);
                return name;
            }
            return getGeneratedNameForNode(node);
        }
        /**
         * Gets the internal name of a declaration. This is primarily used for declarations that can be
         * referred to by name in the body of an ES5 class function body. An internal name will *never*
         * be prefixed with an module or namespace export modifier like "exports." when emitted as an
         * expression. An internal name will also *never* be renamed due to a collision with a block
         * scoped variable.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getInternalName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps, 16384 /* LocalName */ | 32768 /* InternalName */);
        }
        /**
         * Gets the local name of a declaration. This is primarily used for declarations that can be
         * referred to by name in the declaration's immediate scope (classes, enums, namespaces). A
         * local name will *never* be prefixed with an module or namespace export modifier like
         * "exports." when emitted as an expression.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getLocalName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps, 16384 /* LocalName */);
        }
        /**
         * Gets the export name of a declaration. This is primarily used for declarations that can be
         * referred to by name in the declaration's immediate scope (classes, enums, namespaces). An
         * export name will *always* be prefixed with an module or namespace export modifier like
         * `"exports."` when emitted as an expression if the name points to an exported symbol.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getExportName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps, 8192 /* ExportName */);
        }
        /**
         * Gets the name of a declaration for use in declarations.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getDeclarationName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps);
        }
        /**
         * Gets a namespace-qualified name for use in expressions.
         *
         * @param ns The namespace identifier.
         * @param name The name.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getNamespaceMemberName(ns, name, allowComments, allowSourceMaps) {
            var qualifiedName = createPropertyAccessExpression(ns, ts.nodeIsSynthesized(name) ? name : cloneNode(name));
            ts.setTextRange(qualifiedName, name);
            var emitFlags = 0;
            if (!allowSourceMaps)
                emitFlags |= 48 /* NoSourceMap */;
            if (!allowComments)
                emitFlags |= 1536 /* NoComments */;
            if (emitFlags)
                ts.setEmitFlags(qualifiedName, emitFlags);
            return qualifiedName;
        }
        /**
         * Gets the exported name of a declaration for use in expressions.
         *
         * An exported name will *always* be prefixed with an module or namespace export modifier like
         * "exports." if the name points to an exported symbol.
         *
         * @param ns The namespace identifier.
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getExternalModuleOrNamespaceExportName(ns, node, allowComments, allowSourceMaps) {
            if (ns && ts.hasSyntacticModifier(node, 1 /* Export */)) {
                return getNamespaceMemberName(ns, getName(node), allowComments, allowSourceMaps);
            }
            return getExportName(node, allowComments, allowSourceMaps);
        }
        /**
         * Copies any necessary standard and custom prologue-directives into target array.
         * @param source origin statements array
         * @param target result statements array
         * @param ensureUseStrict boolean determining whether the function need to add prologue-directives
         * @param visitor Optional callback used to visit any custom prologue directives.
         */
        function copyPrologue(source, target, ensureUseStrict, visitor) {
            var offset = copyStandardPrologue(source, target, ensureUseStrict);
            return copyCustomPrologue(source, target, offset, visitor);
        }
        function isUseStrictPrologue(node) {
            return ts.isStringLiteral(node.expression) && node.expression.text === "use strict";
        }
        function createUseStrictPrologue() {
            return ts.startOnNewLine(createExpressionStatement(createStringLiteral("use strict")));
        }
        /**
         * Copies only the standard (string-expression) prologue-directives into the target statement-array.
         * @param source origin statements array
         * @param target result statements array
         * @param ensureUseStrict boolean determining whether the function need to add prologue-directives
         */
        function copyStandardPrologue(source, target, ensureUseStrict) {
            ts.Debug.assert(target.length === 0, "Prologue directives should be at the first statement in the target statements array");
            var foundUseStrict = false;
            var statementOffset = 0;
            var numStatements = source.length;
            while (statementOffset < numStatements) {
                var statement = source[statementOffset];
                if (ts.isPrologueDirective(statement)) {
                    if (isUseStrictPrologue(statement)) {
                        foundUseStrict = true;
                    }
                    target.push(statement);
                }
                else {
                    break;
                }
                statementOffset++;
            }
            if (ensureUseStrict && !foundUseStrict) {
                target.push(createUseStrictPrologue());
            }
            return statementOffset;
        }
        function copyCustomPrologue(source, target, statementOffset, visitor, filter) {
            if (filter === void 0) { filter = ts.returnTrue; }
            var numStatements = source.length;
            while (statementOffset !== undefined && statementOffset < numStatements) {
                var statement = source[statementOffset];
                if (ts.getEmitFlags(statement) & 1048576 /* CustomPrologue */ && filter(statement)) {
                    ts.append(target, visitor ? ts.visitNode(statement, visitor, ts.isStatement) : statement);
                }
                else {
                    break;
                }
                statementOffset++;
            }
            return statementOffset;
        }
        /**
         * Ensures "use strict" directive is added
         *
         * @param statements An array of statements
         */
        function ensureUseStrict(statements) {
            var foundUseStrict = ts.findUseStrictPrologue(statements);
            if (!foundUseStrict) {
                return ts.setTextRange(createNodeArray(__spreadArray([createUseStrictPrologue()], statements, true)), statements);
            }
            return statements;
        }
        /**
         * Lifts a NodeArray containing only Statement nodes to a block.
         *
         * @param nodes The NodeArray.
         */
        function liftToBlock(nodes) {
            ts.Debug.assert(ts.every(nodes, ts.isStatementOrBlock), "Cannot lift nodes to a Block.");
            return ts.singleOrUndefined(nodes) || createBlock(nodes);
        }
        function findSpanEnd(array, test, start) {
            var i = start;
            while (i < array.length && test(array[i])) {
                i++;
            }
            return i;
        }
        function mergeLexicalEnvironment(statements, declarations) {
            if (!ts.some(declarations)) {
                return statements;
            }
            // When we merge new lexical statements into an existing statement list, we merge them in the following manner:
            //
            // Given:
            //
            // | Left                               | Right                               |
            // |------------------------------------|-------------------------------------|
            // | [standard prologues (left)]        | [standard prologues (right)]        |
            // | [hoisted functions (left)]         | [hoisted functions (right)]         |
            // | [hoisted variables (left)]         | [hoisted variables (right)]         |
            // | [lexical init statements (left)]   | [lexical init statements (right)]   |
            // | [other statements (left)]          |                                     |
            //
            // The resulting statement list will be:
            //
            // | Result                              |
            // |-------------------------------------|
            // | [standard prologues (right)]        |
            // | [standard prologues (left)]         |
            // | [hoisted functions (right)]         |
            // | [hoisted functions (left)]          |
            // | [hoisted variables (right)]         |
            // | [hoisted variables (left)]          |
            // | [lexical init statements (right)]   |
            // | [lexical init statements (left)]    |
            // | [other statements (left)]           |
            //
            // NOTE: It is expected that new lexical init statements must be evaluated before existing lexical init statements,
            // as the prior transformation may depend on the evaluation of the lexical init statements to be in the correct state.
            // find standard prologues on left in the following order: standard directives, hoisted functions, hoisted variables, other custom
            var leftStandardPrologueEnd = findSpanEnd(statements, ts.isPrologueDirective, 0);
            var leftHoistedFunctionsEnd = findSpanEnd(statements, ts.isHoistedFunction, leftStandardPrologueEnd);
            var leftHoistedVariablesEnd = findSpanEnd(statements, ts.isHoistedVariableStatement, leftHoistedFunctionsEnd);
            // find standard prologues on right in the following order: standard directives, hoisted functions, hoisted variables, other custom
            var rightStandardPrologueEnd = findSpanEnd(declarations, ts.isPrologueDirective, 0);
            var rightHoistedFunctionsEnd = findSpanEnd(declarations, ts.isHoistedFunction, rightStandardPrologueEnd);
            var rightHoistedVariablesEnd = findSpanEnd(declarations, ts.isHoistedVariableStatement, rightHoistedFunctionsEnd);
            var rightCustomPrologueEnd = findSpanEnd(declarations, ts.isCustomPrologue, rightHoistedVariablesEnd);
            ts.Debug.assert(rightCustomPrologueEnd === declarations.length, "Expected declarations to be valid standard or custom prologues");
            // splice prologues from the right into the left. We do this in reverse order
            // so that we don't need to recompute the index on the left when we insert items.
            var left = ts.isNodeArray(statements) ? statements.slice() : statements;
            // splice other custom prologues from right into left
            if (rightCustomPrologueEnd > rightHoistedVariablesEnd) {
                left.splice.apply(left, __spreadArray([leftHoistedVariablesEnd, 0], declarations.slice(rightHoistedVariablesEnd, rightCustomPrologueEnd), false));
            }
            // splice hoisted variables from right into left
            if (rightHoistedVariablesEnd > rightHoistedFunctionsEnd) {
                left.splice.apply(left, __spreadArray([leftHoistedFunctionsEnd, 0], declarations.slice(rightHoistedFunctionsEnd, rightHoistedVariablesEnd), false));
            }
            // splice hoisted functions from right into left
            if (rightHoistedFunctionsEnd > rightStandardPrologueEnd) {
                left.splice.apply(left, __spreadArray([leftStandardPrologueEnd, 0], declarations.slice(rightStandardPrologueEnd, rightHoistedFunctionsEnd), false));
            }
            // splice standard prologues from right into left (that are not already in left)
            if (rightStandardPrologueEnd > 0) {
                if (leftStandardPrologueEnd === 0) {
                    left.splice.apply(left, __spreadArray([0, 0], declarations.slice(0, rightStandardPrologueEnd), false));
                }
                else {
                    var leftPrologues = new ts.Map();
                    for (var i = 0; i < leftStandardPrologueEnd; i++) {
                        var leftPrologue = statements[i];
                        leftPrologues.set(leftPrologue.expression.text, true);
                    }
                    for (var i = rightStandardPrologueEnd - 1; i >= 0; i--) {
                        var rightPrologue = declarations[i];
                        if (!leftPrologues.has(rightPrologue.expression.text)) {
                            left.unshift(rightPrologue);
                        }
                    }
                }
            }
            if (ts.isNodeArray(statements)) {
                return ts.setTextRange(createNodeArray(left, statements.hasTrailingComma), statements);
            }
            return statements;
        }
        function updateModifiers(node, modifiers) {
            var _a;
            if (typeof modifiers === "number") {
                modifiers = createModifiersFromModifierFlags(modifiers);
            }
            return ts.isParameter(node) ? updateParameterDeclaration(node, node.decorators, modifiers, node.dotDotDotToken, node.name, node.questionToken, node.type, node.initializer) :
                ts.isPropertySignature(node) ? updatePropertySignature(node, modifiers, node.name, node.questionToken, node.type) :
                    ts.isPropertyDeclaration(node) ? updatePropertyDeclaration(node, node.decorators, modifiers, node.name, (_a = node.questionToken) !== null && _a !== void 0 ? _a : node.exclamationToken, node.type, node.initializer) :
                        ts.isMethodSignature(node) ? updateMethodSignature(node, modifiers, node.name, node.questionToken, node.typeParameters, node.parameters, node.type) :
                            ts.isMethodDeclaration(node) ? updateMethodDeclaration(node, node.decorators, modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body) :
                                ts.isConstructorDeclaration(node) ? updateConstructorDeclaration(node, node.decorators, modifiers, node.parameters, node.body) :
                                    ts.isGetAccessorDeclaration(node) ? updateGetAccessorDeclaration(node, node.decorators, modifiers, node.name, node.parameters, node.type, node.body) :
                                        ts.isSetAccessorDeclaration(node) ? updateSetAccessorDeclaration(node, node.decorators, modifiers, node.name, node.parameters, node.body) :
                                            ts.isIndexSignatureDeclaration(node) ? updateIndexSignature(node, node.decorators, modifiers, node.parameters, node.type) :
                                                ts.isFunctionExpression(node) ? updateFunctionExpression(node, modifiers, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body) :
                                                    ts.isArrowFunction(node) ? updateArrowFunction(node, modifiers, node.typeParameters, node.parameters, node.type, node.equalsGreaterThanToken, node.body) :
                                                        ts.isClassExpression(node) ? updateClassExpression(node, node.decorators, modifiers, node.name, node.typeParameters, node.heritageClauses, node.members) :
                                                            ts.isVariableStatement(node) ? updateVariableStatement(node, modifiers, node.declarationList) :
                                                                ts.isFunctionDeclaration(node) ? updateFunctionDeclaration(node, node.decorators, modifiers, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body) :
                                                                    ts.isClassDeclaration(node) ? updateClassDeclaration(node, node.decorators, modifiers, node.name, node.typeParameters, node.heritageClauses, node.members) :
                                                                        ts.isInterfaceDeclaration(node) ? updateInterfaceDeclaration(node, node.decorators, modifiers, node.name, node.typeParameters, node.heritageClauses, node.members) :
                                                                            ts.isTypeAliasDeclaration(node) ? updateTypeAliasDeclaration(node, node.decorators, modifiers, node.name, node.typeParameters, node.type) :
                                                                                ts.isEnumDeclaration(node) ? updateEnumDeclaration(node, node.decorators, modifiers, node.name, node.members) :
                                                                                    ts.isModuleDeclaration(node) ? updateModuleDeclaration(node, node.decorators, modifiers, node.name, node.body) :
                                                                                        ts.isImportEqualsDeclaration(node) ? updateImportEqualsDeclaration(node, node.decorators, modifiers, node.isTypeOnly, node.name, node.moduleReference) :
                                                                                            ts.isImportDeclaration(node) ? updateImportDeclaration(node, node.decorators, modifiers, node.importClause, node.moduleSpecifier) :
                                                                                                ts.isExportAssignment(node) ? updateExportAssignment(node, node.decorators, modifiers, node.expression) :
                                                                                                    ts.isExportDeclaration(node) ? updateExportDeclaration(node, node.decorators, modifiers, node.isTypeOnly, node.exportClause, node.moduleSpecifier) :
                                                                                                        ts.Debug.assertNever(node);
        }
        function asNodeArray(array) {
            return array ? createNodeArray(array) : undefined;
        }
        function asName(name) {
            return typeof name === "string" ? createIdentifier(name) :
                name;
        }
        function asExpression(value) {
            return typeof value === "string" ? createStringLiteral(value) :
                typeof value === "number" ? createNumericLiteral(value) :
                    typeof value === "boolean" ? value ? createTrue() : createFalse() :
                        value;
        }
        function asToken(value) {
            return typeof value === "number" ? createToken(value) : value;
        }
        function asEmbeddedStatement(statement) {
            return statement && ts.isNotEmittedStatement(statement) ? ts.setTextRange(setOriginalNode(createEmptyStatement(), statement), statement) : statement;
        }
    }
    ts.createNodeFactory = createNodeFactory;
    function updateWithoutOriginal(updated, original) {
        if (updated !== original) {
            ts.setTextRange(updated, original);
        }
        return updated;
    }
    function updateWithOriginal(updated, original) {
        if (updated !== original) {
            setOriginalNode(updated, original);
            ts.setTextRange(updated, original);
        }
        return updated;
    }
    function getDefaultTagNameForKind(kind) {
        switch (kind) {
            case 338 /* JSDocTypeTag */: return "type";
            case 336 /* JSDocReturnTag */: return "returns";
            case 337 /* JSDocThisTag */: return "this";
            case 334 /* JSDocEnumTag */: return "enum";
            case 325 /* JSDocAuthorTag */: return "author";
            case 327 /* JSDocClassTag */: return "class";
            case 328 /* JSDocPublicTag */: return "public";
            case 329 /* JSDocPrivateTag */: return "private";
            case 330 /* JSDocProtectedTag */: return "protected";
            case 331 /* JSDocReadonlyTag */: return "readonly";
            case 332 /* JSDocOverrideTag */: return "override";
            case 339 /* JSDocTemplateTag */: return "template";
            case 340 /* JSDocTypedefTag */: return "typedef";
            case 335 /* JSDocParameterTag */: return "param";
            case 342 /* JSDocPropertyTag */: return "prop";
            case 333 /* JSDocCallbackTag */: return "callback";
            case 323 /* JSDocAugmentsTag */: return "augments";
            case 324 /* JSDocImplementsTag */: return "implements";
            default:
                return ts.Debug.fail("Unsupported kind: " + ts.Debug.formatSyntaxKind(kind));
        }
    }
    var rawTextScanner;
    var invalidValueSentinel = {};
    function getCookedText(kind, rawText) {
        if (!rawTextScanner) {
            rawTextScanner = ts.createScanner(99 /* Latest */, /*skipTrivia*/ false, 0 /* Standard */);
        }
        switch (kind) {
            case 14 /* NoSubstitutionTemplateLiteral */:
                rawTextScanner.setText("`" + rawText + "`");
                break;
            case 15 /* TemplateHead */:
                // tslint:disable-next-line no-invalid-template-strings
                rawTextScanner.setText("`" + rawText + "${");
                break;
            case 16 /* TemplateMiddle */:
                // tslint:disable-next-line no-invalid-template-strings
                rawTextScanner.setText("}" + rawText + "${");
                break;
            case 17 /* TemplateTail */:
                rawTextScanner.setText("}" + rawText + "`");
                break;
        }
        var token = rawTextScanner.scan();
        if (token === 19 /* CloseBraceToken */) {
            token = rawTextScanner.reScanTemplateToken(/*isTaggedTemplate*/ false);
        }
        if (rawTextScanner.isUnterminated()) {
            rawTextScanner.setText(undefined);
            return invalidValueSentinel;
        }
        var tokenValue;
        switch (token) {
            case 14 /* NoSubstitutionTemplateLiteral */:
            case 15 /* TemplateHead */:
            case 16 /* TemplateMiddle */:
            case 17 /* TemplateTail */:
                tokenValue = rawTextScanner.getTokenValue();
                break;
        }
        if (tokenValue === undefined || rawTextScanner.scan() !== 1 /* EndOfFileToken */) {
            rawTextScanner.setText(undefined);
            return invalidValueSentinel;
        }
        rawTextScanner.setText(undefined);
        return tokenValue;
    }
    function propagateIdentifierNameFlags(node) {
        // An IdentifierName is allowed to be `await`
        return propagateChildFlags(node) & ~16777216 /* ContainsPossibleTopLevelAwait */;
    }
    function propagatePropertyNameFlagsOfChild(node, transformFlags) {
        return transformFlags | (node.transformFlags & 33562624 /* PropertyNamePropagatingFlags */);
    }
    function propagateChildFlags(child) {
        if (!child)
            return 0 /* None */;
        var childFlags = child.transformFlags & ~getTransformFlagsSubtreeExclusions(child.kind);
        return ts.isNamedDeclaration(child) && ts.isPropertyName(child.name) ? propagatePropertyNameFlagsOfChild(child.name, childFlags) : childFlags;
    }
    function propagateChildrenFlags(children) {
        return children ? children.transformFlags : 0 /* None */;
    }
    function aggregateChildrenFlags(children) {
        var subtreeFlags = 0 /* None */;
        for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
            var child = children_2[_i];
            subtreeFlags |= propagateChildFlags(child);
        }
        children.transformFlags = subtreeFlags;
    }
    /**
     * Gets the transform flags to exclude when unioning the transform flags of a subtree.
     */
    /* @internal */
    function getTransformFlagsSubtreeExclusions(kind) {
        if (kind >= 175 /* FirstTypeNode */ && kind <= 198 /* LastTypeNode */) {
            return -2 /* TypeExcludes */;
        }
        switch (kind) {
            case 206 /* CallExpression */:
            case 207 /* NewExpression */:
            case 202 /* ArrayLiteralExpression */:
                return 536887296 /* ArrayLiteralOrCallOrNewExcludes */;
            case 259 /* ModuleDeclaration */:
                return 589443072 /* ModuleExcludes */;
            case 162 /* Parameter */:
                return 536870912 /* ParameterExcludes */;
            case 212 /* ArrowFunction */:
                return 557748224 /* ArrowFunctionExcludes */;
            case 211 /* FunctionExpression */:
            case 254 /* FunctionDeclaration */:
                return 591310848 /* FunctionExcludes */;
            case 253 /* VariableDeclarationList */:
                return 537165824 /* VariableDeclarationListExcludes */;
            case 255 /* ClassDeclaration */:
            case 224 /* ClassExpression */:
                return 536940544 /* ClassExcludes */;
            case 169 /* Constructor */:
                return 591306752 /* ConstructorExcludes */;
            case 165 /* PropertyDeclaration */:
                return 570433536 /* PropertyExcludes */;
            case 167 /* MethodDeclaration */:
            case 170 /* GetAccessor */:
            case 171 /* SetAccessor */:
                return 574529536 /* MethodOrAccessorExcludes */;
            case 129 /* AnyKeyword */:
            case 145 /* NumberKeyword */:
            case 156 /* BigIntKeyword */:
            case 142 /* NeverKeyword */:
            case 148 /* StringKeyword */:
            case 146 /* ObjectKeyword */:
            case 132 /* BooleanKeyword */:
            case 149 /* SymbolKeyword */:
            case 114 /* VoidKeyword */:
            case 161 /* TypeParameter */:
            case 164 /* PropertySignature */:
            case 166 /* MethodSignature */:
            case 172 /* CallSignature */:
            case 173 /* ConstructSignature */:
            case 174 /* IndexSignature */:
            case 256 /* InterfaceDeclaration */:
            case 257 /* TypeAliasDeclaration */:
                return -2 /* TypeExcludes */;
            case 203 /* ObjectLiteralExpression */:
                return 536973312 /* ObjectLiteralExcludes */;
            case 290 /* CatchClause */:
                return 536903680 /* CatchClauseExcludes */;
            case 199 /* ObjectBindingPattern */:
            case 200 /* ArrayBindingPattern */:
                return 536887296 /* BindingPatternExcludes */;
            case 209 /* TypeAssertionExpression */:
            case 227 /* AsExpression */:
            case 345 /* PartiallyEmittedExpression */:
            case 210 /* ParenthesizedExpression */:
            case 106 /* SuperKeyword */:
                return 536870912 /* OuterExpressionExcludes */;
            case 204 /* PropertyAccessExpression */:
            case 205 /* ElementAccessExpression */:
                return 536870912 /* PropertyAccessExcludes */;
            default:
                return 536870912 /* NodeExcludes */;
        }
    }
    ts.getTransformFlagsSubtreeExclusions = getTransformFlagsSubtreeExclusions;
    var baseFactory = ts.createBaseNodeFactory();
    function makeSynthetic(node) {
        node.flags |= 8 /* Synthesized */;
        return node;
    }
    var syntheticFactory = {
        createBaseSourceFileNode: function (kind) { return makeSynthetic(baseFactory.createBaseSourceFileNode(kind)); },
        createBaseIdentifierNode: function (kind) { return makeSynthetic(baseFactory.createBaseIdentifierNode(kind)); },
        createBasePrivateIdentifierNode: function (kind) { return makeSynthetic(baseFactory.createBasePrivateIdentifierNode(kind)); },
        createBaseTokenNode: function (kind) { return makeSynthetic(baseFactory.createBaseTokenNode(kind)); },
        createBaseNode: function (kind) { return makeSynthetic(baseFactory.createBaseNode(kind)); },
    };
    ts.factory = createNodeFactory(4 /* NoIndentationOnFreshPropertyAccess */, syntheticFactory);
    function createUnparsedSourceFile(textOrInputFiles, mapPathOrType, mapTextOrStripInternal) {
        var stripInternal;
        var bundleFileInfo;
        var fileName;
        var text;
        var length;
        var sourceMapPath;
        var sourceMapText;
        var getText;
        var getSourceMapText;
        var oldFileOfCurrentEmit;
        if (!ts.isString(textOrInputFiles)) {
            ts.Debug.assert(mapPathOrType === "js" || mapPathOrType === "dts");
            fileName = (mapPathOrType === "js" ? textOrInputFiles.javascriptPath : textOrInputFiles.declarationPath) || "";
            sourceMapPath = mapPathOrType === "js" ? textOrInputFiles.javascriptMapPath : textOrInputFiles.declarationMapPath;
            getText = function () { return mapPathOrType === "js" ? textOrInputFiles.javascriptText : textOrInputFiles.declarationText; };
            getSourceMapText = function () { return mapPathOrType === "js" ? textOrInputFiles.javascriptMapText : textOrInputFiles.declarationMapText; };
            length = function () { return getText().length; };
            if (textOrInputFiles.buildInfo && textOrInputFiles.buildInfo.bundle) {
                ts.Debug.assert(mapTextOrStripInternal === undefined || typeof mapTextOrStripInternal === "boolean");
                stripInternal = mapTextOrStripInternal;
                bundleFileInfo = mapPathOrType === "js" ? textOrInputFiles.buildInfo.bundle.js : textOrInputFiles.buildInfo.bundle.dts;
                oldFileOfCurrentEmit = textOrInputFiles.oldFileOfCurrentEmit;
            }
        }
        else {
            fileName = "";
            text = textOrInputFiles;
            length = textOrInputFiles.length;
            sourceMapPath = mapPathOrType;
            sourceMapText = mapTextOrStripInternal;
        }
        var node = oldFileOfCurrentEmit ?
            parseOldFileOfCurrentEmit(ts.Debug.assertDefined(bundleFileInfo)) :
            parseUnparsedSourceFile(bundleFileInfo, stripInternal, length);
        node.fileName = fileName;
        node.sourceMapPath = sourceMapPath;
        node.oldFileOfCurrentEmit = oldFileOfCurrentEmit;
        if (getText && getSourceMapText) {
            Object.defineProperty(node, "text", { get: getText });
            Object.defineProperty(node, "sourceMapText", { get: getSourceMapText });
        }
        else {
            ts.Debug.assert(!oldFileOfCurrentEmit);
            node.text = text !== null && text !== void 0 ? text : "";
            node.sourceMapText = sourceMapText;
        }
        return node;
    }
    ts.createUnparsedSourceFile = createUnparsedSourceFile;
    function parseUnparsedSourceFile(bundleFileInfo, stripInternal, length) {
        var prologues;
        var helpers;
        var referencedFiles;
        var typeReferenceDirectives;
        var libReferenceDirectives;
        var prependChildren;
        var texts;
        var hasNoDefaultLib;
        for (var _i = 0, _a = bundleFileInfo ? bundleFileInfo.sections : ts.emptyArray; _i < _a.length; _i++) {
            var section = _a[_i];
            switch (section.kind) {
                case "prologue" /* Prologue */:
                    prologues = ts.append(prologues, ts.setTextRange(ts.factory.createUnparsedPrologue(section.data), section));
                    break;
                case "emitHelpers" /* EmitHelpers */:
                    helpers = ts.append(helpers, ts.getAllUnscopedEmitHelpers().get(section.data));
                    break;
                case "no-default-lib" /* NoDefaultLib */:
                    hasNoDefaultLib = true;
                    break;
                case "reference" /* Reference */:
                    referencedFiles = ts.append(referencedFiles, { pos: -1, end: -1, fileName: section.data });
                    break;
                case "type" /* Type */:
                    typeReferenceDirectives = ts.append(typeReferenceDirectives, section.data);
                    break;
                case "lib" /* Lib */:
                    libReferenceDirectives = ts.append(libReferenceDirectives, { pos: -1, end: -1, fileName: section.data });
                    break;
                case "prepend" /* Prepend */:
                    var prependTexts = void 0;
                    for (var _b = 0, _c = section.texts; _b < _c.length; _b++) {
                        var text = _c[_b];
                        if (!stripInternal || text.kind !== "internal" /* Internal */) {
                            prependTexts = ts.append(prependTexts, ts.setTextRange(ts.factory.createUnparsedTextLike(text.data, text.kind === "internal" /* Internal */), text));
                        }
                    }
                    prependChildren = ts.addRange(prependChildren, prependTexts);
                    texts = ts.append(texts, ts.factory.createUnparsedPrepend(section.data, prependTexts !== null && prependTexts !== void 0 ? prependTexts : ts.emptyArray));
                    break;
                case "internal" /* Internal */:
                    if (stripInternal) {
                        if (!texts)
                            texts = [];
                        break;
                    }
                // falls through
                case "text" /* Text */:
                    texts = ts.append(texts, ts.setTextRange(ts.factory.createUnparsedTextLike(section.data, section.kind === "internal" /* Internal */), section));
                    break;
                default:
                    ts.Debug.assertNever(section);
            }
        }
        if (!texts) {
            var textNode = ts.factory.createUnparsedTextLike(/*data*/ undefined, /*internal*/ false);
            ts.setTextRangePosWidth(textNode, 0, typeof length === "function" ? length() : length);
            texts = [textNode];
        }
        var node = ts.parseNodeFactory.createUnparsedSource(prologues !== null && prologues !== void 0 ? prologues : ts.emptyArray, /*syntheticReferences*/ undefined, texts);
        ts.setEachParent(prologues, node);
        ts.setEachParent(texts, node);
        ts.setEachParent(prependChildren, node);
        node.hasNoDefaultLib = hasNoDefaultLib;
        node.helpers = helpers;
        node.referencedFiles = referencedFiles || ts.emptyArray;
        node.typeReferenceDirectives = typeReferenceDirectives;
        node.libReferenceDirectives = libReferenceDirectives || ts.emptyArray;
        return node;
    }
    function parseOldFileOfCurrentEmit(bundleFileInfo) {
        var texts;
        var syntheticReferences;
        for (var _i = 0, _a = bundleFileInfo.sections; _i < _a.length; _i++) {
            var section = _a[_i];
            switch (section.kind) {
                case "internal" /* Internal */:
                case "text" /* Text */:
                    texts = ts.append(texts, ts.setTextRange(ts.factory.createUnparsedTextLike(section.data, section.kind === "internal" /* Internal */), section));
                    break;
                case "no-default-lib" /* NoDefaultLib */:
                case "reference" /* Reference */:
                case "type" /* Type */:
                case "lib" /* Lib */:
                    syntheticReferences = ts.append(syntheticReferences, ts.setTextRange(ts.factory.createUnparsedSyntheticReference(section), section));
                    break;
                // Ignore
                case "prologue" /* Prologue */:
                case "emitHelpers" /* EmitHelpers */:
                case "prepend" /* Prepend */:
                    break;
                default:
                    ts.Debug.assertNever(section);
            }
        }
        var node = ts.factory.createUnparsedSource(ts.emptyArray, syntheticReferences, texts !== null && texts !== void 0 ? texts : ts.emptyArray);
        ts.setEachParent(syntheticReferences, node);
        ts.setEachParent(texts, node);
        node.helpers = ts.map(bundleFileInfo.sources && bundleFileInfo.sources.helpers, function (name) { return ts.getAllUnscopedEmitHelpers().get(name); });
        return node;
    }
    function createInputFiles(javascriptTextOrReadFileText, declarationTextOrJavascriptPath, javascriptMapPath, javascriptMapTextOrDeclarationPath, declarationMapPath, declarationMapTextOrBuildInfoPath, javascriptPath, declarationPath, buildInfoPath, buildInfo, oldFileOfCurrentEmit) {
        var node = ts.parseNodeFactory.createInputFiles();
        if (!ts.isString(javascriptTextOrReadFileText)) {
            var cache_1 = new ts.Map();
            var textGetter_1 = function (path) {
                if (path === undefined)
                    return undefined;
                var value = cache_1.get(path);
                if (value === undefined) {
                    value = javascriptTextOrReadFileText(path);
                    cache_1.set(path, value !== undefined ? value : false);
                }
                return value !== false ? value : undefined;
            };
            var definedTextGetter_1 = function (path) {
                var result = textGetter_1(path);
                return result !== undefined ? result : "/* Input file " + path + " was missing */\r\n";
            };
            var buildInfo_1;
            var getAndCacheBuildInfo_1 = function (getText) {
                if (buildInfo_1 === undefined) {
                    var result = getText();
                    buildInfo_1 = result !== undefined ? ts.getBuildInfo(result) : false;
                }
                return buildInfo_1 || undefined;
            };
            node.javascriptPath = declarationTextOrJavascriptPath;
            node.javascriptMapPath = javascriptMapPath;
            node.declarationPath = ts.Debug.assertDefined(javascriptMapTextOrDeclarationPath);
            node.declarationMapPath = declarationMapPath;
            node.buildInfoPath = declarationMapTextOrBuildInfoPath;
            Object.defineProperties(node, {
                javascriptText: { get: function () { return definedTextGetter_1(declarationTextOrJavascriptPath); } },
                javascriptMapText: { get: function () { return textGetter_1(javascriptMapPath); } },
                declarationText: { get: function () { return definedTextGetter_1(ts.Debug.assertDefined(javascriptMapTextOrDeclarationPath)); } },
                declarationMapText: { get: function () { return textGetter_1(declarationMapPath); } },
                buildInfo: { get: function () { return getAndCacheBuildInfo_1(function () { return textGetter_1(declarationMapTextOrBuildInfoPath); }); } }
            });
        }
        else {
            node.javascriptText = javascriptTextOrReadFileText;
            node.javascriptMapPath = javascriptMapPath;
            node.javascriptMapText = javascriptMapTextOrDeclarationPath;
            node.declarationText = declarationTextOrJavascriptPath;
            node.declarationMapPath = declarationMapPath;
            node.declarationMapText = declarationMapTextOrBuildInfoPath;
            node.javascriptPath = javascriptPath;
            node.declarationPath = declarationPath;
            node.buildInfoPath = buildInfoPath;
            node.buildInfo = buildInfo;
            node.oldFileOfCurrentEmit = oldFileOfCurrentEmit;
        }
        return node;
    }
    ts.createInputFiles = createInputFiles;
    // tslint:disable-next-line variable-name
    var SourceMapSource;
    /**
     * Create an external source map source file reference
     */
    function createSourceMapSource(fileName, text, skipTrivia) {
        return new (SourceMapSource || (SourceMapSource = ts.objectAllocator.getSourceMapSourceConstructor()))(fileName, text, skipTrivia);
    }
    ts.createSourceMapSource = createSourceMapSource;
    // Utilities
    function setOriginalNode(node, original) {
        node.original = original;
        if (original) {
            var emitNode = original.emitNode;
            if (emitNode)
                node.emitNode = mergeEmitNode(emitNode, node.emitNode);
        }
        return node;
    }
    ts.setOriginalNode = setOriginalNode;
    function mergeEmitNode(sourceEmitNode, destEmitNode) {
        var flags = sourceEmitNode.flags, leadingComments = sourceEmitNode.leadingComments, trailingComments = sourceEmitNode.trailingComments, commentRange = sourceEmitNode.commentRange, sourceMapRange = sourceEmitNode.sourceMapRange, tokenSourceMapRanges = sourceEmitNode.tokenSourceMapRanges, constantValue = sourceEmitNode.constantValue, helpers = sourceEmitNode.helpers, startsOnNewLine = sourceEmitNode.startsOnNewLine;
        if (!destEmitNode)
            destEmitNode = {};
        // We are using `.slice()` here in case `destEmitNode.leadingComments` is pushed to later.
        if (leadingComments)
            destEmitNode.leadingComments = ts.addRange(leadingComments.slice(), destEmitNode.leadingComments);
        if (trailingComments)
            destEmitNode.trailingComments = ts.addRange(trailingComments.slice(), destEmitNode.trailingComments);
        if (flags)
            destEmitNode.flags = flags & ~268435456 /* Immutable */;
        if (commentRange)
            destEmitNode.commentRange = commentRange;
        if (sourceMapRange)
            destEmitNode.sourceMapRange = sourceMapRange;
        if (tokenSourceMapRanges)
            destEmitNode.tokenSourceMapRanges = mergeTokenSourceMapRanges(tokenSourceMapRanges, destEmitNode.tokenSourceMapRanges);
        if (constantValue !== undefined)
            destEmitNode.constantValue = constantValue;
        if (helpers) {
            for (var _i = 0, helpers_1 = helpers; _i < helpers_1.length; _i++) {
                var helper = helpers_1[_i];
                destEmitNode.helpers = ts.appendIfUnique(destEmitNode.helpers, helper);
            }
        }
        if (startsOnNewLine !== undefined)
            destEmitNode.startsOnNewLine = startsOnNewLine;
        return destEmitNode;
    }
    function mergeTokenSourceMapRanges(sourceRanges, destRanges) {
        if (!destRanges)
            destRanges = [];
        for (var key in sourceRanges) {
            destRanges[key] = sourceRanges[key];
        }
        return destRanges;
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    /**
     * Associates a node with the current transformation, initializing
     * various transient transformation properties.
     * @internal
     */
    function getOrCreateEmitNode(node) {
        var _a;
        if (!node.emitNode) {
            if (ts.isParseTreeNode(node)) {
                // To avoid holding onto transformation artifacts, we keep track of any
                // parse tree node we are annotating. This allows us to clean them up after
                // all transformations have completed.
                if (node.kind === 300 /* SourceFile */) {
                    return node.emitNode = { annotatedNodes: [node] };
                }
                var sourceFile = (_a = ts.getSourceFileOfNode(ts.getParseTreeNode(ts.getSourceFileOfNode(node)))) !== null && _a !== void 0 ? _a : ts.Debug.fail("Could not determine parsed source file.");
                getOrCreateEmitNode(sourceFile).annotatedNodes.push(node);
            }
            node.emitNode = {};
        }
        else {
            ts.Debug.assert(!(node.emitNode.flags & 268435456 /* Immutable */), "Invalid attempt to mutate an immutable node.");
        }
        return node.emitNode;
    }
    ts.getOrCreateEmitNode = getOrCreateEmitNode;
    /**
     * Clears any `EmitNode` entries from parse-tree nodes.
     * @param sourceFile A source file.
     */
    function disposeEmitNodes(sourceFile) {
        var _a, _b;
        // During transformation we may need to annotate a parse tree node with transient
        // transformation properties. As parse tree nodes live longer than transformation
        // nodes, we need to make sure we reclaim any memory allocated for custom ranges
        // from these nodes to ensure we do not hold onto entire subtrees just for position
        // information. We also need to reset these nodes to a pre-transformation state
        // for incremental parsing scenarios so that we do not impact later emit.
        var annotatedNodes = (_b = (_a = ts.getSourceFileOfNode(ts.getParseTreeNode(sourceFile))) === null || _a === void 0 ? void 0 : _a.emitNode) === null || _b === void 0 ? void 0 : _b.annotatedNodes;
        if (annotatedNodes) {
            for (var _i = 0, annotatedNodes_1 = annotatedNodes; _i < annotatedNodes_1.length; _i++) {
                var node = annotatedNodes_1[_i];
                node.emitNode = undefined;
            }
        }
    }
    ts.disposeEmitNodes = disposeEmitNodes;
    /**
     * Sets `EmitFlags.NoComments` on a node and removes any leading and trailing synthetic comments.
     * @internal
     */
    function removeAllComments(node) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.flags |= 1536 /* NoComments */;
        emitNode.leadingComments = undefined;
        emitNode.trailingComments = undefined;
        return node;
    }
    ts.removeAllComments = removeAllComments;
    /**
     * Sets flags that control emit behavior of a node.
     */
    function setEmitFlags(node, emitFlags) {
        getOrCreateEmitNode(node).flags = emitFlags;
        return node;
    }
    ts.setEmitFlags = setEmitFlags;
    /**
     * Sets flags that control emit behavior of a node.
     */
    /* @internal */
    function addEmitFlags(node, emitFlags) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.flags = emitNode.flags | emitFlags;
        return node;
    }
    ts.addEmitFlags = addEmitFlags;
    /**
     * Gets a custom text range to use when emitting source maps.
     */
    function getSourceMapRange(node) {
        var _a, _b;
        return (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.sourceMapRange) !== null && _b !== void 0 ? _b : node;
    }
    ts.getSourceMapRange = getSourceMapRange;
    /**
     * Sets a custom text range to use when emitting source maps.
     */
    function setSourceMapRange(node, range) {
        getOrCreateEmitNode(node).sourceMapRange = range;
        return node;
    }
    ts.setSourceMapRange = setSourceMapRange;
    /**
     * Gets the TextRange to use for source maps for a token of a node.
     */
    function getTokenSourceMapRange(node, token) {
        var _a, _b;
        return (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.tokenSourceMapRanges) === null || _b === void 0 ? void 0 : _b[token];
    }
    ts.getTokenSourceMapRange = getTokenSourceMapRange;
    /**
     * Sets the TextRange to use for source maps for a token of a node.
     */
    function setTokenSourceMapRange(node, token, range) {
        var _a;
        var emitNode = getOrCreateEmitNode(node);
        var tokenSourceMapRanges = (_a = emitNode.tokenSourceMapRanges) !== null && _a !== void 0 ? _a : (emitNode.tokenSourceMapRanges = []);
        tokenSourceMapRanges[token] = range;
        return node;
    }
    ts.setTokenSourceMapRange = setTokenSourceMapRange;
    /**
     * Gets a custom text range to use when emitting comments.
     */
    /*@internal*/
    function getStartsOnNewLine(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.startsOnNewLine;
    }
    ts.getStartsOnNewLine = getStartsOnNewLine;
    /**
     * Sets a custom text range to use when emitting comments.
     */
    /*@internal*/
    function setStartsOnNewLine(node, newLine) {
        getOrCreateEmitNode(node).startsOnNewLine = newLine;
        return node;
    }
    ts.setStartsOnNewLine = setStartsOnNewLine;
    /**
     * Gets a custom text range to use when emitting comments.
     */
    function getCommentRange(node) {
        var _a, _b;
        return (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.commentRange) !== null && _b !== void 0 ? _b : node;
    }
    ts.getCommentRange = getCommentRange;
    /**
     * Sets a custom text range to use when emitting comments.
     */
    function setCommentRange(node, range) {
        getOrCreateEmitNode(node).commentRange = range;
        return node;
    }
    ts.setCommentRange = setCommentRange;
    function getSyntheticLeadingComments(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.leadingComments;
    }
    ts.getSyntheticLeadingComments = getSyntheticLeadingComments;
    function setSyntheticLeadingComments(node, comments) {
        getOrCreateEmitNode(node).leadingComments = comments;
        return node;
    }
    ts.setSyntheticLeadingComments = setSyntheticLeadingComments;
    function addSyntheticLeadingComment(node, kind, text, hasTrailingNewLine) {
        return setSyntheticLeadingComments(node, ts.append(getSyntheticLeadingComments(node), { kind: kind, pos: -1, end: -1, hasTrailingNewLine: hasTrailingNewLine, text: text }));
    }
    ts.addSyntheticLeadingComment = addSyntheticLeadingComment;
    function getSyntheticTrailingComments(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.trailingComments;
    }
    ts.getSyntheticTrailingComments = getSyntheticTrailingComments;
    function setSyntheticTrailingComments(node, comments) {
        getOrCreateEmitNode(node).trailingComments = comments;
        return node;
    }
    ts.setSyntheticTrailingComments = setSyntheticTrailingComments;
    function addSyntheticTrailingComment(node, kind, text, hasTrailingNewLine) {
        return setSyntheticTrailingComments(node, ts.append(getSyntheticTrailingComments(node), { kind: kind, pos: -1, end: -1, hasTrailingNewLine: hasTrailingNewLine, text: text }));
    }
    ts.addSyntheticTrailingComment = addSyntheticTrailingComment;
    function moveSyntheticComments(node, original) {
        setSyntheticLeadingComments(node, getSyntheticLeadingComments(original));
        setSyntheticTrailingComments(node, getSyntheticTrailingComments(original));
        var emit = getOrCreateEmitNode(original);
        emit.leadingComments = undefined;
        emit.trailingComments = undefined;
        return node;
    }
    ts.moveSyntheticComments = moveSyntheticComments;
    /**
     * Gets the constant value to emit for an expression representing an enum.
     */
    function getConstantValue(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.constantValue;
    }
    ts.getConstantValue = getConstantValue;
    /**
     * Sets the constant value to emit for an expression.
     */
    function setConstantValue(node, value) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.constantValue = value;
        return node;
    }
    ts.setConstantValue = setConstantValue;
    /**
     * Adds an EmitHelper to a node.
     */
    function addEmitHelper(node, helper) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.helpers = ts.append(emitNode.helpers, helper);
        return node;
    }
    ts.addEmitHelper = addEmitHelper;
    /**
     * Add EmitHelpers to a node.
     */
    function addEmitHelpers(node, helpers) {
        if (ts.some(helpers)) {
            var emitNode = getOrCreateEmitNode(node);
            for (var _i = 0, helpers_2 = helpers; _i < helpers_2.length; _i++) {
                var helper = helpers_2[_i];
                emitNode.helpers = ts.appendIfUnique(emitNode.helpers, helper);
            }
        }
        return node;
    }
    ts.addEmitHelpers = addEmitHelpers;
    /**
     * Removes an EmitHelper from a node.
     */
    function removeEmitHelper(node, helper) {
        var _a;
        var helpers = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.helpers;
        if (helpers) {
            return ts.orderedRemoveItem(helpers, helper);
        }
        return false;
    }
    ts.removeEmitHelper = removeEmitHelper;
    /**
     * Gets the EmitHelpers of a node.
     */
    function getEmitHelpers(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.helpers;
    }
    ts.getEmitHelpers = getEmitHelpers;
    /**
     * Moves matching emit helpers from a source node to a target node.
     */
    function moveEmitHelpers(source, target, predicate) {
        var sourceEmitNode = source.emitNode;
        var sourceEmitHelpers = sourceEmitNode && sourceEmitNode.helpers;
        if (!ts.some(sourceEmitHelpers))
            return;
        var targetEmitNode = getOrCreateEmitNode(target);
        var helpersRemoved = 0;
        for (var i = 0; i < sourceEmitHelpers.length; i++) {
            var helper = sourceEmitHelpers[i];
            if (predicate(helper)) {
                helpersRemoved++;
                targetEmitNode.helpers = ts.appendIfUnique(targetEmitNode.helpers, helper);
            }
            else if (helpersRemoved > 0) {
                sourceEmitHelpers[i - helpersRemoved] = helper;
            }
        }
        if (helpersRemoved > 0) {
            sourceEmitHelpers.length -= helpersRemoved;
        }
    }
    ts.moveEmitHelpers = moveEmitHelpers;
    /* @internal */
    function ignoreSourceNewlines(node) {
        getOrCreateEmitNode(node).flags |= 134217728 /* IgnoreSourceNewlines */;
        return node;
    }
    ts.ignoreSourceNewlines = ignoreSourceNewlines;
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function createEmitHelperFactory(context) {
        var factory = context.factory;
        var immutableTrue = ts.memoize(function () { return ts.setEmitFlags(factory.createTrue(), 268435456 /* Immutable */); });
        var immutableFalse = ts.memoize(function () { return ts.setEmitFlags(factory.createFalse(), 268435456 /* Immutable */); });
        return {
            getUnscopedHelperName: getUnscopedHelperName,
            // TypeScript Helpers
            createDecorateHelper: createDecorateHelper,
            createMetadataHelper: createMetadataHelper,
            createParamHelper: createParamHelper,
            // ES2018 Helpers
            createAssignHelper: createAssignHelper,
            createAwaitHelper: createAwaitHelper,
            createAsyncGeneratorHelper: createAsyncGeneratorHelper,
            createAsyncDelegatorHelper: createAsyncDelegatorHelper,
            createAsyncValuesHelper: createAsyncValuesHelper,
            // ES2018 Destructuring Helpers
            createRestHelper: createRestHelper,
            // ES2017 Helpers
            createAwaiterHelper: createAwaiterHelper,
            // ES2015 Helpers
            createExtendsHelper: createExtendsHelper,
            createTemplateObjectHelper: createTemplateObjectHelper,
            createSpreadArrayHelper: createSpreadArrayHelper,
            // ES2015 Destructuring Helpers
            createValuesHelper: createValuesHelper,
            createReadHelper: createReadHelper,
            // ES2015 Generator Helpers
            createGeneratorHelper: createGeneratorHelper,
            // ES Module Helpers
            createCreateBindingHelper: createCreateBindingHelper,
            createImportStarHelper: createImportStarHelper,
            createImportStarCallbackHelper: createImportStarCallbackHelper,
            createImportDefaultHelper: createImportDefaultHelper,
            createExportStarHelper: createExportStarHelper,
            // Class Fields Helpers
            createClassPrivateFieldGetHelper: createClassPrivateFieldGetHelper,
            createClassPrivateFieldSetHelper: createClassPrivateFieldSetHelper,
        };
        /**
         * Gets an identifier for the name of an *unscoped* emit helper.
         */
        function getUnscopedHelperName(name) {
            return ts.setEmitFlags(factory.createIdentifier(name), 4096 /* HelperName */ | 2 /* AdviseOnEmitNode */);
        }
        // TypeScript Helpers
        function createDecorateHelper(decoratorExpressions, target, memberName, descriptor) {
            context.requestEmitHelper(ts.decorateHelper);
            var argumentsArray = [];
            argumentsArray.push(factory.createArrayLiteralExpression(decoratorExpressions, /*multiLine*/ true));
            argumentsArray.push(target);
            if (memberName) {
                argumentsArray.push(memberName);
                if (descriptor) {
                    argumentsArray.push(descriptor);
                }
            }
            return factory.createCallExpression(getUnscopedHelperName("__decorate"), 
            /*typeArguments*/ undefined, argumentsArray);
        }
        function createMetadataHelper(metadataKey, metadataValue) {
            context.requestEmitHelper(ts.metadataHelper);
            return factory.createCallExpression(getUnscopedHelperName("__metadata"), 
            /*typeArguments*/ undefined, [
                factory.createStringLiteral(metadataKey),
                metadataValue
            ]);
        }
        function createParamHelper(expression, parameterOffset, location) {
            context.requestEmitHelper(ts.paramHelper);
            return ts.setTextRange(factory.createCallExpression(getUnscopedHelperName("__param"), 
            /*typeArguments*/ undefined, [
                factory.createNumericLiteral(parameterOffset + ""),
                expression
            ]), location);
        }
        // ES2018 Helpers
        function createAssignHelper(attributesSegments) {
            if (context.getCompilerOptions().target >= 2 /* ES2015 */) {
                return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "assign"), 
                /*typeArguments*/ undefined, attributesSegments);
            }
            context.requestEmitHelper(ts.assignHelper);
            return factory.createCallExpression(getUnscopedHelperName("__assign"), 
            /*typeArguments*/ undefined, attributesSegments);
        }
        function createAwaitHelper(expression) {
            context.requestEmitHelper(ts.awaitHelper);
            return factory.createCallExpression(getUnscopedHelperName("__await"), /*typeArguments*/ undefined, [expression]);
        }
        function createAsyncGeneratorHelper(generatorFunc, hasLexicalThis) {
            context.requestEmitHelper(ts.awaitHelper);
            context.requestEmitHelper(ts.asyncGeneratorHelper);
            // Mark this node as originally an async function
            (generatorFunc.emitNode || (generatorFunc.emitNode = {})).flags |= 262144 /* AsyncFunctionBody */ | 524288 /* ReuseTempVariableScope */;
            return factory.createCallExpression(getUnscopedHelperName("__asyncGenerator"), 
            /*typeArguments*/ undefined, [
                hasLexicalThis ? factory.createThis() : factory.createVoidZero(),
                factory.createIdentifier("arguments"),
                generatorFunc
            ]);
        }
        function createAsyncDelegatorHelper(expression) {
            context.requestEmitHelper(ts.awaitHelper);
            context.requestEmitHelper(ts.asyncDelegator);
            return factory.createCallExpression(getUnscopedHelperName("__asyncDelegator"), 
            /*typeArguments*/ undefined, [expression]);
        }
        function createAsyncValuesHelper(expression) {
            context.requestEmitHelper(ts.asyncValues);
            return factory.createCallExpression(getUnscopedHelperName("__asyncValues"), 
            /*typeArguments*/ undefined, [expression]);
        }
        // ES2018 Destructuring Helpers
        /** Given value: o, propName: p, pattern: { a, b, ...p } from the original statement
         * `{ a, b, ...p } = o`, create `p = __rest(o, ["a", "b"]);`
         */
        function createRestHelper(value, elements, computedTempVariables, location) {
            context.requestEmitHelper(ts.restHelper);
            var propertyNames = [];
            var computedTempVariableOffset = 0;
            for (var i = 0; i < elements.length - 1; i++) {
                var propertyName = ts.getPropertyNameOfBindingOrAssignmentElement(elements[i]);
                if (propertyName) {
                    if (ts.isComputedPropertyName(propertyName)) {
                        ts.Debug.assertIsDefined(computedTempVariables, "Encountered computed property name but 'computedTempVariables' argument was not provided.");
                        var temp = computedTempVariables[computedTempVariableOffset];
                        computedTempVariableOffset++;
                        // typeof _tmp === "symbol" ? _tmp : _tmp + ""
                        propertyNames.push(factory.createConditionalExpression(factory.createTypeCheck(temp, "symbol"), 
                        /*questionToken*/ undefined, temp, 
                        /*colonToken*/ undefined, factory.createAdd(temp, factory.createStringLiteral(""))));
                    }
                    else {
                        propertyNames.push(factory.createStringLiteralFromNode(propertyName));
                    }
                }
            }
            return factory.createCallExpression(getUnscopedHelperName("__rest"), 
            /*typeArguments*/ undefined, [
                value,
                ts.setTextRange(factory.createArrayLiteralExpression(propertyNames), location)
            ]);
        }
        // ES2017 Helpers
        function createAwaiterHelper(hasLexicalThis, hasLexicalArguments, promiseConstructor, body) {
            context.requestEmitHelper(ts.awaiterHelper);
            var generatorFunc = factory.createFunctionExpression(
            /*modifiers*/ undefined, factory.createToken(41 /* AsteriskToken */), 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, 
            /*parameters*/ [], 
            /*type*/ undefined, body);
            // Mark this node as originally an async function
            (generatorFunc.emitNode || (generatorFunc.emitNode = {})).flags |= 262144 /* AsyncFunctionBody */ | 524288 /* ReuseTempVariableScope */;
            return factory.createCallExpression(getUnscopedHelperName("__awaiter"), 
            /*typeArguments*/ undefined, [
                hasLexicalThis ? factory.createThis() : factory.createVoidZero(),
                hasLexicalArguments ? factory.createIdentifier("arguments") : factory.createVoidZero(),
                promiseConstructor ? ts.createExpressionFromEntityName(factory, promiseConstructor) : factory.createVoidZero(),
                generatorFunc
            ]);
        }
        // ES2015 Helpers
        function createExtendsHelper(name) {
            context.requestEmitHelper(ts.extendsHelper);
            return factory.createCallExpression(getUnscopedHelperName("__extends"), 
            /*typeArguments*/ undefined, [name, factory.createUniqueName("_super", 16 /* Optimistic */ | 32 /* FileLevel */)]);
        }
        function createTemplateObjectHelper(cooked, raw) {
            context.requestEmitHelper(ts.templateObjectHelper);
            return factory.createCallExpression(getUnscopedHelperName("__makeTemplateObject"), 
            /*typeArguments*/ undefined, [cooked, raw]);
        }
        function createSpreadArrayHelper(to, from, packFrom) {
            context.requestEmitHelper(ts.spreadArrayHelper);
            return factory.createCallExpression(getUnscopedHelperName("__spreadArray"), 
            /*typeArguments*/ undefined, [to, from, packFrom ? immutableTrue() : immutableFalse()]);
        }
        // ES2015 Destructuring Helpers
        function createValuesHelper(expression) {
            context.requestEmitHelper(ts.valuesHelper);
            return factory.createCallExpression(getUnscopedHelperName("__values"), 
            /*typeArguments*/ undefined, [expression]);
        }
        function createReadHelper(iteratorRecord, count) {
            context.requestEmitHelper(ts.readHelper);
            return factory.createCallExpression(getUnscopedHelperName("__read"), 
            /*typeArguments*/ undefined, count !== undefined
                ? [iteratorRecord, factory.createNumericLiteral(count + "")]
                : [iteratorRecord]);
        }
        // ES2015 Generator Helpers
        function createGeneratorHelper(body) {
            context.requestEmitHelper(ts.generatorHelper);
            return factory.createCallExpression(getUnscopedHelperName("__generator"), 
            /*typeArguments*/ undefined, [factory.createThis(), body]);
        }
        // ES Module Helpers
        function createCreateBindingHelper(module, inputName, outputName) {
            context.requestEmitHelper(ts.createBindingHelper);
            return factory.createCallExpression(getUnscopedHelperName("__createBinding"), 
            /*typeArguments*/ undefined, __spreadArray([factory.createIdentifier("exports"), module, inputName], (outputName ? [outputName] : []), true));
        }
        function createImportStarHelper(expression) {
            context.requestEmitHelper(ts.importStarHelper);
            return factory.createCallExpression(getUnscopedHelperName("__importStar"), 
            /*typeArguments*/ undefined, [expression]);
        }
        function createImportStarCallbackHelper() {
            context.requestEmitHelper(ts.importStarHelper);
            return getUnscopedHelperName("__importStar");
        }
        function createImportDefaultHelper(expression) {
            context.requestEmitHelper(ts.importDefaultHelper);
            return factory.createCallExpression(getUnscopedHelperName("__importDefault"), 
            /*typeArguments*/ undefined, [expression]);
        }
        function createExportStarHelper(moduleExpression, exportsExpression) {
            if (exportsExpression === void 0) { exportsExpression = factory.createIdentifier("exports"); }
            context.requestEmitHelper(ts.exportStarHelper);
            context.requestEmitHelper(ts.createBindingHelper);
            return factory.createCallExpression(getUnscopedHelperName("__exportStar"), 
            /*typeArguments*/ undefined, [moduleExpression, exportsExpression]);
        }
        // Class Fields Helpers
        function createClassPrivateFieldGetHelper(receiver, state, kind, f) {
            context.requestEmitHelper(ts.classPrivateFieldGetHelper);
            var args;
            if (!f) {
                args = [receiver, state, factory.createStringLiteral(kind)];
            }
            else {
                args = [receiver, state, factory.createStringLiteral(kind), f];
            }
            return factory.createCallExpression(getUnscopedHelperName("__classPrivateFieldGet"), /*typeArguments*/ undefined, args);
        }
        function createClassPrivateFieldSetHelper(receiver, state, value, kind, f) {
            context.requestEmitHelper(ts.classPrivateFieldSetHelper);
            var args;
            if (!f) {
                args = [receiver, state, value, factory.createStringLiteral(kind)];
            }
            else {
                args = [receiver, state, value, factory.createStringLiteral(kind), f];
            }
            return factory.createCallExpression(getUnscopedHelperName("__classPrivateFieldSet"), /*typeArguments*/ undefined, args);
        }
    }
    ts.createEmitHelperFactory = createEmitHelperFactory;
    /* @internal */
    function compareEmitHelpers(x, y) {
        if (x === y)
            return 0 /* EqualTo */;
        if (x.priority === y.priority)
            return 0 /* EqualTo */;
        if (x.priority === undefined)
            return 1 /* GreaterThan */;
        if (y.priority === undefined)
            return -1 /* LessThan */;
        return ts.compareValues(x.priority, y.priority);
    }
    ts.compareEmitHelpers = compareEmitHelpers;
    /**
     * @param input Template string input strings
     * @param args Names which need to be made file-level unique
     */
    function helperString(input) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return function (uniqueName) {
            var result = "";
            for (var i = 0; i < args.length; i++) {
                result += input[i];
                result += uniqueName(args[i]);
            }
            result += input[input.length - 1];
            return result;
        };
    }
    ts.helperString = helperString;
    // TypeScript Helpers
    ts.decorateHelper = {
        name: "typescript:decorate",
        importName: "__decorate",
        scoped: false,
        priority: 2,
        text: "\n            var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n                var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n                if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n                else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n                return c > 3 && r && Object.defineProperty(target, key, r), r;\n            };"
    };
    ts.metadataHelper = {
        name: "typescript:metadata",
        importName: "__metadata",
        scoped: false,
        priority: 3,
        text: "\n            var __metadata = (this && this.__metadata) || function (k, v) {\n                if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n            };"
    };
    ts.paramHelper = {
        name: "typescript:param",
        importName: "__param",
        scoped: false,
        priority: 4,
        text: "\n            var __param = (this && this.__param) || function (paramIndex, decorator) {\n                return function (target, key) { decorator(target, key, paramIndex); }\n            };"
    };
    // ES2018 Helpers
    ts.assignHelper = {
        name: "typescript:assign",
        importName: "__assign",
        scoped: false,
        priority: 1,
        text: "\n            var __assign = (this && this.__assign) || function () {\n                __assign = Object.assign || function(t) {\n                    for (var s, i = 1, n = arguments.length; i < n; i++) {\n                        s = arguments[i];\n                        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                            t[p] = s[p];\n                    }\n                    return t;\n                };\n                return __assign.apply(this, arguments);\n            };"
    };
    ts.awaitHelper = {
        name: "typescript:await",
        importName: "__await",
        scoped: false,
        text: "\n            var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }"
    };
    ts.asyncGeneratorHelper = {
        name: "typescript:asyncGenerator",
        importName: "__asyncGenerator",
        scoped: false,
        dependencies: [ts.awaitHelper],
        text: "\n            var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n                if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n                var g = generator.apply(thisArg, _arguments || []), i, q = [];\n                return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n                function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n                function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n                function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n                function fulfill(value) { resume(\"next\", value); }\n                function reject(value) { resume(\"throw\", value); }\n                function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n            };"
    };
    ts.asyncDelegator = {
        name: "typescript:asyncDelegator",
        importName: "__asyncDelegator",
        scoped: false,
        dependencies: [ts.awaitHelper],
        text: "\n            var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {\n                var i, p;\n                return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n                function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\n            };"
    };
    ts.asyncValues = {
        name: "typescript:asyncValues",
        importName: "__asyncValues",
        scoped: false,
        text: "\n            var __asyncValues = (this && this.__asyncValues) || function (o) {\n                if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n                var m = o[Symbol.asyncIterator], i;\n                return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n                function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n                function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n            };"
    };
    // ES2018 Destructuring Helpers
    ts.restHelper = {
        name: "typescript:rest",
        importName: "__rest",
        scoped: false,
        text: "\n            var __rest = (this && this.__rest) || function (s, e) {\n                var t = {};\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n                    t[p] = s[p];\n                if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n                    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                            t[p[i]] = s[p[i]];\n                    }\n                return t;\n            };"
    };
    // ES2017 Helpers
    ts.awaiterHelper = {
        name: "typescript:awaiter",
        importName: "__awaiter",
        scoped: false,
        priority: 5,
        text: "\n            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n                return new (P || (P = Promise))(function (resolve, reject) {\n                    function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n                    function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n                    step((generator = generator.apply(thisArg, _arguments || [])).next());\n                });\n            };"
    };
    // ES2015 Helpers
    ts.extendsHelper = {
        name: "typescript:extends",
        importName: "__extends",
        scoped: false,
        priority: 0,
        text: "\n            var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d, b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n                    return extendStatics(d, b);\n                };\n\n                return function (d, b) {\n                    if (typeof b !== \"function\" && b !== null)\n                        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n                    extendStatics(d, b);\n                    function __() { this.constructor = d; }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            })();"
    };
    ts.templateObjectHelper = {
        name: "typescript:makeTemplateObject",
        importName: "__makeTemplateObject",
        scoped: false,
        priority: 0,
        text: "\n            var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {\n                if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n                return cooked;\n            };"
    };
    ts.readHelper = {
        name: "typescript:read",
        importName: "__read",
        scoped: false,
        text: "\n            var __read = (this && this.__read) || function (o, n) {\n                var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n                if (!m) return o;\n                var i = m.call(o), r, ar = [], e;\n                try {\n                    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n                }\n                catch (error) { e = { error: error }; }\n                finally {\n                    try {\n                        if (r && !r.done && (m = i[\"return\"])) m.call(i);\n                    }\n                    finally { if (e) throw e.error; }\n                }\n                return ar;\n            };"
    };
    ts.spreadArrayHelper = {
        name: "typescript:spreadArray",
        importName: "__spreadArray",
        scoped: false,
        text: "\n            var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n                if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n                    if (ar || !(i in from)) {\n                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                        ar[i] = from[i];\n                    }\n                }\n                return to.concat(ar || Array.prototype.slice.call(from));\n            };"
    };
    // ES2015 Destructuring Helpers
    ts.valuesHelper = {
        name: "typescript:values",
        importName: "__values",
        scoped: false,
        text: "\n            var __values = (this && this.__values) || function(o) {\n                var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n                if (m) return m.call(o);\n                if (o && typeof o.length === \"number\") return {\n                    next: function () {\n                        if (o && i >= o.length) o = void 0;\n                        return { value: o && o[i++], done: !o };\n                    }\n                };\n                throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n            };"
    };
    // ES2015 Generator Helpers
    // The __generator helper is used by down-level transformations to emulate the runtime
    // semantics of an ES2015 generator function. When called, this helper returns an
    // object that implements the Iterator protocol, in that it has `next`, `return`, and
    // `throw` methods that step through the generator when invoked.
    //
    // parameters:
    //  @param thisArg  The value to use as the `this` binding for the transformed generator body.
    //  @param body     A function that acts as the transformed generator body.
    //
    // variables:
    //  _       Persistent state for the generator that is shared between the helper and the
    //          generator body. The state object has the following members:
    //            sent() - A method that returns or throws the current completion value.
    //            label  - The next point at which to resume evaluation of the generator body.
    //            trys   - A stack of protected regions (try/catch/finally blocks).
    //            ops    - A stack of pending instructions when inside of a finally block.
    //  f       A value indicating whether the generator is executing.
    //  y       An iterator to delegate for a yield*.
    //  t       A temporary variable that holds one of the following values (note that these
    //          cases do not overlap):
    //          - The completion value when resuming from a `yield` or `yield*`.
    //          - The error value for a catch block.
    //          - The current protected region (array of try/catch/finally/end labels).
    //          - The verb (`next`, `throw`, or `return` method) to delegate to the expression
    //            of a `yield*`.
    //          - The result of evaluating the verb delegated to the expression of a `yield*`.
    //
    // functions:
    //  verb(n)     Creates a bound callback to the `step` function for opcode `n`.
    //  step(op)    Evaluates opcodes in a generator body until execution is suspended or
    //              completed.
    //
    // The __generator helper understands a limited set of instructions:
    //  0: next(value?)     - Start or resume the generator with the specified value.
    //  1: throw(error)     - Resume the generator with an exception. If the generator is
    //                        suspended inside of one or more protected regions, evaluates
    //                        any intervening finally blocks between the current label and
    //                        the nearest catch block or function boundary. If uncaught, the
    //                        exception is thrown to the caller.
    //  2: return(value?)   - Resume the generator as if with a return. If the generator is
    //                        suspended inside of one or more protected regions, evaluates any
    //                        intervening finally blocks.
    //  3: break(label)     - Jump to the specified label. If the label is outside of the
    //                        current protected region, evaluates any intervening finally
    //                        blocks.
    //  4: yield(value?)    - Yield execution to the caller with an optional value. When
    //                        resumed, the generator will continue at the next label.
    //  5: yield*(value)    - Delegates evaluation to the supplied iterator. When
    //                        delegation completes, the generator will continue at the next
    //                        label.
    //  6: catch(error)     - Handles an exception thrown from within the generator body. If
    //                        the current label is inside of one or more protected regions,
    //                        evaluates any intervening finally blocks between the current
    //                        label and the nearest catch block or function boundary. If
    //                        uncaught, the exception is thrown to the caller.
    //  7: endfinally       - Ends a finally block, resuming the last instruction prior to
    //                        entering a finally block.
    //
    // For examples of how these are used, see the comments in ./transformers/generators.ts
    ts.generatorHelper = {
        name: "typescript:generator",
        importName: "__generator",
        scoped: false,
        priority: 6,
        text: "\n            var __generator = (this && this.__generator) || function (thisArg, body) {\n                var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n                return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n                function verb(n) { return function (v) { return step([n, v]); }; }\n                function step(op) {\n                    if (f) throw new TypeError(\"Generator is already executing.\");\n                    while (_) try {\n                        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n                        if (y = 0, t) op = [op[0] & 2, t.value];\n                        switch (op[0]) {\n                            case 0: case 1: t = op; break;\n                            case 4: _.label++; return { value: op[1], done: false };\n                            case 5: _.label++; y = op[1]; op = [0]; continue;\n                            case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                            default:\n                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                                if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                                if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                                if (t[2]) _.ops.pop();\n                                _.trys.pop(); continue;\n                        }\n                        op = body.call(thisArg, _);\n                    } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n                    if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n                }\n            };"
    };
    // ES Module Helpers
    ts.createBindingHelper = {
        name: "typescript:commonjscreatebinding",
        importName: "__createBinding",
        scoped: false,
        priority: 1,
        text: "\n            var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n                if (k2 === undefined) k2 = k;\n                Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n            }) : (function(o, m, k, k2) {\n                if (k2 === undefined) k2 = k;\n                o[k2] = m[k];\n            }));"
    };
    ts.setModuleDefaultHelper = {
        name: "typescript:commonjscreatevalue",
        importName: "__setModuleDefault",
        scoped: false,
        priority: 1,
        text: "\n            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n                Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n            }) : function(o, v) {\n                o[\"default\"] = v;\n            });"
    };
    // emit helper for `import * as Name from "foo"`
    ts.importStarHelper = {
        name: "typescript:commonjsimportstar",
        importName: "__importStar",
        scoped: false,
        dependencies: [ts.createBindingHelper, ts.setModuleDefaultHelper],
        priority: 2,
        text: "\n            var __importStar = (this && this.__importStar) || function (mod) {\n                if (mod && mod.__esModule) return mod;\n                var result = {};\n                if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n                __setModuleDefault(result, mod);\n                return result;\n            };"
    };
    // emit helper for `import Name from "foo"`
    ts.importDefaultHelper = {
        name: "typescript:commonjsimportdefault",
        importName: "__importDefault",
        scoped: false,
        text: "\n            var __importDefault = (this && this.__importDefault) || function (mod) {\n                return (mod && mod.__esModule) ? mod : { \"default\": mod };\n            };"
    };
    ts.exportStarHelper = {
        name: "typescript:export-star",
        importName: "__exportStar",
        scoped: false,
        dependencies: [ts.createBindingHelper],
        priority: 2,
        text: "\n            var __exportStar = (this && this.__exportStar) || function(m, exports) {\n                for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n            };"
    };
    /**
     * Parameters:
     *  @param receiver  The object from which the private member will be read.
     *  @param state  One of the following:
     *      - A WeakMap used to read a private instance field.
     *      - A WeakSet used as an instance brand for private instance methods and accessors.
     *      - A function value that should be the undecorated class constructor used to brand check private static fields, methods, and accessors.
     *  @param kind  (optional pre TS 4.3, required for TS 4.3+) One of the following values:
     *      - undefined  Indicates a private instance field (pre TS 4.3).
     *      - "f"  Indicates a private field (instance or static).
     *      - "m"  Indicates a private method (instance or static).
     *      - "a"  Indicates a private accessor (instance or static).
     *  @param f  (optional pre TS 4.3) Depends on the arguments for state and kind:
     *      - If kind is "m", this should be the function corresponding to the static or instance method.
     *      - If kind is "a", this should be the function corresponding to the getter method, or undefined if the getter was not defined.
     *      - If kind is "f" and state is a function, this should be an object holding the value of a static field, or undefined if the static field declaration has not yet been evaluated.
     * Usage:
     * This helper will only ever be used by the compiler in the following ways:
     *
     * Reading from a private instance field (pre TS 4.3):
     *      __classPrivateFieldGet(<any>, <WeakMap>)
     *
     * Reading from a private instance field (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakMap>, "f")
     *
     * Reading from a private instance get accessor (when defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakSet>, "a", <function>)
     *
     * Reading from a private instance get accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakSet>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Reading from a private instance method (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakSet>, "m", <function>)
     *
     * Reading from a private static field (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "f", <{ value: any }>)
     *
     * Reading from a private static get accessor (when defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "a", <function>)
     *
     * Reading from a private static get accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Reading from a private static method (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "m", <function>)
     */
    ts.classPrivateFieldGetHelper = {
        name: "typescript:classPrivateFieldGet",
        importName: "__classPrivateFieldGet",
        scoped: false,
        text: "\n            var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n                if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n                if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n                return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n            };"
    };
    /**
     * Parameters:
     *  @param receiver  The object on which the private member will be set.
     *  @param state  One of the following:
     *      - A WeakMap used to store a private instance field.
     *      - A WeakSet used as an instance brand for private instance methods and accessors.
     *      - A function value that should be the undecorated class constructor used to brand check private static fields, methods, and accessors.
     *  @param value  The value to set.
     *  @param kind  (optional pre TS 4.3, required for TS 4.3+) One of the following values:
     *       - undefined  Indicates a private instance field (pre TS 4.3).
     *       - "f"  Indicates a private field (instance or static).
     *       - "m"  Indicates a private method (instance or static).
     *       - "a"  Indicates a private accessor (instance or static).
     *   @param f  (optional pre TS 4.3) Depends on the arguments for state and kind:
     *       - If kind is "m", this should be the function corresponding to the static or instance method.
     *       - If kind is "a", this should be the function corresponding to the setter method, or undefined if the setter was not defined.
     *       - If kind is "f" and state is a function, this should be an object holding the value of a static field, or undefined if the static field declaration has not yet been evaluated.
     * Usage:
     * This helper will only ever be used by the compiler in the following ways:
     *
     * Writing to a private instance field (pre TS 4.3):
     *      __classPrivateFieldSet(<any>, <WeakMap>, <any>)
     *
     * Writing to a private instance field (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakMap>, <any>, "f")
     *
     * Writing to a private instance set accessor (when defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakSet>, <any>, "a", <function>)
     *
     * Writing to a private instance set accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakSet>, <any>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Writing to a private instance method (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakSet>, <any>, "m", <function>)
     *      NOTE: This always results in a runtime error.
     *
     * Writing to a private static field (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "f", <{ value: any }>)
     *
     * Writing to a private static set accessor (when defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "a", <function>)
     *
     * Writing to a private static set accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Writing to a private static method (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "m", <function>)
     *      NOTE: This always results in a runtime error.
     */
    ts.classPrivateFieldSetHelper = {
        name: "typescript:classPrivateFieldSet",
        importName: "__classPrivateFieldSet",
        scoped: false,
        text: "\n            var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n                if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n                if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n                if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n                return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n            };"
    };
    var allUnscopedEmitHelpers;
    function getAllUnscopedEmitHelpers() {
        return allUnscopedEmitHelpers || (allUnscopedEmitHelpers = ts.arrayToMap([
            ts.decorateHelper,
            ts.metadataHelper,
            ts.paramHelper,
            ts.assignHelper,
            ts.awaitHelper,
            ts.asyncGeneratorHelper,
            ts.asyncDelegator,
            ts.asyncValues,
            ts.restHelper,
            ts.awaiterHelper,
            ts.extendsHelper,
            ts.templateObjectHelper,
            ts.spreadArrayHelper,
            ts.valuesHelper,
            ts.readHelper,
            ts.generatorHelper,
            ts.importStarHelper,
            ts.importDefaultHelper,
            ts.exportStarHelper,
            ts.classPrivateFieldGetHelper,
            ts.classPrivateFieldSetHelper,
            ts.createBindingHelper,
            ts.setModuleDefaultHelper
        ], function (helper) { return helper.name; }));
    }
    ts.getAllUnscopedEmitHelpers = getAllUnscopedEmitHelpers;
    ts.asyncSuperHelper = {
        name: "typescript:async-super",
        scoped: true,
        text: helperString(__makeTemplateObject(["\n            const ", " = name => super[name];"], ["\n            const ", " = name => super[name];"]), "_superIndex")
    };
    ts.advancedAsyncSuperHelper = {
        name: "typescript:advanced-async-super",
        scoped: true,
        text: helperString(__makeTemplateObject(["\n            const ", " = (function (geti, seti) {\n                const cache = Object.create(null);\n                return name => cache[name] || (cache[name] = { get value() { return geti(name); }, set value(v) { seti(name, v); } });\n            })(name => super[name], (name, value) => super[name] = value);"], ["\n            const ", " = (function (geti, seti) {\n                const cache = Object.create(null);\n                return name => cache[name] || (cache[name] = { get value() { return geti(name); }, set value(v) { seti(name, v); } });\n            })(name => super[name], (name, value) => super[name] = value);"]), "_superIndex")
    };
    function isCallToHelper(firstSegment, helperName) {
        return ts.isCallExpression(firstSegment)
            && ts.isIdentifier(firstSegment.expression)
            && (ts.getEmitFlags(firstSegment.expression) & 4096 /* HelperName */) !== 0
            && firstSegment.expression.escapedText === helperName;
    }
    ts.isCallToHelper = isCallToHelper;
})(ts || (ts = {}));
var ts;
(function (ts) {
    // Literals
    function isNumericLiteral(node) {
        return node.kind === 8 /* NumericLiteral */;
    }
    ts.isNumericLiteral = isNumericLiteral;
    function isBigIntLiteral(node) {
        return node.kind === 9 /* BigIntLiteral */;
    }
    ts.isBigIntLiteral = isBigIntLiteral;
    function isStringLiteral(node) {
        return node.kind === 10 /* StringLiteral */;
    }
    ts.isStringLiteral = isStringLiteral;
    function isJsxText(node) {
        return node.kind === 11 /* JsxText */;
    }
    ts.isJsxText = isJsxText;
    function isRegularExpressionLiteral(node) {
        return node.kind === 13 /* RegularExpressionLiteral */;
    }
    ts.isRegularExpressionLiteral = isRegularExpressionLiteral;
    function isNoSubstitutionTemplateLiteral(node) {
        return node.kind === 14 /* NoSubstitutionTemplateLiteral */;
    }
    ts.isNoSubstitutionTemplateLiteral = isNoSubstitutionTemplateLiteral;
    // Pseudo-literals
    function isTemplateHead(node) {
        return node.kind === 15 /* TemplateHead */;
    }
    ts.isTemplateHead = isTemplateHead;
    function isTemplateMiddle(node) {
        return node.kind === 16 /* TemplateMiddle */;
    }
    ts.isTemplateMiddle = isTemplateMiddle;
    function isTemplateTail(node) {
        return node.kind === 17 /* TemplateTail */;
    }
    ts.isTemplateTail = isTemplateTail;
    // Punctuation
    function isDotDotDotToken(node) {
        return node.kind === 25 /* DotDotDotToken */;
    }
    ts.isDotDotDotToken = isDotDotDotToken;
    /*@internal*/
    function isCommaToken(node) {
        return node.kind === 27 /* CommaToken */;
    }
    ts.isCommaToken = isCommaToken;
    function isPlusToken(node) {
        return node.kind === 39 /* PlusToken */;
    }
    ts.isPlusToken = isPlusToken;
    function isMinusToken(node) {
        return node.kind === 40 /* MinusToken */;
    }
    ts.isMinusToken = isMinusToken;
    function isAsteriskToken(node) {
        return node.kind === 41 /* AsteriskToken */;
    }
    ts.isAsteriskToken = isAsteriskToken;
    /*@internal*/
    function isExclamationToken(node) {
        return node.kind === 53 /* ExclamationToken */;
    }
    ts.isExclamationToken = isExclamationToken;
    /*@internal*/
    function isQuestionToken(node) {
        return node.kind === 57 /* QuestionToken */;
    }
    ts.isQuestionToken = isQuestionToken;
    /*@internal*/
    function isColonToken(node) {
        return node.kind === 58 /* ColonToken */;
    }
    ts.isColonToken = isColonToken;
    /*@internal*/
    function isQuestionDotToken(node) {
        return node.kind === 28 /* QuestionDotToken */;
    }
    ts.isQuestionDotToken = isQuestionDotToken;
    /*@internal*/
    function isEqualsGreaterThanToken(node) {
        return node.kind === 38 /* EqualsGreaterThanToken */;
    }
    ts.isEqualsGreaterThanToken = isEqualsGreaterThanToken;
    // Identifiers
    function isIdentifier(node) {
        return node.kind === 79 /* Identifier */;
    }
    ts.isIdentifier = isIdentifier;
    function isPrivateIdentifier(node) {
        return node.kind === 80 /* PrivateIdentifier */;
    }
    ts.isPrivateIdentifier = isPrivateIdentifier;
    // Reserved Words
    /* @internal */
    function isExportModifier(node) {
        return node.kind === 93 /* ExportKeyword */;
    }
    ts.isExportModifier = isExportModifier;
    /* @internal */
    function isAsyncModifier(node) {
        return node.kind === 130 /* AsyncKeyword */;
    }
    ts.isAsyncModifier = isAsyncModifier;
    /* @internal */
    function isAssertsKeyword(node) {
        return node.kind === 128 /* AssertsKeyword */;
    }
    ts.isAssertsKeyword = isAssertsKeyword;
    /* @internal */
    function isAwaitKeyword(node) {
        return node.kind === 131 /* AwaitKeyword */;
    }
    ts.isAwaitKeyword = isAwaitKeyword;
    /* @internal */
    function isReadonlyKeyword(node) {
        return node.kind === 143 /* ReadonlyKeyword */;
    }
    ts.isReadonlyKeyword = isReadonlyKeyword;
    /* @internal */
    function isStaticModifier(node) {
        return node.kind === 124 /* StaticKeyword */;
    }
    ts.isStaticModifier = isStaticModifier;
    /* @internal */
    function isAbstractModifier(node) {
        return node.kind === 126 /* AbstractKeyword */;
    }
    ts.isAbstractModifier = isAbstractModifier;
    /*@internal*/
    function isSuperKeyword(node) {
        return node.kind === 106 /* SuperKeyword */;
    }
    ts.isSuperKeyword = isSuperKeyword;
    /*@internal*/
    function isImportKeyword(node) {
        return node.kind === 100 /* ImportKeyword */;
    }
    ts.isImportKeyword = isImportKeyword;
    // Names
    function isQualifiedName(node) {
        return node.kind === 159 /* QualifiedName */;
    }
    ts.isQualifiedName = isQualifiedName;
    function isComputedPropertyName(node) {
        return node.kind === 160 /* ComputedPropertyName */;
    }
    ts.isComputedPropertyName = isComputedPropertyName;
    // Signature elements
    function isTypeParameterDeclaration(node) {
        return node.kind === 161 /* TypeParameter */;
    }
    ts.isTypeParameterDeclaration = isTypeParameterDeclaration;
    // TODO(rbuckton): Rename to 'isParameterDeclaration'
    function isParameter(node) {
        return node.kind === 162 /* Parameter */;
    }
    ts.isParameter = isParameter;
    function isDecorator(node) {
        return node.kind === 163 /* Decorator */;
    }
    ts.isDecorator = isDecorator;
    // TypeMember
    function isPropertySignature(node) {
        return node.kind === 164 /* PropertySignature */;
    }
    ts.isPropertySignature = isPropertySignature;
    function isPropertyDeclaration(node) {
        return node.kind === 165 /* PropertyDeclaration */;
    }
    ts.isPropertyDeclaration = isPropertyDeclaration;
    function isMethodSignature(node) {
        return node.kind === 166 /* MethodSignature */;
    }
    ts.isMethodSignature = isMethodSignature;
    function isMethodDeclaration(node) {
        return node.kind === 167 /* MethodDeclaration */;
    }
    ts.isMethodDeclaration = isMethodDeclaration;
    function isClassStaticBlockDeclaration(node) {
        return node.kind === 168 /* ClassStaticBlockDeclaration */;
    }
    ts.isClassStaticBlockDeclaration = isClassStaticBlockDeclaration;
    function isConstructorDeclaration(node) {
        return node.kind === 169 /* Constructor */;
    }
    ts.isConstructorDeclaration = isConstructorDeclaration;
    function isGetAccessorDeclaration(node) {
        return node.kind === 170 /* GetAccessor */;
    }
    ts.isGetAccessorDeclaration = isGetAccessorDeclaration;
    function isSetAccessorDeclaration(node) {
        return node.kind === 171 /* SetAccessor */;
    }
    ts.isSetAccessorDeclaration = isSetAccessorDeclaration;
    function isCallSignatureDeclaration(node) {
        return node.kind === 172 /* CallSignature */;
    }
    ts.isCallSignatureDeclaration = isCallSignatureDeclaration;
    function isConstructSignatureDeclaration(node) {
        return node.kind === 173 /* ConstructSignature */;
    }
    ts.isConstructSignatureDeclaration = isConstructSignatureDeclaration;
    function isIndexSignatureDeclaration(node) {
        return node.kind === 174 /* IndexSignature */;
    }
    ts.isIndexSignatureDeclaration = isIndexSignatureDeclaration;
    // Type
    function isTypePredicateNode(node) {
        return node.kind === 175 /* TypePredicate */;
    }
    ts.isTypePredicateNode = isTypePredicateNode;
    function isTypeReferenceNode(node) {
        return node.kind === 176 /* TypeReference */;
    }
    ts.isTypeReferenceNode = isTypeReferenceNode;
    function isFunctionTypeNode(node) {
        return node.kind === 177 /* FunctionType */;
    }
    ts.isFunctionTypeNode = isFunctionTypeNode;
    function isConstructorTypeNode(node) {
        return node.kind === 178 /* ConstructorType */;
    }
    ts.isConstructorTypeNode = isConstructorTypeNode;
    function isTypeQueryNode(node) {
        return node.kind === 179 /* TypeQuery */;
    }
    ts.isTypeQueryNode = isTypeQueryNode;
    function isTypeLiteralNode(node) {
        return node.kind === 180 /* TypeLiteral */;
    }
    ts.isTypeLiteralNode = isTypeLiteralNode;
    function isArrayTypeNode(node) {
        return node.kind === 181 /* ArrayType */;
    }
    ts.isArrayTypeNode = isArrayTypeNode;
    function isTupleTypeNode(node) {
        return node.kind === 182 /* TupleType */;
    }
    ts.isTupleTypeNode = isTupleTypeNode;
    function isNamedTupleMember(node) {
        return node.kind === 195 /* NamedTupleMember */;
    }
    ts.isNamedTupleMember = isNamedTupleMember;
    function isOptionalTypeNode(node) {
        return node.kind === 183 /* OptionalType */;
    }
    ts.isOptionalTypeNode = isOptionalTypeNode;
    function isRestTypeNode(node) {
        return node.kind === 184 /* RestType */;
    }
    ts.isRestTypeNode = isRestTypeNode;
    function isUnionTypeNode(node) {
        return node.kind === 185 /* UnionType */;
    }
    ts.isUnionTypeNode = isUnionTypeNode;
    function isIntersectionTypeNode(node) {
        return node.kind === 186 /* IntersectionType */;
    }
    ts.isIntersectionTypeNode = isIntersectionTypeNode;
    function isConditionalTypeNode(node) {
        return node.kind === 187 /* ConditionalType */;
    }
    ts.isConditionalTypeNode = isConditionalTypeNode;
    function isInferTypeNode(node) {
        return node.kind === 188 /* InferType */;
    }
    ts.isInferTypeNode = isInferTypeNode;
    function isParenthesizedTypeNode(node) {
        return node.kind === 189 /* ParenthesizedType */;
    }
    ts.isParenthesizedTypeNode = isParenthesizedTypeNode;
    function isThisTypeNode(node) {
        return node.kind === 190 /* ThisType */;
    }
    ts.isThisTypeNode = isThisTypeNode;
    function isTypeOperatorNode(node) {
        return node.kind === 191 /* TypeOperator */;
    }
    ts.isTypeOperatorNode = isTypeOperatorNode;
    function isIndexedAccessTypeNode(node) {
        return node.kind === 192 /* IndexedAccessType */;
    }
    ts.isIndexedAccessTypeNode = isIndexedAccessTypeNode;
    function isMappedTypeNode(node) {
        return node.kind === 193 /* MappedType */;
    }
    ts.isMappedTypeNode = isMappedTypeNode;
    function isLiteralTypeNode(node) {
        return node.kind === 194 /* LiteralType */;
    }
    ts.isLiteralTypeNode = isLiteralTypeNode;
    function isImportTypeNode(node) {
        return node.kind === 198 /* ImportType */;
    }
    ts.isImportTypeNode = isImportTypeNode;
    function isTemplateLiteralTypeSpan(node) {
        return node.kind === 197 /* TemplateLiteralTypeSpan */;
    }
    ts.isTemplateLiteralTypeSpan = isTemplateLiteralTypeSpan;
    function isTemplateLiteralTypeNode(node) {
        return node.kind === 196 /* TemplateLiteralType */;
    }
    ts.isTemplateLiteralTypeNode = isTemplateLiteralTypeNode;
    // Binding patterns
    function isObjectBindingPattern(node) {
        return node.kind === 199 /* ObjectBindingPattern */;
    }
    ts.isObjectBindingPattern = isObjectBindingPattern;
    function isArrayBindingPattern(node) {
        return node.kind === 200 /* ArrayBindingPattern */;
    }
    ts.isArrayBindingPattern = isArrayBindingPattern;
    function isBindingElement(node) {
        return node.kind === 201 /* BindingElement */;
    }
    ts.isBindingElement = isBindingElement;
    // Expression
    function isArrayLiteralExpression(node) {
        return node.kind === 202 /* ArrayLiteralExpression */;
    }
    ts.isArrayLiteralExpression = isArrayLiteralExpression;
    function isObjectLiteralExpression(node) {
        return node.kind === 203 /* ObjectLiteralExpression */;
    }
    ts.isObjectLiteralExpression = isObjectLiteralExpression;
    function isPropertyAccessExpression(node) {
        return node.kind === 204 /* PropertyAccessExpression */;
    }
    ts.isPropertyAccessExpression = isPropertyAccessExpression;
    function isElementAccessExpression(node) {
        return node.kind === 205 /* ElementAccessExpression */;
    }
    ts.isElementAccessExpression = isElementAccessExpression;
    function isCallExpression(node) {
        return node.kind === 206 /* CallExpression */;
    }
    ts.isCallExpression = isCallExpression;
    function isNewExpression(node) {
        return node.kind === 207 /* NewExpression */;
    }
    ts.isNewExpression = isNewExpression;
    function isTaggedTemplateExpression(node) {
        return node.kind === 208 /* TaggedTemplateExpression */;
    }
    ts.isTaggedTemplateExpression = isTaggedTemplateExpression;
    function isTypeAssertionExpression(node) {
        return node.kind === 209 /* TypeAssertionExpression */;
    }
    ts.isTypeAssertionExpression = isTypeAssertionExpression;
    function isParenthesizedExpression(node) {
        return node.kind === 210 /* ParenthesizedExpression */;
    }
    ts.isParenthesizedExpression = isParenthesizedExpression;
    function isFunctionExpression(node) {
        return node.kind === 211 /* FunctionExpression */;
    }
    ts.isFunctionExpression = isFunctionExpression;
    function isArrowFunction(node) {
        return node.kind === 212 /* ArrowFunction */;
    }
    ts.isArrowFunction = isArrowFunction;
    function isDeleteExpression(node) {
        return node.kind === 213 /* DeleteExpression */;
    }
    ts.isDeleteExpression = isDeleteExpression;
    function isTypeOfExpression(node) {
        return node.kind === 214 /* TypeOfExpression */;
    }
    ts.isTypeOfExpression = isTypeOfExpression;
    function isVoidExpression(node) {
        return node.kind === 215 /* VoidExpression */;
    }
    ts.isVoidExpression = isVoidExpression;
    function isAwaitExpression(node) {
        return node.kind === 216 /* AwaitExpression */;
    }
    ts.isAwaitExpression = isAwaitExpression;
    function isPrefixUnaryExpression(node) {
        return node.kind === 217 /* PrefixUnaryExpression */;
    }
    ts.isPrefixUnaryExpression = isPrefixUnaryExpression;
    function isPostfixUnaryExpression(node) {
        return node.kind === 218 /* PostfixUnaryExpression */;
    }
    ts.isPostfixUnaryExpression = isPostfixUnaryExpression;
    function isBinaryExpression(node) {
        return node.kind === 219 /* BinaryExpression */;
    }
    ts.isBinaryExpression = isBinaryExpression;
    function isConditionalExpression(node) {
        return node.kind === 220 /* ConditionalExpression */;
    }
    ts.isConditionalExpression = isConditionalExpression;
    function isTemplateExpression(node) {
        return node.kind === 221 /* TemplateExpression */;
    }
    ts.isTemplateExpression = isTemplateExpression;
    function isYieldExpression(node) {
        return node.kind === 222 /* YieldExpression */;
    }
    ts.isYieldExpression = isYieldExpression;
    function isSpreadElement(node) {
        return node.kind === 223 /* SpreadElement */;
    }
    ts.isSpreadElement = isSpreadElement;
    function isClassExpression(node) {
        return node.kind === 224 /* ClassExpression */;
    }
    ts.isClassExpression = isClassExpression;
    function isOmittedExpression(node) {
        return node.kind === 225 /* OmittedExpression */;
    }
    ts.isOmittedExpression = isOmittedExpression;
    function isExpressionWithTypeArguments(node) {
        return node.kind === 226 /* ExpressionWithTypeArguments */;
    }
    ts.isExpressionWithTypeArguments = isExpressionWithTypeArguments;
    function isAsExpression(node) {
        return node.kind === 227 /* AsExpression */;
    }
    ts.isAsExpression = isAsExpression;
    function isNonNullExpression(node) {
        return node.kind === 228 /* NonNullExpression */;
    }
    ts.isNonNullExpression = isNonNullExpression;
    function isMetaProperty(node) {
        return node.kind === 229 /* MetaProperty */;
    }
    ts.isMetaProperty = isMetaProperty;
    function isSyntheticExpression(node) {
        return node.kind === 230 /* SyntheticExpression */;
    }
    ts.isSyntheticExpression = isSyntheticExpression;
    function isPartiallyEmittedExpression(node) {
        return node.kind === 345 /* PartiallyEmittedExpression */;
    }
    ts.isPartiallyEmittedExpression = isPartiallyEmittedExpression;
    function isCommaListExpression(node) {
        return node.kind === 346 /* CommaListExpression */;
    }
    ts.isCommaListExpression = isCommaListExpression;
    // Misc
    function isTemplateSpan(node) {
        return node.kind === 231 /* TemplateSpan */;
    }
    ts.isTemplateSpan = isTemplateSpan;
    function isSemicolonClassElement(node) {
        return node.kind === 232 /* SemicolonClassElement */;
    }
    ts.isSemicolonClassElement = isSemicolonClassElement;
    // Elements
    function isBlock(node) {
        return node.kind === 233 /* Block */;
    }
    ts.isBlock = isBlock;
    function isVariableStatement(node) {
        return node.kind === 235 /* VariableStatement */;
    }
    ts.isVariableStatement = isVariableStatement;
    function isEmptyStatement(node) {
        return node.kind === 234 /* EmptyStatement */;
    }
    ts.isEmptyStatement = isEmptyStatement;
    function isExpressionStatement(node) {
        return node.kind === 236 /* ExpressionStatement */;
    }
    ts.isExpressionStatement = isExpressionStatement;
    function isIfStatement(node) {
        return node.kind === 237 /* IfStatement */;
    }
    ts.isIfStatement = isIfStatement;
    function isDoStatement(node) {
        return node.kind === 238 /* DoStatement */;
    }
    ts.isDoStatement = isDoStatement;
    function isWhileStatement(node) {
        return node.kind === 239 /* WhileStatement */;
    }
    ts.isWhileStatement = isWhileStatement;
    function isForStatement(node) {
        return node.kind === 240 /* ForStatement */;
    }
    ts.isForStatement = isForStatement;
    function isForInStatement(node) {
        return node.kind === 241 /* ForInStatement */;
    }
    ts.isForInStatement = isForInStatement;
    function isForOfStatement(node) {
        return node.kind === 242 /* ForOfStatement */;
    }
    ts.isForOfStatement = isForOfStatement;
    function isContinueStatement(node) {
        return node.kind === 243 /* ContinueStatement */;
    }
    ts.isContinueStatement = isContinueStatement;
    function isBreakStatement(node) {
        return node.kind === 244 /* BreakStatement */;
    }
    ts.isBreakStatement = isBreakStatement;
    function isReturnStatement(node) {
        return node.kind === 245 /* ReturnStatement */;
    }
    ts.isReturnStatement = isReturnStatement;
    function isWithStatement(node) {
        return node.kind === 246 /* WithStatement */;
    }
    ts.isWithStatement = isWithStatement;
    function isSwitchStatement(node) {
        return node.kind === 247 /* SwitchStatement */;
    }
    ts.isSwitchStatement = isSwitchStatement;
    function isLabeledStatement(node) {
        return node.kind === 248 /* LabeledStatement */;
    }
    ts.isLabeledStatement = isLabeledStatement;
    function isThrowStatement(node) {
        return node.kind === 249 /* ThrowStatement */;
    }
    ts.isThrowStatement = isThrowStatement;
    function isTryStatement(node) {
        return node.kind === 250 /* TryStatement */;
    }
    ts.isTryStatement = isTryStatement;
    function isDebuggerStatement(node) {
        return node.kind === 251 /* DebuggerStatement */;
    }
    ts.isDebuggerStatement = isDebuggerStatement;
    function isVariableDeclaration(node) {
        return node.kind === 252 /* VariableDeclaration */;
    }
    ts.isVariableDeclaration = isVariableDeclaration;
    function isVariableDeclarationList(node) {
        return node.kind === 253 /* VariableDeclarationList */;
    }
    ts.isVariableDeclarationList = isVariableDeclarationList;
    function isFunctionDeclaration(node) {
        return node.kind === 254 /* FunctionDeclaration */;
    }
    ts.isFunctionDeclaration = isFunctionDeclaration;
    function isClassDeclaration(node) {
        return node.kind === 255 /* ClassDeclaration */;
    }
    ts.isClassDeclaration = isClassDeclaration;
    function isInterfaceDeclaration(node) {
        return node.kind === 256 /* InterfaceDeclaration */;
    }
    ts.isInterfaceDeclaration = isInterfaceDeclaration;
    function isTypeAliasDeclaration(node) {
        return node.kind === 257 /* TypeAliasDeclaration */;
    }
    ts.isTypeAliasDeclaration = isTypeAliasDeclaration;
    function isEnumDeclaration(node) {
        return node.kind === 258 /* EnumDeclaration */;
    }
    ts.isEnumDeclaration = isEnumDeclaration;
    function isModuleDeclaration(node) {
        return node.kind === 259 /* ModuleDeclaration */;
    }
    ts.isModuleDeclaration = isModuleDeclaration;
    function isModuleBlock(node) {
        return node.kind === 260 /* ModuleBlock */;
    }
    ts.isModuleBlock = isModuleBlock;
    function isCaseBlock(node) {
        return node.kind === 261 /* CaseBlock */;
    }
    ts.isCaseBlock = isCaseBlock;
    function isNamespaceExportDeclaration(node) {
        return node.kind === 262 /* NamespaceExportDeclaration */;
    }
    ts.isNamespaceExportDeclaration = isNamespaceExportDeclaration;
    function isImportEqualsDeclaration(node) {
        return node.kind === 263 /* ImportEqualsDeclaration */;
    }
    ts.isImportEqualsDeclaration = isImportEqualsDeclaration;
    function isImportDeclaration(node) {
        return node.kind === 264 /* ImportDeclaration */;
    }
    ts.isImportDeclaration = isImportDeclaration;
    function isImportClause(node) {
        return node.kind === 265 /* ImportClause */;
    }
    ts.isImportClause = isImportClause;
    function isNamespaceImport(node) {
        return node.kind === 266 /* NamespaceImport */;
    }
    ts.isNamespaceImport = isNamespaceImport;
    function isNamespaceExport(node) {
        return node.kind === 272 /* NamespaceExport */;
    }
    ts.isNamespaceExport = isNamespaceExport;
    function isNamedImports(node) {
        return node.kind === 267 /* NamedImports */;
    }
    ts.isNamedImports = isNamedImports;
    function isImportSpecifier(node) {
        return node.kind === 268 /* ImportSpecifier */;
    }
    ts.isImportSpecifier = isImportSpecifier;
    function isExportAssignment(node) {
        return node.kind === 269 /* ExportAssignment */;
    }
    ts.isExportAssignment = isExportAssignment;
    function isExportDeclaration(node) {
        return node.kind === 270 /* ExportDeclaration */;
    }
    ts.isExportDeclaration = isExportDeclaration;
    function isNamedExports(node) {
        return node.kind === 271 /* NamedExports */;
    }
    ts.isNamedExports = isNamedExports;
    function isExportSpecifier(node) {
        return node.kind === 273 /* ExportSpecifier */;
    }
    ts.isExportSpecifier = isExportSpecifier;
    function isMissingDeclaration(node) {
        return node.kind === 274 /* MissingDeclaration */;
    }
    ts.isMissingDeclaration = isMissingDeclaration;
    function isNotEmittedStatement(node) {
        return node.kind === 344 /* NotEmittedStatement */;
    }
    ts.isNotEmittedStatement = isNotEmittedStatement;
    /* @internal */
    function isSyntheticReference(node) {
        return node.kind === 349 /* SyntheticReferenceExpression */;
    }
    ts.isSyntheticReference = isSyntheticReference;
    /* @internal */
    function isMergeDeclarationMarker(node) {
        return node.kind === 347 /* MergeDeclarationMarker */;
    }
    ts.isMergeDeclarationMarker = isMergeDeclarationMarker;
    /* @internal */
    function isEndOfDeclarationMarker(node) {
        return node.kind === 348 /* EndOfDeclarationMarker */;
    }
    ts.isEndOfDeclarationMarker = isEndOfDeclarationMarker;
    // Module References
    function isExternalModuleReference(node) {
        return node.kind === 275 /* ExternalModuleReference */;
    }
    ts.isExternalModuleReference = isExternalModuleReference;
    // JSX
    function isJsxElement(node) {
        return node.kind === 276 /* JsxElement */;
    }
    ts.isJsxElement = isJsxElement;
    function isJsxSelfClosingElement(node) {
        return node.kind === 277 /* JsxSelfClosingElement */;
    }
    ts.isJsxSelfClosingElement = isJsxSelfClosingElement;
    function isJsxOpeningElement(node) {
        return node.kind === 278 /* JsxOpeningElement */;
    }
    ts.isJsxOpeningElement = isJsxOpeningElement;
    function isJsxClosingElement(node) {
        return node.kind === 279 /* JsxClosingElement */;
    }
    ts.isJsxClosingElement = isJsxClosingElement;
    function isJsxFragment(node) {
        return node.kind === 280 /* JsxFragment */;
    }
    ts.isJsxFragment = isJsxFragment;
    function isJsxOpeningFragment(node) {
        return node.kind === 281 /* JsxOpeningFragment */;
    }
    ts.isJsxOpeningFragment = isJsxOpeningFragment;
    function isJsxClosingFragment(node) {
        return node.kind === 282 /* JsxClosingFragment */;
    }
    ts.isJsxClosingFragment = isJsxClosingFragment;
    function isJsxAttribute(node) {
        return node.kind === 283 /* JsxAttribute */;
    }
    ts.isJsxAttribute = isJsxAttribute;
    function isJsxAttributes(node) {
        return node.kind === 284 /* JsxAttributes */;
    }
    ts.isJsxAttributes = isJsxAttributes;
    function isJsxSpreadAttribute(node) {
        return node.kind === 285 /* JsxSpreadAttribute */;
    }
    ts.isJsxSpreadAttribute = isJsxSpreadAttribute;
    function isJsxExpression(node) {
        return node.kind === 286 /* JsxExpression */;
    }
    ts.isJsxExpression = isJsxExpression;
    // Clauses
    function isCaseClause(node) {
        return node.kind === 287 /* CaseClause */;
    }
    ts.isCaseClause = isCaseClause;
    function isDefaultClause(node) {
        return node.kind === 288 /* DefaultClause */;
    }
    ts.isDefaultClause = isDefaultClause;
    function isHeritageClause(node) {
        return node.kind === 289 /* HeritageClause */;
    }
    ts.isHeritageClause = isHeritageClause;
    function isCatchClause(node) {
        return node.kind === 290 /* CatchClause */;
    }
    ts.isCatchClause = isCatchClause;
    // Property assignments
    function isPropertyAssignment(node) {
        return node.kind === 291 /* PropertyAssignment */;
    }
    ts.isPropertyAssignment = isPropertyAssignment;
    function isShorthandPropertyAssignment(node) {
        return node.kind === 292 /* ShorthandPropertyAssignment */;
    }
    ts.isShorthandPropertyAssignment = isShorthandPropertyAssignment;
    function isSpreadAssignment(node) {
        return node.kind === 293 /* SpreadAssignment */;
    }
    ts.isSpreadAssignment = isSpreadAssignment;
    // Enum
    function isEnumMember(node) {
        return node.kind === 294 /* EnumMember */;
    }
    ts.isEnumMember = isEnumMember;
    // Unparsed
    // TODO(rbuckton): isUnparsedPrologue
    function isUnparsedPrepend(node) {
        return node.kind === 296 /* UnparsedPrepend */;
    }
    ts.isUnparsedPrepend = isUnparsedPrepend;
    // TODO(rbuckton): isUnparsedText
    // TODO(rbuckton): isUnparsedInternalText
    // TODO(rbuckton): isUnparsedSyntheticReference
    // Top-level nodes
    function isSourceFile(node) {
        return node.kind === 300 /* SourceFile */;
    }
    ts.isSourceFile = isSourceFile;
    function isBundle(node) {
        return node.kind === 301 /* Bundle */;
    }
    ts.isBundle = isBundle;
    function isUnparsedSource(node) {
        return node.kind === 302 /* UnparsedSource */;
    }
    ts.isUnparsedSource = isUnparsedSource;
    // TODO(rbuckton): isInputFiles
    // JSDoc Elements
    function isJSDocTypeExpression(node) {
        return node.kind === 304 /* JSDocTypeExpression */;
    }
    ts.isJSDocTypeExpression = isJSDocTypeExpression;
    function isJSDocNameReference(node) {
        return node.kind === 305 /* JSDocNameReference */;
    }
    ts.isJSDocNameReference = isJSDocNameReference;
    function isJSDocMemberName(node) {
        return node.kind === 306 /* JSDocMemberName */;
    }
    ts.isJSDocMemberName = isJSDocMemberName;
    function isJSDocLink(node) {
        return node.kind === 319 /* JSDocLink */;
    }
    ts.isJSDocLink = isJSDocLink;
    function isJSDocLinkCode(node) {
        return node.kind === 320 /* JSDocLinkCode */;
    }
    ts.isJSDocLinkCode = isJSDocLinkCode;
    function isJSDocLinkPlain(node) {
        return node.kind === 321 /* JSDocLinkPlain */;
    }
    ts.isJSDocLinkPlain = isJSDocLinkPlain;
    function isJSDocAllType(node) {
        return node.kind === 307 /* JSDocAllType */;
    }
    ts.isJSDocAllType = isJSDocAllType;
    function isJSDocUnknownType(node) {
        return node.kind === 308 /* JSDocUnknownType */;
    }
    ts.isJSDocUnknownType = isJSDocUnknownType;
    function isJSDocNullableType(node) {
        return node.kind === 309 /* JSDocNullableType */;
    }
    ts.isJSDocNullableType = isJSDocNullableType;
    function isJSDocNonNullableType(node) {
        return node.kind === 310 /* JSDocNonNullableType */;
    }
    ts.isJSDocNonNullableType = isJSDocNonNullableType;
    function isJSDocOptionalType(node) {
        return node.kind === 311 /* JSDocOptionalType */;
    }
    ts.isJSDocOptionalType = isJSDocOptionalType;
    function isJSDocFunctionType(node) {
        return node.kind === 312 /* JSDocFunctionType */;
    }
    ts.isJSDocFunctionType = isJSDocFunctionType;
    function isJSDocVariadicType(node) {
        return node.kind === 313 /* JSDocVariadicType */;
    }
    ts.isJSDocVariadicType = isJSDocVariadicType;
    function isJSDocNamepathType(node) {
        return node.kind === 314 /* JSDocNamepathType */;
    }
    ts.isJSDocNamepathType = isJSDocNamepathType;
    function isJSDoc(node) {
        return node.kind === 315 /* JSDocComment */;
    }
    ts.isJSDoc = isJSDoc;
    function isJSDocTypeLiteral(node) {
        return node.kind === 317 /* JSDocTypeLiteral */;
    }
    ts.isJSDocTypeLiteral = isJSDocTypeLiteral;
    function isJSDocSignature(node) {
        return node.kind === 318 /* JSDocSignature */;
    }
    ts.isJSDocSignature = isJSDocSignature;
    // JSDoc Tags
    function isJSDocAugmentsTag(node) {
        return node.kind === 323 /* JSDocAugmentsTag */;
    }
    ts.isJSDocAugmentsTag = isJSDocAugmentsTag;
    function isJSDocAuthorTag(node) {
        return node.kind === 325 /* JSDocAuthorTag */;
    }
    ts.isJSDocAuthorTag = isJSDocAuthorTag;
    function isJSDocClassTag(node) {
        return node.kind === 327 /* JSDocClassTag */;
    }
    ts.isJSDocClassTag = isJSDocClassTag;
    function isJSDocCallbackTag(node) {
        return node.kind === 333 /* JSDocCallbackTag */;
    }
    ts.isJSDocCallbackTag = isJSDocCallbackTag;
    function isJSDocPublicTag(node) {
        return node.kind === 328 /* JSDocPublicTag */;
    }
    ts.isJSDocPublicTag = isJSDocPublicTag;
    function isJSDocPrivateTag(node) {
        return node.kind === 329 /* JSDocPrivateTag */;
    }
    ts.isJSDocPrivateTag = isJSDocPrivateTag;
    function isJSDocProtectedTag(node) {
        return node.kind === 330 /* JSDocProtectedTag */;
    }
    ts.isJSDocProtectedTag = isJSDocProtectedTag;
    function isJSDocReadonlyTag(node) {
        return node.kind === 331 /* JSDocReadonlyTag */;
    }
    ts.isJSDocReadonlyTag = isJSDocReadonlyTag;
    function isJSDocOverrideTag(node) {
        return node.kind === 332 /* JSDocOverrideTag */;
    }
    ts.isJSDocOverrideTag = isJSDocOverrideTag;
    function isJSDocDeprecatedTag(node) {
        return node.kind === 326 /* JSDocDeprecatedTag */;
    }
    ts.isJSDocDeprecatedTag = isJSDocDeprecatedTag;
    function isJSDocSeeTag(node) {
        return node.kind === 341 /* JSDocSeeTag */;
    }
    ts.isJSDocSeeTag = isJSDocSeeTag;
    function isJSDocEnumTag(node) {
        return node.kind === 334 /* JSDocEnumTag */;
    }
    ts.isJSDocEnumTag = isJSDocEnumTag;
    function isJSDocParameterTag(node) {
        return node.kind === 335 /* JSDocParameterTag */;
    }
    ts.isJSDocParameterTag = isJSDocParameterTag;
    function isJSDocReturnTag(node) {
        return node.kind === 336 /* JSDocReturnTag */;
    }
    ts.isJSDocReturnTag = isJSDocReturnTag;
    function isJSDocThisTag(node) {
        return node.kind === 337 /* JSDocThisTag */;
    }
    ts.isJSDocThisTag = isJSDocThisTag;
    function isJSDocTypeTag(node) {
        return node.kind === 338 /* JSDocTypeTag */;
    }
    ts.isJSDocTypeTag = isJSDocTypeTag;
    function isJSDocTemplateTag(node) {
        return node.kind === 339 /* JSDocTemplateTag */;
    }
    ts.isJSDocTemplateTag = isJSDocTemplateTag;
    function isJSDocTypedefTag(node) {
        return node.kind === 340 /* JSDocTypedefTag */;
    }
    ts.isJSDocTypedefTag = isJSDocTypedefTag;
    function isJSDocUnknownTag(node) {
        return node.kind === 322 /* JSDocTag */;
    }
    ts.isJSDocUnknownTag = isJSDocUnknownTag;
    function isJSDocPropertyTag(node) {
        return node.kind === 342 /* JSDocPropertyTag */;
    }
    ts.isJSDocPropertyTag = isJSDocPropertyTag;
    function isJSDocImplementsTag(node) {
        return node.kind === 324 /* JSDocImplementsTag */;
    }
    ts.isJSDocImplementsTag = isJSDocImplementsTag;
    // Synthesized list
    /* @internal */
    function isSyntaxList(n) {
        return n.kind === 343 /* SyntaxList */;
    }
    ts.isSyntaxList = isSyntaxList;
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    // Compound nodes
    function createEmptyExports(factory) {
        return factory.createExportDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*isTypeOnly*/ false, factory.createNamedExports([]), /*moduleSpecifier*/ undefined);
    }
    ts.createEmptyExports = createEmptyExports;
    function createMemberAccessForPropertyName(factory, target, memberName, location) {
        if (ts.isComputedPropertyName(memberName)) {
            return ts.setTextRange(factory.createElementAccessExpression(target, memberName.expression), location);
        }
        else {
            var expression = ts.setTextRange(ts.isMemberName(memberName)
                ? factory.createPropertyAccessExpression(target, memberName)
                : factory.createElementAccessExpression(target, memberName), memberName);
            ts.getOrCreateEmitNode(expression).flags |= 64 /* NoNestedSourceMaps */;
            return expression;
        }
    }
    ts.createMemberAccessForPropertyName = createMemberAccessForPropertyName;
    function createReactNamespace(reactNamespace, parent) {
        // To ensure the emit resolver can properly resolve the namespace, we need to
        // treat this identifier as if it were a source tree node by clearing the `Synthesized`
        // flag and setting a parent node.
        var react = ts.parseNodeFactory.createIdentifier(reactNamespace || "React");
        // Set the parent that is in parse tree
        // this makes sure that parent chain is intact for checker to traverse complete scope tree
        ts.setParent(react, ts.getParseTreeNode(parent));
        return react;
    }
    function createJsxFactoryExpressionFromEntityName(factory, jsxFactory, parent) {
        if (ts.isQualifiedName(jsxFactory)) {
            var left = createJsxFactoryExpressionFromEntityName(factory, jsxFactory.left, parent);
            var right = factory.createIdentifier(ts.idText(jsxFactory.right));
            right.escapedText = jsxFactory.right.escapedText;
            return factory.createPropertyAccessExpression(left, right);
        }
        else {
            return createReactNamespace(ts.idText(jsxFactory), parent);
        }
    }
    function createJsxFactoryExpression(factory, jsxFactoryEntity, reactNamespace, parent) {
        return jsxFactoryEntity ?
            createJsxFactoryExpressionFromEntityName(factory, jsxFactoryEntity, parent) :
            factory.createPropertyAccessExpression(createReactNamespace(reactNamespace, parent), "createElement");
    }
    ts.createJsxFactoryExpression = createJsxFactoryExpression;
    function createJsxFragmentFactoryExpression(factory, jsxFragmentFactoryEntity, reactNamespace, parent) {
        return jsxFragmentFactoryEntity ?
            createJsxFactoryExpressionFromEntityName(factory, jsxFragmentFactoryEntity, parent) :
            factory.createPropertyAccessExpression(createReactNamespace(reactNamespace, parent), "Fragment");
    }
    function createExpressionForJsxElement(factory, callee, tagName, props, children, location) {
        var argumentsList = [tagName];
        if (props) {
            argumentsList.push(props);
        }
        if (children && children.length > 0) {
            if (!props) {
                argumentsList.push(factory.createNull());
            }
            if (children.length > 1) {
                for (var _i = 0, children_3 = children; _i < children_3.length; _i++) {
                    var child = children_3[_i];
                    startOnNewLine(child);
                    argumentsList.push(child);
                }
            }
            else {
                argumentsList.push(children[0]);
            }
        }
        return ts.setTextRange(factory.createCallExpression(callee, 
        /*typeArguments*/ undefined, argumentsList), location);
    }
    ts.createExpressionForJsxElement = createExpressionForJsxElement;
    function createExpressionForJsxFragment(factory, jsxFactoryEntity, jsxFragmentFactoryEntity, reactNamespace, children, parentElement, location) {
        var tagName = createJsxFragmentFactoryExpression(factory, jsxFragmentFactoryEntity, reactNamespace, parentElement);
        var argumentsList = [tagName, factory.createNull()];
        if (children && children.length > 0) {
            if (children.length > 1) {
                for (var _i = 0, children_4 = children; _i < children_4.length; _i++) {
                    var child = children_4[_i];
                    startOnNewLine(child);
                    argumentsList.push(child);
                }
            }
            else {
                argumentsList.push(children[0]);
            }
        }
        return ts.setTextRange(factory.createCallExpression(createJsxFactoryExpression(factory, jsxFactoryEntity, reactNamespace, parentElement), 
        /*typeArguments*/ undefined, argumentsList), location);
    }
    ts.createExpressionForJsxFragment = createExpressionForJsxFragment;
    // Utilities
    function createForOfBindingStatement(factory, node, boundValue) {
        if (ts.isVariableDeclarationList(node)) {
            var firstDeclaration = ts.first(node.declarations);
            var updatedDeclaration = factory.updateVariableDeclaration(firstDeclaration, firstDeclaration.name, 
            /*exclamationToken*/ undefined, 
            /*type*/ undefined, boundValue);
            return ts.setTextRange(factory.createVariableStatement(
            /*modifiers*/ undefined, factory.updateVariableDeclarationList(node, [updatedDeclaration])), 
            /*location*/ node);
        }
        else {
            var updatedExpression = ts.setTextRange(factory.createAssignment(node, boundValue), /*location*/ node);
            return ts.setTextRange(factory.createExpressionStatement(updatedExpression), /*location*/ node);
        }
    }
    ts.createForOfBindingStatement = createForOfBindingStatement;
    function insertLeadingStatement(factory, dest, source) {
        if (ts.isBlock(dest)) {
            return factory.updateBlock(dest, ts.setTextRange(factory.createNodeArray(__spreadArray([source], dest.statements, true)), dest.statements));
        }
        else {
            return factory.createBlock(factory.createNodeArray([dest, source]), /*multiLine*/ true);
        }
    }
    ts.insertLeadingStatement = insertLeadingStatement;
    function createExpressionFromEntityName(factory, node) {
        if (ts.isQualifiedName(node)) {
            var left = createExpressionFromEntityName(factory, node.left);
            // TODO(rbuckton): Does this need to be parented?
            var right = ts.setParent(ts.setTextRange(factory.cloneNode(node.right), node.right), node.right.parent);
            return ts.setTextRange(factory.createPropertyAccessExpression(left, right), node);
        }
        else {
            // TODO(rbuckton): Does this need to be parented?
            return ts.setParent(ts.setTextRange(factory.cloneNode(node), node), node.parent);
        }
    }
    ts.createExpressionFromEntityName = createExpressionFromEntityName;
    function createExpressionForPropertyName(factory, memberName) {
        if (ts.isIdentifier(memberName)) {
            return factory.createStringLiteralFromNode(memberName);
        }
        else if (ts.isComputedPropertyName(memberName)) {
            // TODO(rbuckton): Does this need to be parented?
            return ts.setParent(ts.setTextRange(factory.cloneNode(memberName.expression), memberName.expression), memberName.expression.parent);
        }
        else {
            // TODO(rbuckton): Does this need to be parented?
            return ts.setParent(ts.setTextRange(factory.cloneNode(memberName), memberName), memberName.parent);
        }
    }
    ts.createExpressionForPropertyName = createExpressionForPropertyName;
    function createExpressionForAccessorDeclaration(factory, properties, property, receiver, multiLine) {
        var _a = ts.getAllAccessorDeclarations(properties, property), firstAccessor = _a.firstAccessor, getAccessor = _a.getAccessor, setAccessor = _a.setAccessor;
        if (property === firstAccessor) {
            return ts.setTextRange(factory.createObjectDefinePropertyCall(receiver, createExpressionForPropertyName(factory, property.name), factory.createPropertyDescriptor({
                enumerable: factory.createFalse(),
                configurable: true,
                get: getAccessor && ts.setTextRange(ts.setOriginalNode(factory.createFunctionExpression(getAccessor.modifiers, 
                /*asteriskToken*/ undefined, 
                /*name*/ undefined, 
                /*typeParameters*/ undefined, getAccessor.parameters, 
                /*type*/ undefined, getAccessor.body // TODO: GH#18217
                ), getAccessor), getAccessor),
                set: setAccessor && ts.setTextRange(ts.setOriginalNode(factory.createFunctionExpression(setAccessor.modifiers, 
                /*asteriskToken*/ undefined, 
                /*name*/ undefined, 
                /*typeParameters*/ undefined, setAccessor.parameters, 
                /*type*/ undefined, setAccessor.body // TODO: GH#18217
                ), setAccessor), setAccessor)
            }, !multiLine)), firstAccessor);
        }
        return undefined;
    }
    function createExpressionForPropertyAssignment(factory, property, receiver) {
        return ts.setOriginalNode(ts.setTextRange(factory.createAssignment(createMemberAccessForPropertyName(factory, receiver, property.name, /*location*/ property.name), property.initializer), property), property);
    }
    function createExpressionForShorthandPropertyAssignment(factory, property, receiver) {
        return ts.setOriginalNode(ts.setTextRange(factory.createAssignment(createMemberAccessForPropertyName(factory, receiver, property.name, /*location*/ property.name), factory.cloneNode(property.name)), 
        /*location*/ property), 
        /*original*/ property);
    }
    function createExpressionForMethodDeclaration(factory, method, receiver) {
        return ts.setOriginalNode(ts.setTextRange(factory.createAssignment(createMemberAccessForPropertyName(factory, receiver, method.name, /*location*/ method.name), ts.setOriginalNode(ts.setTextRange(factory.createFunctionExpression(method.modifiers, method.asteriskToken, 
        /*name*/ undefined, 
        /*typeParameters*/ undefined, method.parameters, 
        /*type*/ undefined, method.body // TODO: GH#18217
        ), 
        /*location*/ method), 
        /*original*/ method)), 
        /*location*/ method), 
        /*original*/ method);
    }
    function createExpressionForObjectLiteralElementLike(factory, node, property, receiver) {
        if (property.name && ts.isPrivateIdentifier(property.name)) {
            ts.Debug.failBadSyntaxKind(property.name, "Private identifiers are not allowed in object literals.");
        }
        switch (property.kind) {
            case 170 /* GetAccessor */:
            case 171 /* SetAccessor */:
                return createExpressionForAccessorDeclaration(factory, node.properties, property, receiver, !!node.multiLine);
            case 291 /* PropertyAssignment */:
                return createExpressionForPropertyAssignment(factory, property, receiver);
            case 292 /* ShorthandPropertyAssignment */:
                return createExpressionForShorthandPropertyAssignment(factory, property, receiver);
            case 167 /* MethodDeclaration */:
                return createExpressionForMethodDeclaration(factory, property, receiver);
        }
    }
    ts.createExpressionForObjectLiteralElementLike = createExpressionForObjectLiteralElementLike;
    /**
     * Expand the read and increment/decrement operations a pre- or post-increment or pre- or post-decrement expression.
     *
     * ```ts
     * // input
     * <expression>++
     * // output (if result is not discarded)
     * var <temp>;
     * (<temp> = <expression>, <resultVariable> = <temp>++, <temp>)
     * // output (if result is discarded)
     * var <temp>;
     * (<temp> = <expression>, <temp>++, <temp>)
     *
     * // input
     * ++<expression>
     * // output (if result is not discarded)
     * var <temp>;
     * (<temp> = <expression>, <resultVariable> = ++<temp>)
     * // output (if result is discarded)
     * var <temp>;
     * (<temp> = <expression>, ++<temp>)
     * ```
     *
     * It is up to the caller to supply a temporary variable for `<resultVariable>` if one is needed.
     * The temporary variable `<temp>` is injected so that `++` and `--` work uniformly with `number` and `bigint`.
     * The result of the expression is always the final result of incrementing or decrementing the expression, so that it can be used for storage.
     *
     * @param factory {@link NodeFactory} used to create the expanded representation.
     * @param node The original prefix or postfix unary node.
     * @param expression The expression to use as the value to increment or decrement
     * @param resultVariable A temporary variable in which to store the result. Pass `undefined` if the result is discarded, or if the value of `<temp>` is the expected result.
     */
    function expandPreOrPostfixIncrementOrDecrementExpression(factory, node, expression, recordTempVariable, resultVariable) {
        var operator = node.operator;
        ts.Debug.assert(operator === 45 /* PlusPlusToken */ || operator === 46 /* MinusMinusToken */, "Expected 'node' to be a pre- or post-increment or pre- or post-decrement expression");
        var temp = factory.createTempVariable(recordTempVariable);
        expression = factory.createAssignment(temp, expression);
        ts.setTextRange(expression, node.operand);
        var operation = ts.isPrefixUnaryExpression(node) ?
            factory.createPrefixUnaryExpression(operator, temp) :
            factory.createPostfixUnaryExpression(temp, operator);
        ts.setTextRange(operation, node);
        if (resultVariable) {
            operation = factory.createAssignment(resultVariable, operation);
            ts.setTextRange(operation, node);
        }
        expression = factory.createComma(expression, operation);
        ts.setTextRange(expression, node);
        if (ts.isPostfixUnaryExpression(node)) {
            expression = factory.createComma(expression, temp);
            ts.setTextRange(expression, node);
        }
        return expression;
    }
    ts.expandPreOrPostfixIncrementOrDecrementExpression = expandPreOrPostfixIncrementOrDecrementExpression;
    /**
     * Gets whether an identifier should only be referred to by its internal name.
     */
    function isInternalName(node) {
        return (ts.getEmitFlags(node) & 32768 /* InternalName */) !== 0;
    }
    ts.isInternalName = isInternalName;
    /**
     * Gets whether an identifier should only be referred to by its local name.
     */
    function isLocalName(node) {
        return (ts.getEmitFlags(node) & 16384 /* LocalName */) !== 0;
    }
    ts.isLocalName = isLocalName;
    /**
     * Gets whether an identifier should only be referred to by its export representation if the
     * name points to an exported symbol.
     */
    function isExportName(node) {
        return (ts.getEmitFlags(node) & 8192 /* ExportName */) !== 0;
    }
    ts.isExportName = isExportName;
    function isUseStrictPrologue(node) {
        return ts.isStringLiteral(node.expression) && node.expression.text === "use strict";
    }
    function findUseStrictPrologue(statements) {
        for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {
            var statement = statements_1[_i];
            if (ts.isPrologueDirective(statement)) {
                if (isUseStrictPrologue(statement)) {
                    return statement;
                }
            }
            else {
                break;
            }
        }
        return undefined;
    }
    ts.findUseStrictPrologue = findUseStrictPrologue;
    function startsWithUseStrict(statements) {
        var firstStatement = ts.firstOrUndefined(statements);
        return firstStatement !== undefined
            && ts.isPrologueDirective(firstStatement)
            && isUseStrictPrologue(firstStatement);
    }
    ts.startsWithUseStrict = startsWithUseStrict;
    function isCommaSequence(node) {
        return node.kind === 219 /* BinaryExpression */ && node.operatorToken.kind === 27 /* CommaToken */ ||
            node.kind === 346 /* CommaListExpression */;
    }
    ts.isCommaSequence = isCommaSequence;
    function isOuterExpression(node, kinds) {
        if (kinds === void 0) { kinds = 15 /* All */; }
        switch (node.kind) {
            case 210 /* ParenthesizedExpression */:
                return (kinds & 1 /* Parentheses */) !== 0;
            case 209 /* TypeAssertionExpression */:
            case 227 /* AsExpression */:
                return (kinds & 2 /* TypeAssertions */) !== 0;
            case 228 /* NonNullExpression */:
                return (kinds & 4 /* NonNullAssertions */) !== 0;
            case 345 /* PartiallyEmittedExpression */:
                return (kinds & 8 /* PartiallyEmittedExpressions */) !== 0;
        }
        return false;
    }
    ts.isOuterExpression = isOuterExpression;
    function skipOuterExpressions(node, kinds) {
        if (kinds === void 0) { kinds = 15 /* All */; }
        while (isOuterExpression(node, kinds)) {
            node = node.expression;
        }
        return node;
    }
    ts.skipOuterExpressions = skipOuterExpressions;
    function skipAssertions(node) {
        return skipOuterExpressions(node, 6 /* Assertions */);
    }
    ts.skipAssertions = skipAssertions;
    function startOnNewLine(node) {
        return ts.setStartsOnNewLine(node, /*newLine*/ true);
    }
    ts.startOnNewLine = startOnNewLine;
    function getExternalHelpersModuleName(node) {
        var parseNode = ts.getOriginalNode(node, ts.isSourceFile);
        var emitNode = parseNode && parseNode.emitNode;
        return emitNode && emitNode.externalHelpersModuleName;
    }
    ts.getExternalHelpersModuleName = getExternalHelpersModuleName;
    function hasRecordedExternalHelpers(sourceFile) {
        var parseNode = ts.getOriginalNode(sourceFile, ts.isSourceFile);
        var emitNode = parseNode && parseNode.emitNode;
        return !!emitNode && (!!emitNode.externalHelpersModuleName || !!emitNode.externalHelpers);
    }
    ts.hasRecordedExternalHelpers = hasRecordedExternalHelpers;
    function createExternalHelpersImportDeclarationIfNeeded(nodeFactory, helperFactory, sourceFile, compilerOptions, hasExportStarsToExportValues, hasImportStar, hasImportDefault) {
        if (compilerOptions.importHelpers && ts.isEffectiveExternalModule(sourceFile, compilerOptions)) {
            var namedBindings = void 0;
            var moduleKind = ts.getEmitModuleKind(compilerOptions);
            if (moduleKind >= ts.ModuleKind.ES2015 && moduleKind <= ts.ModuleKind.ESNext) {
                // use named imports
                var helpers = ts.getEmitHelpers(sourceFile);
                if (helpers) {
                    var helperNames = [];
                    for (var _i = 0, helpers_3 = helpers; _i < helpers_3.length; _i++) {
                        var helper = helpers_3[_i];
                        if (!helper.scoped) {
                            var importName = helper.importName;
                            if (importName) {
                                ts.pushIfUnique(helperNames, importName);
                            }
                        }
                    }
                    if (ts.some(helperNames)) {
                        helperNames.sort(ts.compareStringsCaseSensitive);
                        // Alias the imports if the names are used somewhere in the file.
                        // NOTE: We don't need to care about global import collisions as this is a module.
                        namedBindings = nodeFactory.createNamedImports(ts.map(helperNames, function (name) { return ts.isFileLevelUniqueName(sourceFile, name)
                            ? nodeFactory.createImportSpecifier(/*propertyName*/ undefined, nodeFactory.createIdentifier(name))
                            : nodeFactory.createImportSpecifier(nodeFactory.createIdentifier(name), helperFactory.getUnscopedHelperName(name)); }));
                        var parseNode = ts.getOriginalNode(sourceFile, ts.isSourceFile);
                        var emitNode = ts.getOrCreateEmitNode(parseNode);
                        emitNode.externalHelpers = true;
                    }
                }
            }
            else {
                // use a namespace import
                var externalHelpersModuleName = getOrCreateExternalHelpersModuleNameIfNeeded(nodeFactory, sourceFile, compilerOptions, hasExportStarsToExportValues, hasImportStar || hasImportDefault);
                if (externalHelpersModuleName) {
                    namedBindings = nodeFactory.createNamespaceImport(externalHelpersModuleName);
                }
            }
            if (namedBindings) {
                var externalHelpersImportDeclaration = nodeFactory.createImportDeclaration(
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, nodeFactory.createImportClause(/*isTypeOnly*/ false, /*name*/ undefined, namedBindings), nodeFactory.createStringLiteral(ts.externalHelpersModuleNameText));
                ts.addEmitFlags(externalHelpersImportDeclaration, 67108864 /* NeverApplyImportHelper */);
                return externalHelpersImportDeclaration;
            }
        }
    }
    ts.createExternalHelpersImportDeclarationIfNeeded = createExternalHelpersImportDeclarationIfNeeded;
    function getOrCreateExternalHelpersModuleNameIfNeeded(factory, node, compilerOptions, hasExportStarsToExportValues, hasImportStarOrImportDefault) {
        if (compilerOptions.importHelpers && ts.isEffectiveExternalModule(node, compilerOptions)) {
            var externalHelpersModuleName = getExternalHelpersModuleName(node);
            if (externalHelpersModuleName) {
                return externalHelpersModuleName;
            }
            var moduleKind = ts.getEmitModuleKind(compilerOptions);
            var create = (hasExportStarsToExportValues || (compilerOptions.esModuleInterop && hasImportStarOrImportDefault))
                && moduleKind !== ts.ModuleKind.System
                && moduleKind < ts.ModuleKind.ES2015;
            if (!create) {
                var helpers = ts.getEmitHelpers(node);
                if (helpers) {
                    for (var _i = 0, helpers_4 = helpers; _i < helpers_4.length; _i++) {
                        var helper = helpers_4[_i];
                        if (!helper.scoped) {
                            create = true;
                            break;
                        }
                    }
                }
            }
            if (create) {
                var parseNode = ts.getOriginalNode(node, ts.isSourceFile);
                var emitNode = ts.getOrCreateEmitNode(parseNode);
                return emitNode.externalHelpersModuleName || (emitNode.externalHelpersModuleName = factory.createUniqueName(ts.externalHelpersModuleNameText));
            }
        }
    }
    ts.getOrCreateExternalHelpersModuleNameIfNeeded = getOrCreateExternalHelpersModuleNameIfNeeded;
    /**
     * Get the name of that target module from an import or export declaration
     */
    function getLocalNameForExternalImport(factory, node, sourceFile) {
        var namespaceDeclaration = ts.getNamespaceDeclarationNode(node);
        if (namespaceDeclaration && !ts.isDefaultImport(node) && !ts.isExportNamespaceAsDefaultDeclaration(node)) {
            var name = namespaceDeclaration.name;
            return ts.isGeneratedIdentifier(name) ? name : factory.createIdentifier(ts.getSourceTextOfNodeFromSourceFile(sourceFile, name) || ts.idText(name));
        }
        if (node.kind === 264 /* ImportDeclaration */ && node.importClause) {
            return factory.getGeneratedNameForNode(node);
        }
        if (node.kind === 270 /* ExportDeclaration */ && node.moduleSpecifier) {
            return factory.getGeneratedNameForNode(node);
        }
        return undefined;
    }
    ts.getLocalNameForExternalImport = getLocalNameForExternalImport;
    /**
     * Get the name of a target module from an import/export declaration as should be written in the emitted output.
     * The emitted output name can be different from the input if:
     *  1. The module has a /// <amd-module name="<new name>" />
     *  2. --out or --outFile is used, making the name relative to the rootDir
     *  3- The containing SourceFile has an entry in renamedDependencies for the import as requested by some module loaders (e.g. System).
     * Otherwise, a new StringLiteral node representing the module name will be returned.
     */
    function getExternalModuleNameLiteral(factory, importNode, sourceFile, host, resolver, compilerOptions) {
        var moduleName = ts.getExternalModuleName(importNode);
        if (moduleName && ts.isStringLiteral(moduleName)) {
            return tryGetModuleNameFromDeclaration(importNode, host, factory, resolver, compilerOptions)
                || tryRenameExternalModule(factory, moduleName, sourceFile)
                || factory.cloneNode(moduleName);
        }
        return undefined;
    }
    ts.getExternalModuleNameLiteral = getExternalModuleNameLiteral;
    /**
     * Some bundlers (SystemJS builder) sometimes want to rename dependencies.
     * Here we check if alternative name was provided for a given moduleName and return it if possible.
     */
    function tryRenameExternalModule(factory, moduleName, sourceFile) {
        var rename = sourceFile.renamedDependencies && sourceFile.renamedDependencies.get(moduleName.text);
        return rename ? factory.createStringLiteral(rename) : undefined;
    }
    /**
     * Get the name of a module as should be written in the emitted output.
     * The emitted output name can be different from the input if:
     *  1. The module has a /// <amd-module name="<new name>" />
     *  2. --out or --outFile is used, making the name relative to the rootDir
     * Otherwise, a new StringLiteral node representing the module name will be returned.
     */
    function tryGetModuleNameFromFile(factory, file, host, options) {
        if (!file) {
            return undefined;
        }
        if (file.moduleName) {
            return factory.createStringLiteral(file.moduleName);
        }
        if (!file.isDeclarationFile && ts.outFile(options)) {
            re