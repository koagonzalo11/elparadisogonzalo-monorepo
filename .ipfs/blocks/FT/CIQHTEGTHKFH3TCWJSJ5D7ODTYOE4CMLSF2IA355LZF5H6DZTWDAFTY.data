
                var source = sourceParams[i];
                var target = targetParams[i];
                if (source === target)
                    continue;
                // We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`
                if (!isTypeIdenticalTo(getConstraintFromTypeParameter(source) || unknownType, instantiateType(getConstraintFromTypeParameter(target) || unknownType, mapper)))
                    return false;
                // We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.
                // It might make sense to combine these defaults in the future, but doing so intelligently requires knowing
                // if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type)
                // and, since it's just an inference _default_, just picking one arbitrarily works OK.
            }
            return true;
        }
        function combineUnionThisParam(left, right, mapper) {
            if (!left || !right) {
                return left || right;
            }
            // A signature `this` type might be a read or a write position... It's very possible that it should be invariant
            // and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
            // permissive when calling, for now, we'll intersect the `this` types just like we do for param types in union signatures.
            var thisType = getIntersectionType([getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)]);
            return createSymbolWithType(left, thisType);
        }
        function combineUnionParameters(left, right, mapper) {
            var leftCount = getParameterCount(left);
            var rightCount = getParameterCount(right);
            var longest = leftCount >= rightCount ? left : right;
            var shorter = longest === left ? right : left;
            var longestCount = longest === left ? leftCount : rightCount;
            var eitherHasEffectiveRest = (hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right));
            var needsExtraRestElement = eitherHasEffectiveRest && !hasEffectiveRestParameter(longest);
            var params = new Array(longestCount + (needsExtraRestElement ? 1 : 0));
            for (var i = 0; i < longestCount; i++) {
                var longestParamType = tryGetTypeAtPosition(longest, i);
                if (longest === right) {
                    longestParamType = instantiateType(longestParamType, mapper);
                }
                var shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;
                if (shorter === right) {
                    shorterParamType = instantiateType(shorterParamType, mapper);
                }
                var unionParamType = getIntersectionType([longestParamType, shorterParamType]);
                var isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);
                var isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);
                var leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);
                var rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);
                var paramName = leftName === rightName ? leftName :
                    !leftName ? rightName :
                        !rightName ? leftName :
                            undefined;
                var paramSymbol = createSymbol(1 /* FunctionScopedVariable */ | (isOptional && !isRestParam ? 16777216 /* Optional */ : 0), paramName || "arg" + i);
                paramSymbol.type = isRestParam ? createArrayType(unionParamType) : unionParamType;
                params[i] = paramSymbol;
            }
            if (needsExtraRestElement) {
                var restParamSymbol = createSymbol(1 /* FunctionScopedVariable */, "args");
                restParamSymbol.type = createArrayType(getTypeAtPosition(shorter, longestCount));
                if (shorter === right) {
                    restParamSymbol.type = instantiateType(restParamSymbol.type, mapper);
                }
                params[longestCount] = restParamSymbol;
            }
            return params;
        }
        function combineSignaturesOfUnionMembers(left, right) {
            var typeParams = left.typeParameters || right.typeParameters;
            var paramMapper;
            if (left.typeParameters && right.typeParameters) {
                paramMapper = createTypeMapper(right.typeParameters, left.typeParameters);
                // We just use the type parameter defaults from the first signature
            }
            var declaration = left.declaration;
            var params = combineUnionParameters(left, right, paramMapper);
            var thisParam = combineUnionThisParam(left.thisParameter, right.thisParameter, paramMapper);
            var minArgCount = Math.max(left.minArgumentCount, right.minArgumentCount);
            var result = createSignature(declaration, typeParams, thisParam, params, 
            /*resolvedReturnType*/ undefined, 
            /*resolvedTypePredicate*/ undefined, minArgCount, (left.flags | right.flags) & 39 /* PropagatingFlags */);
            result.compositeKind = 1048576 /* Union */;
            result.compositeSignatures = ts.concatenate(left.compositeKind !== 2097152 /* Intersection */ && left.compositeSignatures || [left], [right]);
            if (paramMapper) {
                result.mapper = left.compositeKind !== 2097152 /* Intersection */ && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper;
            }
            return result;
        }
        function getUnionIndexInfos(types) {
            var sourceInfos = getIndexInfosOfType(types[0]);
            if (sourceInfos) {
                var result = [];
                var _loop_11 = function (info) {
                    var indexType = info.keyType;
                    if (ts.every(types, function (t) { return !!getIndexInfoOfType(t, indexType); })) {
                        result.push(createIndexInfo(indexType, getUnionType(ts.map(types, function (t) { return getIndexTypeOfType(t, indexType); })), ts.some(types, function (t) { return getIndexInfoOfType(t, indexType).isReadonly; })));
                    }
                };
                for (var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++) {
                    var info = sourceInfos_1[_i];
                    _loop_11(info);
                }
                return result;
            }
            return ts.emptyArray;
        }
        function resolveUnionTypeMembers(type) {
            // The members and properties collections are empty for union types. To get all properties of a union
            // type use getPropertiesOfType (only the language service uses this).
            var callSignatures = getUnionSignatures(ts.map(type.types, function (t) { return t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(t, 0 /* Call */); }));
            var constructSignatures = getUnionSignatures(ts.map(type.types, function (t) { return getSignaturesOfType(t, 1 /* Construct */); }));
            var indexInfos = getUnionIndexInfos(type.types);
            setStructuredTypeMembers(type, emptySymbols, callSignatures, constructSignatures, indexInfos);
        }
        function intersectTypes(type1, type2) {
            return !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]);
        }
        function findMixins(types) {
            var constructorTypeCount = ts.countWhere(types, function (t) { return getSignaturesOfType(t, 1 /* Construct */).length > 0; });
            var mixinFlags = ts.map(types, isMixinConstructorType);
            if (constructorTypeCount > 0 && constructorTypeCount === ts.countWhere(mixinFlags, function (b) { return b; })) {
                var firstMixinIndex = mixinFlags.indexOf(/*searchElement*/ true);
                mixinFlags[firstMixinIndex] = false;
            }
            return mixinFlags;
        }
        function includeMixinType(type, types, mixinFlags, index) {
            var mixedTypes = [];
            for (var i = 0; i < types.length; i++) {
                if (i === index) {
                    mixedTypes.push(type);
                }
                else if (mixinFlags[i]) {
                    mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], 1 /* Construct */)[0]));
                }
            }
            return getIntersectionType(mixedTypes);
        }
        function resolveIntersectionTypeMembers(type) {
            // The members and properties collections are empty for intersection types. To get all properties of an
            // intersection type use getPropertiesOfType (only the language service uses this).
            var callSignatures;
            var constructSignatures;
            var indexInfos;
            var types = type.types;
            var mixinFlags = findMixins(types);
            var mixinCount = ts.countWhere(mixinFlags, function (b) { return b; });
            var _loop_12 = function (i) {
                var t = type.types[i];
                // When an intersection type contains mixin constructor types, the construct signatures from
                // those types are discarded and their return types are mixed into the return types of all
                // other construct signatures in the intersection type. For example, the intersection type
                // '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature
                // 'new(s: string) => A & B'.
                if (!mixinFlags[i]) {
                    var signatures = getSignaturesOfType(t, 1 /* Construct */);
                    if (signatures.length && mixinCount > 0) {
                        signatures = ts.map(signatures, function (s) {
                            var clone = cloneSignature(s);
                            clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i);
                            return clone;
                        });
                    }
                    constructSignatures = appendSignatures(constructSignatures, signatures);
                }
                callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, 0 /* Call */));
                indexInfos = ts.reduceLeft(getIndexInfosOfType(t), function (infos, newInfo) { return appendIndexInfo(infos, newInfo, /*union*/ false); }, indexInfos);
            };
            for (var i = 0; i < types.length; i++) {
                _loop_12(i);
            }
            setStructuredTypeMembers(type, emptySymbols, callSignatures || ts.emptyArray, constructSignatures || ts.emptyArray, indexInfos || ts.emptyArray);
        }
        function appendSignatures(signatures, newSignatures) {
            var _loop_13 = function (sig) {
                if (!signatures || ts.every(signatures, function (s) { return !compareSignaturesIdentical(s, sig, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false, compareTypesIdentical); })) {
                    signatures = ts.append(signatures, sig);
                }
            };
            for (var _i = 0, newSignatures_1 = newSignatures; _i < newSignatures_1.length; _i++) {
                var sig = newSignatures_1[_i];
                _loop_13(sig);
            }
            return signatures;
        }
        function appendIndexInfo(indexInfos, newInfo, union) {
            if (indexInfos) {
                for (var i = 0; i < indexInfos.length; i++) {
                    var info = indexInfos[i];
                    if (info.keyType === newInfo.keyType) {
                        indexInfos[i] = createIndexInfo(info.keyType, union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]), union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly);
                        return indexInfos;
                    }
                }
            }
            return ts.append(indexInfos, newInfo);
        }
        /**
         * Converts an AnonymousType to a ResolvedType.
         */
        function resolveAnonymousTypeMembers(type) {
            var symbol = getMergedSymbol(type.symbol);
            if (type.target) {
                setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                var members = createInstantiatedSymbolTable(getPropertiesOfObjectType(type.target), type.mapper, /*mappingThisOnly*/ false);
                var callSignatures = instantiateSignatures(getSignaturesOfType(type.target, 0 /* Call */), type.mapper);
                var constructSignatures = instantiateSignatures(getSignaturesOfType(type.target, 1 /* Construct */), type.mapper);
                var indexInfos = instantiateIndexInfos(getIndexInfosOfType(type.target), type.mapper);
                setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
            }
            else if (symbol.flags & 2048 /* TypeLiteral */) {
                setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                var members = getMembersOfSymbol(symbol);
                var callSignatures = getSignaturesOfSymbol(members.get("__call" /* Call */));
                var constructSignatures = getSignaturesOfSymbol(members.get("__new" /* New */));
                var indexInfos = getIndexInfosOfSymbol(symbol);
                setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
            }
            else {
                // Combinations of function, class, enum and module
                var members = emptySymbols;
                var indexInfos = void 0;
                if (symbol.exports) {
                    members = getExportsOfSymbol(symbol);
                    if (symbol === globalThisSymbol) {
                        var varsOnly_1 = new ts.Map();
                        members.forEach(function (p) {
                            if (!(p.flags & 418 /* BlockScoped */)) {
                                varsOnly_1.set(p.escapedName, p);
                            }
                        });
                        members = varsOnly_1;
                    }
                }
                var baseConstructorIndexInfo = void 0;
                setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                if (symbol.flags & 32 /* Class */) {
                    var classType = getDeclaredTypeOfClassOrInterface(symbol);
                    var baseConstructorType = getBaseConstructorTypeOfClass(classType);
                    if (baseConstructorType.flags & (524288 /* Object */ | 2097152 /* Intersection */ | 8650752 /* TypeVariable */)) {
                        members = ts.createSymbolTable(getNamedOrIndexSignatureMembers(members));
                        addInheritedMembers(members, getPropertiesOfType(baseConstructorType));
                    }
                    else if (baseConstructorType === anyType) {
                        baseConstructorIndexInfo = createIndexInfo(stringType, anyType, /*isReadonly*/ false);
                    }
                }
                var indexSymbol = getIndexSymbolFromSymbolTable(members);
                if (indexSymbol) {
                    indexInfos = getIndexInfosOfIndexSymbol(indexSymbol);
                }
                else {
                    if (baseConstructorIndexInfo) {
                        indexInfos = ts.append(indexInfos, baseConstructorIndexInfo);
                    }
                    if (symbol.flags & 384 /* Enum */ && (getDeclaredTypeOfSymbol(symbol).flags & 32 /* Enum */ ||
                        ts.some(type.properties, function (prop) { return !!(getTypeOfSymbol(prop).flags & 296 /* NumberLike */); }))) {
                        indexInfos = ts.append(indexInfos, enumNumberIndexInfo);
                    }
                }
                setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, indexInfos || ts.emptyArray);
                // We resolve the members before computing the signatures because a signature may use
                // typeof with a qualified name expression that circularly references the type we are
                // in the process of resolving (see issue #6072). The temporarily empty signature list
                // will never be observed because a qualified name can't reference signatures.
                if (symbol.flags & (16 /* Function */ | 8192 /* Method */)) {
                    type.callSignatures = getSignaturesOfSymbol(symbol);
                }
                // And likewise for construct signatures for classes
                if (symbol.flags & 32 /* Class */) {
                    var classType_1 = getDeclaredTypeOfClassOrInterface(symbol);
                    var constructSignatures = symbol.members ? getSignaturesOfSymbol(symbol.members.get("__constructor" /* Constructor */)) : ts.emptyArray;
                    if (symbol.flags & 16 /* Function */) {
                        constructSignatures = ts.addRange(constructSignatures.slice(), ts.mapDefined(type.callSignatures, function (sig) { return isJSConstructor(sig.declaration) ?
                            createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType_1, /*resolvedTypePredicate*/ undefined, sig.minArgumentCount, sig.flags & 39 /* PropagatingFlags */) :
                            undefined; }));
                    }
                    if (!constructSignatures.length) {
                        constructSignatures = getDefaultConstructSignatures(classType_1);
                    }
                    type.constructSignatures = constructSignatures;
                }
            }
        }
        function replaceIndexedAccess(instantiable, type, replacement) {
            // map type.indexType to 0
            // map type.objectType to `[TReplacement]`
            // thus making the indexed access `[TReplacement][0]` or `TReplacement`
            return instantiateType(instantiable, createTypeMapper([type.indexType, type.objectType], [getNumberLiteralType(0), createTupleType([replacement])]));
        }
        function resolveReverseMappedTypeMembers(type) {
            var indexInfo = getIndexInfoOfType(type.source, stringType);
            var modifiers = getMappedTypeModifiers(type.mappedType);
            var readonlyMask = modifiers & 1 /* IncludeReadonly */ ? false : true;
            var optionalMask = modifiers & 4 /* IncludeOptional */ ? 0 : 16777216 /* Optional */;
            var indexInfos = indexInfo ? [createIndexInfo(stringType, inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType), readonlyMask && indexInfo.isReadonly)] : ts.emptyArray;
            var members = ts.createSymbolTable();
            for (var _i = 0, _a = getPropertiesOfType(type.source); _i < _a.length; _i++) {
                var prop = _a[_i];
                var checkFlags = 8192 /* ReverseMapped */ | (readonlyMask && isReadonlySymbol(prop) ? 8 /* Readonly */ : 0);
                var inferredProp = createSymbol(4 /* Property */ | prop.flags & optionalMask, prop.escapedName, checkFlags);
                inferredProp.declarations = prop.declarations;
                inferredProp.nameType = getSymbolLinks(prop).nameType;
                inferredProp.propertyType = getTypeOfSymbol(prop);
                if (type.constraintType.type.flags & 8388608 /* IndexedAccess */
                    && type.constraintType.type.objectType.flags & 262144 /* TypeParameter */
                    && type.constraintType.type.indexType.flags & 262144 /* TypeParameter */) {
                    // A reverse mapping of `{[K in keyof T[K_1]]: T[K_1]}` is the same as that of `{[K in keyof T]: T}`, since all we care about is
                    // inferring to the "type parameter" (or indexed access) shared by the constraint and template. So, to reduce the number of
                    // type identities produced, we simplify such indexed access occurences
                    var newTypeParam = type.constraintType.type.objectType;
                    var newMappedType = replaceIndexedAccess(type.mappedType, type.constraintType.type, newTypeParam);
                    inferredProp.mappedType = newMappedType;
                    inferredProp.constraintType = getIndexType(newTypeParam);
                }
                else {
                    inferredProp.mappedType = type.mappedType;
                    inferredProp.constraintType = type.constraintType;
                }
                members.set(prop.escapedName, inferredProp);
            }
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, indexInfos);
        }
        // Return the lower bound of the key type in a mapped type. Intuitively, the lower
        // bound includes those keys that are known to always be present, for example because
        // because of constraints on type parameters (e.g. 'keyof T' for a constrained T).
        function getLowerBoundOfKeyType(type) {
            if (type.flags & 4194304 /* Index */) {
                var t = getApparentType(type.type);
                return isGenericTupleType(t) ? getKnownKeysOfTupleType(t) : getIndexType(t);
            }
            if (type.flags & 16777216 /* Conditional */) {
                if (type.root.isDistributive) {
                    var checkType = type.checkType;
                    var constraint = getLowerBoundOfKeyType(checkType);
                    if (constraint !== checkType) {
                        return getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper));
                    }
                }
                return type;
            }
            if (type.flags & 1048576 /* Union */) {
                return mapType(type, getLowerBoundOfKeyType);
            }
            if (type.flags & 2097152 /* Intersection */) {
                return getIntersectionType(ts.sameMap(type.types, getLowerBoundOfKeyType));
            }
            return type;
        }
        function getIsLateCheckFlag(s) {
            return ts.getCheckFlags(s) & 4096 /* Late */;
        }
        /** Resolve the members of a mapped type { [P in K]: T } */
        function resolveMappedTypeMembers(type) {
            var members = ts.createSymbolTable();
            var indexInfos;
            // Resolve upfront such that recursive references see an empty object type.
            setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            // In { [P in K]: T }, we refer to P as the type parameter type, K as the constraint type,
            // and T as the template type.
            var typeParameter = getTypeParameterFromMappedType(type);
            var constraintType = getConstraintTypeFromMappedType(type);
            var nameType = getNameTypeFromMappedType(type.target || type);
            var templateType = getTemplateTypeFromMappedType(type.target || type);
            var modifiersType = getApparentType(getModifiersTypeFromMappedType(type)); // The 'T' in 'keyof T'
            var templateModifiers = getMappedTypeModifiers(type);
            var include = keyofStringsOnly ? 128 /* StringLiteral */ : 8576 /* StringOrNumberLiteralOrUnique */;
            if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                // We have a { [P in keyof T]: X }
                for (var _i = 0, _a = getPropertiesOfType(modifiersType); _i < _a.length; _i++) {
                    var prop = _a[_i];
                    addMemberForKeyType(getLiteralTypeFromProperty(prop, include));
                }
                if (modifiersType.flags & 1 /* Any */) {
                    addMemberForKeyType(stringType);
                }
                else {
                    for (var _b = 0, _c = getIndexInfosOfType(modifiersType); _b < _c.length; _b++) {
                        var info = _c[_b];
                        if (!keyofStringsOnly || info.keyType.flags & (4 /* String */ | 134217728 /* TemplateLiteral */)) {
                            addMemberForKeyType(info.keyType);
                        }
                    }
                }
            }
            else {
                forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
            }
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, indexInfos || ts.emptyArray);
            function addMemberForKeyType(keyType) {
                var propNameType = nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType;
                forEachType(propNameType, function (t) { return addMemberForKeyTypeWorker(keyType, t); });
            }
            function addMemberForKeyTypeWorker(keyType, propNameType) {
                // If the current iteration type constituent is a string literal type, create a property.
                // Otherwise, for type string create a string index signature.
                if (isTypeUsableAsPropertyName(propNameType)) {
                    var propName = getPropertyNameFromType(propNameType);
                    // String enum members from separate enums with identical values
                    // are distinct types with the same property name. Make the resulting
                    // property symbol's name type be the union of those enum member types.
                    var existingProp = members.get(propName);
                    if (existingProp) {
                        existingProp.nameType = getUnionType([existingProp.nameType, propNameType]);
                        existingProp.keyType = getUnionType([existingProp.keyType, keyType]);
                    }
                    else {
                        var modifiersProp = isTypeUsableAsPropertyName(keyType) ? getPropertyOfType(modifiersType, getPropertyNameFromType(keyType)) : undefined;
                        var isOptional = !!(templateModifiers & 4 /* IncludeOptional */ ||
                            !(templateModifiers & 8 /* ExcludeOptional */) && modifiersProp && modifiersProp.flags & 16777216 /* Optional */);
                        var isReadonly = !!(templateModifiers & 1 /* IncludeReadonly */ ||
                            !(templateModifiers & 2 /* ExcludeReadonly */) && modifiersProp && isReadonlySymbol(modifiersProp));
                        var stripOptional = strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags & 16777216 /* Optional */;
                        var lateFlag = modifiersProp ? getIsLateCheckFlag(modifiersProp) : 0;
                        var prop = createSymbol(4 /* Property */ | (isOptional ? 16777216 /* Optional */ : 0), propName, lateFlag | 262144 /* Mapped */ | (isReadonly ? 8 /* Readonly */ : 0) | (stripOptional ? 524288 /* StripOptional */ : 0));
                        prop.mappedType = type;
                        prop.nameType = propNameType;
                        prop.keyType = keyType;
                        if (modifiersProp) {
                            prop.syntheticOrigin = modifiersProp;
                            // If the mapped type has an `as XXX` clause, the property name likely won't match the declaration name and
                            // multiple properties may map to the same name. Thus, we attach no declarations to the symbol.
                            prop.declarations = nameType ? undefined : modifiersProp.declarations;
                        }
                        members.set(propName, prop);
                    }
                }
                else if (isValidIndexKeyType(propNameType) || propNameType.flags & (1 /* Any */ | 32 /* Enum */)) {
                    var indexKeyType = propNameType.flags & (1 /* Any */ | 4 /* String */) ? stringType :
                        propNameType.flags & (8 /* Number */ | 32 /* Enum */) ? numberType :
                            propNameType;
                    var propType = instantiateType(templateType, appendTypeMapping(type.mapper, typeParameter, keyType));
                    var indexInfo = createIndexInfo(indexKeyType, propType, !!(templateModifiers & 1 /* IncludeReadonly */));
                    indexInfos = appendIndexInfo(indexInfos, indexInfo, /*union*/ true);
                }
            }
        }
        function getTypeOfMappedSymbol(symbol) {
            if (!symbol.type) {
                var mappedType = symbol.mappedType;
                if (!pushTypeResolution(symbol, 0 /* Type */)) {
                    mappedType.containsError = true;
                    return errorType;
                }
                var templateType = getTemplateTypeFromMappedType(mappedType.target || mappedType);
                var mapper = appendTypeMapping(mappedType.mapper, getTypeParameterFromMappedType(mappedType), symbol.keyType);
                var propType = instantiateType(templateType, mapper);
                // When creating an optional property in strictNullChecks mode, if 'undefined' isn't assignable to the
                // type, we include 'undefined' in the type. Similarly, when creating a non-optional property in strictNullChecks
                // mode, if the underlying property is optional we remove 'undefined' from the type.
                var type = strictNullChecks && symbol.flags & 16777216 /* Optional */ && !maybeTypeOfKind(propType, 32768 /* Undefined */ | 16384 /* Void */) ? getOptionalType(propType, /*isProperty*/ true) :
                    symbol.checkFlags & 524288 /* StripOptional */ ? removeMissingOrUndefinedType(propType) :
                        propType;
                if (!popTypeResolution()) {
                    error(currentNode, ts.Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbolToString(symbol), typeToString(mappedType));
                    type = errorType;
                }
                symbol.type = type;
            }
            return symbol.type;
        }
        function getTypeParameterFromMappedType(type) {
            return type.typeParameter ||
                (type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfNode(type.declaration.typeParameter)));
        }
        function getConstraintTypeFromMappedType(type) {
            return type.constraintType ||
                (type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType);
        }
        function getNameTypeFromMappedType(type) {
            return type.declaration.nameType ?
                type.nameType || (type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper)) :
                undefined;
        }
        function getTemplateTypeFromMappedType(type) {
            return type.templateType ||
                (type.templateType = type.declaration.type ?
                    instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty*/ true, !!(getMappedTypeModifiers(type) & 4 /* IncludeOptional */)), type.mapper) :
                    errorType);
        }
        function getConstraintDeclarationForMappedType(type) {
            return ts.getEffectiveConstraintOfTypeParameter(type.declaration.typeParameter);
        }
        function isMappedTypeWithKeyofConstraintDeclaration(type) {
            var constraintDeclaration = getConstraintDeclarationForMappedType(type); // TODO: GH#18217
            return constraintDeclaration.kind === 191 /* TypeOperator */ &&
                constraintDeclaration.operator === 139 /* KeyOfKeyword */;
        }
        function getModifiersTypeFromMappedType(type) {
            if (!type.modifiersType) {
                if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                    // If the constraint declaration is a 'keyof T' node, the modifiers type is T. We check
                    // AST nodes here because, when T is a non-generic type, the logic below eagerly resolves
                    // 'keyof T' to a literal union type and we can't recover T from that type.
                    type.modifiersType = instantiateType(getTypeFromTypeNode(getConstraintDeclarationForMappedType(type).type), type.mapper);
                }
                else {
                    // Otherwise, get the declared constraint type, and if the constraint type is a type parameter,
                    // get the constraint of that type parameter. If the resulting type is an indexed type 'keyof T',
                    // the modifiers type is T. Otherwise, the modifiers type is unknown.
                    var declaredType = getTypeFromMappedTypeNode(type.declaration);
                    var constraint = getConstraintTypeFromMappedType(declaredType);
                    var extendedConstraint = constraint && constraint.flags & 262144 /* TypeParameter */ ? getConstraintOfTypeParameter(constraint) : constraint;
                    type.modifiersType = extendedConstraint && extendedConstraint.flags & 4194304 /* Index */ ? instantiateType(extendedConstraint.type, type.mapper) : unknownType;
                }
            }
            return type.modifiersType;
        }
        function getMappedTypeModifiers(type) {
            var declaration = type.declaration;
            return (declaration.readonlyToken ? declaration.readonlyToken.kind === 40 /* MinusToken */ ? 2 /* ExcludeReadonly */ : 1 /* IncludeReadonly */ : 0) |
                (declaration.questionToken ? declaration.questionToken.kind === 40 /* MinusToken */ ? 8 /* ExcludeOptional */ : 4 /* IncludeOptional */ : 0);
        }
        function getMappedTypeOptionality(type) {
            var modifiers = getMappedTypeModifiers(type);
            return modifiers & 8 /* ExcludeOptional */ ? -1 : modifiers & 4 /* IncludeOptional */ ? 1 : 0;
        }
        function getCombinedMappedTypeOptionality(type) {
            var optionality = getMappedTypeOptionality(type);
            var modifiersType = getModifiersTypeFromMappedType(type);
            return optionality || (isGenericMappedType(modifiersType) ? getMappedTypeOptionality(modifiersType) : 0);
        }
        function isPartialMappedType(type) {
            return !!(ts.getObjectFlags(type) & 32 /* Mapped */ && getMappedTypeModifiers(type) & 4 /* IncludeOptional */);
        }
        function isGenericMappedType(type) {
            return !!(ts.getObjectFlags(type) & 32 /* Mapped */) && isGenericIndexType(getConstraintTypeFromMappedType(type));
        }
        function resolveStructuredTypeMembers(type) {
            if (!type.members) {
                if (type.flags & 524288 /* Object */) {
                    if (type.objectFlags & 4 /* Reference */) {
                        resolveTypeReferenceMembers(type);
                    }
                    else if (type.objectFlags & 3 /* ClassOrInterface */) {
                        resolveClassOrInterfaceMembers(type);
                    }
                    else if (type.objectFlags & 1024 /* ReverseMapped */) {
                        resolveReverseMappedTypeMembers(type);
                    }
                    else if (type.objectFlags & 16 /* Anonymous */) {
                        resolveAnonymousTypeMembers(type);
                    }
                    else if (type.objectFlags & 32 /* Mapped */) {
                        resolveMappedTypeMembers(type);
                    }
                }
                else if (type.flags & 1048576 /* Union */) {
                    resolveUnionTypeMembers(type);
                }
                else if (type.flags & 2097152 /* Intersection */) {
                    resolveIntersectionTypeMembers(type);
                }
            }
            return type;
        }
        /** Return properties of an object type or an empty array for other types */
        function getPropertiesOfObjectType(type) {
            if (type.flags & 524288 /* Object */) {
                return resolveStructuredTypeMembers(type).properties;
            }
            return ts.emptyArray;
        }
        /** If the given type is an object type and that type has a property by the given name,
         * return the symbol for that property. Otherwise return undefined.
         */
        function getPropertyOfObjectType(type, name) {
            if (type.flags & 524288 /* Object */) {
                var resolved = resolveStructuredTypeMembers(type);
                var symbol = resolved.members.get(name);
                if (symbol && symbolIsValue(symbol)) {
                    return symbol;
                }
            }
        }
        function getPropertiesOfUnionOrIntersectionType(type) {
            if (!type.resolvedProperties) {
                var members = ts.createSymbolTable();
                for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
                    var current = _a[_i];
                    for (var _b = 0, _c = getPropertiesOfType(current); _b < _c.length; _b++) {
                        var prop = _c[_b];
                        if (!members.has(prop.escapedName)) {
                            var combinedProp = getPropertyOfUnionOrIntersectionType(type, prop.escapedName);
                            if (combinedProp) {
                                members.set(prop.escapedName, combinedProp);
                            }
                        }
                    }
                    // The properties of a union type are those that are present in all constituent types, so
                    // we only need to check the properties of the first type without index signature
                    if (type.flags & 1048576 /* Union */ && getIndexInfosOfType(current).length === 0) {
                        break;
                    }
                }
                type.resolvedProperties = getNamedMembers(members);
            }
            return type.resolvedProperties;
        }
        function getPropertiesOfType(type) {
            type = getReducedApparentType(type);
            return type.flags & 3145728 /* UnionOrIntersection */ ?
                getPropertiesOfUnionOrIntersectionType(type) :
                getPropertiesOfObjectType(type);
        }
        function isTypeInvalidDueToUnionDiscriminant(contextualType, obj) {
            var list = obj.properties;
            return list.some(function (property) {
                var nameType = property.name && getLiteralTypeFromPropertyName(property.name);
                var name = nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;
                var expected = name === undefined ? undefined : getTypeOfPropertyOfType(contextualType, name);
                return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected);
            });
        }
        function getAllPossiblePropertiesOfTypes(types) {
            var unionType = getUnionType(types);
            if (!(unionType.flags & 1048576 /* Union */)) {
                return getAugmentedPropertiesOfType(unionType);
            }
            var props = ts.createSymbolTable();
            for (var _i = 0, types_4 = types; _i < types_4.length; _i++) {
                var memberType = types_4[_i];
                for (var _a = 0, _b = getAugmentedPropertiesOfType(memberType); _a < _b.length; _a++) {
                    var escapedName = _b[_a].escapedName;
                    if (!props.has(escapedName)) {
                        var prop = createUnionOrIntersectionProperty(unionType, escapedName);
                        // May be undefined if the property is private
                        if (prop)
                            props.set(escapedName, prop);
                    }
                }
            }
            return ts.arrayFrom(props.values());
        }
        function getConstraintOfType(type) {
            return type.flags & 262144 /* TypeParameter */ ? getConstraintOfTypeParameter(type) :
                type.flags & 8388608 /* IndexedAccess */ ? getConstraintOfIndexedAccess(type) :
                    type.flags & 16777216 /* Conditional */ ? getConstraintOfConditionalType(type) :
                        getBaseConstraintOfType(type);
        }
        function getConstraintOfTypeParameter(typeParameter) {
            return hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : undefined;
        }
        function getConstraintOfIndexedAccess(type) {
            return hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(type) : undefined;
        }
        function getSimplifiedTypeOrConstraint(type) {
            var simplified = getSimplifiedType(type, /*writing*/ false);
            return simplified !== type ? simplified : getConstraintOfType(type);
        }
        function getConstraintFromIndexedAccess(type) {
            var indexConstraint = getSimplifiedTypeOrConstraint(type.indexType);
            if (indexConstraint && indexConstraint !== type.indexType) {
                var indexedAccess = getIndexedAccessTypeOrUndefined(type.objectType, indexConstraint, type.accessFlags);
                if (indexedAccess) {
                    return indexedAccess;
                }
            }
            var objectConstraint = getSimplifiedTypeOrConstraint(type.objectType);
            if (objectConstraint && objectConstraint !== type.objectType) {
                return getIndexedAccessTypeOrUndefined(objectConstraint, type.indexType, type.accessFlags);
            }
            return undefined;
        }
        function getDefaultConstraintOfConditionalType(type) {
            if (!type.resolvedDefaultConstraint) {
                // An `any` branch of a conditional type would normally be viral - specifically, without special handling here,
                // a conditional type with a single branch of type `any` would be assignable to anything, since it's constraint would simplify to
                // just `any`. This result is _usually_ unwanted - so instead here we elide an `any` branch from the constraint type,
                // in effect treating `any` like `never` rather than `unknown` in this location.
                var trueConstraint = getInferredTrueTypeFromConditionalType(type);
                var falseConstraint = getFalseTypeFromConditionalType(type);
                type.resolvedDefaultConstraint = isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]);
            }
            return type.resolvedDefaultConstraint;
        }
        function getConstraintOfDistributiveConditionalType(type) {
            // Check if we have a conditional type of the form 'T extends U ? X : Y', where T is a constrained
            // type parameter. If so, create an instantiation of the conditional type where T is replaced
            // with its constraint. We do this because if the constraint is a union type it will be distributed
            // over the conditional type and possibly reduced. For example, 'T extends undefined ? never : T'
            // removes 'undefined' from T.
            // We skip returning a distributive constraint for a restrictive instantiation of a conditional type
            // as the constraint for all type params (check type included) have been replace with `unknown`, which
            // is going to produce even more false positive/negative results than the distribute constraint already does.
            // Please note: the distributive constraint is a kludge for emulating what a negated type could to do filter
            // a union - once negated types exist and are applied to the conditional false branch, this "constraint"
            // likely doesn't need to exist.
            if (type.root.isDistributive && type.restrictiveInstantiation !== type) {
                var simplified = getSimplifiedType(type.checkType, /*writing*/ false);
                var constraint = simplified === type.checkType ? getConstraintOfType(simplified) : simplified;
                if (constraint && constraint !== type.checkType) {
                    var instantiated = getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper));
                    if (!(instantiated.flags & 131072 /* Never */)) {
                        return instantiated;
                    }
                }
            }
            return undefined;
        }
        function getConstraintFromConditionalType(type) {
            return getConstraintOfDistributiveConditionalType(type) || getDefaultConstraintOfConditionalType(type);
        }
        function getConstraintOfConditionalType(type) {
            return hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(type) : undefined;
        }
        function getEffectiveConstraintOfIntersection(types, targetIsUnion) {
            var constraints;
            var hasDisjointDomainType = false;
            for (var _i = 0, types_5 = types; _i < types_5.length; _i++) {
                var t = types_5[_i];
                if (t.flags & 465829888 /* Instantiable */) {
                    // We keep following constraints as long as we have an instantiable type that is known
                    // not to be circular or infinite (hence we stop on index access types).
                    var constraint = getConstraintOfType(t);
                    while (constraint && constraint.flags & (262144 /* TypeParameter */ | 4194304 /* Index */ | 16777216 /* Conditional */)) {
                        constraint = getConstraintOfType(constraint);
                    }
                    if (constraint) {
                        constraints = ts.append(constraints, constraint);
                        if (targetIsUnion) {
                            constraints = ts.append(constraints, t);
                        }
                    }
                }
                else if (t.flags & 469892092 /* DisjointDomains */) {
                    hasDisjointDomainType = true;
                }
            }
            // If the target is a union type or if we are intersecting with types belonging to one of the
            // disjoint domains, we may end up producing a constraint that hasn't been examined before.
            if (constraints && (targetIsUnion || hasDisjointDomainType)) {
                if (hasDisjointDomainType) {
                    // We add any types belong to one of the disjoint domains because they might cause the final
                    // intersection operation to reduce the union constraints.
                    for (var _a = 0, types_6 = types; _a < types_6.length; _a++) {
                        var t = types_6[_a];
                        if (t.flags & 469892092 /* DisjointDomains */) {
                            constraints = ts.append(constraints, t);
                        }
                    }
                }
                return getIntersectionType(constraints);
            }
            return undefined;
        }
        function getBaseConstraintOfType(type) {
            if (type.flags & (58982400 /* InstantiableNonPrimitive */ | 3145728 /* UnionOrIntersection */ | 134217728 /* TemplateLiteral */ | 268435456 /* StringMapping */)) {
                var constraint = getResolvedBaseConstraint(type);
                return constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : undefined;
            }
            return type.flags & 4194304 /* Index */ ? keyofConstraintType : undefined;
        }
        /**
         * This is similar to `getBaseConstraintOfType` except it returns the input type if there's no base constraint, instead of `undefined`
         * It also doesn't map indexes to `string`, as where this is used this would be unneeded (and likely undesirable)
         */
        function getBaseConstraintOrType(type) {
            return getBaseConstraintOfType(type) || type;
        }
        function hasNonCircularBaseConstraint(type) {
            return getResolvedBaseConstraint(type) !== circularConstraintType;
        }
        /**
         * Return the resolved base constraint of a type variable. The noConstraintType singleton is returned if the
         * type variable has no constraint, and the circularConstraintType singleton is returned if the constraint
         * circularly references the type variable.
         */
        function getResolvedBaseConstraint(type) {
            if (type.resolvedBaseConstraint) {
                return type.resolvedBaseConstraint;
            }
            var stack = [];
            return type.resolvedBaseConstraint = getTypeWithThisArgument(getImmediateBaseConstraint(type), type);
            function getImmediateBaseConstraint(t) {
                if (!t.immediateBaseConstraint) {
                    if (!pushTypeResolution(t, 4 /* ImmediateBaseConstraint */)) {
                        return circularConstraintType;
                    }
                    var result = void 0;
                    // We always explore at least 10 levels of nested constraints. Thereafter, we continue to explore
                    // up to 50 levels of nested constraints provided there are no "deeply nested" types on the stack
                    // (i.e. no types for which five instantiations have been recorded on the stack). If we reach 50
                    // levels of nesting, we are presumably exploring a repeating pattern with a long cycle that hasn't
                    // yet triggered the deeply nested limiter. We have no test cases that actually get to 50 levels of
                    // nesting, so it is effectively just a safety stop.
                    if (stack.length < 10 || stack.length < 50 && !isDeeplyNestedType(t, stack, stack.length)) {
                        stack.push(t);
                        result = computeBaseConstraint(getSimplifiedType(t, /*writing*/ false));
                        stack.pop();
                    }
                    if (!popTypeResolution()) {
                        if (t.flags & 262144 /* TypeParameter */) {
                            var errorNode = getConstraintDeclaration(t);
                            if (errorNode) {
                                var diagnostic = error(errorNode, ts.Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(t));
                                if (currentNode && !ts.isNodeDescendantOf(errorNode, currentNode) && !ts.isNodeDescendantOf(currentNode, errorNode)) {
                                    ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(currentNode, ts.Diagnostics.Circularity_originates_in_type_at_this_location));
                                }
                            }
                        }
                        result = circularConstraintType;
                    }
                    t.immediateBaseConstraint = result || noConstraintType;
                }
                return t.immediateBaseConstraint;
            }
            function getBaseConstraint(t) {
                var c = getImmediateBaseConstraint(t);
                return c !== noConstraintType && c !== circularConstraintType ? c : undefined;
            }
            function computeBaseConstraint(t) {
                if (t.flags & 262144 /* TypeParameter */) {
                    var constraint = getConstraintFromTypeParameter(t);
                    return t.isThisType || !constraint ?
                        constraint :
                        getBaseConstraint(constraint);
                }
                if (t.flags & 3145728 /* UnionOrIntersection */) {
                    var types = t.types;
                    var baseTypes = [];
                    var different = false;
                    for (var _i = 0, types_7 = types; _i < types_7.length; _i++) {
                        var type_3 = types_7[_i];
                        var baseType = getBaseConstraint(type_3);
                        if (baseType) {
                            if (baseType !== type_3) {
                                different = true;
                            }
                            baseTypes.push(baseType);
                        }
                        else {
                            different = true;
                        }
                    }
                    if (!different) {
                        return t;
                    }
                    return t.flags & 1048576 /* Union */ && baseTypes.length === types.length ? getUnionType(baseTypes) :
                        t.flags & 2097152 /* Intersection */ && baseTypes.length ? getIntersectionType(baseTypes) :
                            undefined;
                }
                if (t.flags & 4194304 /* Index */) {
                    return keyofConstraintType;
                }
                if (t.flags & 134217728 /* TemplateLiteral */) {
                    var types = t.types;
                    var constraints = ts.mapDefined(types, getBaseConstraint);
                    return constraints.length === types.length ? getTemplateLiteralType(t.texts, constraints) : stringType;
                }
                if (t.flags & 268435456 /* StringMapping */) {
                    var constraint = getBaseConstraint(t.type);
                    return constraint ? getStringMappingType(t.symbol, constraint) : stringType;
                }
                if (t.flags & 8388608 /* IndexedAccess */) {
                    var baseObjectType = getBaseConstraint(t.objectType);
                    var baseIndexType = getBaseConstraint(t.indexType);
                    var baseIndexedAccess = baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, t.accessFlags);
                    return baseIndexedAccess && getBaseConstraint(baseIndexedAccess);
                }
                if (t.flags & 16777216 /* Conditional */) {
                    var constraint = getConstraintFromConditionalType(t);
                    return constraint && getBaseConstraint(constraint);
                }
                if (t.flags & 33554432 /* Substitution */) {
                    return getBaseConstraint(t.substitute);
                }
                return t;
            }
        }
        function getApparentTypeOfIntersectionType(type) {
            return type.resolvedApparentType || (type.resolvedApparentType = getTypeWithThisArgument(type, type, /*apparentType*/ true));
        }
        function getResolvedTypeParameterDefault(typeParameter) {
            if (!typeParameter.default) {
                if (typeParameter.target) {
                    var targetDefault = getResolvedTypeParameterDefault(typeParameter.target);
                    typeParameter.default = targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType;
                }
                else {
                    // To block recursion, set the initial value to the resolvingDefaultType.
                    typeParameter.default = resolvingDefaultType;
                    var defaultDeclaration = typeParameter.symbol && ts.forEach(typeParameter.symbol.declarations, function (decl) { return ts.isTypeParameterDeclaration(decl) && decl.default; });
                    var defaultType = defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType;
                    if (typeParameter.default === resolvingDefaultType) {
                        // If we have not been called recursively, set the correct default type.
                        typeParameter.default = defaultType;
                    }
                }
            }
            else if (typeParameter.default === resolvingDefaultType) {
                // If we are called recursively for this type parameter, mark the default as circular.
                typeParameter.default = circularConstraintType;
            }
            return typeParameter.default;
        }
        /**
         * Gets the default type for a type parameter.
         *
         * If the type parameter is the result of an instantiation, this gets the instantiated
         * default type of its target. If the type parameter has no default type or the default is
         * circular, `undefined` is returned.
         */
        function getDefaultFromTypeParameter(typeParameter) {
            var defaultType = getResolvedTypeParameterDefault(typeParameter);
            return defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined;
        }
        function hasNonCircularTypeParameterDefault(typeParameter) {
            return getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType;
        }
        /**
         * Indicates whether the declaration of a typeParameter has a default type.
         */
        function hasTypeParameterDefault(typeParameter) {
            return !!(typeParameter.symbol && ts.forEach(typeParameter.symbol.declarations, function (decl) { return ts.isTypeParameterDeclaration(decl) && decl.default; }));
        }
        function getApparentTypeOfMappedType(type) {
            return type.resolvedApparentType || (type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type));
        }
        function getResolvedApparentTypeOfMappedType(type) {
            var typeVariable = getHomomorphicTypeVariable(type);
            if (typeVariable && !type.declaration.nameType) {
                var constraint = getConstraintOfTypeParameter(typeVariable);
                if (constraint && (isArrayType(constraint) || isTupleType(constraint))) {
                    return instantiateType(type, prependTypeMapping(typeVariable, constraint, type.mapper));
                }
            }
            return type;
        }
        /**
         * For a type parameter, return the base constraint of the type parameter. For the string, number,
         * boolean, and symbol primitive types, return the corresponding object types. Otherwise return the
         * type itself.
         */
        function getApparentType(type) {
            var t = type.flags & 465829888 /* Instantiable */ ? getBaseConstraintOfType(type) || unknownType : type;
            return ts.getObjectFlags(t) & 32 /* Mapped */ ? getApparentTypeOfMappedType(t) :
                t.flags & 2097152 /* Intersection */ ? getApparentTypeOfIntersectionType(t) :
                    t.flags & 402653316 /* StringLike */ ? globalStringType :
                        t.flags & 296 /* NumberLike */ ? globalNumberType :
                            t.flags & 2112 /* BigIntLike */ ? getGlobalBigIntType(/*reportErrors*/ languageVersion >= 7 /* ES2020 */) :
                                t.flags & 528 /* BooleanLike */ ? globalBooleanType :
                                    t.flags & 12288 /* ESSymbolLike */ ? getGlobalESSymbolType(/*reportErrors*/ languageVersion >= 2 /* ES2015 */) :
                                        t.flags & 67108864 /* NonPrimitive */ ? emptyObjectType :
                                            t.flags & 4194304 /* Index */ ? keyofConstraintType :
                                                t.flags & 2 /* Unknown */ && !strictNullChecks ? emptyObjectType :
                                                    t;
        }
        function getReducedApparentType(type) {
            // Since getApparentType may return a non-reduced union or intersection type, we need to perform
            // type reduction both before and after obtaining the apparent type. For example, given a type parameter
            // 'T extends A | B', the type 'T & X' becomes 'A & X | B & X' after obtaining the apparent type, and
            // that type may need further reduction to remove empty intersections.
            return getReducedType(getApparentType(getReducedType(type)));
        }
        function createUnionOrIntersectionProperty(containingType, name, skipObjectFunctionPropertyAugment) {
            var _a, _b;
            var singleProp;
            var propSet;
            var indexTypes;
            var isUnion = containingType.flags & 1048576 /* Union */;
            // Flags we want to propagate to the result if they exist in all source symbols
            var optionalFlag = isUnion ? 0 /* None */ : 16777216 /* Optional */;
            var syntheticFlag = 4 /* SyntheticMethod */;
            var checkFlags = 0;
            var mergedInstantiations = false;
            for (var _i = 0, _c = containingType.types; _i < _c.length; _i++) {
                var current = _c[_i];
                var type = getApparentType(current);
                if (!(type === errorType || type.flags & 131072 /* Never */)) {
                    var prop = getPropertyOfType(type, name, skipObjectFunctionPropertyAugment);
                    var modifiers = prop ? ts.getDeclarationModifierFlagsFromSymbol(prop) : 0;
                    if (prop) {
                        if (isUnion) {
                            optionalFlag |= (prop.flags & 16777216 /* Optional */);
                        }
                        else {
                            optionalFlag &= prop.flags;
                        }
                        if (!singleProp) {
                            singleProp = prop;
                        }
                        else if (prop !== singleProp) {
                            var isInstantiation = (getTargetSymbol(prop) || prop) === (getTargetSymbol(singleProp) || singleProp);
                            // If the symbols are instances of one another with identical types - consider the symbols
                            // equivalent and just use the first one, which thus allows us to avoid eliding private
                            // members when intersecting a (this-)instantiations of a class with it's raw base or another instance
                            if (isInstantiation && compareProperties(singleProp, prop, function (a, b) { return a === b ? -1 /* True */ : 0 /* False */; }) === -1 /* True */) {
                                // If we merged instantiations of a generic type, we replicate the symbol parent resetting behavior we used
                                // to do when we recorded multiple distinct symbols so that we still get, eg, `Array<T>.length` printed
                                // back and not `Array<string>.length` when we're looking at a `.length` access on a `string[] | number[]`
                                mergedInstantiations = !!singleProp.parent && !!ts.length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent));
                            }
                            else {
                                if (!propSet) {
                                    propSet = new ts.Map();
                                    propSet.set(getSymbolId(singleProp), singleProp);
                                }
                                var id = getSymbolId(prop);
                                if (!propSet.has(id)) {
                                    propSet.set(id, prop);
                                }
                            }
                        }
                        checkFlags |= (isReadonlySymbol(prop) ? 8 /* Readonly */ : 0) |
                            (!(modifiers & 24 /* NonPublicAccessibilityModifier */) ? 256 /* ContainsPublic */ : 0) |
                            (modifiers & 16 /* Protected */ ? 512 /* ContainsProtected */ : 0) |
                            (modifiers & 8 /* Private */ ? 1024 /* ContainsPrivate */ : 0) |
                            (modifiers & 32 /* Static */ ? 2048 /* ContainsStatic */ : 0);
                        if (!isPrototypeProperty(prop)) {
                            syntheticFlag = 2 /* SyntheticProperty */;
                        }
                    }
                    else if (isUnion) {
                        var indexInfo = !isLateBoundName(name) && getApplicableIndexInfoForName(type, name);
                        if (indexInfo) {
                            checkFlags |= 32 /* WritePartial */ | (indexInfo.isReadonly ? 8 /* Readonly */ : 0);
                            indexTypes = ts.append(indexTypes, isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type);
                        }
                        else if (isObjectLiteralType(type) && !(ts.getObjectFlags(type) & 4194304 /* ContainsSpread */)) {
                            checkFlags |= 32 /* WritePartial */;
                            indexTypes = ts.append(indexTypes, undefinedType);
                        }
                        else {
                            checkFlags |= 16 /* ReadPartial */;
                        }
                    }
                }
            }
            if (!singleProp || isUnion && (propSet || checkFlags & 48 /* Partial */) && checkFlags & (1024 /* ContainsPrivate */ | 512 /* ContainsProtected */)) {
                // No property was found, or, in a union, a property has a private or protected declaration in one
                // constituent, but is missing or has a different declaration in another constituent.
                return undefined;
            }
            if (!propSet && !(checkFlags & 16 /* ReadPartial */) && !indexTypes) {
                if (mergedInstantiations) {
                    // No symbol from a union/intersection should have a `.parent` set (since unions/intersections don't act as symbol parents)
                    // Unless that parent is "reconstituted" from the "first value declaration" on the symbol (which is likely different than its instantiated parent!)
                    // They also have a `.containingType` set, which affects some services endpoints behavior, like `getRootSymbol`
                    var clone_1 = createSymbolWithType(singleProp, singleProp.type);
                    clone_1.parent = (_b = (_a = singleProp.valueDeclaration) === null || _a === void 0 ? void 0 : _a.symbol) === null || _b === void 0 ? void 0 : _b.parent;
                    clone_1.containingType = containingType;
                    clone_1.mapper = singleProp.mapper;
                    return clone_1;
                }
                else {
                    return singleProp;
                }
            }
            var props = propSet ? ts.arrayFrom(propSet.values()) : [singleProp];
            var declarations;
            var firstType;
            var nameType;
            var propTypes = [];
            var firstValueDeclaration;
            var hasNonUniformValueDeclaration = false;
            for (var _d = 0, props_1 = props; _d < props_1.length; _d++) {
                var prop = props_1[_d];
                if (!firstValueDeclaration) {
                    firstValueDeclaration = prop.valueDeclaration;
                }
                else if (prop.valueDeclaration && prop.valueDeclaration !== firstValueDeclaration) {
                    hasNonUniformValueDeclaration = true;
                }
                declarations = ts.addRange(declarations, prop.declarations);
                var type = getTypeOfSymbol(prop);
                if (!firstType) {
                    firstType = type;
                    nameType = getSymbolLinks(prop).nameType;
                }
                else if (type !== firstType) {
                    checkFlags |= 64 /* HasNonUniformType */;
                }
                if (isLiteralType(type)) {
                    checkFlags |= 128 /* HasLiteralType */;
                }
                if (type.flags & 131072 /* Never */) {
                    checkFlags |= 131072 /* HasNeverType */;
                }
                propTypes.push(type);
            }
            ts.addRange(propTypes, indexTypes);
            var result = createSymbol(4 /* Property */ | optionalFlag, name, syntheticFlag | checkFlags);
            result.containingType = containingType;
            if (!hasNonUniformValueDeclaration && firstValueDeclaration) {
                result.valueDeclaration = firstValueDeclaration;
                // Inherit information about parent type.
                if (firstValueDeclaration.symbol.parent) {
                    result.parent = firstValueDeclaration.symbol.parent;
                }
            }
            result.declarations = declarations;
            result.nameType = nameType;
            if (propTypes.length > 2) {
                // When `propTypes` has the potential to explode in size when normalized, defer normalization until absolutely needed
                result.checkFlags |= 65536 /* DeferredType */;
                result.deferralParent = containingType;
                result.deferralConstituents = propTypes;
            }
            else {
                result.type = isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes);
            }
            return result;
        }
        // Return the symbol for a given property in a union or intersection type, or undefined if the property
        // does not exist in any constituent type. Note that the returned property may only be present in some
        // constituents, in which case the isPartial flag is set when the containing type is union type. We need
        // these partial properties when identifying discriminant properties, but otherwise they are filtered out
        // and do not appear to be present in the union type.
        function getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment) {
            var _a, _b;
            var property = ((_a = type.propertyCacheWithoutObjectFunctionPropertyAugment) === null || _a === void 0 ? void 0 : _a.get(name)) ||
                !skipObjectFunctionPropertyAugment ? (_b = type.propertyCache) === null || _b === void 0 ? void 0 : _b.get(name) : undefined;
            if (!property) {
                property = createUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
                if (property) {
                    var properties = skipObjectFunctionPropertyAugment ? type.propertyCacheWithoutObjectFunctionPropertyAugment || (type.propertyCacheWithoutObjectFunctionPropertyAugment = ts.createSymbolTable()) : type.propertyCache || (type.propertyCache = ts.createSymbolTable());
                    properties.set(name, property);
                }
            }
            return property;
        }
        function getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment) {
            var property = getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
            // We need to filter out partial properties in union types
            return property && !(ts.getCheckFlags(property) & 16 /* ReadPartial */) ? property : undefined;
        }
        /**
         * Return the reduced form of the given type. For a union type, it is a union of the normalized constituent types.
         * For an intersection of types containing one or more mututally exclusive discriminant properties, it is 'never'.
         * For all other types, it is simply the type itself. Discriminant properties are considered mutually exclusive when
         * no constituent property has type 'never', but the intersection of the constituent property types is 'never'.
         */
        function getReducedType(type) {
            if (type.flags & 1048576 /* Union */ && type.objectFlags & 33554432 /* ContainsIntersections */) {
                return type.resolvedReducedType || (type.resolvedReducedType = getReducedUnionType(type));
            }
            else if (type.flags & 2097152 /* Intersection */) {
                if (!(type.objectFlags & 33554432 /* IsNeverIntersectionComputed */)) {
                    type.objectFlags |= 33554432 /* IsNeverIntersectionComputed */ |
                        (ts.some(getPropertiesOfUnionOrIntersectionType(type), isNeverReducedProperty) ? 67108864 /* IsNeverIntersection */ : 0);
                }
                return type.objectFlags & 67108864 /* IsNeverIntersection */ ? neverType : type;
            }
            return type;
        }
        function getReducedUnionType(unionType) {
            var reducedTypes = ts.sameMap(unionType.types, getReducedType);
            if (reducedTypes === unionType.types) {
                return unionType;
            }
            var reduced = getUnionType(reducedTypes);
            if (reduced.flags & 1048576 /* Union */) {
                reduced.resolvedReducedType = reduced;
            }
            return reduced;
        }
        function isNeverReducedProperty(prop) {
            return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop);
        }
        function isDiscriminantWithNeverType(prop) {
            // Return true for a synthetic non-optional property with non-uniform types, where at least one is
            // a literal type and none is never, that reduces to never.
            return !(prop.flags & 16777216 /* Optional */) &&
                (ts.getCheckFlags(prop) & (192 /* Discriminant */ | 131072 /* HasNeverType */)) === 192 /* Discriminant */ &&
                !!(getTypeOfSymbol(prop).flags & 131072 /* Never */);
        }
        function isConflictingPrivateProperty(prop) {
            // Return true for a synthetic property with multiple declarations, at least one of which is private.
            return !prop.valueDeclaration && !!(ts.getCheckFlags(prop) & 1024 /* ContainsPrivate */);
        }
        function elaborateNeverIntersection(errorInfo, type) {
            if (type.flags & 2097152 /* Intersection */ && ts.getObjectFlags(type) & 67108864 /* IsNeverIntersection */) {
                var neverProp = ts.find(getPropertiesOfUnionOrIntersectionType(type), isDiscriminantWithNeverType);
                if (neverProp) {
                    return ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, typeToString(type, /*enclosingDeclaration*/ undefined, 536870912 /* NoTypeReduction */), symbolToString(neverProp));
                }
                var privateProp = ts.find(getPropertiesOfUnionOrIntersectionType(type), isConflictingPrivateProperty);
                if (privateProp) {
                    return ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, typeToString(type, /*enclosingDeclaration*/ undefined, 536870912 /* NoTypeReduction */), symbolToString(privateProp));
                }
            }
            return errorInfo;
        }
        /**
         * Return the symbol for the property with the given name in the given type. Creates synthetic union properties when
         * necessary, maps primitive types and type parameters are to their apparent types, and augments with properties from
         * Object and Function as appropriate.
         *
         * @param type a type to look up property from
         * @param name a name of property to look up in a given type
         */
        function getPropertyOfType(type, name, skipObjectFunctionPropertyAugment) {
            type = getReducedApparentType(type);
            if (type.flags & 524288 /* Object */) {
                var resolved = resolveStructuredTypeMembers(type);
                var symbol = resolved.members.get(name);
                if (symbol && symbolIsValue(symbol)) {
                    return symbol;
                }
                if (skipObjectFunctionPropertyAugment)
                    return undefined;
                var functionType = resolved === anyFunctionType ? globalFunctionType :
                    resolved.callSignatures.length ? globalCallableFunctionType :
                        resolved.constructSignatures.length ? globalNewableFunctionType :
                            undefined;
                if (functionType) {
                    var symbol_1 = getPropertyOfObjectType(functionType, name);
                    if (symbol_1) {
                        return symbol_1;
                    }
                }
                return getPropertyOfObjectType(globalObjectType, name);
            }
            if (type.flags & 3145728 /* UnionOrIntersection */) {
                return getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment);
            }
            return undefined;
        }
        function getSignaturesOfStructuredType(type, kind) {
            if (type.flags & 3670016 /* StructuredType */) {
                var resolved = resolveStructuredTypeMembers(type);
                return kind === 0 /* Call */ ? resolved.callSignatures : resolved.constructSignatures;
            }
            return ts.emptyArray;
        }
        /**
         * Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and
         * maps primitive types and type parameters are to their apparent types.
         */
        function getSignaturesOfType(type, kind) {
            return getSignaturesOfStructuredType(getReducedApparentType(type), kind);
        }
        function findIndexInfo(indexInfos, keyType) {
            return ts.find(indexInfos, function (info) { return info.keyType === keyType; });
        }
        function findApplicableIndexInfo(indexInfos, keyType) {
            // Index signatures for type 'string' are considered only when no other index signatures apply.
            var stringIndexInfo;
            var applicableInfo;
            var applicableInfos;
            for (var _i = 0, indexInfos_1 = indexInfos; _i < indexInfos_1.length; _i++) {
                var info = indexInfos_1[_i];
                if (info.keyType === stringType) {
                    stringIndexInfo = info;
                }
                else if (isApplicableIndexType(keyType, info.keyType)) {
                    if (!applicableInfo) {
                        applicableInfo = info;
                    }
                    else {
                        (applicableInfos || (applicableInfos = [applicableInfo])).push(info);
                    }
                }
            }
            // When more than one index signature is applicable we create a synthetic IndexInfo. Instead of computing
            // the intersected key type, we just use unknownType for the key type as nothing actually depends on the
            // keyType property of the returned IndexInfo.
            return applicableInfos ? createIndexInfo(unknownType, getIntersectionType(ts.map(applicableInfos, function (info) { return info.type; })), ts.reduceLeft(applicableInfos, function (isReadonly, info) { return isReadonly && info.isReadonly; }, /*initial*/ true)) :
                applicableInfo ? applicableInfo :
                    stringIndexInfo && isApplicableIndexType(keyType, stringType) ? stringIndexInfo :
                        undefined;
        }
        function isApplicableIndexType(source, target) {
            // A 'string' index signature applies to types assignable to 'string' or 'number', and a 'number' index
            // signature applies to types assignable to 'number' and numeric string literal types.
            return isTypeAssignableTo(source, target) ||
                target === stringType && isTypeAssignableTo(source, numberType) ||
                target === numberType && !!(source.flags & 128 /* StringLiteral */) && isNumericLiteralName(source.value);
        }
        function getIndexInfosOfStructuredType(type) {
            if (type.flags & 3670016 /* StructuredType */) {
                var resolved = resolveStructuredTypeMembers(type);
                return resolved.indexInfos;
            }
            return ts.emptyArray;
        }
        function getIndexInfosOfType(type) {
            return getIndexInfosOfStructuredType(getReducedApparentType(type));
        }
        // Return the indexing info of the given kind in the given type. Creates synthetic union index types when necessary and
        // maps primitive types and type parameters are to their apparent types.
        function getIndexInfoOfType(type, keyType) {
            return findIndexInfo(getIndexInfosOfType(type), keyType);
        }
        // Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and
        // maps primitive types and type parameters are to their apparent types.
        function getIndexTypeOfType(type, keyType) {
            var _a;
            return (_a = getIndexInfoOfType(type, keyType)) === null || _a === void 0 ? void 0 : _a.type;
        }
        function getApplicableIndexInfos(type, keyType) {
            return getIndexInfosOfType(type).filter(function (info) { return isApplicableIndexType(keyType, info.keyType); });
        }
        function getApplicableIndexInfo(type, keyType) {
            return findApplicableIndexInfo(getIndexInfosOfType(type), keyType);
        }
        function getApplicableIndexInfoForName(type, name) {
            return getApplicableIndexInfo(type, isLateBoundName(name) ? esSymbolType : getStringLiteralType(ts.unescapeLeadingUnderscores(name)));
        }
        // Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
        // type checking functions).
        function getTypeParametersFromDeclaration(declaration) {
            var result;
            for (var _i = 0, _a = ts.getEffectiveTypeParameterDeclarations(declaration); _i < _a.length; _i++) {
                var node = _a[_i];
                result = ts.appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol));
            }
            return result;
        }
        function symbolsToArray(symbols) {
            var result = [];
            symbols.forEach(function (symbol, id) {
                if (!isReservedMemberName(id)) {
                    result.push(symbol);
                }
            });
            return result;
        }
        function isJSDocOptionalParameter(node) {
            return ts.isInJSFile(node) && (
            // node.type should only be a JSDocOptionalType when node is a parameter of a JSDocFunctionType
            node.type && node.type.kind === 311 /* JSDocOptionalType */
                || ts.getJSDocParameterTags(node).some(function (_a) {
                    var isBracketed = _a.isBracketed, typeExpression = _a.typeExpression;
                    return isBracketed || !!typeExpression && typeExpression.type.kind === 311 /* JSDocOptionalType */;
                }));
        }
        function tryFindAmbientModule(moduleName, withAugmentations) {
            if (ts.isExternalModuleNameRelative(moduleName)) {
                return undefined;
            }
            var symbol = getSymbol(globals, '"' + moduleName + '"', 512 /* ValueModule */);
            // merged symbol is module declaration symbol combined with all augmentations
            return symbol && withAugmentations ? getMergedSymbol(symbol) : symbol;
        }
        function isOptionalParameter(node) {
            if (ts.hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isJSDocOptionalParameter(node)) {
                return true;
            }
            if (node.initializer) {
                var signature = getSignatureFromDeclaration(node.parent);
                var parameterIndex = node.parent.parameters.indexOf(node);
                ts.Debug.assert(parameterIndex >= 0);
                // Only consider syntactic or instantiated parameters as optional, not `void` parameters as this function is used
                // in grammar checks and checking for `void` too early results in parameter types widening too early
                // and causes some noImplicitAny errors to be lost.
                return parameterIndex >= getMinArgumentCount(signature, 1 /* StrongArityForUntypedJS */ | 2 /* VoidIsNonOptional */);
            }
            var iife = ts.getImmediatelyInvokedFunctionExpression(node.parent);
            if (iife) {
                return !node.type &&
                    !node.dotDotDotToken &&
                    node.parent.parameters.indexOf(node) >= iife.arguments.length;
            }
            return false;
        }
        function isOptionalPropertyDeclaration(node) {
            return ts.isPropertyDeclaration(node) && node.questionToken;
        }
        function isOptionalJSDocPropertyLikeTag(node) {
            if (!ts.isJSDocPropertyLikeTag(node)) {
                return false;
            }
            var isBracketed = node.isBracketed, typeExpression = node.typeExpression;
            return isBracketed || !!typeExpression && typeExpression.type.kind === 311 /* JSDocOptionalType */;
        }
        function createTypePredicate(kind, parameterName, parameterIndex, type) {
            return { kind: kind, parameterName: parameterName, parameterIndex: parameterIndex, type: type };
        }
        /**
         * Gets the minimum number of type arguments needed to satisfy all non-optional type
         * parameters.
         */
        function getMinTypeArgumentCount(typeParameters) {
            var minTypeArgumentCount = 0;
            if (typeParameters) {
                for (var i = 0; i < typeParameters.length; i++) {
                    if (!hasTypeParameterDefault(typeParameters[i])) {
                        minTypeArgumentCount = i + 1;
                    }
                }
            }
            return minTypeArgumentCount;
        }
        function fillMissingTypeArguments(typeArguments, typeParameters, minTypeArgumentCount, isJavaScriptImplicitAny) {
            var numTypeParameters = ts.length(typeParameters);
            if (!numTypeParameters) {
                return [];
            }
            var numTypeArguments = ts.length(typeArguments);
            if (isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters)) {
                var result = typeArguments ? typeArguments.slice() : [];
                // Map invalid forward references in default types to the error type
                for (var i = numTypeArguments; i < numTypeParameters; i++) {
                    result[i] = errorType;
                }
                var baseDefaultType = getDefaultTypeArgumentType(isJavaScriptImplicitAny);
                for (var i = numTypeArguments; i < numTypeParameters; i++) {
                    var defaultType = getDefaultFromTypeParameter(typeParameters[i]);
                    if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) {
                        defaultType = anyType;
                    }
                    result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters, result)) : baseDefaultType;
                }
                result.length = typeParameters.length;
                return result;
            }
            return typeArguments && typeArguments.slice();
        }
        function getSignatureFromDeclaration(declaration) {
            var links = getNodeLinks(declaration);
            if (!links.resolvedSignature) {
                var parameters = [];
                var flags = 0 /* None */;
                var minArgumentCount = 0;
                var thisParameter = void 0;
                var hasThisParameter = false;
                var iife = ts.getImmediatelyInvokedFunctionExpression(declaration);
                var isJSConstructSignature = ts.isJSDocConstructSignature(declaration);
                var isUntypedSignatureInJSFile = !iife &&
                    ts.isInJSFile(declaration) &&
                    ts.isValueSignatureDeclaration(declaration) &&
                    !ts.hasJSDocParameterTags(declaration) &&
                    !ts.getJSDocType(declaration);
                if (isUntypedSignatureInJSFile) {
                    flags |= 32 /* IsUntypedSignatureInJSFile */;
                }
                // If this is a JSDoc construct signature, then skip the first parameter in the
                // parameter list.  The first parameter represents the return type of the construct
                // signature.
                for (var i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {
                    var param = declaration.parameters[i];
                    var paramSymbol = param.symbol;
                    var type = ts.isJSDocParameterTag(param) ? (param.typeExpression && param.typeExpression.type) : param.type;
                    // Include parameter symbol instead of property symbol in the signature
                    if (paramSymbol && !!(paramSymbol.flags & 4 /* Property */) && !ts.isBindingPattern(param.name)) {
                        var resolvedSymbol = resolveName(param, paramSymbol.escapedName, 111551 /* Value */, undefined, undefined, /*isUse*/ false);
                        paramSymbol = resolvedSymbol;
                    }
                    if (i === 0 && paramSymbol.escapedName === "this" /* This */) {
                        hasThisParameter = true;
                        thisParameter = param.symbol;
                    }
                    else {
                        parameters.push(paramSymbol);
                    }
                    if (type && type.kind === 194 /* LiteralType */) {
                        flags |= 2 /* HasLiteralTypes */;
                    }
                    // Record a new minimum argument count if this is not an optional parameter
                    var isOptionalParameter_1 = isOptionalJSDocPropertyLikeTag(param) ||
                        param.initializer || param.questionToken || ts.isRestParameter(param) ||
                        iife && parameters.length > iife.arguments.length && !type ||
                        isJSDocOptionalParameter(param);
                    if (!isOptionalParameter_1) {
                        minArgumentCount = parameters.length;
                    }
                }
                // If only one accessor includes a this-type annotation, the other behaves as if it had the same type annotation
                if ((declaration.kind === 170 /* GetAccessor */ || declaration.kind === 171 /* SetAccessor */) &&
                    hasBindableName(declaration) &&
                    (!hasThisParameter || !thisParameter)) {
                    var otherKind = declaration.kind === 170 /* GetAccessor */ ? 171 /* SetAccessor */ : 170 /* GetAccessor */;
                    var other = ts.getDeclarationOfKind(getSymbolOfNode(declaration), otherKind);
                    if (other) {
                        thisParameter = getAnnotatedAccessorThisParameter(other);
                    }
                }
                var classType = declaration.kind === 169 /* Constructor */ ?
                    getDeclaredTypeOfClassOrInterface(getMergedSymbol(declaration.parent.symbol))
                    : undefined;
                var typeParameters = classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration);
                if (ts.hasRestParameter(declaration) || ts.isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters)) {
                    flags |= 1 /* HasRestParameter */;
                }
                if (ts.isConstructorTypeNode(declaration) && ts.hasSyntacticModifier(declaration, 128 /* Abstract */) ||
                    ts.isConstructorDeclaration(declaration) && ts.hasSyntacticModifier(declaration.parent, 128 /* Abstract */)) {
                    flags |= 4 /* Abstract */;
                }
                links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, 
                /*resolvedReturnType*/ undefined, /*resolvedTypePredicate*/ undefined, minArgumentCount, flags);
            }
            return links.resolvedSignature;
        }
        /**
         * A JS function gets a synthetic rest parameter if it references `arguments` AND:
         * 1. It has no parameters but at least one `@param` with a type that starts with `...`
         * OR
         * 2. It has at least one parameter, and the last parameter has a matching `@param` with a type that starts with `...`
         */
        function maybeAddJsSyntheticRestParameter(declaration, parameters) {
            if (ts.isJSDocSignature(declaration) || !containsArgumentsReference(declaration)) {
                return false;
            }
            var lastParam = ts.lastOrUndefined(declaration.parameters);
            var lastParamTags = lastParam ? ts.getJSDocParameterTags(lastParam) : ts.getJSDocTags(declaration).filter(ts.isJSDocParameterTag);
            var lastParamVariadicType = ts.firstDefined(lastParamTags, function (p) {
                return p.typeExpression && ts.isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : undefined;
            });
            var syntheticArgsSymbol = createSymbol(3 /* Variable */, "args", 32768 /* RestParameter */);
            syntheticArgsSymbol.type = lastParamVariadicType ? createArrayType(getTypeFromTypeNode(lastParamVariadicType.type)) : anyArrayType;
            if (lastParamVariadicType) {
                // Replace the last parameter with a rest parameter.
                parameters.pop();
            }
            parameters.push(syntheticArgsSymbol);
            return true;
        }
        function getSignatureOfTypeTag(node) {
            // should be attached to a function declaration or expression
            if (!(ts.isInJSFile(node) && ts.isFunctionLikeDeclaration(node)))
                return undefined;
            var typeTag = ts.getJSDocTypeTag(node);
            return (typeTag === null || typeTag === void 0 ? void 0 : typeTag.typeExpression) && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
        }
        function getReturnTypeOfTypeTag(node) {
            var signature = getSignatureOfTypeTag(node);
            return signature && getReturnTypeOfSignature(signature);
        }
        function containsArgumentsReference(declaration) {
            var links = getNodeLinks(declaration);
            if (links.containsArgumentsReference === undefined) {
                if (links.flags & 8192 /* CaptureArguments */) {
                    links.containsArgumentsReference = true;
                }
                else {
                    links.containsArgumentsReference = traverse(declaration.body);
                }
            }
            return links.containsArgumentsReference;
            function traverse(node) {
                if (!node)
                    return false;
                switch (node.kind) {
                    case 79 /* Identifier */:
                        return node.escapedText === argumentsSymbol.escapedName && getResolvedSymbol(node) === argumentsSymbol;
                    case 165 /* PropertyDeclaration */:
                    case 167 /* MethodDeclaration */:
                    case 170 /* GetAccessor */:
                    case 171 /* SetAccessor */:
                        return node.name.kind === 160 /* ComputedPropertyName */
                            && traverse(node.name);
                    case 204 /* PropertyAccessExpression */:
                    case 205 /* ElementAccessExpression */:
                        return traverse(node.expression);
                    default:
                        return !ts.nodeStartsNewLexicalEnvironment(node) && !ts.isPartOfTypeNode(node) && !!ts.forEachChild(node, traverse);
                }
            }
        }
        function getSignaturesOfSymbol(symbol) {
            if (!symbol || !symbol.declarations)
                return ts.emptyArray;
            var result = [];
            for (var i = 0; i < symbol.declarations.length; i++) {
                var decl = symbol.declarations[i];
                if (!ts.isFunctionLike(decl))
                    continue;
                // Don't include signature if node is the implementation of an overloaded function. A node is considered
                // an implementation node if it has a body and the previous node is of the same kind and immediately
                // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
                if (i > 0 && decl.body) {
                    var previous = symbol.declarations[i - 1];
                    if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) {
                        continue;
                    }
                }
                result.push(getSignatureFromDeclaration(decl));
            }
            return result;
        }
        function resolveExternalModuleTypeByLiteral(name) {
            var moduleSym = resolveExternalModuleName(name, name);
            if (moduleSym) {
                var resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
                if (resolvedModuleSymbol) {
                    return getTypeOfSymbol(resolvedModuleSymbol);
                }
            }
            return anyType;
        }
        function getThisTypeOfSignature(signature) {
            if (signature.thisParameter) {
                return getTypeOfSymbol(signature.thisParameter);
            }
        }
        function getTypePredicateOfSignature(signature) {
            if (!signature.resolvedTypePredicate) {
                if (signature.target) {
                    var targetTypePredicate = getTypePredicateOfSignature(signature.target);
                    signature.resolvedTypePredicate = targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper) : noTypePredicate;
                }
                else if (signature.compositeSignatures) {
                    signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate;
                }
                else {
                    var type = signature.declaration && ts.getEffectiveReturnTypeNode(signature.declaration);
                    var jsdocPredicate = void 0;
                    if (!type && ts.isInJSFile(signature.declaration)) {
                        var jsdocSignature = getSignatureOfTypeTag(signature.declaration);
                        if (jsdocSignature && signature !== jsdocSignature) {
                            jsdocPredicate = getTypePredicateOfSignature(jsdocSignature);
                        }
                    }
                    signature.resolvedTypePredicate = type && ts.isTypePredicateNode(type) ?
                        createTypePredicateFromTypePredicateNode(type, signature) :
                        jsdocPredicate || noTypePredicate;
                }
                ts.Debug.assert(!!signature.resolvedTypePredicate);
            }
            return signature.resolvedTypePredicate === noTypePredicate ? undefined : signature.resolvedTypePredicate;
        }
        function createTypePredicateFromTypePredicateNode(node, signature) {
            var parameterName = node.parameterName;
            var type = node.type && getTypeFromTypeNode(node.type);
            return parameterName.kind === 190 /* ThisType */ ?
                createTypePredicate(node.assertsModifier ? 2 /* AssertsThis */ : 0 /* This */, /*parameterName*/ undefined, /*parameterIndex*/ undefined, type) :
                createTypePredicate(node.assertsModifier ? 3 /* AssertsIdentifier */ : 1 /* Identifier */, parameterName.escapedText, ts.findIndex(signature.parameters, function (p) { return p.escapedName === parameterName.escapedText; }), type);
        }
        function getUnionOrIntersectionType(types, kind, unionReduction) {
            return kind !== 2097152 /* Intersection */ ? getUnionType(types, unionReduction) : getIntersectionType(types);
        }
        function getReturnTypeOfSignature(signature) {
            if (!signature.resolvedReturnType) {
                if (!pushTypeResolution(signature, 3 /* ResolvedReturnType */)) {
                    return errorType;
                }
                var type = signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) :
                    signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(ts.map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, 2 /* Subtype */), signature.mapper) :
                        getReturnTypeFromAnnotation(signature.declaration) ||
                            (ts.nodeIsMissing(signature.declaration.body) ? anyType : getReturnTypeFromBody(signature.declaration));
                if (signature.flags & 8 /* IsInnerCallChain */) {
                    type = addOptionalTypeMarker(type);
                }
                else if (signature.flags & 16 /* IsOuterCallChain */) {
                    type = getOptionalType(type);
                }
                if (!popTypeResolution()) {
                    if (signature.declaration) {
                        var typeNode = ts.getEffectiveReturnTypeNode(signature.declaration);
                        if (typeNode) {
                            error(typeNode, ts.Diagnostics.Return_type_annotation_circularly_references_itself);
                        }
                        else if (noImplicitAny) {
                            var declaration = signature.declaration;
                            var name = ts.getNameOfDeclaration(declaration);
                            if (name) {
                                error(name, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, ts.declarationNameToString(name));
                            }
                            else {
                                error(declaration, ts.Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
                            }
                        }
                    }
                    type = anyType;
                }
                signature.resolvedReturnType = type;
            }
            return signature.resolvedReturnType;
        }
        function getReturnTypeFromAnnotation(declaration) {
            if (declaration.kind === 169 /* Constructor */) {
                return getDeclaredTypeOfClassOrInterface(getMergedSymbol(declaration.parent.symbol));
            }
            if (ts.isJSDocConstructSignature(declaration)) {
                return getTypeFromTypeNode(declaration.parameters[0].type); // TODO: GH#18217
            }
            var typeNode = ts.getEffectiveReturnTypeNode(declaration);
            if (typeNode) {
                return getTypeFromTypeNode(typeNode);
            }
            if (declaration.kind === 170 /* GetAccessor */ && hasBindableName(declaration)) {
                var jsDocType = ts.isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration);
                if (jsDocType) {
                    return jsDocType;
                }
                var setter = ts.getDeclarationOfKind(getSymbolOfNode(declaration), 171 /* SetAccessor */);
                var setterType = getAnnotatedAccessorType(setter);
                if (setterType) {
                    return setterType;
                }
            }
            return getReturnTypeOfTypeTag(declaration);
        }
        function isResolvingReturnTypeOfSignature(signature) {
            return !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, 3 /* ResolvedReturnType */) >= 0;
        }
        function getRestTypeOfSignature(signature) {
            return tryGetRestTypeOfSignature(signature) || anyType;
        }
        function tryGetRestTypeOfSignature(signature) {
            if (signatureHasRestParameter(signature)) {
                var sigRestType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                var restType = isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType;
                return restType && getIndexTypeOfType(restType, numberType);
            }
            return undefined;
        }
        function getSignatureInstantiation(signature, typeArguments, isJavascript, inferredTypeParameters) {
            var instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript));
            if (inferredTypeParameters) {
                var returnSignature = getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature));
                if (returnSignature) {
                    var newReturnSignature = cloneSignature(returnSignature);
                    newReturnSignature.typeParameters = inferredTypeParameters;
                    var newInstantiatedSignature = cloneSignature(instantiatedSignature);
                    newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature);
                    return newInstantiatedSignature;
                }
            }
            return instantiatedSignature;
        }
        function getSignatureInstantiationWithoutFillingInTypeArguments(signature, typeArguments) {
            var instantiations = signature.instantiations || (signature.instantiations = new ts.Map());
            var id = getTypeListId(typeArguments);
            var instantiation = instantiations.get(id);
            if (!instantiation) {
                instantiations.set(id, instantiation = createSignatureInstantiation(signature, typeArguments));
            }
            return instantiation;
        }
        function createSignatureInstantiation(signature, typeArguments) {
            return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments), /*eraseTypeParameters*/ true);
        }
        function createSignatureTypeMapper(signature, typeArguments) {
            return createTypeMapper(signature.typeParameters, typeArguments);
        }
        function getErasedSignature(signature) {
            return signature.typeParameters ?
                signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) :
                signature;
        }
        function createErasedSignature(signature) {
            // Create an instantiation of the signature where all type arguments are the any type.
            return instantiateSignature(signature, createTypeEraser(signature.typeParameters), /*eraseTypeParameters*/ true);
        }
        function getCanonicalSignature(signature) {
            return signature.typeParameters ?
                signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) :
                signature;
        }
        function createCanonicalSignature(signature) {
            // Create an instantiation of the signature where each unconstrained type parameter is replaced with
            // its original. When a generic class or interface is instantiated, each generic method in the class or
            // interface is instantiated with a fresh set of cloned type parameters (which we need to handle scenarios
            // where different generations of the same type parameter are in scope). This leads to a lot of new type
            // identities, and potentially a lot of work comparing those identities, so here we create an instantiation
            // that uses the original type identities for all unconstrained type parameters.
            return getSignatureInstantiation(signature, ts.map(signature.typeParameters, function (tp) { return tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp; }), ts.isInJSFile(signature.declaration));
        }
        function getBaseSignature(signature) {
            var typeParameters = signature.typeParameters;
            if (typeParameters) {
                if (signature.baseSignatureCache) {
                    return signature.baseSignatureCache;
                }
                var typeEraser = createTypeEraser(typeParameters);
                var baseConstraintMapper_1 = createTypeMapper(typeParameters, ts.map(typeParameters, function (tp) { return getConstraintOfTypeParameter(tp) || unknownType; }));
                var baseConstraints = ts.map(typeParameters, function (tp) { return instantiateType(tp, baseConstraintMapper_1) || unknownType; });
                // Run N type params thru the immediate constraint mapper up to N times
                // This way any noncircular interdependent type parameters are definitely resolved to their external dependencies
                for (var i = 0; i < typeParameters.length - 1; i++) {
                    baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper_1);
                }
                // and then apply a type eraser to remove any remaining circularly dependent type parameters
                baseConstraints = instantiateTypes(baseConstraints, typeEraser);
                return signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), /*eraseTypeParameters*/ true);
            }
            return signature;
        }
        function getOrCreateTypeFromSignature(signature) {
            // There are two ways to declare a construct signature, one is by declaring a class constructor
            // using the constructor keyword, and the other is declaring a bare construct signature in an
            // object type literal or interface (using the new keyword). Each way of declaring a constructor
            // will result in a different declaration kind.
            if (!signature.isolatedSignatureType) {
                var kind = signature.declaration ? signature.declaration.kind : 0 /* Unknown */;
                var isConstructor = kind === 169 /* Constructor */ || kind === 173 /* ConstructSignature */ || kind === 178 /* ConstructorType */;
                var type = createObjectType(16 /* Anonymous */);
                type.members = emptySymbols;
                type.properties = ts.emptyArray;
                type.callSignatures = !isConstructor ? [signature] : ts.emptyArray;
                type.constructSignatures = isConstructor ? [signature] : ts.emptyArray;
                type.indexInfos = ts.emptyArray;
                signature.isolatedSignatureType = type;
            }
            return signature.isolatedSignatureType;
        }
        function getIndexSymbol(symbol) {
            return symbol.members ? getIndexSymbolFromSymbolTable(symbol.members) : undefined;
        }
        function getIndexSymbolFromSymbolTable(symbolTable) {
            return symbolTable.get("__index" /* Index */);
        }
        function createIndexInfo(keyType, type, isReadonly, declaration) {
            return { keyType: keyType, type: type, isReadonly: isReadonly, declaration: declaration };
        }
        function getIndexInfosOfSymbol(symbol) {
            var indexSymbol = getIndexSymbol(symbol);
            return indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol) : ts.emptyArray;
        }
        function getIndexInfosOfIndexSymbol(indexSymbol) {
            if (indexSymbol.declarations) {
                var indexInfos_2 = [];
                var _loop_14 = function (declaration) {
                    if (declaration.parameters.length === 1) {
                        var parameter = declaration.parameters[0];
                        if (parameter.type) {
                            forEachType(getTypeFromTypeNode(parameter.type), function (keyType) {
                                if (isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos_2, keyType)) {
                                    indexInfos_2.push(createIndexInfo(keyType, declaration.type ? getTypeFromTypeNode(declaration.type) : anyType, ts.hasEffectiveModifier(declaration, 64 /* Readonly */), declaration));
                                }
                            });
                        }
                    }
                };
                for (var _i = 0, _a = indexSymbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    _loop_14(declaration);
                }
                return indexInfos_2;
            }
            return ts.emptyArray;
        }
        function isValidIndexKeyType(type) {
            return !!(type.flags & (4 /* String */ | 8 /* Number */ | 4096 /* ESSymbol */)) || isPatternLiteralType(type) ||
                !!(type.flags & 2097152 /* Intersection */) && !isGenericIndexType(type) && !isGenericObjectType(type) && ts.some(type.types, isValidIndexKeyType);
        }
        function getConstraintDeclaration(type) {
            return ts.mapDefined(ts.filter(type.symbol && type.symbol.declarations, ts.isTypeParameterDeclaration), ts.getEffectiveConstraintOfTypeParameter)[0];
        }
        function getInferredTypeParameterConstraint(typeParameter) {
            var _a;
            var inferences;
            if ((_a = typeParameter.symbol) === null || _a === void 0 ? void 0 : _a.declarations) {
                for (var _i = 0, _b = typeParameter.symbol.declarations; _i < _b.length; _i++) {
                    var declaration = _b[_i];
                    if (declaration.parent.kind === 188 /* InferType */) {
                        // When an 'infer T' declaration is immediately contained in a type reference node
                        // (such as 'Foo<infer T>'), T's constraint is inferred from the constraint of the
                        // corresponding type parameter in 'Foo'. When multiple 'infer T' declarations are
                        // present, we form an intersection of the inferred constraint types.
                        var _c = ts.walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent), _d = _c[0], childTypeParameter = _d === void 0 ? declaration.parent : _d, grandParent = _c[1];
                        if (grandParent.kind === 176 /* TypeReference */) {
                            var typeReference = grandParent;
                            var typeParameters = getTypeParametersForTypeReference(typeReference);
                            if (typeParameters) {
                                var index = typeReference.typeArguments.indexOf(childTypeParameter);
                                if (index < typeParameters.length) {
                                    var declaredConstraint = getConstraintOfTypeParameter(typeParameters[index]);
                                    if (declaredConstraint) {
                                        // Type parameter constraints can reference other type parameters so
                                        // constraints need to be instantiated. If instantiation produces the
                                        // type parameter itself, we discard that inference. For example, in
                                        //   type Foo<T extends string, U extends T> = [T, U];
                                        //   type Bar<T> = T extends Foo<infer X, infer X> ? Foo<X, X> : T;
                                        // the instantiated constraint for U is X, so we discard that inference.
                                        var mapper = createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReference, typeParameters));
                                        var constraint = instantiateType(declaredConstraint, mapper);
                                        if (constraint !== typeParameter) {
                                            inferences = ts.append(inferences, constraint);
                                        }
                                    }
                                }
                            }
                        }
                        // When an 'infer T' declaration is immediately contained in a rest parameter declaration, a rest type
                        // or a named rest tuple element, we infer an 'unknown[]' constraint.
                        else if (grandParent.kind === 162 /* Parameter */ && grandParent.dotDotDotToken ||
                            grandParent.kind === 184 /* RestType */ ||
                            grandParent.kind === 195 /* NamedTupleMember */ && grandParent.dotDotDotToken) {
                            inferences = ts.append(inferences, createArrayType(unknownType));
                        }
                        // When an 'infer T' declaration is immediately contained in a string template type, we infer a 'string'
                        // constraint.
                        else if (grandParent.kind === 197 /* TemplateLiteralTypeSpan */) {
                            inferences = ts.append(inferences, stringType);
                        }
                        // When an 'infer T' declaration is in the constraint position of a mapped type, we infer a 'keyof any'
                        // constraint.
                        else if (grandParent.kind === 161 /* TypeParameter */ && grandParent.parent.kind === 193 /* MappedType */) {
                            inferences = ts.append(inferences, keyofConstraintType);
                        }
                        // When an 'infer T' declaration is the template of a mapped type, and that mapped type is the extends
                        // clause of a conditional whose check type is also a mapped type, give it a constraint equal to the template
                        // of the check type's mapped type
                        else if (grandParent.kind === 193 /* MappedType */ && grandParent.type &&
                            ts.skipParentheses(grandParent.type) === declaration.parent && grandParent.parent.kind === 187 /* ConditionalType */ &&
                            grandParent.parent.extendsType === grandParent && grandParent.parent.checkType.kind === 193 /* MappedType */ &&
                            grandParent.parent.checkType.type) {
                            var checkMappedType_1 = grandParent.parent.checkType;
                            var nodeType = getTypeFromTypeNode(checkMappedType_1.type);
                            inferences = ts.append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfNode(checkMappedType_1.typeParameter)), checkMappedType_1.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType_1.typeParameter.constraint) : keyofConstraintType)));
                        }
                    }
                }
            }
            return inferences && getIntersectionType(inferences);
        }
        /** This is a worker function. Use getConstraintOfTypeParameter which guards against circular constraints. */
        function getConstraintFromTypeParameter(typeParameter) {
            if (!typeParameter.constraint) {
                if (typeParameter.target) {
                    var targetConstraint = getConstraintOfTypeParameter(typeParameter.target);
                    typeParameter.constraint = targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType;
                }
                else {
                    var constraintDeclaration = getConstraintDeclaration(typeParameter);
                    if (!constraintDeclaration) {
                        typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType;
                    }
                    else {
                        var type = getTypeFromTypeNode(constraintDeclaration);
                        if (type.flags & 1 /* Any */ && type !== errorType) { // Allow errorType to propegate to keep downstream errors suppressed
                            // use keyofConstraintType as the base constraint for mapped type key constraints (unknown isn;t assignable to that, but `any` was),
                            // use unknown otherwise
                            type = constraintDeclaration.parent.parent.kind === 193 /* MappedType */ ? keyofConstraintType : unknownType;
                        }
                        typeParameter.constraint = type;
                    }
                }
            }
            return typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint;
        }
        function getParentSymbolOfTypeParameter(typeParameter) {
            var tp = ts.getDeclarationOfKind(typeParameter.symbol, 161 /* TypeParameter */);
            var host = ts.isJSDocTemplateTag(tp.parent) ? ts.getHostSignatureFromJSDoc(tp.parent) : tp.parent;
            return host && getSymbolOfNode(host);
        }
        function getTypeListId(types) {
            var result = "";
            if (types) {
                var length_4 = types.length;
                var i = 0;
                while (i < length_4) {
                    var startId = types[i].id;
                    var count = 1;
                    while (i + count < length_4 && types[i + count].id === startId + count) {
                        count++;
                    }
                    if (result.length) {
                        result += ",";
                    }
                    result += startId;
                    if (count > 1) {
                        result += ":" + count;
                    }
                    i += count;
                }
            }
            return result;
        }
        function getAliasId(aliasSymbol, aliasTypeArguments) {
            return aliasSymbol ? "@" + getSymbolId(aliasSymbol) + (aliasTypeArguments ? ":" + getTypeListId(aliasTypeArguments) : "") : "";
        }
        // This function is used to propagate certain flags when creating new object type references and union types.
        // It is only necessary to do so if a constituent type might be the undefined type, the null type, the type
        // of an object literal or the anyFunctionType. This is because there are operations in the type checker
        // that care about the presence of such types at arbitrary depth in a containing type.
        function getPropagatingFlagsOfTypes(types, excludeKinds) {
            var result = 0;
            for (var _i = 0, types_8 = types; _i < types_8.length; _i++) {
                var type = types_8[_i];
                if (!(type.flags & excludeKinds)) {
                    result |= ts.getObjectFlags(type);
                }
            }
            return result & 917504 /* PropagatingFlags */;
        }
        function createTypeReference(target, typeArguments) {
            var id = getTypeListId(typeArguments);
            var type = target.instantiations.get(id);
            if (!type) {
                type = createObjectType(4 /* Reference */, target.symbol);
                target.instantiations.set(id, type);
                type.objectFlags |= typeArguments ? getPropagatingFlagsOfTypes(typeArguments, /*excludeKinds*/ 0) : 0;
                type.target = target;
                type.resolvedTypeArguments = typeArguments;
            }
            return type;
        }
        function cloneTypeReference(source) {
            var type = createType(source.flags);
            type.symbol = source.symbol;
            type.objectFlags = source.objectFlags;
            type.target = source.target;
            type.resolvedTypeArguments = source.resolvedTypeArguments;
            return type;
        }
        function createDeferredTypeReference(target, node, mapper, aliasSymbol, aliasTypeArguments) {
            if (!aliasSymbol) {
                aliasSymbol = getAliasSymbolForTypeNode(node);
                var localAliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                aliasTypeArguments = mapper ? instantiateTypes(localAliasTypeArguments, mapper) : localAliasTypeArguments;
            }
            var type = createObjectType(4 /* Reference */, target.symbol);
            type.target = target;
            type.node = node;
            type.mapper = mapper;
            type.aliasSymbol = aliasSymbol;
            type.aliasTypeArguments = aliasTypeArguments;
            return type;
        }
        function getTypeArguments(type) {
            var _a, _b;
            if (!type.resolvedTypeArguments) {
                if (!pushTypeResolution(type, 6 /* ResolvedTypeArguments */)) {
                    return ((_a = type.target.localTypeParameters) === null || _a === void 0 ? void 0 : _a.map(function () { return errorType; })) || ts.emptyArray;
                }
                var node = type.node;
                var typeArguments = !node ? ts.emptyArray :
                    node.kind === 176 /* TypeReference */ ? ts.concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments(node, type.target.localTypeParameters)) :
                        node.kind === 181 /* ArrayType */ ? [getTypeFromTypeNode(node.elementType)] :
                            ts.map(node.elements, getTypeFromTypeNode);
                if (popTypeResolution()) {
                    type.resolvedTypeArguments = type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments;
                }
                else {
                    type.resolvedTypeArguments = ((_b = type.target.localTypeParameters) === null || _b === void 0 ? void 0 : _b.map(function () { return errorType; })) || ts.emptyArray;
                    error(type.node || currentNode, type.target.symbol ? ts.Diagnostics.Type_arguments_for_0_circularly_reference_themselves : ts.Diagnostics.Tuple_type_arguments_circularly_reference_themselves, type.target.symbol && symbolToString(type.target.symbol));
                }
            }
            return type.resolvedTypeArguments;
        }
        function getTypeReferenceArity(type) {
            return ts.length(type.target.typeParameters);
        }
        /**
         * Get type from type-reference that reference to class or interface
         */
        function getTypeFromClassOrInterfaceReference(node, symbol) {
            var type = getDeclaredTypeOfSymbol(getMergedSymbol(symbol));
            var typeParameters = type.localTypeParameters;
            if (typeParameters) {
                var numTypeArguments = ts.length(node.typeArguments);
                var minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
                var isJs = ts.isInJSFile(node);
                var isJsImplicitAny = !noImplicitAny && isJs;
                if (!isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length)) {
                    var missingAugmentsTag = isJs && ts.isExpressionWithTypeArguments(node) && !ts.isJSDocAugmentsTag(node.parent);
                    var diag = minTypeArgumentCount === typeParameters.length ?
                        missingAugmentsTag ?
                            ts.Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag :
                            ts.Diagnostics.Generic_type_0_requires_1_type_argument_s :
                        missingAugmentsTag ?
                            ts.Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag :
                            ts.Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments;
                    var typeStr = typeToString(type, /*enclosingDeclaration*/ undefined, 2 /* WriteArrayAsGenericType */);
                    error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length);
                    if (!isJs) {
                        // TODO: Adopt same permissive behavior in TS as in JS to reduce follow-on editing experience failures (requires editing fillMissingTypeArguments)
                        return errorType;
                    }
                }
                if (node.kind === 176 /* TypeReference */ && isDeferredTypeReferenceNode(node, ts.length(node.typeArguments) !== typeParameters.length)) {
                    return createDeferredTypeReference(type, node, /*mapper*/ undefined);
                }
                // In a type reference, the outer type parameters of the referenced class or interface are automatically
                // supplied as type arguments and the type reference only specifies arguments for the local type parameters
                // of the class or interface.
                var typeArguments = ts.concatenate(type.outerTypeParameters, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs));
                return createTypeReference(type, typeArguments);
            }
            return checkNoTypeArguments(node, symbol) ? type : errorType;
        }
        function getTypeAliasInstantiation(symbol, typeArguments, aliasSymbol, aliasTypeArguments) {
            var type = getDeclaredTypeOfSymbol(symbol);
            if (type === intrinsicMarkerType && intrinsicTypeKinds.has(symbol.escapedName) && typeArguments && typeArguments.length === 1) {
                return getStringMappingType(symbol, typeArguments[0]);
            }
            var links = getSymbolLinks(symbol);
            var typeParameters = links.typeParameters;
            var id = getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
            var instantiation = links.instantiations.get(id);
            if (!instantiation) {
                links.instantiations.set(id, instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), ts.isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments));
            }
            return instantiation;
        }
        /**
         * Get type from reference to type alias. When a type alias is generic, the declared type of the type alias may include
         * references to the type parameters of the alias. We replace those with the actual type arguments by instantiating the
         * declared type. Instantiations are cached using the type identities of the type arguments as the key.
         */
        function getTypeFromTypeAliasReference(node, symbol) {
            var type = getDeclaredTypeOfSymbol(symbol);
            var typeParameters = getSymbolLinks(symbol).typeParameters;
            if (typeParameters) {
                var numTypeArguments = ts.length(node.typeArguments);
                var minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
                if (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
                    error(node, minTypeArgumentCount === typeParameters.length ?
                        ts.Diagnostics.Generic_type_0_requires_1_type_argument_s :
                        ts.Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments, symbolToString(symbol), minTypeArgumentCount, typeParameters.length);
                    return errorType;
                }
                // We refrain from associating a local type alias with an instantiation of a top-level type alias
                // because the local alias may end up being referenced in an inferred return type where it is not
                // accessible--which in turn may lead to a large structural expansion of the type when generating
                // a .d.ts file. See #43622 for an example.
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                var newAliasSymbol = aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)) ? aliasSymbol : undefined;
                return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, getTypeArgumentsForAliasSymbol(newAliasSymbol));
            }
            return checkNoTypeArguments(node, symbol) ? type : errorType;
        }
        function isLocalTypeAlias(symbol) {
            var _a;
            var declaration = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isTypeAlias);
            return !!(declaration && ts.getContainingFunction(declaration));
        }
        function getTypeReferenceName(node) {
            switch (node.kind) {
                case 176 /* TypeReference */:
                    return node.typeName;
                case 226 /* ExpressionWithTypeArguments */:
                    // We only support expressions that are simple qualified names. For other
                    // expressions this produces undefined.
                    var expr = node.expression;
                    if (ts.isEntityNameExpression(expr)) {
                        return expr;
                    }
                // fall through;
            }
            return undefined;
        }
        function resolveTypeReferenceName(typeReferenceName, meaning, ignoreErrors) {
            if (!typeReferenceName) {
                return unknownSymbol;
            }
            return resolveEntityName(typeReferenceName, meaning, ignoreErrors) || unknownSymbol;
        }
        function getTypeReferenceType(node, symbol) {
            if (symbol === unknownSymbol) {
                return errorType;
            }
            symbol = getExpandoSymbol(symbol) || symbol;
            if (symbol.flags & (32 /* Class */ | 64 /* Interface */)) {
                return getTypeFromClassOrInterfaceReference(node, symbol);
            }
            if (symbol.flags & 524288 /* TypeAlias */) {
                return getTypeFromTypeAliasReference(node, symbol);
            }
            // Get type from reference to named type that cannot be generic (enum or type parameter)
            var res = tryGetDeclaredTypeOfSymbol(symbol);
            if (res) {
                return checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(res) : errorType;
            }
            if (symbol.flags & 111551 /* Value */ && isJSDocTypeReference(node)) {
                var jsdocType = getTypeFromJSDocValueReference(node, symbol);
                if (jsdocType) {
                    return jsdocType;
                }
                else {
                    // Resolve the type reference as a Type for the purpose of reporting errors.
                    resolveTypeReferenceName(getTypeReferenceName(node), 788968 /* Type */);
                    return getTypeOfSymbol(symbol);
                }
            }
            return errorType;
        }
        /**
         * A JSdoc TypeReference may be to a value, but resolve it as a type anyway.
         * Example: import('./b').ConstructorFunction
         */
        function getTypeFromJSDocValueReference(node, symbol) {
            var links = getNodeLinks(node);
            if (!links.resolvedJSDocType) {
                var valueType = getTypeOfSymbol(symbol);
                var typeType = valueType;
                if (symbol.valueDeclaration) {
                    var isImportTypeWithQualifier = node.kind === 198 /* ImportType */ && node.qualifier;
                    // valueType might not have a symbol, eg, {import('./b').STRING_LITERAL}
                    if (valueType.symbol && valueType.symbol !== symbol && isImportTypeWithQualifier) {
                        typeType = getTypeReferenceType(node, valueType.symbol);
                    }
                }
                links.resolvedJSDocType = typeType;
            }
            return links.resolvedJSDocType;
        }
        function getSubstitutionType(baseType, substitute) {
            if (substitute.flags & 3 /* AnyOrUnknown */ || substitute === baseType) {
                return baseType;
            }
            var id = getTypeId(baseType) + ">" + getTypeId(substitute);
            var cached = substitutionTypes.get(id);
            if (cached) {
                return cached;
            }
            var result = createType(33554432 /* Substitution */);
            result.baseType = baseType;
            result.substitute = substitute;
            substitutionTypes.set(id, result);
            return result;
        }
        function isUnaryTupleTypeNode(node) {
            return node.kind === 182 /* TupleType */ && node.elements.length === 1;
        }
        function getImpliedConstraint(type, checkNode, extendsNode) {
            return isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode) ? getImpliedConstraint(type, checkNode.elements[0], extendsNode.elements[0]) :
                getActualTypeVariable(getTypeFromTypeNode(checkNode)) === type ? getTypeFromTypeNode(extendsNode) :
                    undefined;
        }
        function getConditionalFlowTypeOfType(type, node) {
            var constraints;
            var covariant = true;
            while (node && !ts.isStatement(node) && node.kind !== 315 /* JSDocComment */) {
                var parent = node.parent;
                // only consider variance flipped by parameter locations - `keyof` types would usually be considered variance inverting, but
                // often get used in indexed accesses where they behave sortof invariantly, but our checking is lax
                if (parent.kind === 162 /* Parameter */) {
                    covariant = !covariant;
                }
                // Always substitute on type parameters, regardless of variance, since even
                // in contravariant positions, they may rely on substituted constraints to be valid
                if ((covariant || type.flags & 8650752 /* TypeVariable */) && parent.kind === 187 /* ConditionalType */ && node === parent.trueType) {
                    var constraint = getImpliedConstraint(type, parent.checkType, parent.extendsType);
                    if (constraint) {
                        constraints = ts.append(constraints, constraint);
                    }
                }
                node = parent;
            }
            return constraints ? getSubstitutionType(type, getIntersectionType(ts.append(constraints, type))) : type;
        }
        function isJSDocTypeReference(node) {
            return !!(node.flags & 4194304 /* JSDoc */) && (node.kind === 176 /* TypeReference */ || node.kind === 198 /* ImportType */);
        }
        function checkNoTypeArguments(node, symbol) {
            if (node.typeArguments) {
                error(node, ts.Diagnostics.Type_0_is_not_generic, symbol ? symbolToString(symbol) : node.typeName ? ts.declarationNameToString(node.typeName) : anon);
                return false;
            }
            return true;
        }
        function getIntendedTypeFromJSDocTypeReference(node) {
            if (ts.isIdentifier(node.typeName)) {
                var typeArgs = node.typeArguments;
                switch (node.typeName.escapedText) {
                    case "String":
                        checkNoTypeArguments(node);
                        return stringType;
                    case "Number":
                        checkNoTypeArguments(node);
                        return numberType;
                    case "Boolean":
                        checkNoTypeArguments(node);
                        return booleanType;
                    case "Void":
                        checkNoTypeArguments(node);
                        return voidType;
                    case "Undefined":
                        checkNoTypeArguments(node);
                        return undefinedType;
                    case "Null":
                        checkNoTypeArguments(node);
                        return nullType;
                    case "Function":
                    case "function":
                        checkNoTypeArguments(node);
                        return globalFunctionType;
                    case "array":
                        return (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : undefined;
                    case "promise":
                        return (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(anyType) : undefined;
                    case "Object":
                        if (typeArgs && typeArgs.length === 2) {
                            if (ts.isJSDocIndexSignature(node)) {
                                var indexed = getTypeFromTypeNode(typeArgs[0]);
                                var target = getTypeFromTypeNode(typeArgs[1]);
                                var indexInfo = indexed === stringType || indexed === numberType ? [createIndexInfo(indexed, target, /*isReadonly*/ false)] : ts.emptyArray;
                                return createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, indexInfo);
                            }
                            return anyType;
                        }
                        checkNoTypeArguments(node);
                        return !noImplicitAny ? anyType : undefined;
                }
            }
        }
        function getTypeFromJSDocNullableTypeNode(node) {
            var type = getTypeFromTypeNode(node.type);
            return strictNullChecks ? getNullableType(type, 65536 /* Null */) : type;
        }
        function getTypeFromTypeReference(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // handle LS queries on the `const` in `x as const` by resolving to the type of `x`
                if (ts.isConstTypeReference(node) && ts.isAssertionExpression(node.parent)) {
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = checkExpressionCached(node.parent.expression);
                }
                var symbol = void 0;
                var type = void 0;
                var meaning = 788968 /* Type */;
                if (isJSDocTypeReference(node)) {
                    type = getIntendedTypeFromJSDocTypeReference(node);
                    if (!type) {
                        symbol = resolveTypeReferenceName(getTypeReferenceName(node), meaning, /*ignoreErrors*/ true);
                        if (symbol === unknownSymbol) {
                            symbol = resolveTypeReferenceName(getTypeReferenceName(node), meaning | 111551 /* Value */);
                        }
                        else {
                            resolveTypeReferenceName(getTypeReferenceName(node), meaning); // Resolve again to mark errors, if any
                        }
                        type = getTypeReferenceType(node, symbol);
                    }
                }
                if (!type) {
                    symbol = resolveTypeReferenceName(getTypeReferenceName(node), meaning);
                    type = getTypeReferenceType(node, symbol);
                }
                // Cache both the resolved symbol and the resolved type. The resolved symbol is needed when we check the
                // type reference in checkTypeReferenceNode.
                links.resolvedSymbol = symbol;
                links.resolvedType = type;
            }
            return links.resolvedType;
        }
        function typeArgumentsFromTypeReferenceNode(node) {
            return ts.map(node.typeArguments, getTypeFromTypeNode);
        }
        function getTypeFromTypeQueryNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // TypeScript 1.0 spec (April 2014): 3.6.3
                // The expression is processed as an identifier expression (section 4.3)
                // or property access expression(section 4.10),
                // the widened type(section 3.9) of which becomes the result.
                var type = ts.isThisIdentifier(node.exprName) ? checkThisExpression(node.exprName) : checkExpression(node.exprName);
                links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type));
            }
            return links.resolvedType;
        }
        function getTypeOfGlobalSymbol(symbol, arity) {
            function getTypeDeclaration(symbol) {
                var declarations = symbol.declarations;
                if (declarations) {
                    for (var _i = 0, declarations_3 = declarations; _i < declarations_3.length; _i++) {
                        var declaration = declarations_3[_i];
                        switch (declaration.kind) {
                            case 255 /* ClassDeclaration */:
                            case 256 /* InterfaceDeclaration */:
                            case 258 /* EnumDeclaration */:
                                return declaration;
                        }
                    }
                }
            }
            if (!symbol) {
                return arity ? emptyGenericType : emptyObjectType;
            }
            var type = getDeclaredTypeOfSymbol(symbol);
            if (!(type.flags & 524288 /* Object */)) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_be_a_class_or_interface_type, ts.symbolName(symbol));
                return arity ? emptyGenericType : emptyObjectType;
            }
            if (ts.length(type.typeParameters) !== arity) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_have_1_type_parameter_s, ts.symbolName(symbol), arity);
                return arity ? emptyGenericType : emptyObjectType;
            }
            return type;
        }
        function getGlobalValueSymbol(name, reportErrors) {
            return getGlobalSymbol(name, 111551 /* Value */, reportErrors ? ts.Diagnostics.Cannot_find_global_value_0 : undefined);
        }
        function getGlobalTypeSymbol(name, reportErrors) {
            return getGlobalSymbol(name, 788968 /* Type */, reportErrors ? ts.Diagnostics.Cannot_find_global_type_0 : undefined);
        }
        function getGlobalSymbol(name, meaning, diagnostic) {
            // Don't track references for global symbols anyway, so value if `isReference` is arbitrary
            return resolveName(undefined, name, meaning, diagnostic, name, /*isUse*/ false);
        }
        function getGlobalType(name, arity, reportErrors) {
            var symbol = getGlobalTypeSymbol(name, reportErrors);
            return symbol || reportErrors ? getTypeOfGlobalSymbol(symbol, arity) : undefined;
        }
        function getGlobalTypedPropertyDescriptorType() {
            return deferredGlobalTypedPropertyDescriptorType || (deferredGlobalTypedPropertyDescriptorType = getGlobalType("TypedPropertyDescriptor", /*arity*/ 1, /*reportErrors*/ true)) || emptyGenericType;
        }
        function getGlobalTemplateStringsArrayType() {
            return deferredGlobalTemplateStringsArrayType || (deferredGlobalTemplateStringsArrayType = getGlobalType("TemplateStringsArray", /*arity*/ 0, /*reportErrors*/ true)) || emptyObjectType;
        }
        function getGlobalImportMetaType() {
            return deferredGlobalImportMetaType || (deferredGlobalImportMetaType = getGlobalType("ImportMeta", /*arity*/ 0, /*reportErrors*/ true)) || emptyObjectType;
        }
        function getGlobalImportMetaExpressionType() {
            if (!deferredGlobalImportMetaExpressionType) {
                // Create a synthetic type `ImportMetaExpression { meta: MetaProperty }`
                var symbol = createSymbol(0 /* None */, "ImportMetaExpression");
                var importMetaType = getGlobalImportMetaType();
                var metaPropertySymbol = createSymbol(4 /* Property */, "meta", 8 /* Readonly */);
                metaPropertySymbol.parent = symbol;
                metaPropertySymbol.type = importMetaType;
                var members = ts.createSymbolTable([metaPropertySymbol]);
                symbol.members = members;
                deferredGlobalImportMetaExpressionType = createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            }
            return deferredGlobalImportMetaExpressionType;
        }
        function getGlobalESSymbolConstructorSymbol(reportErrors) {
            return deferredGlobalESSymbolConstructorSymbol || (deferredGlobalESSymbolConstructorSymbol = getGlobalValueSymbol("Symbol", reportErrors));
        }
        function getGlobalESSymbolConstructorTypeSymbol(reportErrors) {
            return deferredGlobalESSymbolConstructorTypeSymbol || (deferredGlobalESSymbolConstructorTypeSymbol = getGlobalTypeSymbol("SymbolConstructor", reportErrors));
        }
        function getGlobalESSymbolType(reportErrors) {
            return deferredGlobalESSymbolType || (deferredGlobalESSymbolType = getGlobalType("Symbol", /*arity*/ 0, reportErrors)) || emptyObjectType;
        }
        function getGlobalPromiseType(reportErrors) {
            return deferredGlobalPromiseType || (deferredGlobalPromiseType = getGlobalType("Promise", /*arity*/ 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalPromiseLikeType(reportErrors) {
            return deferredGlobalPromiseLikeType || (deferredGlobalPromiseLikeType = getGlobalType("PromiseLike", /*arity*/ 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalPromiseConstructorSymbol(reportErrors) {
            return deferredGlobalPromiseConstructorSymbol || (deferredGlobalPromiseConstructorSymbol = getGlobalValueSymbol("Promise", reportErrors));
        }
        function getGlobalPromiseConstructorLikeType(reportErrors) {
            return deferredGlobalPromiseConstructorLikeType || (deferredGlobalPromiseConstructorLikeType = getGlobalType("PromiseConstructorLike", /*arity*/ 0, reportErrors)) || emptyObjectType;
        }
        function getGlobalAsyncIterableType(reportErrors) {
            return deferredGlobalAsyncIterableType || (deferredGlobalAsyncIterableType = getGlobalType("AsyncIterable", /*arity*/ 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalAsyncIteratorType(reportErrors) {
            return deferredGlobalAsyncIteratorType || (deferredGlobalAsyncIteratorType = getGlobalType("AsyncIterator", /*arity*/ 3, reportErrors)) || emptyGenericType;
        }
        function getGlobalAsyncIterableIteratorType(reportErrors) {
            return deferredGlobalAsyncIterableIteratorType || (deferredGlobalAsyncIterableIteratorType = getGlobalType("AsyncIterableIterator", /*arity*/ 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalAsyncGeneratorType(reportErrors) {
            return deferredGlobalAsyncGeneratorType || (deferredGlobalAsyncGeneratorType = getGlobalType("AsyncGenerator", /*arity*/ 3, reportErrors)) || emptyGenericType;
        }
        function getGlobalIterableType(reportErrors) {
            return deferredGlobalIterableType || (deferredGlobalIterableType = getGlobalType("Iterable", /*arity*/ 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalIteratorType(reportErrors) {
            return deferredGlobalIteratorType || (deferredGlobalIteratorType = getGlobalType("Iterator", /*arity*/ 3, reportErrors)) || emptyGenericType;
        }
        function getGlobalIterableIteratorType(reportErrors) {
            return deferredGlobalIterableIteratorType || (deferredGlobalIterableIteratorType = getGlobalType("IterableIterator", /*arity*/ 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalGeneratorType(reportErrors) {
            return deferredGlobalGeneratorType || (deferredGlobalGeneratorType = getGlobalType("Generator", /*arity*/ 3, reportErrors)) || emptyGenericType;
        }
        function getGlobalIteratorYieldResultType(reportErrors) {
            return deferredGlobalIteratorYieldResultType || (deferredGlobalIteratorYieldResultType = getGlobalType("IteratorYieldResult", /*arity*/ 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalIteratorReturnResultType(reportErrors) {
            return deferredGlobalIteratorReturnResultType || (deferredGlobalIteratorReturnResultType = getGlobalType("IteratorReturnResult", /*arity*/ 1, reportErrors)) || emptyGenericType;
        }
        function getGlobalTypeOrUndefined(name, arity) {
            if (arity === void 0) { arity = 0; }
            var symbol = getGlobalSymbol(name, 788968 /* Type */, /*diagnostic*/ undefined);
            return symbol && getTypeOfGlobalSymbol(symbol, arity);
        }
        function getGlobalExtractSymbol() {
            return deferredGlobalExtractSymbol || (deferredGlobalExtractSymbol = getGlobalSymbol("Extract", 524288 /* TypeAlias */, ts.Diagnostics.Cannot_find_global_type_0)); // TODO: GH#18217
        }
        function getGlobalOmitSymbol() {
            return deferredGlobalOmitSymbol || (deferredGlobalOmitSymbol = getGlobalSymbol("Omit", 524288 /* TypeAlias */, ts.Diagnostics.Cannot_find_global_type_0)); // TODO: GH#18217
        }
        function getGlobalBigIntType(reportErrors) {
            return deferredGlobalBigIntType || (deferredGlobalBigIntType = getGlobalType("BigInt", /*arity*/ 0, reportErrors)) || emptyObjectType;
        }
        /**
         * Instantiates a global type that is generic with some element type, and returns that instantiation.
         */
        function createTypeFromGenericGlobalType(genericGlobalType, typeArguments) {
            return genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType;
        }
        function createTypedPropertyDescriptorType(propertyType) {
            return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType(), [propertyType]);
        }
        function createIterableType(iteratedType) {
            return createTypeFromGenericGlobalType(getGlobalIterableType(/*reportErrors*/ true), [iteratedType]);
        }
        function createArrayType(elementType, readonly) {
            return createTypeFromGenericGlobalType(readonly ? globalReadonlyArrayType : globalArrayType, [elementType]);
        }
        function getTupleElementFlags(node) {
            switch (node.kind) {
                case 183 /* OptionalType */:
                    return 2 /* Optional */;
                case 184 /* RestType */:
                    return getRestTypeElementFlags(node);
                case 195 /* NamedTupleMember */:
                    return node.questionToken ? 2 /* Optional */ :
                        node.dotDotDotToken ? getRestTypeElementFlags(node) :
                            1 /* Required */;
                default:
                    return 1 /* Required */;
            }
        }
        function getRestTypeElementFlags(node) {
            return getArrayElementTypeNode(node.type) ? 4 /* Rest */ : 8 /* Variadic */;
        }
        function getArrayOrTupleTargetType(node) {
            var readonly = isReadonlyTypeOperator(node.parent);
            var elementType = getArrayElementTypeNode(node);
            if (elementType) {
                return readonly ? globalReadonlyArrayType : globalArrayType;
            }
            var elementFlags = ts.map(node.elements, getTupleElementFlags);
            var missingName = ts.some(node.elements, function (e) { return e.kind !== 195 /* NamedTupleMember */; });
            return getTupleTargetType(elementFlags, readonly, /*associatedNames*/ missingName ? undefined : node.elements);
        }
        // Return true if the given type reference node is directly aliased or if it needs to be deferred
        // because it is possibly contained in a circular chain of eagerly resolved types.
        function isDeferredTypeReferenceNode(node, hasDefaultTypeArguments) {
            return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && (node.kind === 181 /* ArrayType */ ? mayResolveTypeAlias(node.elementType) :
                node.kind === 182 /* TupleType */ ? ts.some(node.elements, mayResolveTypeAlias) :
                    hasDefaultTypeArguments || ts.some(node.typeArguments, mayResolveTypeAlias));
        }
        // Return true when the given node is transitively contained in type constructs that eagerly
        // resolve their constituent types. We include SyntaxKind.TypeReference because type arguments
        // of type aliases are eagerly resolved.
        function isResolvedByTypeAlias(node) {
            var parent = node.parent;
            switch (parent.kind) {
                case 189 /* ParenthesizedType */:
                case 195 /* NamedTupleMember */:
                case 176 /* TypeReference */:
                case 185 /* UnionType */:
                case 186 /* IntersectionType */:
                case 192 /* IndexedAccessType */:
                case 187 /* ConditionalType */:
                case 191 /* TypeOperator */:
                case 181 /* ArrayType */:
                case 182 /* TupleType */:
                    return isResolvedByTypeAlias(parent);
                case 257 /* TypeAliasDeclaration */:
                    return true;
            }
            return false;
        }
        // Return true if resolving the given node (i.e. getTypeFromTypeNode) possibly causes resolution
        // of a type alias.
        function mayResolveTypeAlias(node) {
            switch (node.kind) {
                case 176 /* TypeReference */:
                    return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node.typeName, 788968 /* Type */).flags & 524288 /* TypeAlias */);
                case 179 /* TypeQuery */:
                    return true;
                case 191 /* TypeOperator */:
                    return node.operator !== 152 /* UniqueKeyword */ && mayResolveTypeAlias(node.type);
                case 189 /* ParenthesizedType */:
                case 183 /* OptionalType */:
                case 195 /* NamedTupleMember */:
                case 311 /* JSDocOptionalType */:
                case 309 /* JSDocNullableType */:
                case 310 /* JSDocNonNullableType */:
                case 304 /* JSDocTypeExpression */:
                    return mayResolveTypeAlias(node.type);
                case 184 /* RestType */:
                    return node.type.kind !== 181 /* ArrayType */ || mayResolveTypeAlias(node.type.elementType);
                case 185 /* UnionType */:
                case 186 /* IntersectionType */:
                    return ts.some(node.types, mayResolveTypeAlias);
                case 192 /* IndexedAccessType */:
                    return mayResolveTypeAlias(node.objectType) || mayResolveTypeAlias(node.indexType);
                case 187 /* ConditionalType */:
                    return mayResolveTypeAlias(node.checkType) || mayResolveTypeAlias(node.extendsType) ||
                        mayResolveTypeAlias(node.trueType) || mayResolveTypeAlias(node.falseType);
            }
            return false;
        }
        function getTypeFromArrayOrTupleTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var target = getArrayOrTupleTargetType(node);
                if (target === emptyGenericType) {
                    links.resolvedType = emptyObjectType;
                }
                else if (!(node.kind === 182 /* TupleType */ && ts.some(node.elements, function (e) { return !!(getTupleElementFlags(e) & 8 /* Variadic */); })) && isDeferredTypeReferenceNode(node)) {
                    links.resolvedType = node.kind === 182 /* TupleType */ && node.elements.length === 0 ? target :
                        createDeferredTypeReference(target, node, /*mapper*/ undefined);
                }
                else {
                    var elementTypes = node.kind === 181 /* ArrayType */ ? [getTypeFromTypeNode(node.elementType)] : ts.map(node.elements, getTypeFromTypeNode);
                    links.resolvedType = createNormalizedTypeReference(target, elementTypes);
                }
            }
            return links.resolvedType;
        }
        function isReadonlyTypeOperator(node) {
            return ts.isTypeOperatorNode(node) && node.operator === 143 /* ReadonlyKeyword */;
        }
        function createTupleType(elementTypes, elementFlags, readonly, namedMemberDeclarations) {
            if (readonly === void 0) { readonly = false; }
            var tupleTarget = getTupleTargetType(elementFlags || ts.map(elementTypes, function (_) { return 1 /* Required */; }), readonly, namedMemberDeclarations);
            return tupleTarget === emptyGenericType ? emptyObjectType :
                elementTypes.length ? createNormalizedTypeReference(tupleTarget, elementTypes) :
                    tupleTarget;
        }
        function getTupleTargetType(elementFlags, readonly, namedMemberDeclarations) {
            if (elementFlags.length === 1 && elementFlags[0] & 4 /* Rest */) {
                // [...X[]] is equivalent to just X[]
                return readonly ? globalReadonlyArrayType : globalArrayType;
            }
            var key = ts.map(elementFlags, function (f) { return f & 1 /* Required */ ? "#" : f & 2 /* Optional */ ? "?" : f & 4 /* Rest */ ? "." : "*"; }).join() +
                (readonly ? "R" : "") +
                (namedMemberDeclarations && namedMemberDeclarations.length ? "," + ts.map(namedMemberDeclarations, getNodeId).join(",") : "");
            var type = tupleTypes.get(key);
            if (!type) {
                tupleTypes.set(key, type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations));
            }
            return type;
        }
        // We represent tuple types as type references to synthesized generic interface types created by
        // this function. The types are of the form:
        //
        //   interface Tuple<T0, T1, T2, ...> extends Array<T0 | T1 | T2 | ...> { 0: T0, 1: T1, 2: T2, ... }
        //
        // Note that the generic type created by this function has no symbol associated with it. The same
        // is true for each of the synthesized type parameters.
        function createTupleTargetType(elementFlags, readonly, namedMemberDeclarations) {
            var arity = elementFlags.length;
            var minLength = ts.countWhere(elementFlags, function (f) { return !!(f & (1 /* Required */ | 8 /* Variadic */)); });
            var typeParameters;
            var properties = [];
            var combinedFlags = 0;
            if (arity) {
                typeParameters = new Array(arity);
                for (var i = 0; i < arity; i++) {
                    var typeParameter = typeParameters[i] = createTypeParameter();
                    var flags = elementFlags[i];
                    combinedFlags |= flags;
                    if (!(combinedFlags & 12 /* Variable */)) {
                        var property = createSymbol(4 /* Property */ | (flags & 2 /* Optional */ ? 16777216 /* Optional */ : 0), "" + i, readonly ? 8 /* Readonly */ : 0);
                        property.tupleLabelDeclaration = namedMemberDeclarations === null || namedMemberDeclarations === void 0 ? void 0 : namedMemberDeclarations[i];
                        property.type = typeParameter;
                        properties.push(property);
                    }
                }
            }
            var fixedLength = properties.length;
            var lengthSymbol = createSymbol(4 /* Property */, "length");
            if (combinedFlags & 12 /* Variable */) {
                lengthSymbol.type = numberType;
            }
            else {
                var literalTypes = [];
                for (var i = minLength; i <= arity; i++)
                    literalTypes.push(getNumberLiteralType(i));
                lengthSymbol.type = getUnionType(literalTypes);
            }
            properties.push(lengthSymbol);
            var type = createObjectType(8 /* Tuple */ | 4 /* Reference */);
            type.typeParameters = typeParameters;
            type.outerTypeParameters = undefined;
            type.localTypeParameters = typeParameters;
            type.instantiations = new ts.Map();
            type.instantiations.set(getTypeListId(type.typeParameters), type);
            type.target = type;
            type.resolvedTypeArguments = type.typeParameters;
            type.thisType = createTypeParameter();
            type.thisType.isThisType = true;
            type.thisType.constraint = type;
            type.declaredProperties = properties;
            type.declaredCallSignatures = ts.emptyArray;
            type.declaredConstructSignatures = ts.emptyArray;
            type.declaredIndexInfos = ts.emptyArray;
            type.elementFlags = elementFlags;
            type.minLength = minLength;
            type.fixedLength = fixedLength;
            type.hasRestElement = !!(combinedFlags & 12 /* Variable */);
            type.combinedFlags = combinedFlags;
            type.readonly = readonly;
            type.labeledElementDeclarations = namedMemberDeclarations;
            return type;
        }
        function createNormalizedTypeReference(target, typeArguments) {
            return target.objectFlags & 8 /* Tuple */ ? createNormalizedTupleType(target, typeArguments) : createTypeReference(target, typeArguments);
        }
        function createNormalizedTupleType(target, elementTypes) {
            var _a, _b, _c;
            if (!(target.combinedFlags & 14 /* NonRequired */)) {
                // No need to normalize when we only have regular required elements
                return createTypeReference(target, elementTypes);
            }
            if (target.combinedFlags & 8 /* Variadic */) {
                // Transform [A, ...(X | Y | Z)] into [A, ...X] | [A, ...Y] | [A, ...Z]
                var unionIndex_1 = ts.findIndex(elementTypes, function (t, i) { return !!(target.elementFlags[i] & 8 /* Variadic */ && t.flags & (131072 /* Never */ | 1048576 /* Union */)); });
                if (unionIndex_1 >= 0) {
                    return checkCrossProductUnion(ts.map(elementTypes, function (t, i) { return target.elementFlags[i] & 8 /* Variadic */ ? t : unknownType; })) ?
                        mapType(elementTypes[unionIndex_1], function (t) { return createNormalizedTupleType(target, ts.replaceElement(elementTypes, unionIndex_1, t)); }) :
                        errorType;
                }
            }
            // We have optional, rest, or variadic elements that may need normalizing. Normalization ensures that all variadic
            // elements are generic and that the tuple type has one of the following layouts, disregarding variadic elements:
            // (1) Zero or more required elements, followed by zero or more optional elements, followed by zero or one rest element.
            // (2) Zero or more required elements, followed by a rest element, followed by zero or more required elements.
            // In either layout, zero or more generic variadic elements may be present at any location.
            var expandedTypes = [];
            var expandedFlags = [];
            var expandedDeclarations = [];
            var lastRequiredIndex = -1;
            var firstRestIndex = -1;
            var lastOptionalOrRestIndex = -1;
            var _loop_15 = function (i) {
                var type = elementTypes[i];
                var flags = target.elementFlags[i];
                if (flags & 8 /* Variadic */) {
                    if (type.flags & 58982400 /* InstantiableNonPrimitive */ || isGenericMappedType(type)) {
                        // Generic variadic elements stay as they are.
                        addElement(type, 8 /* Variadic */, (_a = target.labeledElementDeclarations) === null || _a === void 0 ? void 0 : _a[i]);
                    }
                    else if (isTupleType(type)) {
                        var elements = getTypeArguments(type);
                        if (elements.length + expandedTypes.length >= 10000) {
                            error(currentNode, ts.isPartOfTypeNode(currentNode)
                                ? ts.Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent
                                : ts.Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent);
                            return { value: errorType };
                        }
                        // Spread variadic elements with tuple types into the resulting tuple.
                        ts.forEach(elements, function (t, n) { var _a; return addElement(t, type.target.elementFlags[n], (_a = type.target.labeledElementDeclarations) === null || _a === void 0 ? void 0 : _a[n]); });
                    }
                    else {
                        // Treat everything else as an array type and create a rest element.
                        addElement(isArrayLikeType(type) && getIndexTypeOfType(type, numberType) || errorType, 4 /* Rest */, (_b = target.labeledElementDeclarations) === null || _b === void 0 ? void 0 : _b[i]);
                    }
                }
                else {
                    // Copy other element kinds with no change.
                    addElement(type, flags, (_c = target.labeledElementDeclarations) === null || _c === void 0 ? void 0 : _c[i]);
                }
            };
            for (var i = 0; i < elementTypes.length; i++) {
                var state_4 = _loop_15(i);
                if (typeof state_4 === "object")
                    return state_4.value;
            }
            // Turn optional elements preceding the last required element into required elements
            for (var i = 0; i < lastRequiredIndex; i++) {
                if (expandedFlags[i] & 2 /* Optional */)
                    expandedFlags[i] = 1 /* Required */;
            }
            if (firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex) {
                // Turn elements between first rest and last optional/rest into a single rest element
                expandedTypes[firstRestIndex] = getUnionType(ts.sameMap(expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex + 1), function (t, i) { return expandedFlags[firstRestIndex + i] & 8 /* Variadic */ ? getIndexedAccessType(t, numberType) : t; }));
                expandedTypes.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
                expandedFlags.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
                expandedDeclarations === null || expandedDeclarations === void 0 ? void 0 : expandedDeclarations.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
            }
            var tupleTarget = getTupleTargetType(expandedFlags, target.readonly, expandedDeclarations);
            return tupleTarget === emptyGenericType ? emptyObjectType :
                expandedFlags.length ? createTypeReference(tupleTarget, expandedTypes) :
                    tupleTarget;
            function addElement(type, flags, declaration) {
                if (flags & 1 /* Required */) {
                    lastRequiredIndex = expandedFlags.length;
                }
                if (flags & 4 /* Rest */ && firstRestIndex < 0) {
                    firstRestIndex = expandedFlags.length;
                }
                if (flags & (2 /* Optional */ | 4 /* Rest */)) {
                    lastOptionalOrRestIndex = expandedFlags.length;
                }
                expandedTypes.push(type);
                expandedFlags.push(flags);
                if (expandedDeclarations && declaration) {
                    expandedDeclarations.push(declaration);
                }
                else {
                    expandedDeclarations = undefined;
                }
            }
        }
        function sliceTupleType(type, index, endSkipCount) {
            if (endSkipCount === void 0) { endSkipCount = 0; }
            var target = type.target;
            var endIndex = getTypeReferenceArity(type) - endSkipCount;
            return index > target.fixedLength ? getRestArrayTypeOfTupleType(type) || createTupleType(ts.emptyArray) :
                createTupleType(getTypeArguments(type).slice(index, endIndex), target.elementFlags.slice(index, endIndex), 
                /*readonly*/ false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex));
        }
        function getKnownKeysOfTupleType(type) {
            return getUnionType(ts.append(ts.arrayOf(type.target.fixedLength, function (i) { return getStringLiteralType("" + i); }), getIndexType(type.target.readonly ? globalReadonlyArrayType : globalArrayType)));
        }
        // Return count of starting consecutive tuple elements of the given kind(s)
        function getStartElementCount(type, flags) {
            var index = ts.findIndex(type.elementFlags, function (f) { return !(f & flags); });
            return index >= 0 ? index : type.elementFlags.length;
        }
        // Return count of ending consecutive tuple elements of the given kind(s)
        function getEndElementCount(type, flags) {
            return type.elementFlags.length - ts.findLastIndex(type.elementFlags, function (f) { return !(f & flags); }) - 1;
        }
        function getTypeFromOptionalTypeNode(node) {
            return addOptionality(getTypeFromTypeNode(node.type), /*isProperty*/ true);
        }
        function getTypeId(type) {
            return type.id;
        }
        function containsType(types, type) {
            return ts.binarySearch(types, type, getTypeId, ts.compareValues) >= 0;
        }
        function insertType(types, type) {
            var index = ts.binarySearch(types, type, getTypeId, ts.compareValues);
            if (index < 0) {
                types.splice(~index, 0, type);
                return true;
            }
            return false;
        }
        function addTypeToUnion(typeSet, includes, type) {
            var flags = type.flags;
            if (flags & 1048576 /* Union */) {
                return addTypesToUnion(typeSet, includes | (isNamedUnionType(type) ? 1048576 /* Union */ : 0), type.types);
            }
            // We ignore 'never' types in unions
            if (!(flags & 131072 /* Never */)) {
                includes |= flags & 205258751 /* IncludesMask */;
                if (flags & 469499904 /* StructuredOrInstantiable */)
                    includes |= 262144 /* IncludesStructuredOrInstantiable */;
                if (type === wildcardType)
                    includes |= 8388608 /* IncludesWildcard */;
                if (!strictNullChecks && flags & 98304 /* Nullable */) {
                    if (!(ts.getObjectFlags(type) & 131072 /* ContainsWideningType */))
                        includes |= 4194304 /* IncludesNonWideningType */;
                }
                else {
                    var len = typeSet.length;
                    var index = len && type.id > typeSet[len - 1].id ? ~len : ts.binarySearch(typeSet, type, getTypeId, ts.compareValues);
                    if (index < 0) {
                        typeSet.splice(~index, 0, type);
                    }
                }
            }
            return includes;
        }
        // Add the given types to the given type set. Order is preserved, duplicates are removed,
        // and nested types of the given kind are flattened into the set.
        function addTypesToUnion(typeSet, includes, types) {
            for (var _i = 0, types_9 = types; _i < types_9.length; _i++) {
                var type = types_9[_i];
                includes = addTypeToUnion(typeSet, includes, type);
            }
            return includes;
        }
        function removeSubtypes(types, hasObjectTypes) {
            var id = getTypeListId(types);
            var match = subtypeReductionCache.get(id);
            if (match) {
                return match;
            }
            // We assume that redundant primitive types have already been removed from the types array and that there
            // are no any and unknown types in the array. Thus, the only possible supertypes for primitive types are empty
            // object types, and if none of those are present we can exclude primitive types from the subtype check.
            var hasEmptyObject = hasObjectTypes && ts.some(types, function (t) { return !!(t.flags & 524288 /* Object */) && !isGenericMappedType(t) && isEmptyResolvedType(resolveStructuredTypeMembers(t)); });
            var len = types.length;
            var i = len;
            var count = 0;
            while (i > 0) {
                i--;
                var source = types[i];
                if (hasEmptyObject || source.flags & 469499904 /* StructuredOrInstantiable */) {
                    // Find the first property with a unit type, if any. When constituents have a property by the same name
                    // but of a different unit type, we can quickly disqualify them from subtype checks. This helps subtype
                    // reduction of large discriminated union types.
                    var keyProperty = source.flags & (524288 /* Object */ | 2097152 /* Intersection */ | 58982400 /* InstantiableNonPrimitive */) ?
                        ts.find(getPropertiesOfType(source), function (p) { return isUnitType(getTypeOfSymbol(p)); }) :
                        undefined;
                    var keyPropertyType = keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty));
                    for (var _i = 0, types_10 = types; _i < types_10.length; _i++) {
                        var target = types_10[_i];
                        if (source !== target) {
                            if (count === 100000) {
                                // After 100000 subtype checks we estimate the remaining amount of work by assuming the
                                // same ratio of checks per element. If the estimated number of remaining type checks is
                                // greater than 1M we deem the union type too complex to represent. This for example
                                // caps union types at 1000 unique object types.
                                var estimatedCount = (count / (len - i)) * len;
                                if (estimatedCount > 1000000) {
                                    ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes" /* CheckTypes */, "removeSubtypes_DepthLimit", { typeIds: types.map(function (t) { return t.id; }) });
                                    error(currentNode, ts.Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
                                    return undefined;
                                }
                            }
                            count++;
                            if (keyProperty && target.flags & (524288 /* Object */ | 2097152 /* Intersection */ | 58982400 /* InstantiableNonPrimitive */)) {
                                var t = getTypeOfPropertyOfType(target, keyProperty.escapedName);
                                if (t && isUnitType(t) && getRegularTypeOfLiteralType(t) !== keyPropertyType) {
                                    continue;
                                }
                            }
                            if (isTypeRelatedTo(source, target, strictSubtypeRelation) && (!(ts.getObjectFlags(getTargetType(source)) & 1 /* Class */) ||
                                !(ts.getObjectFlags(getTargetType(target)) & 1 /* Class */) ||
                                isTypeDerivedFrom(source, target))) {
                                ts.orderedRemoveItemAt(types, i);
                                break;
                            }
                        }
                    }
                }
            }
            subtypeReductionCache.set(id, types);
            return types;
        }
        function removeRedundantLiteralTypes(types, includes, reduceVoidUndefined) {
            var i = types.length;
            while (i > 0) {
                i--;
                var t = types[i];
                var flags = t.flags;
                var remove = flags & (128 /* StringLiteral */ | 134217728 /* TemplateLiteral */ | 268435456 /* StringMapping */) && includes & 4 /* String */ ||
                    flags & 256 /* NumberLiteral */ && includes & 8 /* Number */ ||
                    flags & 2048 /* BigIntLiteral */ && includes & 64 /* BigInt */ ||
                    flags & 8192 /* UniqueESSymbol */ && includes & 4096 /* ESSymbol */ ||
                    reduceVoidUndefined && flags & 32768 /* Undefined */ && includes & 16384 /* Void */ ||
                    isFreshLiteralType(t) && containsType(types, t.regularType);
                if (remove) {
                    ts.orderedRemoveItemAt(types, i);
                }
            }
        }
        function removeStringLiteralsMatchedByTemplateLiterals(types) {
            var templates = ts.filter(types, isPatternLiteralType);
            if (templates.length) {
                var i = types.length;
                var _loop_16 = function () {
                    i--;
                    var t = types[i];
                    if (t.flags & 128 /* StringLiteral */ && ts.some(templates, function (template) { return isTypeSubtypeOf(t, template); })) {
                        ts.orderedRemoveItemAt(types, i);
                    }
                };
                while (i > 0) {
                    _loop_16();
                }
            }
        }
        function isNamedUnionType(type) {
            return !!(type.flags & 1048576 /* Union */ && (type.aliasSymbol || type.origin));
        }
        function addNamedUnions(namedUnions, types) {
            for (var _i = 0, types_11 = types; _i < types_11.length; _i++) {
                var t = types_11[_i];
                if (t.flags & 1048576 /* Union */) {
                    var origin = t.origin;
                    if (t.aliasSymbol || origin && !(origin.flags & 1048576 /* Union */)) {
                        ts.pushIfUnique(namedUnions, t);
                    }
                    else if (origin && origin.flags & 1048576 /* Union */) {
                        addNamedUnions(namedUnions, origin.types);
                    }
                }
            }
        }
        function createOriginUnionOrIntersectionType(flags, types) {
            var result = createOriginType(flags);
            result.types = types;
            return result;
        }
        // We sort and deduplicate the constituent types based on object identity. If the subtypeReduction
        // flag is specified we also reduce the constituent type set to only include types that aren't subtypes
        // of other types. Subtype reduction is expensive for large union types and is possible only when union
        // types are known not to circularly reference themselves (as is the case with union types created by
        // expression constructs such as array literals and the || and ?: operators). Named types can
        // circularly reference themselves and therefore cannot be subtype reduced during their declaration.
        // For example, "type Item = string | (() => Item" is a named type that circularly references itself.
        function getUnionType(types, unionReduction, aliasSymbol, aliasTypeArguments, origin) {
            if (unionReduction === void 0) { unionReduction = 1 /* Literal */; }
            if (types.length === 0) {
                return neverType;
            }
            if (types.length === 1) {
                return types[0];
            }
            var typeSet = [];
            var includes = addTypesToUnion(typeSet, 0, types);
            if (unionReduction !== 0 /* None */) {
                if (includes & 3 /* AnyOrUnknown */) {
                    return includes & 1 /* Any */ ? includes & 8388608 /* IncludesWildcard */ ? wildcardType : anyType : unknownType;
                }
                if (exactOptionalPropertyTypes && includes & 32768 /* Undefined */) {
                    var missingIndex = ts.binarySearch(typeSet, missingType, getTypeId, ts.compareValues);
                    if (missingIndex >= 0 && containsType(typeSet, undefinedType)) {
                        ts.orderedRemoveItemAt(typeSet, missingIndex);
                    }
                }
                if (includes & (2944 /* Literal */ | 8192 /* UniqueESSymbol */ | 134217728 /* TemplateLiteral */ | 268435456 /* StringMapping */) || includes & 16384 /* Void */ && includes & 32768 /* Undefined */) {
                    removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & 2 /* Subtype */));
                }
                if (includes & 128 /* StringLiteral */ && includes & 134217728 /* TemplateLiteral */) {
                    removeStringLiteralsMatchedByTemplateLiterals(typeSet);
                }
                if (unionReduction === 2 /* Subtype */) {
                    typeSet = removeSubtypes(typeSet, !!(includes & 524288 /* Object */));
                    if (!typeSet) {
                        return errorType;
                    }
                }
                if (typeSet.length === 0) {
                    return includes & 65536 /* Null */ ? includes & 4194304 /* IncludesNonWideningType */ ? nullType : nullWideningType :
                        includes & 32768 /* Undefined */ ? includes & 4194304 /* IncludesNonWideningType */ ? undefinedType : undefinedWideningType :
                            neverType;
                }
            }
            if (!origin && includes & 1048576 /* Union */) {
                var namedUnions = [];
                addNamedUnions(namedUnions, types);
                var reducedTypes = [];
                var _loop_17 = function (t) {
                    if (!ts.some(namedUnions, function (union) { return containsType(union.types, t); })) {
                        reducedTypes.push(t);
                    }
                };
                for (var _i = 0, typeSet_1 = typeSet; _i < typeSet_1.length; _i++) {
                    var t = typeSet_1[_i];
                    _loop_17(t);
                }
                if (!aliasSymbol && namedUnions.length === 1 && reducedTypes.length === 0) {
                    return namedUnions[0];
                }
                // We create a denormalized origin type only when the union was created from one or more named unions
                // (unions with alias symbols or origins) and when there is no overlap between those named unions.
                var namedTypesCount = ts.reduceLeft(namedUnions, function (sum, union) { return sum + union.types.length; }, 0);
                if (namedTypesCount + reducedTypes.length === typeSet.length) {
                    for (var _a = 0, namedUnions_1 = namedUnions; _a < namedUnions_1.length; _a++) {
                        var t = namedUnions_1[_a];
                        insertType(reducedTypes, t);
                    }
                    origin = createOriginUnionOrIntersectionType(1048576 /* Union */, reducedTypes);
                }
            }
            var objectFlags = (includes & 468598819 /* NotPrimitiveUnion */ ? 0 : 65536 /* PrimitiveUnion */) |
                (includes & 2097152 /* Intersection */ ? 33554432 /* ContainsIntersections */ : 0);
            return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin);
        }
        function getUnionOrIntersectionTypePredicate(signatures, kind) {
            var first;
            var types = [];
            for (var _i = 0, signatures_6 = signatures; _i < signatures_6.length; _i++) {
                var sig = signatures_6[_i];
                var pred = getTypePredicateOfSignature(sig);
                if (!pred || pred.kind === 2 /* AssertsThis */ || pred.kind === 3 /* AssertsIdentifier */) {
                    if (kind !== 2097152 /* Intersection */) {
                        continue;
                    }
                    else {
                        return; // intersections demand all members be type predicates for the result to have a predicate
                    }
                }
                if (first) {
                    if (!typePredicateKindsMatch(first, pred)) {
                        // No common type predicate.
                        return undefined;
                    }
                }
                else {
                    first = pred;
                }
                types.push(pred.type);
            }
            if (!first) {
                // No signatures had a type predicate.
                return undefined;
            }
            var compositeType = getUnionOrIntersectionType(types, kind);
            return createTypePredicate(first.kind, first.parameterName, first.parameterIndex, compositeType);
        }
        function typePredicateKindsMatch(a, b) {
            return a.kind === b.kind && a.parameterIndex === b.parameterIndex;
        }
        // This function assumes the constituent type list is sorted and deduplicated.
        function getUnionTypeFromSortedList(types, objectFlags, aliasSymbol, aliasTypeArguments, origin) {
            if (types.length === 0) {
                return neverType;
            }
            if (types.length === 1) {
                return types[0];
            }
            var typeKey = !origin ? getTypeListId(types) :
                origin.flags & 1048576 /* Union */ ? "|" + getTypeListId(origin.types) :
                    origin.flags & 2097152 /* Intersection */ ? "&" + getTypeListId(origin.types) :
                        "#" + origin.type.id + "|" + getTypeListId(types); // origin type id alone is insufficient, as `keyof x` may resolve to multiple WIP values while `x` is still resolving
            var id = typeKey + getAliasId(aliasSymbol, aliasTypeArguments);
            var type = unionTypes.get(id);
            if (!type) {
                type = createType(1048576 /* Union */);
                type.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types, /*excludeKinds*/ 98304 /* Nullable */);
                type.types = types;
                type.origin = origin;
                type.aliasSymbol = aliasSymbol;
                type.aliasTypeArguments = aliasTypeArguments;
                if (types.length === 2 && types[0].flags & 512 /* BooleanLiteral */ && types[1].flags & 512 /* BooleanLiteral */) {
                    type.flags |= 16 /* Boolean */;
                    type.intrinsicName = "boolean";
                }
                unionTypes.set(id, type);
            }
            return type;
        }
        function getTypeFromUnionTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                links.resolvedType = getUnionType(ts.map(node.types, getTypeFromTypeNode), 1 /* Literal */, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
            }
            return links.resolvedType;
        }
        function addTypeToIntersection(typeSet, includes, type) {
            var flags = type.flags;
            if (flags & 2097152 /* Intersection */) {
                return addTypesToIntersection(typeSet, includes, type.types);
            }
            if (isEmptyAnonymousObjectType(type)) {
                if (!(includes & 16777216 /* IncludesEmptyObject */)) {
                    includes |= 16777216 /* IncludesEmptyObject */;
                    typeSet.set(type.id.toString(), type);
                }
            }
            else {
                if (flags & 3 /* AnyOrUnknown */) {
                    if (type === wildcardType)
                        includes |= 8388608 /* IncludesWildcard */;
                }
                else if ((strictNullChecks || !(flags & 98304 /* Nullable */)) && !typeSet.has(type.id.toString())) {
                    if (type.flags & 109440 /* Unit */ && includes & 109440 /* Unit */) {
                        // We have seen two distinct unit types which means we should reduce to an
                        // empty intersection. Adding TypeFlags.NonPrimitive causes that to happen.
                        includes |= 67108864 /* NonPrimitive */;
                    }
                    typeSet.set(type.id.toString(), type);
                }
                includes |= flags & 205258751 /* IncludesMask */;
            }
            return includes;
        }
        // Add the given types to the given type set. Order is preserved, freshness is removed from literal
        // types, duplicates are removed, and nested types of the given kind are flattened into the set.
        function addTypesToIntersection(typeSet, includes, types) {
            for (var _i = 0, types_12 = types; _i < types_12.length; _i++) {
                var type = types_12[_i];
                includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type));
            }
            return includes;
        }
        function removeRedundantPrimitiveTypes(types, includes) {
            var i = types.length;
            while (i > 0) {
                i--;
                var t = types[i];
                var remove = t.flags & 4 /* String */ && includes & 128 /* StringLiteral */ ||
                    t.flags & 8 /* Number */ && includes & 256 /* NumberLiteral */ ||
                    t.flags & 64 /* BigInt */ && includes & 2048 /* BigIntLiteral */ ||
                    t.flags & 4096 /* ESSymbol */ && includes & 8192 /* UniqueESSymbol */;
                if (remove) {
                    ts.orderedRemoveItemAt(types, i);
                }
            }
        }
        // Check that the given type has a match in every union. A given type is matched by
        // an identical type, and a literal type is additionally matched by its corresponding
        // primitive type.
        function eachUnionContains(unionTypes, type) {
            for (var _i = 0, unionTypes_1 = unionTypes; _i < unionTypes_1.length; _i++) {
                var u = unionTypes_1[_i];
                if (!containsType(u.types, type)) {
                    var primitive = type.flags & 128 /* StringLiteral */ ? stringType :
                        type.flags & 256 /* NumberLiteral */ ? numberType :
                            type.flags & 2048 /* BigIntLiteral */ ? bigintType :
                                type.flags & 8192 /* UniqueESSymbol */ ? esSymbolType :
                                    undefined;
                    if (!primitive || !containsType(u.types, primitive)) {
                        return false;
                    }
                }
            }
            return true;
        }
        /**
         * Returns `true` if the intersection of the template literals and string literals is the empty set, eg `get${string}` & "setX", and should reduce to `never`
         */
        function extractRedundantTemplateLiterals(types) {
            var i = types.length;
            var literals = ts.filter(types, function (t) { return !!(t.flags & 128 /* StringLiteral */); });
            while (i > 0) {
                i--;
                var t = types[i];
                if (!(t.flags & 134217728 /* TemplateLiteral */))
                    continue;
                for (var _i = 0, literals_1 = literals; _i < literals_1.length; _i++) {
                    var t2 = literals_1[_i];
                    if (isTypeSubtypeOf(t2, t)) {
                        // eg, ``get${T}` & "getX"` is just `"getX"`
                        ts.orderedRemoveItemAt(types, i);
                        break;
                    }
                    else if (isPatternLiteralType(t)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function extractIrreducible(types, flag) {
            if (ts.every(types, function (t) { return !!(t.flags & 1048576 /* Union */) && ts.some(t.types, function (tt) { return !!(tt.flags & flag); }); })) {
                for (var i = 0; i < types.length; i++) {
                    types[i] = filterType(types[i], function (t) { return !(t.flags & flag); });
                }
                return true;
            }
            return false;
        }
        // If the given list of types contains more than one union of primitive types, replace the
        // first with a union containing an intersection of those primitive types, then remove the
        // other unions and return true. Otherwise, do nothing and return false.
        function intersectUnionsOfPrimitiveTypes(types) {
            var unionTypes;
            var index = ts.findIndex(types, function (t) { return !!(ts.getObjectFlags(t) & 65536 /* PrimitiveUnion */); });
            if (index < 0) {
                return false;
            }
            var i = index + 1;
            // Remove all but the first union of primitive types and collect them in
            // the unionTypes array.
            while (i < types.length) {
                var t = types[i];
                if (ts.getObjectFlags(t) & 65536 /* PrimitiveUnion */) {
                    (unionTypes || (unionTypes = [types[index]])).push(t);
                    ts.orderedRemoveItemAt(types, i);
                }
                else {
                    i++;
                }
            }
            // Return false if there was only one union of primitive types
            if (!unionTypes) {
                return false;
            }
            // We have more than one union of primitive types, now intersect them. For each
            // type in each union we check if the type is matched in every union and if so
            // we include it in the result.
            var checked = [];
            var result = [];
            for (var _i = 0, unionTypes_2 = unionTypes; _i < unionTypes_2.length; _i++) {
                var u = unionTypes_2[_i];
                for (var _a = 0, _b = u.types; _a < _b.length; _a++) {
                    var t = _b[_a];
                    if (insertType(checked, t)) {
                        if (eachUnionContains(unionTypes, t)) {
                            insertType(result, t);
                        }
                    }
                }
            }
            // Finally replace the first union with the result
            types[index] = getUnionTypeFromSortedList(result, 65536 /* PrimitiveUnion */);
            return true;
        }
        function createIntersectionType(types, aliasSymbol, aliasTypeArguments) {
            var result = createType(2097152 /* Intersection */);
            result.objectFlags = getPropagatingFlagsOfTypes(types, /*excludeKinds*/ 98304 /* Nullable */);
            result.types = types;
            result.aliasSymbol = aliasSymbol;
            result.aliasTypeArguments = aliasTypeArguments;
            return result;
        }
        // We normalize combinations of intersection and union types based on the distributive property of the '&'
        // operator. Specifically, because X & (A | B) is equivalent to X & A | X & B, we can transform intersection
        // types with union type constituents into equivalent union types with intersection type constituents and
        // effectively ensure that union types are always at the top level in type representations.
        //
        // We do not perform structural deduplication on intersection types. Intersection types are created only by the &
        // type operator and we can't reduce those because we want to support recursive intersection types. For example,
        // a type alias of the form "type List<T> = T & { next: List<T> }" cannot be reduced during its declaration.
        // Also, unlike union types, the order of the constituent types is preserved in order that overload resolution
        // for intersections of types with signatures can be deterministic.
        function getIntersectionType(types, aliasSymbol, aliasTypeArguments) {
            var typeMembershipMap = new ts.Map();
            var includes = addTypesToIntersection(typeMembershipMap, 0, types);
            var typeSet = ts.arrayFrom(typeMembershipMap.values());
            // An intersection type is considered empty if it contains
            // the type never, or
            // more than one unit type or,
            // an object type and a nullable type (null or undefined), or
            // a string-like type and a type known to be non-string-like, or
            // a number-like type and a type known to be non-number-like, or
            // a symbol-like type and a type known to be non-symbol-like, or
            // a void-like type and a type known to be non-void-like, or
            // a non-primitive type and a type known to be primitive.
            if (includes & 131072 /* Never */) {
                return ts.contains(typeSet, silentNeverType) ? silentNeverType : neverType;
            }
            if (strictNullChecks && includes & 98304 /* Nullable */ && includes & (524288 /* Object */ | 67108864 /* NonPrimitive */ | 16777216 /* IncludesEmptyObject */) ||
                includes & 67108864 /* NonPrimitive */ && includes & (469892092 /* DisjointDomains */ & ~67108864 /* NonPrimitive */) ||
                includes & 402653316 /* StringLike */ && includes & (469892092 /* DisjointDomains */ & ~402653316 /* StringLike */) ||
                includes & 296 /* NumberLike */ && includes & (469892092 /* DisjointDomains */ & ~296 /* NumberLike */) ||
                includes & 2112 /* BigIntLike */ && includes & (469892092 /* DisjointDomains */ & ~2112 /* BigIntLike */) ||
                includes & 12288 /* ESSymbolLike */ && includes & (469892092 /* DisjointDomains */ & ~12288 /* ESSymbolLike */) ||
                includes & 49152 /* VoidLike */ && includes & (469892092 /* DisjointDomains */ & ~49152 /* VoidLike */)) {
                return neverType;
            }
            if (includes & 134217728 /* TemplateLiteral */ && includes & 128 /* StringLiteral */ && extractRedundantTemplateLiterals(typeSet)) {
                return neverType;
            }
            if (includes & 1 /* Any */) {
                return includes & 8388608 /* IncludesWildcard */ ? wildcardType : anyType;
            }
            if (!strictNullChecks && includes & 98304 /* Nullable */) {
                return includes & 32768 /* Undefined */ ? undefinedType : nullType;
            }
            if (includes & 4 /* String */ && includes & 128 /* StringLiteral */ ||
                includes & 8 /* Number */ && includes & 256 /* NumberLiteral */ ||
                includes & 64 /* BigInt */ && includes & 2048 /* BigIntLiteral */ ||
                includes & 4096 /* ESSymbol */ && includes & 8192 /* UniqueESSymbol */) {
                removeRedundantPrimitiveTypes(typeSet, includes);
            }
            if (includes & 16777216 /* IncludesEmptyObject */ && includes & 524288 /* Object */) {
                ts.orderedRemoveItemAt(typeSet, ts.findIndex(typeSet, isEmptyAnonymousObjectType));
            }
            if (typeSet.length === 0) {
                return unknownType;
            }
            if (typeSet.length === 1) {
                return typeSet[0];
            }
            var id = getTypeListId(typeSet) + getAliasId(aliasSymbol, aliasTypeArguments);
            var result = intersectionTypes.get(id);
            if (!result) {
                if (includes & 1048576 /* Union */) {
                    if (intersectUnionsOfPrimitiveTypes(typeSet)) {
                        // When the intersection creates a reduced set (which might mean that *all* union types have
                        // disappeared), we restart the operation to get a new set of combined flags. Once we have
                        // reduced we'll never reduce again, so this occurs at most once.
                        result = getIntersectionType(typeSet, aliasSymbol, aliasTypeArguments);
                    }
                    else if (extractIrreducible(typeSet, 32768 /* Undefined */)) {
                        result = getUnionType([getIntersectionType(typeSet), undefinedType], 1 /* Literal */, aliasSymbol, aliasTypeArguments);
                    }
                    else if (extractIrreducible(typeSet, 65536 /* Null */)) {
                        result = getUnionType([getIntersectionType(typeSet), nullType], 1 /* Literal */, aliasSymbol, aliasTypeArguments);
                    }
                    else {
                        // We are attempting to construct a type of the form X & (A | B) & (C | D). Transform this into a type of
                        // the form X & A & C | X & A & D | X & B & C | X & B & D. If the estimated size of the resulting union type
                        // exceeds 100000 constituents, report an error.
                        if (!checkCrossProductUnion(typeSet)) {
                            return errorType;
                        }
                        var constituents = getCrossProductIntersections(typeSet);
                        // We attach a denormalized origin type when at least one constituent of the cross-product union is an
                        // intersection (i.e. when the intersection didn't just reduce one or more unions to smaller unions).
                        var origin = ts.some(constituents, function (t) { return !!(t.flags & 2097152 /* Intersection */); }) ? createOriginUnionOrIntersectionType(2097152 /* Intersection */, typeSet) : undefined;
                        result = getUnionType(constituents, 1 /* Literal */, aliasSymbol, aliasTypeArguments, origin);
                    }
                }
                else {
                    result = createIntersectionType(typeSet, aliasSymbol, aliasTypeArguments);
                }
                intersectionTypes.set(id, result);
            }
            return result;
        }
        function getCrossProductUnionSize(types) {
            return ts.reduceLeft(types, function (n, t) { return t.flags & 1048576 /* Union */ ? n * t.types.length : t.flags & 131072 /* Never */ ? 0 : n; }, 1);
        }
        function checkCrossProductUnion(types) {
            var size = getCrossProductUnionSize(types);
            if (size >= 100000) {
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes" /* CheckTypes */, "checkCrossProductUnion_DepthLimit", { typeIds: types.map(function (t) { return t.id; }), size: size });
                error(currentNode, ts.Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
                return false;
            }
            return true;
        }
        function getCrossProductIntersections(types) {
            var count = getCrossProductUnionSize(types);
            var intersections = [];
            for (var i = 0; i < count; i++) {
                var constituents = types.slice();
                var n = i;
                for (var j = types.length - 1; j >= 0; j--) {
                    if (types[j].flags & 1048576 /* Union */) {
                        var sourceTypes = types[j].types;
                        var length_5 = sourceTypes.length;
                        constituents[j] = sourceTypes[n % length_5];
                        n = Math.floor(n / length_5);
                    }
                }
                var t = getIntersectionType(constituents);
                if (!(t.flags & 131072 /* Never */))
                    intersections.push(t);
            }
            return intersections;
        }
        function getTypeFromIntersectionTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                links.resolvedType = getIntersectionType(ts.map(node.types, getTypeFromTypeNode), aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
            }
            return links.resolvedType;
        }
        function createIndexType(type, stringsOnly) {
            var result = createType(4194304 /* Index */);
            result.type = type;
            result.stringsOnly = stringsOnly;
            return result;
        }
        function createOriginIndexType(type) {
            var result = createOriginType(4194304 /* Index */);
            result.type = type;
            return result;
        }
        function getIndexTypeForGenericType(type, stringsOnly) {
            return stringsOnly ?
                type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(type, /*stringsOnly*/ true)) :
                type.resolvedIndexType || (type.resolvedIndexType = createIndexType(type, /*stringsOnly*/ false));
        }
        function instantiateTypeAsMappedNameType(nameType, type, t) {
            return instantiateType(nameType, appendTypeMapping(type.mapper, getTypeParameterFromMappedType(type), t));
        }
        function getIndexTypeForMappedType(type, noIndexSignatures) {
            var constraint = filterType(getConstraintTypeFromMappedType(type), function (t) { return !(noIndexSignatures && t.flags & (1 /* Any */ | 4 /* String */)); });
            var nameType = type.declaration.nameType && getTypeFromTypeNode(type.declaration.nameType);
            // If the constraint is exclusively string/number/never type(s), we need to pull the property names from the modified type and run them through the `nameType` mapper as well
            // since they won't appear in the constraint, due to subtype reducing with the string/number index types
            var properties = nameType && everyType(constraint, function (t) { return !!(t.flags & (4 /* String */ | 8 /* Number */ | 131072 /* Never */)); }) && getPropertiesOfType(getApparentType(getModifiersTypeFromMappedType(type)));
            return nameType ?
                getUnionType([mapType(constraint, function (t) { return instantiateTypeAsMappedNameType(nameType, type, t); }), mapType(getUnionType(ts.map(properties || ts.emptyArray, function (p) { return getLiteralTypeFromProperty(p, 8576 /* StringOrNumberLiteralOrUnique */); })), function (t) { return instantiateTypeAsMappedNameType(nameType, type, t); })]) :
                constraint;
        }
        // Ordinarily we reduce a keyof M, where M is a mapped type { [P in K as N<P>]: X }, to simply N<K>. This however presumes
        // that N distributes over union types, i.e. that N<A | B | C> is equivalent to N<A> | N<B> | N<C>. Specifically, we only
        // want to perform the reduction when the name type of a mapped type is distributive with respect to the type variable
        // introduced by the 'in' clause of the mapped type. Note that non-generic types are considered to be distributive because
        // they're the same type regardless of what's being distributed over.
        function hasDistributiveNameType(mappedType) {
            var typeVariable = getTypeParameterFromMappedType(mappedType);
            return isDistributive(getNameTypeFromMappedType(mappedType) || typeVariable);
            function isDistributive(type) {
                return type.flags & (3 /* AnyOrUnknown */ | 131068 /* Primitive */ | 131072 /* Never */ | 262144 /* TypeParameter */ | 524288 /* Object */ | 67108864 /* NonPrimitive */) ? true :
                    type.flags & 16777216 /* Conditional */ ? type.root.isDistributive && type.checkType === typeVariable :
                        type.flags & (3145728 /* UnionOrIntersection */ | 134217728 /* TemplateLiteral */) ? ts.every(type.types, isDistributive) :
                            type.flags & 8388608 /* IndexedAccess */ ? isDistributive(type.objectType) && isDistributive(type.indexType) :
                                type.flags & 33554432 /* Substitution */ ? isDistributive(type.substitute) :
                                    type.flags & 268435456 /* StringMapping */ ? isDistributive(type.type) :
                                        false;
            }
        }
        function getLiteralTypeFromPropertyName(name) {
            if (ts.isPrivateIdentifier(name)) {
                return neverType;
            }
            return ts.isIdentifier(name) ? getStringLiteralType(ts.unescapeLeadingUnderscores(name.escapedText)) :
                getRegularTypeOfLiteralType(ts.isComputedPropertyName(name) ? checkComputedPropertyName(name) : checkExpression(name));
        }
        function getLiteralTypeFromProperty(prop, include, includeNonPublic) {
            if (includeNonPublic || !(ts.getDeclarationModifierFlagsFromSymbol(prop) & 24 /* NonPublicAccessibilityModifier */)) {
                var type = getSymbolLinks(getLateBoundSymbol(prop)).nameType;
                if (!type) {
                    var name = ts.getNameOfDeclaration(prop.valueDeclaration);
                    type = prop.escapedName === "default" /* Default */ ? getStringLiteralType("default") :
                        name && getLiteralTypeFromPropertyName(name) || (!ts.isKnownSymbol(prop) ? getStringLiteralType(ts.symbolName(prop)) : undefined);
                }
                if (type && type.flags & include) {
                    return type;
                }
            }
            return neverType;
        }
        function getLiteralTypeFromProperties(type, include, includeOrigin) {
            var origin = includeOrigin && (ts.getObjectFlags(type) & (3 /* ClassOrInterface */ | 4 /* Reference */) || type.aliasSymbol) ? createOriginIndexType(type) : undefined;
            var propertyTypes = ts.map(getPropertiesOfType(type), function (prop) { return getLiteralTypeFromProperty(prop, include); });
            var indexKeyTypes = ts.map(getIndexInfosOfType(type), function (info) { return info !== enumNumberIndexInfo && info.keyType.flags & include ?
                info.keyType === stringType && include & 8 /* Number */ ? stringOrNumberType : info.keyType : neverType; });
            return getUnionType(ts.concatenate(propertyTypes, indexKeyTypes), 1 /* Literal */, 
            /*aliasSymbol*/ undefined, /*aliasTypeArguments*/ undefined, origin);
        }
        function getIndexType(type, stringsOnly, noIndexSignatures) {
            if (stringsOnly === void 0) { stringsOnly = keyofStringsOnly; }
            type = getReducedType(type);
            return type.flags & 1048576 /* Union */ ? getIntersectionType(ts.map(type.types, function (t) { return getIndexType(t, stringsOnly, noIndexSignatures); })) :
                type.flags & 2097152 /* Intersection */ ? getUnionType(ts.map(type.types, function (t) { return getIndexType(t, stringsOnly, noIndexSignatures); })) :
                    type.flags & 58982400 /* InstantiableNonPrimitive */ || isGenericTupleType(type) || isGenericMappedType(type) && !hasDistributiveNameType(type) ? getIndexTypeForGenericType(type, stringsOnly) :
                        ts.getObjectFlags(type) & 32 /* Mapped */ ? getIndexTypeForMappedType(type, noIndexSignatures) :
                            type === wildcardType ? wildcardType :
                                type.flags & 2 /* Unknown */ ? neverType :
                                    type.flags & (1 /* Any */ | 131072 /* Never */) ? keyofConstraintType :
                                        getLiteralTypeFromProperties(type, (noIndexSignatures ? 128 /* StringLiteral */ : 402653316 /* StringLike */) | (stringsOnly ? 0 : 296 /* NumberLike */ | 12288 /* ESSymbolLike */), stringsOnly === keyofStringsOnly && !noIndexSignatures);
        }
        function getExtractStringType(type) {
            if (keyofStringsOnly) {
                return type;
            }
            var extractTypeAlias = getGlobalExtractSymbol();
            return extractTypeAlias ? getTypeAliasInstantiation(extractTypeAlias, [type, stringType]) : stringType;
        }
        function getIndexTypeOrString(type) {
            var indexType = getExtractStringType(getIndexType(type));
            return indexType.flags & 131072 /* Never */ ? stringType : indexType;
        }
        function getTypeFromTypeOperatorNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                switch (node.operator) {
                    case 139 /* KeyOfKeyword */:
                        links.resolvedType = getIndexType(getTypeFromTypeNode(node.type));
                        break;
                    case 152 /* UniqueKeyword */:
                        links.resolvedType = node.type.kind === 149 /* SymbolKeyword */
                            ? getESSymbolLikeTypeForNode(ts.walkUpParenthesizedTypes(node.parent))
                            : errorType;
                        break;
                    case 143 /* ReadonlyKeyword */:
                        links.resolvedType = getTypeFromTypeNode(node.type);
                        break;
                    default:
                        throw ts.Debug.assertNever(node.operator);
                }
            }
            return links.resolvedType;
        }
        function getTypeFromTemplateTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getTemplateLiteralType(__spreadArray([node.head.text], ts.map(node.templateSpans, function (span) { return span.literal.text; }), true), ts.map(node.templateSpans, function (span) { return getTypeFromTypeNode(span.type); }));
            }
            return links.resolvedType;
        }
        function getTemplateLiteralType(texts, types) {
            var unionIndex = ts.findIndex(types, function (t) { return !!(t.flags & (131072 /* Never */ | 1048576 /* Union */)); });
            if (unionIndex >= 0) {
                return checkCrossProductUnion(types) ?
                    mapType(types[unionIndex], function (t) { return getTemplateLiteralType(texts, ts.replaceElement(types, unionIndex, t)); }) :
                    errorType;
            }
            if (ts.contains(types, wildcardType)) {
                return wildcardType;
            }
            var newTypes = [];
            var newTexts = [];
            var text = texts[0];
            if (!addSpans(texts, types)) {
                return stringType;
            }
            if (newTypes.length === 0) {
                return getStringLiteralType(text);
            }
            newTexts.push(text);
            if (ts.every(newTexts, function (t) { return t === ""; }) && ts.every(newTypes, function (t) { return !!(t.flags & 4 /* String */); })) {
                return stringType;
            }
            var id = getTypeListId(newTypes) + "|" + ts.map(newTexts, function (t) { return t.length; }).join(",") + "|" + newTexts.join("");
            var type = templateLiteralTypes.get(id);
            if (!type) {
                templateLiteralTypes.set(id, type = createTemplateLiteralType(newTexts, newTypes));
            }
            return type;
            function addSpans(texts, types) {
                for (var i = 0; i < types.length; i++) {
                    var t = types[i];
                    if (t.flags & (2944 /* Literal */ | 65536 /* Null */ | 32768 /* Undefined */)) {
                        text += getTemplateStringForType(t) || "";
                        text += texts[i + 1];
                    }
                    else if (t.flags & 134217728 /* TemplateLiteral */) {
                        text += t.texts[0];
                        if (!addSpans(t.texts, t.types))
                            return false;
                        text += texts[i + 1];
                    }
                    else if (isGenericIndexType(t) || isPatternLiteralPlaceholderType(t)) {
                        newTypes.push(t);
                        newTexts.push(text);
                        text = texts[i + 1];
                    }
                    else {
                        return false;
                    }
                }
                return true;
            }
        }
        function getTemplateStringForType(type) {
            return type.flags & 128 /* StringLiteral */ ? type.value :
                type.flags & 256 /* NumberLiteral */ ? "" + type.value :
                    type.flags & 2048 /* BigIntLiteral */ ? ts.pseudoBigIntToString(type.value) :
                        type.flags & (512 /* BooleanLiteral */ | 98304 /* Nullable */) ? type.intrinsicName :
                            undefined;
        }
        function createTemplateLiteralType(texts, types) {
            var type = createType(134217728 /* TemplateLiteral */);
            type.texts = texts;
            type.types = types;
            return type;
        }
        function getStringMappingType(symbol, type) {
            return type.flags & (1048576 /* Union */ | 131072 /* Never */) ? mapType(type, function (t) { return getStringMappingType(symbol, t); }) :
                isGenericIndexType(type) ? getStringMappingTypeForGenericType(symbol, type) :
                    type.flags & 128 /* StringLiteral */ ? getStringLiteralType(applyStringMapping(symbol, type.value)) :
                        type;
        }
        function applyStringMapping(symbol, str) {
            switch (intrinsicTypeKinds.get(symbol.escapedName)) {
                case 0 /* Uppercase */: return str.toUpperCase();
                case 1 /* Lowercase */: return str.toLowerCase();
                case 2 /* Capitalize */: return str.charAt(0).toUpperCase() + str.slice(1);
                case 3 /* Uncapitalize */: return str.charAt(0).toLowerCase() + str.slice(1);
            }
            return str;
        }
        function getStringMappingTypeForGenericType(symbol, type) {
            var id = getSymbolId(symbol) + "," + getTypeId(type);
            var result = stringMappingTypes.get(id);
            if (!result) {
                stringMappingTypes.set(id, result = createStringMappingType(symbol, type));
            }
            return result;
        }
        function createStringMappingType(symbol, type) {
            var result = createType(268435456 /* StringMapping */);
            result.symbol = symbol;
            result.type = type;
            return result;
        }
        function createIndexedAccessType(objectType, indexType, accessFlags, aliasSymbol, aliasTypeArguments) {
            var type = createType(8388608 /* IndexedAccess */);
            type.objectType = objectType;
            type.indexType = indexType;
            type.accessFlags = accessFlags;
            type.aliasSymbol = aliasSymbol;
            type.aliasTypeArguments = aliasTypeArguments;
            return type;
        }
        /**
         * Returns if a type is or consists of a JSLiteral object type
         * In addition to objects which are directly literals,
         * * unions where every element is a jsliteral
         * * intersections where at least one element is a jsliteral
         * * and instantiable types constrained to a jsliteral
         * Should all count as literals and not print errors on access or assignment of possibly existing properties.
         * This mirrors the behavior of the index signature propagation, to which this behaves similarly (but doesn't affect assignability or inference).
         */
        function isJSLiteralType(type) {
            if (noImplicitAny) {
                return false; // Flag is meaningless under `noImplicitAny` mode
            }
            if (ts.getObjectFlags(type) & 8192 /* JSLiteral */) {
                return true;
            }
            if (type.flags & 1048576 /* Union */) {
                return ts.every(type.types, isJSLiteralType);
            }
            if (type.flags & 2097152 /* Intersection */) {
                return ts.some(type.types, isJSLiteralType);
            }
            if (type.flags & 465829888 /* Instantiable */) {
                var constraint = getResolvedBaseConstraint(type);
                return constraint !== type && isJSLiteralType(constraint);
            }
            return false;
        }
        function getPropertyNameFromIndex(indexType, accessNode) {
            return isTypeUsableAsPropertyName(indexType) ?
                getPropertyNameFromType(indexType) :
                accessNode && ts.isPropertyName(accessNode) ?
                    // late bound names are handled in the first branch, so here we only need to handle normal names
                    ts.getPropertyNameForPropertyNameNode(accessNode) :
                    undefined;
        }
        function isUncalledFunctionReference(node, symbol) {
            if (symbol.flags & (16 /* Function */ | 8192 /* Method */)) {
                var parent = ts.findAncestor(node.parent, function (n) { return !ts.isAccessExpression(n); }) || node.parent;
                if (ts.isCallLikeExpression(parent)) {
                    return ts.isCallOrNewExpression(parent) && ts.isIdentifier(node) && hasMatchingArgument(parent, node);
                }
                return ts.every(symbol.declarations, function (d) { return !ts.isFunctionLike(d) || !!(ts.getCombinedNodeFlags(d) & 134217728 /* Deprecated */); });
            }
            return true;
        }
        function getPropertyTypeForIndexType(originalObjectType, objectType, indexType, fullIndexType, accessNode, accessFlags) {
            var _a;
            var accessExpression = accessNode && accessNode.kind === 205 /* ElementAccessExpression */ ? accessNode : undefined;
            var propName = accessNode && ts.isPrivateIdentifier(accessNode) ? undefined : getPropertyNameFromIndex(indexType, accessNode);
            if (propName !== undefined) {
                if (accessFlags & 256 /* Contextual */) {
                    return getTypeOfPropertyOfContextualType(objectType, propName) || anyType;
                }
                var prop = getPropertyOfType(objectType, propName);
                if (prop) {
                    if (accessFlags & 64 /* ReportDeprecated */ && accessNode && prop.declarations && getDeclarationNodeFlagsFromSymbol(prop) & 134217728 /* Deprecated */ && isUncalledFunctionReference(accessNode, prop)) {
                        var deprecatedNode = (_a = accessExpression === null || accessExpression === void 0 ? void 0 : accessExpression.argumentExpression) !== null && _a !== void 0 ? _a : (ts.isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode);
                        addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName);
                    }
                    if (accessExpression) {
                        markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol));
                        if (isAssignmentToReadonlyEntity(accessExpression, prop, ts.getAssignmentTargetKind(accessExpression))) {
                            error(accessExpression.argumentExpression, ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop));
                            return undefined;
                        }
                        if (accessFlags & 8 /* CacheSymbol */) {
                            getNodeLinks(accessNode).resolvedSymbol = prop;
                        }
                        if (isThisPropertyAccessInConstructor(accessExpression, prop)) {
                            return autoType;
                        }
                    }
                    var propType = getTypeOfSymbol(prop);
                    return accessExpression && ts.getAssignmentTargetKind(accessExpression) !== 1 /* Definite */ ?
                        getFlowTypeOfReference(accessExpression, propType) :
                        propType;
                }
                if (everyType(objectType, isTupleType) && isNumericLiteralName(propName) && +propName >= 0) {
                    if (accessNode && everyType(objectType, function (t) { return !t.target.hasRestElement; }) && !(accessFlags & 16 /* NoTupleBoundsCheck */)) {
                        var indexNode = getIndexNodeForAccessExpression(accessNode);
                        if (isTupleType(objectType)) {
                            error(indexNode, ts.Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), ts.unescapeLeadingUnderscores(propName));
                        }
                        else {
                            error(indexNode, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.unescapeLeadingUnderscores(propName), typeToString(objectType));
                        }
                    }
                    errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType));
                    return mapType(objectType, function (t) {
                        var restType = getRestTypeOfTupleType(t) || undefinedType;
                        return accessFlags & 1 /* IncludeUndefined */ ? getUnionType([restType, undefinedType]) : restType;
                    });
                }
            }
            if (!(indexType.flags & 98304 /* Nullable */) && isTypeAssignableToKind(indexType, 402653316 /* StringLike */ | 296 /* NumberLike */ | 12288 /* ESSymbolLike */)) {
                if (objectType.flags & (1 /* Any */ | 131072 /* Never */)) {
                    return objectType;
                }
                // If no index signature is applicable, we default to the string index signature. In effect, this means the string
                // index signature applies even when accessing with a symbol-like type.
                var indexInfo = getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType);
                if (indexInfo) {
                    if (accessFlags & 2 /* NoIndexSignatures */ && indexInfo.keyType !== numberType) {
                        if (accessExpression) {
                            error(accessExpression, ts.Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType));
                        }
                        return undefined;
                    }
                    if (accessNode && indexInfo.keyType === stringType && !isTypeAssignableToKind(indexType, 4 /* String */ | 8 /* Number */)) {
                        var indexNode = getIndexNodeForAccessExpression(accessNode);
                        error(indexNode, ts.Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
                        return accessFlags & 1 /* IncludeUndefined */ ? getUnionType([indexInfo.type, undefinedType]) : indexInfo.type;
                    }
                    errorIfWritingToReadonlyIndex(indexInfo);
                    return accessFlags & 1 /* IncludeUndefined */ ? getUnionType([indexInfo.type, undefinedType]) : indexInfo.type;
                }
                if (indexType.flags & 131072 /* Never */) {
                    return neverType;
                }
                if (isJSLiteralType(objectType)) {
                    return anyType;
                }
                if (accessExpression && !isConstEnumObjectType(objectType)) {
                    if (isObjectLiteralType(objectType)) {
                        if (noImplicitAny && indexType.flags & (128 /* StringLiteral */ | 256 /* NumberLiteral */)) {
                            diagnostics.add(ts.createDiagnosticForNode(accessExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType)));
                            return undefinedType;
                        }
                        else if (indexType.flags & (8 /* Number */ | 4 /* String */)) {
                            var types = ts.map(objectType.properties, function (property) {
                                return getTypeOfSymbol(property);
                            });
                            return getUnionType(ts.append(types, undefinedType));
                        }
                    }
                    if (objectType.symbol === globalThisSymbol && propName !== undefined && globalThisSymbol.exports.has(propName) && (globalThisSymbol.exports.get(propName).flags & 418 /* BlockScoped */)) {
                        error(accessExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.unescapeLeadingUnderscores(propName), typeToString(objectType));
                    }
                    else if (noImplicitAny && !compilerOptions.suppressImplicitAnyIndexErrors && !(accessFlags & 128 /* SuppressNoImplicitAnyError */)) {
                        if (propName !== undefined && typeHasStaticProperty(propName, objectType)) {
                            var typeName = typeToString(objectType);
                            error(accessExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName + "[" + ts.getTextOfNode(accessExpression.argumentExpression) + "]");
                        }
                        else if (getIndexTypeOfType(objectType, numberType)) {
                            error(accessExpression.argumentExpression, ts.Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number);
                        }
                        else {
                            var suggestion = void 0;
                            if (propName !== undefined && (suggestion = getSuggestionForNonexistentProperty(propName, objectType))) {
                                if (suggestion !== undefined) {
                                    error(accessExpression.argumentExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(objectType), suggestion);
                                }
                            }
                            else {
                                var suggestion_1 = getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType);
                                if (suggestion_1 !== undefined) {
                                    error(accessExpression, ts.Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion_1);
                                }
                                else {
                                    var errorInfo = void 0;
                                    if (indexType.flags & 1024 /* EnumLiteral */) {
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "[" + typeToString(indexType) + "]", typeToString(objectType));
                                    }
                                    else if (indexType.flags & 8192 /* UniqueESSymbol */) {
                                        var symbolName_2 = getFullyQualifiedName(indexType.symbol, accessExpression);
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "[" + symbolName_2 + "]", typeToString(objectType));
                                    }
                                    else if (indexType.flags & 128 /* StringLiteral */) {
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType));
                                    }
                                    else if (indexType.flags & 256 /* NumberLiteral */) {
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType));
                                    }
                                    else if (indexType.flags & (8 /* Number */ | 4 /* String */)) {
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType));
                                    }
                                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1, typeToString(fullIndexType), typeToString(objectType));
                                    diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(accessExpression, errorInfo));
                                }
                            }
                        }
                    }
                    return undefined;
                }
            }
            if (isJSLiteralType(objectType)) {
                return anyType;
            }
            if (accessNode) {
                var indexNode = getIndexNodeForAccessExpression(accessNode);
                if (indexType.flags & (128 /* StringLiteral */ | 256 /* NumberLiteral */)) {
                    error(indexNode, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "" + indexType.value, typeToString(objectType));
                }
                else if (indexType.flags & (4 /* String */ | 8 /* Number */)) {
                    error(indexNode, ts.Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType));
                }
                else {
                    error(indexNode, ts.Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
                }
            }
            if (isTypeAny(indexType)) {
                return indexType;
            }
            return undefined;
            function errorIfWritingToReadonlyIndex(indexInfo) {
                if (indexInfo && indexInfo.isReadonly && accessExpression && (ts.isAssignmentTarget(accessExpression) || ts.isDeleteTarget(accessExpression))) {
                    error(accessExpression, ts.Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
                }
            }
        }
        function getIndexNodeForAccessExpression(accessNode) {
            return accessNode.kind === 205 /* ElementAccessExpression */ ? accessNode.argumentExpression :
                accessNode.kind === 192 /* IndexedAccessType */ ? accessNode.indexType :
                    accessNode.kind === 160 /* ComputedPropertyName */ ? accessNode.expression :
                        accessNode;
        }
        function isPatternLiteralPlaceholderType(type) {
            return !!(type.flags & (1 /* Any */ | 4 /* String */ | 8 /* Number */ | 64 /* BigInt */));
        }
        function isPatternLiteralType(type) {
            return !!(type.flags & 134217728 /* TemplateLiteral */) && ts.every(type.types, isPatternLiteralPlaceholderType);
        }
        function isGenericType(type) {
            return !!getGenericObjectFlags(type);
        }
        function isGenericObjectType(type) {
            return !!(getGenericObjectFlags(type) & 8388608 /* IsGenericObjectType */);
        }
        function isGenericIndexType(type) {
            return !!(getGenericObjectFlags(type) & 16777216 /* IsGenericIndexType */);
        }
        function getGenericObjectFlags(type) {
            if (type.flags & 3145728 /* UnionOrIntersection */) {
                if (!(type.objectFlags & 4194304 /* IsGenericTypeComputed */)) {
                    type.objectFlags |= 4194304 /* IsGenericTypeComputed */ |
                        ts.reduceLeft(type.types, function (flags, t) { return flags | getGenericObjectFlags(t); }, 0);
                }
                return type.objectFlags & 25165824 /* IsGenericType */;
            }
            if (type.flags & 33554432 /* Substitution */) {
                if (!(type.objectFlags & 4194304 /* IsGenericTypeComputed */)) {
                    type.objectFlags |= 4194304 /* IsGenericTypeComputed */ |
                        getGenericObjectFlags(type.substitute) | getGenericObjectFlags(type.baseType);
                }
                return type.objectFlags & 25165824 /* IsGenericType */;
            }
            return (type.flags & 58982400 /* InstantiableNonPrimitive */ || isGenericMappedType(type) || isGenericTupleType(type) ? 8388608 /* IsGenericObjectType */ : 0) |
                (type.flags & (58982400 /* InstantiableNonPrimitive */ | 4194304 /* Index */ | 134217728 /* TemplateLiteral */ | 268435456 /* StringMapping */) && !isPatternLiteralType(type) ? 16777216 /* IsGenericIndexType */ : 0);
        }
        function isThisTypeParameter(type) {
            return !!(type.flags & 262144 /* TypeParameter */ && type.isThisType);
        }
        function getSimplifiedType(type, writing) {
            return type.flags & 8388608 /* IndexedAccess */ ? getSimplifiedIndexedAccessType(type, writing) :
                type.flags & 16777216 /* Conditional */ ? getSimplifiedConditionalType(type, writing) :
                    type;
        }
        function distributeIndexOverObjectType(objectType, indexType, writing) {
            // (T | U)[K] -> T[K] | U[K] (reading)
            // (T | U)[K] -> T[K] & U[K] (writing)
            // (T & U)[K] -> T[K] & U[K]
            if (objectType.flags & 3145728 /* UnionOrIntersection */) {
                var types = ts.map(objectType.types, function (t) { return getSimplifiedType(getIndexedAccessType(t, indexType), writing); });
                return objectType.flags & 2097152 /* Intersection */ || writing ? getIntersectionType(types) : getUnionType(types);
            }
        }
        function distributeObjectOverIndexType(objectType, indexType, writing) {
            // T[A | B] -> T[A] | T[B] (reading)
            // T[A | B] -> T[A] & T[B] (writing)
            if (indexType.flags & 1048576 /* Union */) {
                var types = ts.map(indexType.types, function (t) { return getSimplifiedType(getIndexedAccessType(objectType, t), writing); });
                return writing ? getIntersectionType(types) : getUnionType(types);
            }
        }
        // Transform an indexed access to a simpler form, if possible. Return the simpler form, or return
        // the type itself if no transformation is possible. The writing flag indicates that the type is
        // the target of an assignment.
        function getSimplifiedIndexedAccessType(type, writing) {
            var cache = writing ? "simplifiedForWriting" : "simplifiedForReading";
            if (type[cache]) {
                return type[cache] === circularConstraintType ? type : type[cache];
            }
            type[cache] = circularConstraintType;
            // We recursively simplify the object type as it may in turn be an indexed access type. For example, with
            // '{ [P in T]: { [Q in U]: number } }[T][U]' we want to first simplify the inner indexed access type.
            var objectType = getSimplifiedType(type.objectType, writing);
            var indexType = getSimplifiedType(type.indexType, writing);
            // T[A | B] -> T[A] | T[B] (reading)
            // T[A | B] -> T[A] & T[B] (writing)
            var distributedOverIndex = distributeObjectOverIndexType(objectType, indexType, writing);
            if (distributedOverIndex) {
                return type[cache] = distributedOverIndex;
            }
            // Only do the inner distributions if the index can no longer be instantiated to cause index distribution again
            if (!(indexType.flags & 465829888 /* Instantiable */)) {
                // (T | U)[K] -> T[K] | U[K] (reading)
                // (T | U)[K] -> T[K] & U[K] (writing)
                // (T & U)[K] -> T[K] & U[K]
                var distributedOverObject = distributeIndexOverObjectType(objectType, indexType, writing);
                if (distributedOverObject) {
                    return type[cache] = distributedOverObject;
                }
            }
            // So ultimately (reading):
            // ((A & B) | C)[K1 | K2] -> ((A & B) | C)[K1] | ((A & B) | C)[K2] -> (A & B)[K1] | C[K1] | (A & B)[K2] | C[K2] -> (A[K1] & B[K1]) | C[K1] | (A[K2] & B[K2]) | C[K2]
            // A generic tuple type indexed by a number exists only when the index type doesn't select a
            // fixed element. We simplify to either the combined type of all elements (when the index type
            // the actual number type) or to the combined type of all non-fixed elements.
            if (isGenericTupleType(objectType) && indexType.flags & 296 /* NumberLike */) {
                var elementType = getElementTypeOfSliceOfTupleType(objectType, indexType.flags & 8 /* Number */ ? 0 : objectType.target.fixedLength, /*endSkipCount*/ 0, writing);
                if (elementType) {
                    return type[cache] = elementType;
                }
            }
            // If the object type is a mapped type { [P in K]: E }, where K is generic, instantiate E using a mapper
            // that substitutes the index type for P. For example, for an index access { [P in K]: Box<T[P]> }[X], we
            // construct the type Box<T[X]>.
            if (isGenericMappedType(objectType)) {
                return type[cache] = mapType(substituteIndexedMappedType(objectType, type.indexType), function (t) { return getSimplifiedType(t, writing); });
            }
            return type[cache] = type;
        }
        function isConditionalTypeAlwaysTrueDisregardingInferTypes(type) {
            var extendsInferParamMapper = type.root.inferTypeParameters && createTypeMapper(type.root.inferTypeParameters, ts.map(type.root.inferTypeParameters, function () { return wildcardType; }));
            var checkType = type.checkType;
            var extendsType = type.extendsType;
            return isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(instantiateType(extendsType, extendsInferParamMapper)));
        }
        function getSimplifiedConditionalType(type, writing) {
            var checkType = type.checkType;
            var extendsType = type.extendsType;
            var trueType = getTrueTypeFromConditionalType(type);
            var falseType = getFalseTypeFromConditionalType(type);
            // Simplifications for types of the form `T extends U ? T : never` and `T extends U ? never : T`.
            if (falseType.flags & 131072 /* Never */ && getActualTypeVariable(trueType) === getActualTypeVariable(checkType)) {
                if (checkType.flags & 1 /* Any */ || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) { // Always true
                    return getSimplifiedType(trueType, writing);
                }
                else if (isIntersectionEmpty(checkType, extendsType)) { // Always false
                    return neverType;
                }
            }
            else if (trueType.flags & 131072 /* Never */ && getActualTypeVariable(falseType) === getActualTypeVariable(checkType)) {
                if (!(checkType.flags & 1 /* Any */) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) { // Always true
                    return neverType;
                }
                else if (checkType.flags & 1 /* Any */ || isIntersectionEmpty(checkType, extendsType)) { // Always false
                    return getSimplifiedType(falseType, writing);
                }
            }
            return type;
        }
        /**
         * Invokes union simplification logic to determine if an intersection is considered empty as a union constituent
         */
        function isIntersectionEmpty(type1, type2) {
            return !!(getUnionType([intersectTypes(type1, type2), neverType]).flags & 131072 /* Never */);
        }
        function substituteIndexedMappedType(objectType, index) {
            var mapper = createTypeMapper([getTypeParameterFromMappedType(objectType)], [index]);
            var templateMapper = combineTypeMappers(objectType.mapper, mapper);
            return instantiateType(getTemplateTypeFromMappedType(objectType), templateMapper);
        }
        function getIndexedAccessType(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) {
            if (accessFlags === void 0) { accessFlags = 0 /* None */; }
            return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || (accessNode ? errorType : unknownType);
        }
        function indexTypeLessThan(indexType, limit) {
            return everyType(indexType, function (t) {
                if (t.flags & 384 /* StringOrNumberLiteral */) {
                    var propName = getPropertyNameFromType(t);
                    if (isNumericLiteralName(propName)) {
                        var index = +propName;
                        return index >= 0 && index < limit;
                    }
                }
                return false;
            });
        }
        function getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) {
            if (accessFlags === void 0) { accessFlags = 0 /* None */; }
            if (objectType === wildcardType || indexType === wildcardType) {
                return wildcardType;
            }
            // If the object type has a string index signature and no other members we know that the result will
            // always be the type of that index signature and we can simplify accordingly.
            if (isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & 98304 /* Nullable */) && isTypeAssignableToKind(indexType, 4 /* String */ | 8 /* Number */)) {
                indexType = stringType;
            }
            // In noUncheckedIndexedAccess mode, indexed access operations that occur in an expression in a read position and resolve to
            // an index signature have 'undefined' included in their type.
            if (compilerOptions.noUncheckedIndexedAccess && accessFlags & 32 /* ExpressionPosition */)
                accessFlags |= 1 /* IncludeUndefined */;
            // If the index type is generic, or if the object type is generic and doesn't originate in an expression and
            // the operation isn't exclusively indexing the fixed (non-variadic) portion of a tuple type, we are performing
            // a higher-order index access where we cannot meaningfully access the properties of the object type. Note that
            // for a generic T and a non-generic K, we eagerly resolve T[K] if it originates in an expression. This is to
            // preserve backwards compatibility. For example, an element access 'this["foo"]' has always been resolved
            // eagerly using the constraint type of 'this' at the given location.
            if (isGenericIndexType(indexType) || (accessNode && accessNode.kind !== 192 /* IndexedAccessType */ ?
                isGenericTupleType(objectType) && !indexTypeLessThan(indexType, objectType.target.fixedLength) :
                isGenericObjectType(objectType) && !(isTupleType(objectType) && indexTypeLessThan(indexType, objectType.target.fixedLength)))) {
                if (objectType.flags & 3 /* AnyOrUnknown */) {
                    return objectType;
                }
                // Defer the operation by creating an indexed access type.
                var persistentAccessFlags = accessFlags & 1 /* Persistent */;
                var id = objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments);
                var type = indexedAccessTypes.get(id);
                if (!type) {
                    indexedAccessTypes.set(id, type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments));
                }
                return type;
            }
            // In the following we resolve T[K] to the type of the property in T selected by K.
            // We treat boolean as different from other unions to improve errors;
            // skipping straight to getPropertyTypeForIndexType gives errors with 'boolean' instead of 'true'.
            var apparentObjectType = getReducedApparentType(objectType);
            if (indexType.flags & 1048576 /* Union */ && !(indexType.flags & 16 /* Boolean */)) {
                var propTypes = [];
                var wasMissingProp = false;
                for (var _i = 0, _a = indexType.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    var propType = getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags | (wasMissingProp ? 128 /* SuppressNoImplicitAnyError */ : 0));
                    if (propType) {
                        propTypes.push(propType);
                    }
                    else if (!accessNode) {
                        // If there's no error node, we can immeditely stop, since error reporting is off
                        return undefined;
                    }
                    else {
                        // Otherwise we set a flag and return at the end of the loop so we still mark all errors
                        wasMissingProp = true;
                    }
                }
                if (wasMissingProp) {
                    return undefined;
                }
                return accessFlags & 4 /* Writing */
                    ? getIntersectionType(propTypes, aliasSymbol, aliasTypeArguments)
                    : getUnionType(propTypes, 1 /* Literal */, aliasSymbol, aliasTypeArguments);
            }
            return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, accessFlags | 8 /* CacheSymbol */ | 64 /* ReportDeprecated */);
        }
        function getTypeFromIndexedAccessTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var objectType = getTypeFromTypeNode(node.objectType);
                var indexType = getTypeFromTypeNode(node.indexType);
                var potentialAlias = getAliasSymbolForTypeNode(node);
                var resolved = getIndexedAccessType(objectType, indexType, 0 /* None */, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias));
                links.resolvedType = resolved.flags & 8388608 /* IndexedAccess */ &&
                    resolved.objectType === objectType &&
                    resolved.indexType === indexType ?
                    getConditionalFlowTypeOfType(resolved, node) : resolved;
            }
            return links.resolvedType;
        }
        function getTypeFromMappedTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var type = createObjectType(32 /* Mapped */, node.symbol);
                type.declaration = node;
                type.aliasSymbol = getAliasSymbolForTypeNode(node);
                type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type.aliasSymbol);
                links.resolvedType = type;
                // Eagerly resolve the constraint type which forces an error if the constraint type circularly
                // references itself through one or more type aliases.
                getConstraintTypeFromMappedType(type);
            }
            return links.resolvedType;
        }
        function getActualTypeVariable(type) {
            if (type.flags & 33554432 /* Substitution */) {
                return type.baseType;
            }
            if (type.flags & 8388608 /* IndexedAccess */ && (type.objectType.flags & 33554432 /* Substitution */ ||
                type.indexType.flags & 33554432 /* Substitution */)) {
                return getIndexedAccessType(getActualTypeVariable(type.objectType), getActualTypeVariable(type.indexType));
            }
            return type;
        }
        function isTypicalNondistributiveConditional(root) {
            return !root.isDistributive && isSingletonTupleType(root.node.checkType) && isSingletonTupleType(root.node.extendsType);
        }
        function isSingletonTupleType(node) {
            return ts.isTupleTypeNode(node) && ts.length(node.elements) === 1 && !ts.isOptionalTypeNode(node.elements[0]) && !ts.isRestTypeNode(node.elements[0]);
        }
        /**
         * We syntactually check for common nondistributive conditional shapes and unwrap them into
         * the intended comparison - we do this so we can check if the unwrapped types are generic or
         * not and appropriately defer condition calculation
         */
        function unwrapNondistributiveConditionalTuple(root, type) {
            return isTypicalNondistributiveConditional(root) && isTupleType(type) ? getTypeArguments(type)[0] : type;
        }
        function getConditionalType(root, mapper, aliasSymbol, aliasTypeArguments) {
            var result;
            var extraTypes;
            // We loop here for an immediately nested conditional type in the false position, effectively treating
            // types of the form 'A extends B ? X : C extends D ? Y : E extends F ? Z : ...' as a single construct for
            // purposes of resolution. This means such types aren't subject to the instantiation depth limiter.
            while (true) {
                var isUnwrapped = isTypicalNondistributiveConditional(root);
                var checkType = instantiateType(unwrapNondistributiveConditionalTuple(root, getActualTypeVariable(root.checkType)), mapper);
                var checkTypeInstantiable = isGenericType(checkType);
                var extendsType = instantiateType(unwrapNondistributiveConditionalTuple(root, root.extendsType), mapper);
                if (checkType === wildcardType || extendsType === wildcardType) {
                    return wildcardType;
                }
                var combinedMapper = void 0;
                if (root.inferTypeParameters) {
                    var context = createInferenceContext(root.inferTypeParameters, /*signature*/ undefined, 0 /* None */);
                    if (!checkTypeInstantiable) {
                        // We don't want inferences from constraints as they may cause us to eagerly resolve the
                        // conditional type instead of deferring resolution. Also, we always want strict function
                        // types rules (i.e. proper contravariance) for inferences.
                        inferTypes(context.inferences, checkType, extendsType, 512 /* NoConstraints */ | 1024 /* AlwaysStrict */);
                    }
                    // It's possible for 'infer T' type paramteters to be given uninstantiated constraints when the
                    // those type parameters are used in type references (see getInferredTypeParameterConstraint). For
                    // that reason we need context.mapper to be first in the combined mapper. See #42636 for examples.
                    combinedMapper = mapper ? combineTypeMappers(context.mapper, mapper) : context.mapper;
                }
                // Instantiate the extends type including inferences for 'infer T' type parameters
                var inferredExtendsType = combinedMapper ? instantiateType(unwrapNondistributiveConditionalTuple(root, root.extendsType), combinedMapper) : extendsType;
                // We attempt to resolve the conditional type only when the check and extends types are non-generic
                if (!checkTypeInstantiable && !isGenericType(inferredExtendsType)) {
                    // Return falseType for a definitely false extends check. We check an instantiations of the two
                    // types with type parameters mapped to the wildcard type, the most permissive instantiations
                    // possible (the wildcard type is assignable to and from all types). If those are not related,
                    // then no instantiations will be and we can just return the false branch type.
                    if (!(inferredExtendsType.flags & 3 /* AnyOrUnknown */) && ((checkType.flags & 1 /* Any */ && !isUnwrapped) || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType)))) {
                        // Return union of trueType and falseType for 'any' since it matches anything
                        if (checkType.flags & 1 /* Any */ &