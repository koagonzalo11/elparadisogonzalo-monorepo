art, fixedNodes); });
            },
        });
        function makeChange(changeTracker, sourceFile, pos, fixedNodes) {
            var token = ts.getTokenAtPosition(sourceFile, pos);
            if (!ts.isIdentifier(token)) {
                return;
            }
            var declaration = token.parent;
            if (declaration.kind === 165 /* PropertyDeclaration */ &&
                (!fixedNodes || ts.tryAddToSet(fixedNodes, declaration))) {
                changeTracker.insertModifierBefore(sourceFile, 134 /* DeclareKeyword */, declaration);
            }
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "addMissingInvocationForDecorator";
        var errorCodes = [ts.Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return makeChange(t, context.sourceFile, context.span.start); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Call_decorator_expression, fixId, ts.Diagnostics.Add_to_all_uncalled_decorators)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) { return makeChange(changes, diag.file, diag.start); }); },
        });
        function makeChange(changeTracker, sourceFile, pos) {
            var token = ts.getTokenAtPosition(sourceFile, pos);
            var decorator = ts.findAncestor(token, ts.isDecorator);
            ts.Debug.assert(!!decorator, "Expected position to be owned by a decorator.");
            var replacement = ts.factory.createCallExpression(decorator.expression, /*typeArguments*/ undefined, /*argumentsArray*/ undefined);
            changeTracker.replaceNode(sourceFile, decorator.expression, replacement);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "addNameToNamelessParameter";
        var errorCodes = [ts.Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return makeChange(t, context.sourceFile, context.span.start); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Add_parameter_name, fixId, ts.Diagnostics.Add_names_to_all_parameters_without_names)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) { return makeChange(changes, diag.file, diag.start); }); },
        });
        function makeChange(changeTracker, sourceFile, pos) {
            var token = ts.getTokenAtPosition(sourceFile, pos);
            if (!ts.isIdentifier(token)) {
                return ts.Debug.fail("add-name-to-nameless-parameter operates on identifiers, but got a " + ts.Debug.formatSyntaxKind(token.kind));
            }
            var param = token.parent;
            if (!ts.isParameter(param)) {
                return ts.Debug.fail("Tried to add a parameter name to a non-parameter: " + ts.Debug.formatSyntaxKind(token.kind));
            }
            var i = param.parent.parameters.indexOf(param);
            ts.Debug.assert(!param.type, "Tried to add a parameter name to a parameter that already had one.");
            ts.Debug.assert(i > -1, "Parameter not found in parent parameter list.");
            var replacement = ts.factory.createParameterDeclaration(
            /*decorators*/ undefined, param.modifiers, param.dotDotDotToken, "arg" + i, param.questionToken, ts.factory.createTypeReferenceNode(token, /*typeArguments*/ undefined), param.initializer);
            changeTracker.replaceNode(sourceFile, token, replacement);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "annotateWithTypeFromJSDoc";
        var errorCodes = [ts.Diagnostics.JSDoc_types_may_be_moved_to_TypeScript_types.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var decl = getDeclaration(context.sourceFile, context.span.start);
                if (!decl)
                    return;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, context.sourceFile, decl); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Annotate_with_type_from_JSDoc, fixId, ts.Diagnostics.Annotate_everything_with_types_from_JSDoc)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var decl = getDeclaration(diag.file, diag.start);
                if (decl)
                    doChange(changes, diag.file, decl);
            }); },
        });
        function getDeclaration(file, pos) {
            var name = ts.getTokenAtPosition(file, pos);
            // For an arrow function with no name, 'name' lands on the first parameter.
            return ts.tryCast(ts.isParameter(name.parent) ? name.parent.parent : name.parent, parameterShouldGetTypeFromJSDoc);
        }
        function parameterShouldGetTypeFromJSDoc(node) {
            return isDeclarationWithType(node) && hasUsableJSDoc(node);
        }
        codefix.parameterShouldGetTypeFromJSDoc = parameterShouldGetTypeFromJSDoc;
        function hasUsableJSDoc(decl) {
            return ts.isFunctionLikeDeclaration(decl)
                ? decl.parameters.some(hasUsableJSDoc) || (!decl.type && !!ts.getJSDocReturnType(decl))
                : !decl.type && !!ts.getJSDocType(decl);
        }
        function doChange(changes, sourceFile, decl) {
            if (ts.isFunctionLikeDeclaration(decl) && (ts.getJSDocReturnType(decl) || decl.parameters.some(function (p) { return !!ts.getJSDocType(p); }))) {
                if (!decl.typeParameters) {
                    var typeParameters = ts.getJSDocTypeParameterDeclarations(decl);
                    if (typeParameters.length)
                        changes.insertTypeParameters(sourceFile, decl, typeParameters);
                }
                var needParens = ts.isArrowFunction(decl) && !ts.findChildOfKind(decl, 20 /* OpenParenToken */, sourceFile);
                if (needParens)
                    changes.insertNodeBefore(sourceFile, ts.first(decl.parameters), ts.factory.createToken(20 /* OpenParenToken */));
                for (var _i = 0, _a = decl.parameters; _i < _a.length; _i++) {
                    var param = _a[_i];
                    if (!param.type) {
                        var paramType = ts.getJSDocType(param);
                        if (paramType)
                            changes.tryInsertTypeAnnotation(sourceFile, param, transformJSDocType(paramType));
                    }
                }
                if (needParens)
                    changes.insertNodeAfter(sourceFile, ts.last(decl.parameters), ts.factory.createToken(21 /* CloseParenToken */));
                if (!decl.type) {
                    var returnType = ts.getJSDocReturnType(decl);
                    if (returnType)
                        changes.tryInsertTypeAnnotation(sourceFile, decl, transformJSDocType(returnType));
                }
            }
            else {
                var jsdocType = ts.Debug.checkDefined(ts.getJSDocType(decl), "A JSDocType for this declaration should exist"); // If not defined, shouldn't have been an error to fix
                ts.Debug.assert(!decl.type, "The JSDocType decl should have a type"); // If defined, shouldn't have been an error to fix.
                changes.tryInsertTypeAnnotation(sourceFile, decl, transformJSDocType(jsdocType));
            }
        }
        function isDeclarationWithType(node) {
            return ts.isFunctionLikeDeclaration(node) ||
                node.kind === 252 /* VariableDeclaration */ ||
                node.kind === 164 /* PropertySignature */ ||
                node.kind === 165 /* PropertyDeclaration */;
        }
        function transformJSDocType(node) {
            switch (node.kind) {
                case 307 /* JSDocAllType */:
                case 308 /* JSDocUnknownType */:
                    return ts.factory.createTypeReferenceNode("any", ts.emptyArray);
                case 311 /* JSDocOptionalType */:
                    return transformJSDocOptionalType(node);
                case 310 /* JSDocNonNullableType */:
                    return transformJSDocType(node.type);
                case 309 /* JSDocNullableType */:
                    return transformJSDocNullableType(node);
                case 313 /* JSDocVariadicType */:
                    return transformJSDocVariadicType(node);
                case 312 /* JSDocFunctionType */:
                    return transformJSDocFunctionType(node);
                case 176 /* TypeReference */:
                    return transformJSDocTypeReference(node);
                default:
                    var visited = ts.visitEachChild(node, transformJSDocType, ts.nullTransformationContext);
                    ts.setEmitFlags(visited, 1 /* SingleLine */);
                    return visited;
            }
        }
        function transformJSDocOptionalType(node) {
            return ts.factory.createUnionTypeNode([ts.visitNode(node.type, transformJSDocType), ts.factory.createTypeReferenceNode("undefined", ts.emptyArray)]);
        }
        function transformJSDocNullableType(node) {
            return ts.factory.createUnionTypeNode([ts.visitNode(node.type, transformJSDocType), ts.factory.createTypeReferenceNode("null", ts.emptyArray)]);
        }
        function transformJSDocVariadicType(node) {
            return ts.factory.createArrayTypeNode(ts.visitNode(node.type, transformJSDocType));
        }
        function transformJSDocFunctionType(node) {
            var _a;
            // TODO: This does not properly handle `function(new:C, string)` per https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System#the-javascript-type-language
            //       however we do handle it correctly in `serializeTypeForDeclaration` in checker.ts
            return ts.factory.createFunctionTypeNode(ts.emptyArray, node.parameters.map(transformJSDocParameter), (_a = node.type) !== null && _a !== void 0 ? _a : ts.factory.createKeywordTypeNode(129 /* AnyKeyword */));
        }
        function transformJSDocParameter(node) {
            var index = node.parent.parameters.indexOf(node);
            var isRest = node.type.kind === 313 /* JSDocVariadicType */ && index === node.parent.parameters.length - 1; // TODO: GH#18217
            var name = node.name || (isRest ? "rest" : "arg" + index);
            var dotdotdot = isRest ? ts.factory.createToken(25 /* DotDotDotToken */) : node.dotDotDotToken;
            return ts.factory.createParameterDeclaration(node.decorators, node.modifiers, dotdotdot, name, node.questionToken, ts.visitNode(node.type, transformJSDocType), node.initializer);
        }
        function transformJSDocTypeReference(node) {
            var name = node.typeName;
            var args = node.typeArguments;
            if (ts.isIdentifier(node.typeName)) {
                if (ts.isJSDocIndexSignature(node)) {
                    return transformJSDocIndexSignature(node);
                }
                var text = node.typeName.text;
                switch (node.typeName.text) {
                    case "String":
                    case "Boolean":
                    case "Object":
                    case "Number":
                        text = text.toLowerCase();
                        break;
                    case "array":
                    case "date":
                    case "promise":
                        text = text[0].toUpperCase() + text.slice(1);
                        break;
                }
                name = ts.factory.createIdentifier(text);
                if ((text === "Array" || text === "Promise") && !node.typeArguments) {
                    args = ts.factory.createNodeArray([ts.factory.createTypeReferenceNode("any", ts.emptyArray)]);
                }
                else {
                    args = ts.visitNodes(node.typeArguments, transformJSDocType);
                }
            }
            return ts.factory.createTypeReferenceNode(name, args);
        }
        function transformJSDocIndexSignature(node) {
            var index = ts.factory.createParameterDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*dotDotDotToken*/ undefined, node.typeArguments[0].kind === 145 /* NumberKeyword */ ? "n" : "s", 
            /*questionToken*/ undefined, ts.factory.createTypeReferenceNode(node.typeArguments[0].kind === 145 /* NumberKeyword */ ? "number" : "string", []), 
            /*initializer*/ undefined);
            var indexSignature = ts.factory.createTypeLiteralNode([ts.factory.createIndexSignature(/*decorators*/ undefined, /*modifiers*/ undefined, [index], node.typeArguments[1])]);
            ts.setEmitFlags(indexSignature, 1 /* SingleLine */);
            return indexSignature;
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "convertFunctionToEs6Class";
        var errorCodes = [ts.Diagnostics.This_constructor_function_may_be_converted_to_a_class_declaration.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) {
                    return doChange(t, context.sourceFile, context.span.start, context.program.getTypeChecker(), context.preferences, context.program.getCompilerOptions());
                });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Convert_function_to_an_ES2015_class, fixId, ts.Diagnostics.Convert_all_constructor_functions_to_classes)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, err) {
                return doChange(changes, err.file, err.start, context.program.getTypeChecker(), context.preferences, context.program.getCompilerOptions());
            }); },
        });
        function doChange(changes, sourceFile, position, checker, preferences, compilerOptions) {
            var ctorSymbol = checker.getSymbolAtLocation(ts.getTokenAtPosition(sourceFile, position));
            if (!ctorSymbol || !ctorSymbol.valueDeclaration || !(ctorSymbol.flags & (16 /* Function */ | 3 /* Variable */))) {
                // Bad input
                return undefined;
            }
            var ctorDeclaration = ctorSymbol.valueDeclaration;
            if (ts.isFunctionDeclaration(ctorDeclaration)) {
                changes.replaceNode(sourceFile, ctorDeclaration, createClassFromFunctionDeclaration(ctorDeclaration));
            }
            else if (ts.isVariableDeclaration(ctorDeclaration)) {
                var classDeclaration = createClassFromVariableDeclaration(ctorDeclaration);
                if (!classDeclaration) {
                    return undefined;
                }
                var ancestor = ctorDeclaration.parent.parent;
                if (ts.isVariableDeclarationList(ctorDeclaration.parent) && ctorDeclaration.parent.declarations.length > 1) {
                    changes.delete(sourceFile, ctorDeclaration);
                    changes.insertNodeAfter(sourceFile, ancestor, classDeclaration);
                }
                else {
                    changes.replaceNode(sourceFile, ancestor, classDeclaration);
                }
            }
            function createClassElementsFromSymbol(symbol) {
                var memberElements = [];
                // all instance members are stored in the "member" array of symbol
                if (symbol.members) {
                    symbol.members.forEach(function (member, key) {
                        if (key === "constructor" && member.valueDeclaration) {
                            // fn.prototype.constructor = fn
                            changes.delete(sourceFile, member.valueDeclaration.parent);
                            return;
                        }
                        var memberElement = createClassElement(member, /*modifiers*/ undefined);
                        if (memberElement) {
                            memberElements.push.apply(memberElements, memberElement);
                        }
                    });
                }
                // all static members are stored in the "exports" array of symbol
                if (symbol.exports) {
                    symbol.exports.forEach(function (member) {
                        if (member.name === "prototype" && member.declarations) {
                            var firstDeclaration = member.declarations[0];
                            // only one "x.prototype = { ... }" will pass
                            if (member.declarations.length === 1 &&
                                ts.isPropertyAccessExpression(firstDeclaration) &&
                                ts.isBinaryExpression(firstDeclaration.parent) &&
                                firstDeclaration.parent.operatorToken.kind === 63 /* EqualsToken */ &&
                                ts.isObjectLiteralExpression(firstDeclaration.parent.right)) {
                                var prototypes = firstDeclaration.parent.right;
                                var memberElement = createClassElement(prototypes.symbol, /** modifiers */ undefined);
                                if (memberElement) {
                                    memberElements.push.apply(memberElements, memberElement);
                                }
                            }
                        }
                        else {
                            var memberElement = createClassElement(member, [ts.factory.createToken(124 /* StaticKeyword */)]);
                            if (memberElement) {
                                memberElements.push.apply(memberElements, memberElement);
                            }
                        }
                    });
                }
                return memberElements;
                function shouldConvertDeclaration(_target, source) {
                    // Right now the only thing we can convert are function expressions, get/set accessors and methods
                    // other values like normal value fields ({a: 1}) shouldn't get transformed.
                    // We can update this once ES public class properties are available.
                    if (ts.isAccessExpression(_target)) {
                        if (ts.isPropertyAccessExpression(_target) && isConstructorAssignment(_target))
                            return true;
                        return ts.isFunctionLike(source);
                    }
                    else {
                        return ts.every(_target.properties, function (property) {
                            // a() {}
                            if (ts.isMethodDeclaration(property) || ts.isGetOrSetAccessorDeclaration(property))
                                return true;
                            // a: function() {}
                            if (ts.isPropertyAssignment(property) && ts.isFunctionExpression(property.initializer) && !!property.name)
                                return true;
                            // x.prototype.constructor = fn
                            if (isConstructorAssignment(property))
                                return true;
                            return false;
                        });
                    }
                }
                function createClassElement(symbol, modifiers) {
                    // Right now the only thing we can convert are function expressions, which are marked as methods
                    // or { x: y } type prototype assignments, which are marked as ObjectLiteral
                    var members = [];
                    if (!(symbol.flags & 8192 /* Method */) && !(symbol.flags & 4096 /* ObjectLiteral */)) {
                        return members;
                    }
                    var memberDeclaration = symbol.valueDeclaration;
                    var assignmentBinaryExpression = memberDeclaration.parent;
                    var assignmentExpr = assignmentBinaryExpression.right;
                    if (!shouldConvertDeclaration(memberDeclaration, assignmentExpr)) {
                        return members;
                    }
                    // delete the entire statement if this expression is the sole expression to take care of the semicolon at the end
                    var nodeToDelete = assignmentBinaryExpression.parent && assignmentBinaryExpression.parent.kind === 236 /* ExpressionStatement */
                        ? assignmentBinaryExpression.parent : assignmentBinaryExpression;
                    changes.delete(sourceFile, nodeToDelete);
                    if (!assignmentExpr) {
                        members.push(ts.factory.createPropertyDeclaration([], modifiers, symbol.name, /*questionToken*/ undefined, 
                        /*type*/ undefined, /*initializer*/ undefined));
                        return members;
                    }
                    // f.x = expr
                    if (ts.isAccessExpression(memberDeclaration) && (ts.isFunctionExpression(assignmentExpr) || ts.isArrowFunction(assignmentExpr))) {
                        var quotePreference = ts.getQuotePreference(sourceFile, preferences);
                        var name = tryGetPropertyName(memberDeclaration, compilerOptions, quotePreference);
                        if (name) {
                            return createFunctionLikeExpressionMember(members, assignmentExpr, name);
                        }
                        return members;
                    }
                    // f.prototype = { ... }
                    else if (ts.isObjectLiteralExpression(assignmentExpr)) {
                        return ts.flatMap(assignmentExpr.properties, function (property) {
                            if (ts.isMethodDeclaration(property) || ts.isGetOrSetAccessorDeclaration(property)) {
                                // MethodDeclaration and AccessorDeclaration can appear in a class directly
                                return members.concat(property);
                            }
                            if (ts.isPropertyAssignment(property) && ts.isFunctionExpression(property.initializer)) {
                                return createFunctionLikeExpressionMember(members, property.initializer, property.name);
                            }
                            // Drop constructor assignments
                            if (isConstructorAssignment(property))
                                return members;
                            return [];
                        });
                    }
                    else {
                        // Don't try to declare members in JavaScript files
                        if (ts.isSourceFileJS(sourceFile))
                            return members;
                        if (!ts.isPropertyAccessExpression(memberDeclaration))
                            return members;
                        var prop = ts.factory.createPropertyDeclaration(/*decorators*/ undefined, modifiers, memberDeclaration.name, /*questionToken*/ undefined, /*type*/ undefined, assignmentExpr);
                        ts.copyLeadingComments(assignmentBinaryExpression.parent, prop, sourceFile);
                        members.push(prop);
                        return members;
                    }
                    function createFunctionLikeExpressionMember(members, expression, name) {
                        if (ts.isFunctionExpression(expression))
                            return createFunctionExpressionMember(members, expression, name);
                        else
                            return createArrowFunctionExpressionMember(members, expression, name);
                    }
                    function createFunctionExpressionMember(members, functionExpression, name) {
                        var fullModifiers = ts.concatenate(modifiers, getModifierKindFromSource(functionExpression, 130 /* AsyncKeyword */));
                        var method = ts.factory.createMethodDeclaration(/*decorators*/ undefined, fullModifiers, /*asteriskToken*/ undefined, name, /*questionToken*/ undefined, 
                        /*typeParameters*/ undefined, functionExpression.parameters, /*type*/ undefined, functionExpression.body);
                        ts.copyLeadingComments(assignmentBinaryExpression, method, sourceFile);
                        return members.concat(method);
                    }
                    function createArrowFunctionExpressionMember(members, arrowFunction, name) {
                        var arrowFunctionBody = arrowFunction.body;
                        var bodyBlock;
                        // case 1: () => { return [1,2,3] }
                        if (arrowFunctionBody.kind === 233 /* Block */) {
                            bodyBlock = arrowFunctionBody;
                        }
                        // case 2: () => [1,2,3]
                        else {
                            bodyBlock = ts.factory.createBlock([ts.factory.createReturnStatement(arrowFunctionBody)]);
                        }
                        var fullModifiers = ts.concatenate(modifiers, getModifierKindFromSource(arrowFunction, 130 /* AsyncKeyword */));
                        var method = ts.factory.createMethodDeclaration(/*decorators*/ undefined, fullModifiers, /*asteriskToken*/ undefined, name, /*questionToken*/ undefined, 
                        /*typeParameters*/ undefined, arrowFunction.parameters, /*type*/ undefined, bodyBlock);
                        ts.copyLeadingComments(assignmentBinaryExpression, method, sourceFile);
                        return members.concat(method);
                    }
                }
            }
            function createClassFromVariableDeclaration(node) {
                var initializer = node.initializer;
                if (!initializer || !ts.isFunctionExpression(initializer) || !ts.isIdentifier(node.name)) {
                    return undefined;
                }
                var memberElements = createClassElementsFromSymbol(node.symbol);
                if (initializer.body) {
                    memberElements.unshift(ts.factory.createConstructorDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, initializer.parameters, initializer.body));
                }
                var modifiers = getModifierKindFromSource(node.parent.parent, 93 /* ExportKeyword */);
                var cls = ts.factory.createClassDeclaration(/*decorators*/ undefined, modifiers, node.name, 
                /*typeParameters*/ undefined, /*heritageClauses*/ undefined, memberElements);
                // Don't call copyComments here because we'll already leave them in place
                return cls;
            }
            function createClassFromFunctionDeclaration(node) {
                var memberElements = createClassElementsFromSymbol(ctorSymbol);
                if (node.body) {
                    memberElements.unshift(ts.factory.createConstructorDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, node.parameters, node.body));
                }
                var modifiers = getModifierKindFromSource(node, 93 /* ExportKeyword */);
                var cls = ts.factory.createClassDeclaration(/*decorators*/ undefined, modifiers, node.name, 
                /*typeParameters*/ undefined, /*heritageClauses*/ undefined, memberElements);
                // Don't call copyComments here because we'll already leave them in place
                return cls;
            }
        }
        function getModifierKindFromSource(source, kind) {
            return ts.filter(source.modifiers, function (modifier) { return modifier.kind === kind; });
        }
        function isConstructorAssignment(x) {
            if (!x.name)
                return false;
            if (ts.isIdentifier(x.name) && x.name.text === "constructor")
                return true;
            return false;
        }
        function tryGetPropertyName(node, compilerOptions, quotePreference) {
            if (ts.isPropertyAccessExpression(node)) {
                return node.name;
            }
            var propName = node.argumentExpression;
            if (ts.isNumericLiteral(propName)) {
                return propName;
            }
            if (ts.isStringLiteralLike(propName)) {
                return ts.isIdentifierText(propName.text, compilerOptions.target) ? ts.factory.createIdentifier(propName.text)
                    : ts.isNoSubstitutionTemplateLiteral(propName) ? ts.factory.createStringLiteral(propName.text, quotePreference === 0 /* Single */)
                        : propName;
            }
            return undefined;
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "convertToAsyncFunction";
        var errorCodes = [ts.Diagnostics.This_may_be_converted_to_an_async_function.code];
        var codeActionSucceeded = true;
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                codeActionSucceeded = true;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return convertToAsyncFunction(t, context.sourceFile, context.span.start, context.program.getTypeChecker()); });
                return codeActionSucceeded ? [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Convert_to_async_function, fixId, ts.Diagnostics.Convert_all_to_async_functions)] : [];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, err) { return convertToAsyncFunction(changes, err.file, err.start, context.program.getTypeChecker()); }); },
        });
        var SynthBindingNameKind;
        (function (SynthBindingNameKind) {
            SynthBindingNameKind[SynthBindingNameKind["Identifier"] = 0] = "Identifier";
            SynthBindingNameKind[SynthBindingNameKind["BindingPattern"] = 1] = "BindingPattern";
        })(SynthBindingNameKind || (SynthBindingNameKind = {}));
        function convertToAsyncFunction(changes, sourceFile, position, checker) {
            // get the function declaration - returns a promise
            var tokenAtPosition = ts.getTokenAtPosition(sourceFile, position);
            var functionToConvert;
            // if the parent of a FunctionLikeDeclaration is a variable declaration, the convertToAsync diagnostic will be reported on the variable name
            if (ts.isIdentifier(tokenAtPosition) && ts.isVariableDeclaration(tokenAtPosition.parent) &&
                tokenAtPosition.parent.initializer && ts.isFunctionLikeDeclaration(tokenAtPosition.parent.initializer)) {
                functionToConvert = tokenAtPosition.parent.initializer;
            }
            else {
                functionToConvert = ts.tryCast(ts.getContainingFunction(ts.getTokenAtPosition(sourceFile, position)), ts.canBeConvertedToAsync);
            }
            if (!functionToConvert) {
                return;
            }
            var synthNamesMap = new ts.Map();
            var isInJavascript = ts.isInJSFile(functionToConvert);
            var setOfExpressionsToReturn = getAllPromiseExpressionsToReturn(functionToConvert, checker);
            var functionToConvertRenamed = renameCollidingVarNames(functionToConvert, checker, synthNamesMap);
            if (!ts.returnsPromise(functionToConvertRenamed, checker)) {
                return;
            }
            var returnStatements = functionToConvertRenamed.body && ts.isBlock(functionToConvertRenamed.body) ? getReturnStatementsWithPromiseHandlers(functionToConvertRenamed.body, checker) : ts.emptyArray;
            var transformer = { checker: checker, synthNamesMap: synthNamesMap, setOfExpressionsToReturn: setOfExpressionsToReturn, isInJSFile: isInJavascript };
            if (!returnStatements.length) {
                return;
            }
            var pos = functionToConvert.modifiers ? functionToConvert.modifiers.end :
                functionToConvert.decorators ? ts.skipTrivia(sourceFile.text, functionToConvert.decorators.end) :
                    functionToConvert.getStart(sourceFile);
            var options = functionToConvert.modifiers ? { prefix: " " } : { suffix: " " };
            changes.insertModifierAt(sourceFile, pos, 130 /* AsyncKeyword */, options);
            var _loop_13 = function (returnStatement) {
                ts.forEachChild(returnStatement, function visit(node) {
                    if (ts.isCallExpression(node)) {
                        var newNodes = transformExpression(node, transformer);
                        changes.replaceNodeWithNodes(sourceFile, returnStatement, newNodes);
                    }
                    else if (!ts.isFunctionLike(node)) {
                        ts.forEachChild(node, visit);
                    }
                });
            };
            for (var _i = 0, returnStatements_1 = returnStatements; _i < returnStatements_1.length; _i++) {
                var returnStatement = returnStatements_1[_i];
                _loop_13(returnStatement);
            }
        }
        function getReturnStatementsWithPromiseHandlers(body, checker) {
            var res = [];
            ts.forEachReturnStatement(body, function (ret) {
                if (ts.isReturnStatementWithFixablePromiseHandler(ret, checker))
                    res.push(ret);
            });
            return res;
        }
        /*
            Finds all of the expressions of promise type that should not be saved in a variable during the refactor
        */
        function getAllPromiseExpressionsToReturn(func, checker) {
            if (!func.body) {
                return new ts.Set();
            }
            var setOfExpressionsToReturn = new ts.Set();
            ts.forEachChild(func.body, function visit(node) {
                if (isPromiseReturningCallExpression(node, checker, "then")) {
                    setOfExpressionsToReturn.add(ts.getNodeId(node));
                    ts.forEach(node.arguments, visit);
                }
                else if (isPromiseReturningCallExpression(node, checker, "catch")) {
                    setOfExpressionsToReturn.add(ts.getNodeId(node));
                    // if .catch() is the last call in the chain, move leftward in the chain until we hit something else that should be returned
                    ts.forEachChild(node, visit);
                }
                else if (isPromiseTypedExpression(node, checker)) {
                    setOfExpressionsToReturn.add(ts.getNodeId(node));
                    // don't recurse here, since we won't refactor any children or arguments of the expression
                }
                else {
                    ts.forEachChild(node, visit);
                }
            });
            return setOfExpressionsToReturn;
        }
        function isPromiseReturningCallExpression(node, checker, name) {
            if (!ts.isCallExpression(node))
                return false;
            var isExpressionOfName = ts.hasPropertyAccessExpressionWithName(node, name);
            var nodeType = isExpressionOfName && checker.getTypeAtLocation(node);
            return !!(nodeType && checker.getPromisedTypeOfPromise(nodeType));
        }
        function isPromiseTypedExpression(node, checker) {
            if (!ts.isExpression(node))
                return false;
            return !!checker.getPromisedTypeOfPromise(checker.getTypeAtLocation(node));
        }
        /*
            Renaming of identifiers may be necessary as the refactor changes scopes -
            This function collects all existing identifier names and names of identifiers that will be created in the refactor.
            It then checks for any collisions and renames them through getSynthesizedDeepClone
        */
        function renameCollidingVarNames(nodeToRename, checker, synthNamesMap) {
            var identsToRenameMap = new ts.Map(); // key is the symbol id
            var collidingSymbolMap = ts.createMultiMap();
            ts.forEachChild(nodeToRename, function visit(node) {
                if (!ts.isIdentifier(node)) {
                    ts.forEachChild(node, visit);
                    return;
                }
                var symbol = checker.getSymbolAtLocation(node);
                if (symbol) {
                    var type = checker.getTypeAtLocation(node);
                    // Note - the choice of the last call signature is arbitrary
                    var lastCallSignature = getLastCallSignature(type, checker);
                    var symbolIdString = ts.getSymbolId(symbol).toString();
                    // If the identifier refers to a function, we want to add the new synthesized variable for the declaration. Example:
                    //   fetch('...').then(response => { ... })
                    // will eventually become
                    //   const response = await fetch('...')
                    // so we push an entry for 'response'.
                    if (lastCallSignature && !ts.isParameter(node.parent) && !ts.isFunctionLikeDeclaration(node.parent) && !synthNamesMap.has(symbolIdString)) {
                        var firstParameter = ts.firstOrUndefined(lastCallSignature.parameters);
                        var ident = (firstParameter === null || firstParameter === void 0 ? void 0 : firstParameter.valueDeclaration)
                            && ts.isParameter(firstParameter.valueDeclaration)
                            && ts.tryCast(firstParameter.valueDeclaration.name, ts.isIdentifier)
                            || ts.factory.createUniqueName("result", 16 /* Optimistic */);
                        var synthName = getNewNameIfConflict(ident, collidingSymbolMap);
                        synthNamesMap.set(symbolIdString, synthName);
                        collidingSymbolMap.add(ident.text, symbol);
                    }
                    // We only care about identifiers that are parameters, variable declarations, or binding elements
                    else if (node.parent && (ts.isParameter(node.parent) || ts.isVariableDeclaration(node.parent) || ts.isBindingElement(node.parent))) {
                        var originalName = node.text;
                        var collidingSymbols = collidingSymbolMap.get(originalName);
                        // if the identifier name conflicts with a different identifier that we've already seen
                        if (collidingSymbols && collidingSymbols.some(function (prevSymbol) { return prevSymbol !== symbol; })) {
                            var newName = getNewNameIfConflict(node, collidingSymbolMap);
                            identsToRenameMap.set(symbolIdString, newName.identifier);
                            synthNamesMap.set(symbolIdString, newName);
                            collidingSymbolMap.add(originalName, symbol);
                        }
                        else {
                            var identifier = ts.getSynthesizedDeepClone(node);
                            synthNamesMap.set(symbolIdString, createSynthIdentifier(identifier));
                            collidingSymbolMap.add(originalName, symbol);
                        }
                    }
                }
            });
            return ts.getSynthesizedDeepCloneWithReplacements(nodeToRename, /*includeTrivia*/ true, function (original) {
                if (ts.isBindingElement(original) && ts.isIdentifier(original.name) && ts.isObjectBindingPattern(original.parent)) {
                    var symbol = checker.getSymbolAtLocation(original.name);
                    var renameInfo = symbol && identsToRenameMap.get(String(ts.getSymbolId(symbol)));
                    if (renameInfo && renameInfo.text !== (original.name || original.propertyName).getText()) {
                        return ts.factory.createBindingElement(original.dotDotDotToken, original.propertyName || original.name, renameInfo, original.initializer);
                    }
                }
                else if (ts.isIdentifier(original)) {
                    var symbol = checker.getSymbolAtLocation(original);
                    var renameInfo = symbol && identsToRenameMap.get(String(ts.getSymbolId(symbol)));
                    if (renameInfo) {
                        return ts.factory.createIdentifier(renameInfo.text);
                    }
                }
            });
        }
        function getNewNameIfConflict(name, originalNames) {
            var numVarsSameName = (originalNames.get(name.text) || ts.emptyArray).length;
            var identifier = numVarsSameName === 0 ? name : ts.factory.createIdentifier(name.text + "_" + numVarsSameName);
            return createSynthIdentifier(identifier);
        }
        function silentFail() {
            codeActionSucceeded = false;
            return ts.emptyArray;
        }
        // dispatch function to recursively build the refactoring
        // should be kept up to date with isFixablePromiseHandler in suggestionDiagnostics.ts
        function transformExpression(node, transformer, prevArgName) {
            if (isPromiseReturningCallExpression(node, transformer.checker, "then")) {
                if (node.arguments.length === 0)
                    return silentFail();
                return transformThen(node, transformer, prevArgName);
            }
            if (isPromiseReturningCallExpression(node, transformer.checker, "catch")) {
                return transformCatch(node, transformer, prevArgName);
            }
            if (ts.isPropertyAccessExpression(node)) {
                return transformExpression(node.expression, transformer, prevArgName);
            }
            var nodeType = transformer.checker.getTypeAtLocation(node);
            if (nodeType && transformer.checker.getPromisedTypeOfPromise(nodeType)) {
                ts.Debug.assertNode(node.original.parent, ts.isPropertyAccessExpression);
                return transformPromiseExpressionOfPropertyAccess(node, transformer, prevArgName);
            }
            return silentFail();
        }
        function transformCatch(node, transformer, prevArgName) {
            var func = ts.singleOrUndefined(node.arguments);
            var argName = func ? getArgBindingName(func, transformer) : undefined;
            var possibleNameForVarDecl;
            // If there is another call in the chain after the .catch() we are transforming, we will need to save the result of both paths (try block and catch block)
            // To do this, we will need to synthesize a variable that we were not aware of while we were adding identifiers to the synthNamesMap
            // We will use the prevArgName and then update the synthNamesMap with a new variable name for the next transformation step
            if (prevArgName && !shouldReturn(node, transformer)) {
                if (isSynthIdentifier(prevArgName)) {
                    possibleNameForVarDecl = prevArgName;
                    transformer.synthNamesMap.forEach(function (val, key) {
                        if (val.identifier.text === prevArgName.identifier.text) {
                            var newSynthName = createUniqueSynthName(prevArgName);
                            transformer.synthNamesMap.set(key, newSynthName);
                        }
                    });
                }
                else {
                    possibleNameForVarDecl = createSynthIdentifier(ts.factory.createUniqueName("result", 16 /* Optimistic */), prevArgName.types);
                }
                // We are about to write a 'let' variable declaration, but `transformExpression` for both
                // the try block and catch block will assign to this name. Setting this flag indicates
                // that future assignments should be written as `name = value` instead of `const name = value`.
                possibleNameForVarDecl.hasBeenDeclared = true;
            }
            var tryBlock = ts.factory.createBlock(transformExpression(node.expression, transformer, possibleNameForVarDecl));
            var transformationBody = func ? getTransformationBody(func, possibleNameForVarDecl, argName, node, transformer) : ts.emptyArray;
            var catchArg = argName ? isSynthIdentifier(argName) ? argName.identifier.text : argName.bindingPattern : "e";
            var catchVariableDeclaration = ts.factory.createVariableDeclaration(catchArg);
            var catchClause = ts.factory.createCatchClause(catchVariableDeclaration, ts.factory.createBlock(transformationBody));
            // In order to avoid an implicit any, we will synthesize a type for the declaration using the unions of the types of both paths (try block and catch block)
            var varDeclList;
            var varDeclIdentifier;
            if (possibleNameForVarDecl && !shouldReturn(node, transformer)) {
                varDeclIdentifier = ts.getSynthesizedDeepClone(possibleNameForVarDecl.identifier);
                var typeArray = possibleNameForVarDecl.types;
                var unionType = transformer.checker.getUnionType(typeArray, 2 /* Subtype */);
                var unionTypeNode = transformer.isInJSFile ? undefined : transformer.checker.typeToTypeNode(unionType, /*enclosingDeclaration*/ undefined, /*flags*/ undefined);
                var varDecl = [ts.factory.createVariableDeclaration(varDeclIdentifier, /*exclamationToken*/ undefined, unionTypeNode)];
                varDeclList = ts.factory.createVariableStatement(/*modifiers*/ undefined, ts.factory.createVariableDeclarationList(varDecl, 1 /* Let */));
            }
            var tryStatement = ts.factory.createTryStatement(tryBlock, catchClause, /*finallyBlock*/ undefined);
            var destructuredResult = prevArgName && varDeclIdentifier && isSynthBindingPattern(prevArgName)
                && ts.factory.createVariableStatement(/*modifiers*/ undefined, ts.factory.createVariableDeclarationList([ts.factory.createVariableDeclaration(ts.getSynthesizedDeepClone(prevArgName.bindingPattern), /*exclamationToken*/ undefined, /*type*/ undefined, varDeclIdentifier)], 2 /* Const */));
            return ts.compact([varDeclList, tryStatement, destructuredResult]);
        }
        function createUniqueSynthName(prevArgName) {
            var renamedPrevArg = ts.factory.createUniqueName(prevArgName.identifier.text, 16 /* Optimistic */);
            return createSynthIdentifier(renamedPrevArg);
        }
        function transformThen(node, transformer, prevArgName) {
            var _a = node.arguments, onFulfilled = _a[0], onRejected = _a[1];
            var onFulfilledArgumentName = getArgBindingName(onFulfilled, transformer);
            var transformationBody = getTransformationBody(onFulfilled, prevArgName, onFulfilledArgumentName, node, transformer);
            if (onRejected) {
                var onRejectedArgumentName = getArgBindingName(onRejected, transformer);
                var tryBlock = ts.factory.createBlock(transformExpression(node.expression, transformer, onFulfilledArgumentName).concat(transformationBody));
                var transformationBody2 = getTransformationBody(onRejected, prevArgName, onRejectedArgumentName, node, transformer);
                var catchArg = onRejectedArgumentName ? isSynthIdentifier(onRejectedArgumentName) ? onRejectedArgumentName.identifier.text : onRejectedArgumentName.bindingPattern : "e";
                var catchVariableDeclaration = ts.factory.createVariableDeclaration(catchArg);
                var catchClause = ts.factory.createCatchClause(catchVariableDeclaration, ts.factory.createBlock(transformationBody2));
                return [ts.factory.createTryStatement(tryBlock, catchClause, /* finallyBlock */ undefined)];
            }
            return transformExpression(node.expression, transformer, onFulfilledArgumentName).concat(transformationBody);
        }
        /**
         * Transforms the 'x' part of `x.then(...)`, or the 'y()' part of `y().catch(...)`, where 'x' and 'y()' are Promises.
         */
        function transformPromiseExpressionOfPropertyAccess(node, transformer, prevArgName) {
            if (shouldReturn(node, transformer)) {
                return [ts.factory.createReturnStatement(ts.getSynthesizedDeepClone(node))];
            }
            return createVariableOrAssignmentOrExpressionStatement(prevArgName, ts.factory.createAwaitExpression(node), /*typeAnnotation*/ undefined);
        }
        function createVariableOrAssignmentOrExpressionStatement(variableName, rightHandSide, typeAnnotation) {
            if (!variableName || isEmptyBindingName(variableName)) {
                // if there's no argName to assign to, there still might be side effects
                return [ts.factory.createExpressionStatement(rightHandSide)];
            }
            if (isSynthIdentifier(variableName) && variableName.hasBeenDeclared) {
                // if the variable has already been declared, we don't need "let" or "const"
                return [ts.factory.createExpressionStatement(ts.factory.createAssignment(ts.getSynthesizedDeepClone(variableName.identifier), rightHandSide))];
            }
            return [
                ts.factory.createVariableStatement(
                /*modifiers*/ undefined, ts.factory.createVariableDeclarationList([
                    ts.factory.createVariableDeclaration(ts.getSynthesizedDeepClone(getNode(variableName)), 
                    /*exclamationToken*/ undefined, typeAnnotation, rightHandSide)
                ], 2 /* Const */))
            ];
        }
        function maybeAnnotateAndReturn(expressionToReturn, typeAnnotation) {
            if (typeAnnotation && expressionToReturn) {
                var name = ts.factory.createUniqueName("result", 16 /* Optimistic */);
                return __spreadArray(__spreadArray([], createVariableOrAssignmentOrExpressionStatement(createSynthIdentifier(name), expressionToReturn, typeAnnotation), true), [
                    ts.factory.createReturnStatement(name)
                ], false);
            }
            return [ts.factory.createReturnStatement(expressionToReturn)];
        }
        // should be kept up to date with isFixablePromiseArgument in suggestionDiagnostics.ts
        function getTransformationBody(func, prevArgName, argName, parent, transformer) {
            var _a, _b, _c, _d, _e;
            switch (func.kind) {
                case 104 /* NullKeyword */:
                    // do not produce a transformed statement for a null argument
                    break;
                case 204 /* PropertyAccessExpression */:
                case 79 /* Identifier */: // identifier includes undefined
                    if (!argName) {
                        // undefined was argument passed to promise handler
                        break;
                    }
                    var synthCall = ts.factory.createCallExpression(ts.getSynthesizedDeepClone(func), /*typeArguments*/ undefined, isSynthIdentifier(argName) ? [argName.identifier] : []);
                    if (shouldReturn(parent, transformer)) {
                        return maybeAnnotateAndReturn(synthCall, (_a = parent.typeArguments) === null || _a === void 0 ? void 0 : _a[0]);
                    }
                    var type = transformer.checker.getTypeAtLocation(func);
                    var callSignatures = transformer.checker.getSignaturesOfType(type, 0 /* Call */);
                    if (!callSignatures.length) {
                        // if identifier in handler has no call signatures, it's invalid
                        return silentFail();
                    }
                    var returnType = callSignatures[0].getReturnType();
                    var varDeclOrAssignment = createVariableOrAssignmentOrExpressionStatement(prevArgName, ts.factory.createAwaitExpression(synthCall), (_b = parent.typeArguments) === null || _b === void 0 ? void 0 : _b[0]);
                    if (prevArgName) {
                        prevArgName.types.push(returnType);
                    }
                    return varDeclOrAssignment;
                case 211 /* FunctionExpression */:
                case 212 /* ArrowFunction */: {
                    var funcBody = func.body;
                    var returnType_1 = (_c = getLastCallSignature(transformer.checker.getTypeAtLocation(func), transformer.checker)) === null || _c === void 0 ? void 0 : _c.getReturnType();
                    // Arrow functions with block bodies { } will enter this control flow
                    if (ts.isBlock(funcBody)) {
                        var refactoredStmts = [];
                        var seenReturnStatement = false;
                        for (var _i = 0, _f = funcBody.statements; _i < _f.length; _i++) {
                            var statement = _f[_i];
                            if (ts.isReturnStatement(statement)) {
                                seenReturnStatement = true;
                                if (ts.isReturnStatementWithFixablePromiseHandler(statement, transformer.checker)) {
                                    refactoredStmts = refactoredStmts.concat(getInnerTransformationBody(transformer, [statement], prevArgName));
                                }
                                else {
                                    var possiblyAwaitedRightHandSide = returnType_1 && statement.expression ? getPossiblyAwaitedRightHandSide(transformer.checker, returnType_1, statement.expression) : statement.expression;
                                    refactoredStmts.push.apply(refactoredStmts, maybeAnnotateAndReturn(possiblyAwaitedRightHandSide, (_d = parent.typeArguments) === null || _d === void 0 ? void 0 : _d[0]));
                                }
                            }
                            else {
                                refactoredStmts.push(statement);
                            }
                        }
                        return shouldReturn(parent, transformer)
                            ? refactoredStmts.map(function (s) { return ts.getSynthesizedDeepClone(s); })
                            : removeReturns(refactoredStmts, prevArgName, transformer, seenReturnStatement);
                    }
                    else {
                        var innerRetStmts = ts.isFixablePromiseHandler(funcBody, transformer.checker) ? [ts.factory.createReturnStatement(funcBody)] : ts.emptyArray;
                        var innerCbBody = getInnerTransformationBody(transformer, innerRetStmts, prevArgName);
                        if (innerCbBody.length > 0) {
                            return innerCbBody;
                        }
                        if (returnType_1) {
                            var possiblyAwaitedRightHandSide = getPossiblyAwaitedRightHandSide(transformer.checker, returnType_1, funcBody);
                            if (!shouldReturn(parent, transformer)) {
                                var transformedStatement = createVariableOrAssignmentOrExpressionStatement(prevArgName, possiblyAwaitedRightHandSide, /*typeAnnotation*/ undefined);
                                if (prevArgName) {
                                    prevArgName.types.push(returnType_1);
                                }
                                return transformedStatement;
                            }
                            else {
                                return maybeAnnotateAndReturn(possiblyAwaitedRightHandSide, (_e = parent.typeArguments) === null || _e === void 0 ? void 0 : _e[0]);
                            }
                        }
                        else {
                            return silentFail();
                        }
                    }
                }
                default:
                    // If no cases apply, we've found a transformation body we don't know how to handle, so the refactoring should no-op to avoid deleting code.
                    return silentFail();
            }
            return ts.emptyArray;
        }
        function getPossiblyAwaitedRightHandSide(checker, type, expr) {
            var rightHandSide = ts.getSynthesizedDeepClone(expr);
            return !!checker.getPromisedTypeOfPromise(type) ? ts.factory.createAwaitExpression(rightHandSide) : rightHandSide;
        }
        function getLastCallSignature(type, checker) {
            var callSignatures = checker.getSignaturesOfType(type, 0 /* Call */);
            return ts.lastOrUndefined(callSignatures);
        }
        function removeReturns(stmts, prevArgName, transformer, seenReturnStatement) {
            var ret = [];
            for (var _i = 0, stmts_1 = stmts; _i < stmts_1.length; _i++) {
                var stmt = stmts_1[_i];
                if (ts.isReturnStatement(stmt)) {
                    if (stmt.expression) {
                        var possiblyAwaitedExpression = isPromiseTypedExpression(stmt.expression, transformer.checker) ? ts.factory.createAwaitExpression(stmt.expression) : stmt.expression;
                        if (prevArgName === undefined) {
                            ret.push(ts.factory.createExpressionStatement(possiblyAwaitedExpression));
                        }
                        else {
                            ret.push(ts.factory.createVariableStatement(/*modifiers*/ undefined, (ts.factory.createVariableDeclarationList([ts.factory.createVariableDeclaration(getNode(prevArgName), /*exclamationToken*/ undefined, /*type*/ undefined, possiblyAwaitedExpression)], 2 /* Const */))));
                        }
                    }
                }
                else {
                    ret.push(ts.getSynthesizedDeepClone(stmt));
                }
            }
            // if block has no return statement, need to define prevArgName as undefined to prevent undeclared variables
            if (!seenReturnStatement && prevArgName !== undefined) {
                ret.push(ts.factory.createVariableStatement(/*modifiers*/ undefined, (ts.factory.createVariableDeclarationList([ts.factory.createVariableDeclaration(getNode(prevArgName), /*exclamationToken*/ undefined, /*type*/ undefined, ts.factory.createIdentifier("undefined"))], 2 /* Const */))));
            }
            return ret;
        }
        function getInnerTransformationBody(transformer, innerRetStmts, prevArgName) {
            var innerCbBody = [];
            for (var _i = 0, innerRetStmts_1 = innerRetStmts; _i < innerRetStmts_1.length; _i++) {
                var stmt = innerRetStmts_1[_i];
                ts.forEachChild(stmt, function visit(node) {
                    if (ts.isCallExpression(node)) {
                        var temp = transformExpression(node, transformer, prevArgName);
                        innerCbBody = innerCbBody.concat(temp);
                        if (innerCbBody.length > 0) {
                            return;
                        }
                    }
                    else if (!ts.isFunctionLike(node)) {
                        ts.forEachChild(node, visit);
                    }
                });
            }
            return innerCbBody;
        }
        function getArgBindingName(funcNode, transformer) {
            var types = [];
            var name;
            if (ts.isFunctionLikeDeclaration(funcNode)) {
                if (funcNode.parameters.length > 0) {
                    var param = funcNode.parameters[0].name;
                    name = getMappedBindingNameOrDefault(param);
                }
            }
            else if (ts.isIdentifier(funcNode)) {
                name = getMapEntryOrDefault(funcNode);
            }
            else if (ts.isPropertyAccessExpression(funcNode) && ts.isIdentifier(funcNode.name)) {
                name = getMapEntryOrDefault(funcNode.name);
            }
            // return undefined argName when arg is null or undefined
            // eslint-disable-next-line no-in-operator
            if (!name || "identifier" in name && name.identifier.text === "undefined") {
                return undefined;
            }
            return name;
            function getMappedBindingNameOrDefault(bindingName) {
                if (ts.isIdentifier(bindingName))
                    return getMapEntryOrDefault(bindingName);
                var elements = ts.flatMap(bindingName.elements, function (element) {
                    if (ts.isOmittedExpression(element))
                        return [];
                    return [getMappedBindingNameOrDefault(element.name)];
                });
                return createSynthBindingPattern(bindingName, elements);
            }
            function getMapEntryOrDefault(identifier) {
                var originalNode = getOriginalNode(identifier);
                var symbol = getSymbol(originalNode);
                if (!symbol) {
                    return createSynthIdentifier(identifier, types);
                }
                var mapEntry = transformer.synthNamesMap.get(ts.getSymbolId(symbol).toString());
                return mapEntry || createSynthIdentifier(identifier, types);
            }
            function getSymbol(node) {
                return node.symbol ? node.symbol : transformer.checker.getSymbolAtLocation(node);
            }
            function getOriginalNode(node) {
                return node.original ? node.original : node;
            }
        }
        function isEmptyBindingName(bindingName) {
            if (!bindingName) {
                return true;
            }
            if (isSynthIdentifier(bindingName)) {
                return !bindingName.identifier.text;
            }
            return ts.every(bindingName.elements, isEmptyBindingName);
        }
        function getNode(bindingName) {
            return isSynthIdentifier(bindingName) ? bindingName.identifier : bindingName.bindingPattern;
        }
        function createSynthIdentifier(identifier, types) {
            if (types === void 0) { types = []; }
            return { kind: 0 /* Identifier */, identifier: identifier, types: types, hasBeenDeclared: false };
        }
        function createSynthBindingPattern(bindingPattern, elements, types) {
            if (elements === void 0) { elements = ts.emptyArray; }
            if (types === void 0) { types = []; }
            return { kind: 1 /* BindingPattern */, bindingPattern: bindingPattern, elements: elements, types: types };
        }
        function isSynthIdentifier(bindingName) {
            return bindingName.kind === 0 /* Identifier */;
        }
        function isSynthBindingPattern(bindingName) {
            return bindingName.kind === 1 /* BindingPattern */;
        }
        function shouldReturn(expression, transformer) {
            return !!expression.original && transformer.setOfExpressionsToReturn.has(ts.getNodeId(expression.original));
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        codefix.registerCodeFix({
            errorCodes: [ts.Diagnostics.File_is_a_CommonJS_module_it_may_be_converted_to_an_ES6_module.code],
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, program = context.program, preferences = context.preferences;
                var changes = ts.textChanges.ChangeTracker.with(context, function (changes) {
                    var moduleExportsChangedToDefault = convertFileToEs6Module(sourceFile, program.getTypeChecker(), changes, program.getCompilerOptions().target, ts.getQuotePreference(sourceFile, preferences));
                    if (moduleExportsChangedToDefault) {
                        for (var _i = 0, _a = program.getSourceFiles(); _i < _a.length; _i++) {
                            var importingFile = _a[_i];
                            fixImportOfModuleExports(importingFile, sourceFile, changes, ts.getQuotePreference(importingFile, preferences));
                        }
                    }
                });
                // No support for fix-all since this applies to the whole file at once anyway.
                return [codefix.createCodeFixActionWithoutFixAll("convertToEs6Module", changes, ts.Diagnostics.Convert_to_ES6_module)];
            },
        });
        function fixImportOfModuleExports(importingFile, exportingFile, changes, quotePreference) {
            for (var _i = 0, _a = importingFile.imports; _i < _a.length; _i++) {
                var moduleSpecifier = _a[_i];
                var imported = ts.getResolvedModule(importingFile, moduleSpecifier.text);
                if (!imported || imported.resolvedFileName !== exportingFile.fileName) {
                    continue;
                }
                var importNode = ts.importFromModuleSpecifier(moduleSpecifier);
                switch (importNode.kind) {
                    case 263 /* ImportEqualsDeclaration */:
                        changes.replaceNode(importingFile, importNode, ts.makeImport(importNode.name, /*namedImports*/ undefined, moduleSpecifier, quotePreference));
                        break;
                    case 206 /* CallExpression */:
                        if (ts.isRequireCall(importNode, /*checkArgumentIsStringLiteralLike*/ false)) {
                            changes.replaceNode(importingFile, importNode, ts.factory.createPropertyAccessExpression(ts.getSynthesizedDeepClone(importNode), "default"));
                        }
                        break;
                }
            }
        }
        /** @returns Whether we converted a `module.exports =` to a default export. */
        function convertFileToEs6Module(sourceFile, checker, changes, target, quotePreference) {
            var identifiers = { original: collectFreeIdentifiers(sourceFile), additional: new ts.Set() };
            var exports = collectExportRenames(sourceFile, checker, identifiers);
            convertExportsAccesses(sourceFile, exports, changes);
            var moduleExportsChangedToDefault = false;
            var useSitesToUnqualify;
            // Process variable statements first to collect use sites that need to be updated inside other transformations
            for (var _i = 0, _a = ts.filter(sourceFile.statements, ts.isVariableStatement); _i < _a.length; _i++) {
                var statement = _a[_i];
                var newUseSites = convertVariableStatement(sourceFile, statement, changes, checker, identifiers, target, quotePreference);
                if (newUseSites) {
                    ts.copyEntries(newUseSites, useSitesToUnqualify !== null && useSitesToUnqualify !== void 0 ? useSitesToUnqualify : (useSitesToUnqualify = new ts.Map()));
                }
            }
            // `convertStatement` will delete entries from `useSitesToUnqualify` when containing statements are replaced
            for (var _b = 0, _c = ts.filter(sourceFile.statements, function (s) { return !ts.isVariableStatement(s); }); _b < _c.length; _b++) {
                var statement = _c[_b];
                var moduleExportsChanged = convertStatement(sourceFile, statement, checker, changes, identifiers, target, exports, useSitesToUnqualify, quotePreference);
                moduleExportsChangedToDefault = moduleExportsChangedToDefault || moduleExportsChanged;
            }
            // Remaining use sites can be changed directly
            useSitesToUnqualify === null || useSitesToUnqualify === void 0 ? void 0 : useSitesToUnqualify.forEach(function (replacement, original) {
                changes.replaceNode(sourceFile, original, replacement);
            });
            return moduleExportsChangedToDefault;
        }
        function collectExportRenames(sourceFile, checker, identifiers) {
            var res = new ts.Map();
            forEachExportReference(sourceFile, function (node) {
                var _a = node.name, text = _a.text, originalKeywordKind = _a.originalKeywordKind;
                if (!res.has(text) && (originalKeywordKind !== undefined && ts.isNonContextualKeyword(originalKeywordKind)
                    || checker.resolveName(text, node, 111551 /* Value */, /*excludeGlobals*/ true))) {
                    // Unconditionally add an underscore in case `text` is a keyword.
                    res.set(text, makeUniqueName("_" + text, identifiers));
                }
            });
            return res;
        }
        function convertExportsAccesses(sourceFile, exports, changes) {
            forEachExportReference(sourceFile, function (node, isAssignmentLhs) {
                if (isAssignmentLhs) {
                    return;
                }
                var text = node.name.text;
                changes.replaceNode(sourceFile, node, ts.factory.createIdentifier(exports.get(text) || text));
            });
        }
        function forEachExportReference(sourceFile, cb) {
            sourceFile.forEachChild(function recur(node) {
                if (ts.isPropertyAccessExpression(node) && ts.isExportsOrModuleExportsOrAlias(sourceFile, node.expression) && ts.isIdentifier(node.name)) {
                    var parent = node.parent;
                    cb(node, ts.isBinaryExpression(parent) && parent.left === node && parent.operatorToken.kind === 63 /* EqualsToken */);
                }
                node.forEachChild(recur);
            });
        }
        function convertStatement(sourceFile, statement, checker, changes, identifiers, target, exports, useSitesToUnqualify, quotePreference) {
            switch (statement.kind) {
                case 235 /* VariableStatement */:
                    convertVariableStatement(sourceFile, statement, changes, checker, identifiers, target, quotePreference);
                    return false;
                case 236 /* ExpressionStatement */: {
                    var expression = statement.expression;
                    switch (expression.kind) {
                        case 206 /* CallExpression */: {
                            if (ts.isRequireCall(expression, /*checkArgumentIsStringLiteralLike*/ true)) {
                                // For side-effecting require() call, just make a side-effecting import.
                                changes.replaceNode(sourceFile, statement, ts.makeImport(/*name*/ undefined, /*namedImports*/ undefined, expression.arguments[0], quotePreference));
                            }
                            return false;
                        }
                        case 219 /* BinaryExpression */: {
                            var operatorToken = expression.operatorToken;
                            return operatorToken.kind === 63 /* EqualsToken */ && convertAssignment(sourceFile, checker, expression, changes, exports, useSitesToUnqualify);
                        }
                    }
                }
                // falls through
                default:
                    return false;
            }
        }
        function convertVariableStatement(sourceFile, statement, changes, checker, identifiers, target, quotePreference) {
            var declarationList = statement.declarationList;
            var foundImport = false;
            var converted = ts.map(declarationList.declarations, function (decl) {
                var name = decl.name, initializer = decl.initializer;
                if (initializer) {
                    if (ts.isExportsOrModuleExportsOrAlias(sourceFile, initializer)) {
                        // `const alias = module.exports;` can be removed.
                        foundImport = true;
                        return convertedImports([]);
                    }
                    else if (ts.isRequireCall(initializer, /*checkArgumentIsStringLiteralLike*/ true)) {
                        foundImport = true;
                        return convertSingleImport(name, initializer.arguments[0], checker, identifiers, target, quotePreference);
                    }
                    else if (ts.isPropertyAccessExpression(initializer) && ts.isRequireCall(initializer.expression, /*checkArgumentIsStringLiteralLike*/ true)) {
                        foundImport = true;
                        return convertPropertyAccessImport(name, initializer.name.text, initializer.expression.arguments[0], identifiers, quotePreference);
                    }
                }
                // Move it out to its own variable statement. (This will not be used if `!foundImport`)
                return convertedImports([ts.factory.createVariableStatement(/*modifiers*/ undefined, ts.factory.createVariableDeclarationList([decl], declarationList.flags))]);
            });
            if (foundImport) {
                // useNonAdjustedEndPosition to ensure we don't eat the newline after the statement.
                changes.replaceNodeWithNodes(sourceFile, statement, ts.flatMap(converted, function (c) { return c.newImports; }));
                var combinedUseSites_1;
                ts.forEach(converted, function (c) {
                    if (c.useSitesToUnqualify) {
                        ts.copyEntries(c.useSitesToUnqualify, combinedUseSites_1 !== null && combinedUseSites_1 !== void 0 ? combinedUseSites_1 : (combinedUseSites_1 = new ts.Map()));
                    }
                });
                return combinedUseSites_1;
            }
        }
        /** Converts `const name = require("moduleSpecifier").propertyName` */
        function convertPropertyAccessImport(name, propertyName, moduleSpecifier, identifiers, quotePreference) {
            switch (name.kind) {
                case 199 /* ObjectBindingPattern */:
                case 200 /* ArrayBindingPattern */: {
                    // `const [a, b] = require("c").d` --> `import { d } from "c"; const [a, b] = d;`
                    var tmp = makeUniqueName(propertyName, identifiers);
                    return convertedImports([
                        makeSingleImport(tmp, propertyName, moduleSpecifier, quotePreference),
                        makeConst(/*modifiers*/ undefined, name, ts.factory.createIdentifier(tmp)),
                    ]);
                }
                case 79 /* Identifier */:
                    // `const a = require("b").c` --> `import { c as a } from "./b";
                    return convertedImports([makeSingleImport(name.text, propertyName, moduleSpecifier, quotePreference)]);
                default:
                    return ts.Debug.assertNever(name, "Convert to ES6 module got invalid syntax form " + name.kind);
            }
        }
        function convertAssignment(sourceFile, checker, assignment, changes, exports, useSitesToUnqualify) {
            var left = assignment.left, right = assignment.right;
            if (!ts.isPropertyAccessExpression(left)) {
                return false;
            }
            if (ts.isExportsOrModuleExportsOrAlias(sourceFile, left)) {
                if (ts.isExportsOrModuleExportsOrAlias(sourceFile, right)) {
                    // `const alias = module.exports;` or `module.exports = alias;` can be removed.
                    changes.delete(sourceFile, assignment.parent);
                }
                else {
                    var replacement = ts.isObjectLiteralExpression(right) ? tryChangeModuleExportsObject(right, useSitesToUnqualify)
                        : ts.isRequireCall(right, /*checkArgumentIsStringLiteralLike*/ true) ? convertReExportAll(right.arguments[0], checker)
                            : undefined;
                    if (replacement) {
                        changes.replaceNodeWithNodes(sourceFile, assignment.parent, replacement[0]);
                        return replacement[1];
                    }
                    else {
                        changes.replaceRangeWithText(sourceFile, ts.createRange(left.getStart(sourceFile), right.pos), "export default");
                        return true;
                    }
                }
            }
            else if (ts.isExportsOrModuleExportsOrAlias(sourceFile, left.expression)) {
                convertNamedExport(sourceFile, assignment, changes, exports);
            }
            return false;
        }
        /**
         * Convert `module.exports = { ... }` to individual exports..
         * We can't always do this if the module has interesting members -- then it will be a default export instead.
         */
        function tryChangeModuleExportsObject(object, useSitesToUnqualify) {
            var statements = ts.mapAllOrFail(object.properties, function (prop) {
                switch (prop.kind) {
                    case 170 /* GetAccessor */:
                    case 171 /* SetAccessor */:
                    // TODO: Maybe we should handle this? See fourslash test `refactorConvertToEs6Module_export_object_shorthand.ts`.
                    // falls through
                    case 292 /* ShorthandPropertyAssignment */:
                    case 293 /* SpreadAssignment */:
                        return undefined;
                    case 291 /* PropertyAssignment */:
                        return !ts.isIdentifier(prop.name) ? undefined : convertExportsDotXEquals_replaceNode(prop.name.text, prop.initializer, useSitesToUnqualify);
                    case 167 /* MethodDeclaration */:
                        return !ts.isIdentifier(prop.name) ? undefined : functionExpressionToDeclaration(prop.name.text, [ts.factory.createToken(93 /* ExportKeyword */)], prop, useSitesToUnqualify);
                    default:
                        ts.Debug.assertNever(prop, "Convert to ES6 got invalid prop kind " + prop.kind);
                }
            });
            return statements && [statements, false];
        }
        function convertNamedExport(sourceFile, assignment, changes, exports) {
            // If "originalKeywordKind" was set, this is e.g. `exports.
            var text = assignment.left.name.text;
            var rename = exports.get(text);
            if (rename !== undefined) {
                /*
                const _class = 0;
                export { _class as class };
                */
                var newNodes = [
                    makeConst(/*modifiers*/ undefined, rename, assignment.right),
                    makeExportDeclaration([ts.factory.createExportSpecifier(rename, text)]),
                ];
                changes.replaceNodeWithNodes(sourceFile, assignment.parent, newNodes);
            }
            else {
                convertExportsPropertyAssignment(assignment, sourceFile, changes);
            }
        }
        function convertReExportAll(reExported, checker) {
            // `module.exports = require("x");` ==> `export * from "x"; export { default } from "x";`
            var moduleSpecifier = reExported.text;
            var moduleSymbol = checker.getSymbolAtLocation(reExported);
            var exports = moduleSymbol ? moduleSymbol.exports : ts.emptyMap;
            return exports.has("export=" /* ExportEquals */) ? [[reExportDefault(moduleSpecifier)], true] :
                !exports.has("default" /* Default */) ? [[reExportStar(moduleSpecifier)], false] :
                    // If there's some non-default export, must include both `export *` and `export default`.
                    exports.size > 1 ? [[reExportStar(moduleSpecifier), reExportDefault(moduleSpecifier)], true] : [[reExportDefault(moduleSpecifier)], true];
        }
        function reExportStar(moduleSpecifier) {
            return makeExportDeclaration(/*exportClause*/ undefined, moduleSpecifier);
        }
        function reExportDefault(moduleSpecifier) {
            return makeExportDeclaration([ts.factory.createExportSpecifier(/*propertyName*/ undefined, "default")], moduleSpecifier);
        }
        function convertExportsPropertyAssignment(_a, sourceFile, changes) {
            var left = _a.left, right = _a.right, parent = _a.parent;
            var name = left.name.text;
            if ((ts.isFunctionExpression(right) || ts.isArrowFunction(right) || ts.isClassExpression(right)) && (!right.name || right.name.text === name)) {
                // `exports.f = function() {}` -> `export function f() {}` -- Replace `exports.f = ` with `export `, and insert the name after `function`.
                changes.replaceRange(sourceFile, { pos: left.getStart(sourceFile), end: right.getStart(sourceFile) }, ts.factory.createToken(93 /* ExportKeyword */), { suffix: " " });
                if (!right.name)
                    changes.insertName(sourceFile, right, name);
                var semi = ts.findChildOfKind(parent, 26 /* SemicolonToken */, sourceFile);
                if (semi)
                    changes.delete(sourceFile, semi);
            }
            else {
                // `exports.f = function g() {}` -> `export const f = function g() {}` -- just replace `exports.` with `export const `
                changes.replaceNodeRangeWithNodes(sourceFile, left.expression, ts.findChildOfKind(left, 24 /* DotToken */, sourceFile), [ts.factory.createToken(93 /* ExportKeyword */), ts.factory.createToken(85 /* ConstKeyword */)], { joiner: " ", suffix: " " });
            }
        }
        // TODO: GH#22492 this will cause an error if a change has been made inside the body of the node.
        function convertExportsDotXEquals_replaceNode(name, exported, useSitesToUnqualify) {
            var modifiers = [ts.factory.createToken(93 /* ExportKeyword */)];
            switch (exported.kind) {
                case 211 /* FunctionExpression */: {
                    var expressionName = exported.name;
                    if (expressionName && expressionName.text !== name) {
                        // `exports.f = function g() {}` -> `export const f = function g() {}`
                        return exportConst();
                    }
                }
                // falls through
                case 212 /* ArrowFunction */:
                    // `exports.f = function() {}` --> `export function f() {}`
                    return functionExpressionToDeclaration(name, modifiers, exported, useSitesToUnqualify);
                case 224 /* ClassExpression */:
                    // `exports.C = class {}` --> `export class C {}`
                    return classExpressionToDeclaration(name, modifiers, exported, useSitesToUnqualify);
                default:
                    return exportConst();
            }
            function exportConst() {
                // `exports.x = 0;` --> `export const x = 0;`
                return makeConst(modifiers, ts.factory.createIdentifier(name), replaceImportUseSites(exported, useSitesToUnqualify)); // TODO: GH#18217
            }
        }
        function replaceImportUseSites(nodeOrNodes, useSitesToUnqualify) {
            if (!useSitesToUnqualify || !ts.some(ts.arrayFrom(useSitesToUnqualify.keys()), function (original) { return ts.rangeContainsRange(nodeOrNodes, original); })) {
                return nodeOrNodes;
            }
            return ts.isArray(nodeOrNodes)
                ? ts.getSynthesizedDeepClonesWithReplacements(nodeOrNodes, /*includeTrivia*/ true, replaceNode)
                : ts.getSynthesizedDeepCloneWithReplacements(nodeOrNodes, /*includeTrivia*/ true, replaceNode);
            function replaceNode(original) {
                // We are replacing `mod.SomeExport` wih `SomeExport`, so we only need to look at PropertyAccessExpressions
                if (original.kind === 204 /* PropertyAccessExpression */) {
                    var replacement = useSitesToUnqualify.get(original);
                    // Remove entry from `useSitesToUnqualify` so the refactor knows it's taken care of by the parent statement we're replacing
                    useSitesToUnqualify.delete(original);
                    return replacement;
                }
            }
        }
        /**
         * Converts `const <<name>> = require("x");`.
         * Returns nodes that will replace the variable declaration for the commonjs import.
         * May also make use `changes` to remove qualifiers at the use sites of imports, to change `mod.x` to `x`.
         */
        function convertSingleImport(name, moduleSpecifier, checker, identifiers, target, quotePreference) {
            switch (name.kind) {
                case 199 /* ObjectBindingPattern */: {
                    var importSpecifiers = ts.mapAllOrFail(name.elements, function (e) {
                        return e.dotDotDotToken || e.initializer || e.propertyName && !ts.isIdentifier(e.propertyName) || !ts.isIdentifier(e.name)
                            ? undefined
                            // (TODO: GH#18217)
                            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                            : makeImportSpecifier(e.propertyName && e.propertyName.text, e.name.text);
                    });
                    if (importSpecifiers) {
                        return convertedImports([ts.makeImport(/*name*/ undefined, importSpecifiers, moduleSpecifier, quotePreference)]);
                    }
                }
                // falls through -- object destructuring has an interesting pattern and must be a variable declaration
                case 200 /* ArrayBindingPattern */: {
                    /*
                    import x from "x";
                    const [a, b, c] = x;
                    */
                    var tmp = makeUniqueName(codefix.moduleSpecifierToValidIdentifier(moduleSpecifier.text, target), identifiers);
                    return convertedImports([
                        ts.makeImport(ts.factory.createIdentifier(tmp), /*namedImports*/ undefined, moduleSpecifier, quotePreference),
                        makeConst(/*modifiers*/ undefined, ts.getSynthesizedDeepClone(name), ts.factory.createIdentifier(tmp)),
                    ]);
                }
                case 79 /* Identifier */:
                    return convertSingleIdentifierImport(name, moduleSpecifier, checker, identifiers, quotePreference);
                default:
                    return ts.Debug.assertNever(name, "Convert to ES6 module got invalid name kind " + name.kind);
            }
        }
        /**
         * Convert `import x = require("x").`
         * Also:
         * - Convert `x.default()` to `x()` to handle ES6 default export
         * - Converts uses like `x.y()` to `y()` and uses a named import.
         */
        function convertSingleIdentifierImport(name, moduleSpecifier, checker, identifiers, quotePreference) {
            var nameSymbol = checker.getSymbolAtLocation(name);
            // Maps from module property name to name actually used. (The same if there isn't shadowing.)
            var namedBindingsNames = new ts.Map();
            // True if there is some non-property use like `x()` or `f(x)`.
            var needDefaultImport = false;
            var useSitesToUnqualify;
            for (var _i = 0, _a = identifiers.original.get(name.text); _i < _a.length; _i++) {
                var use = _a[_i];
                if (checker.getSymbolAtLocation(use) !== nameSymbol || use === name) {
                    // This was a use of a different symbol with the same name, due to shadowing. Ignore.
                    continue;
                }
                var parent = use.parent;
                if (ts.isPropertyAccessExpression(parent)) {
                    var propertyName = parent.name.text;
                    if (propertyName === "default") {
                        needDefaultImport = true;
                        var importDefaultName = use.getText();
                        (useSitesToUnqualify !== null && useSitesToUnqualify !== void 0 ? useSitesToUnqualify : (useSitesToUnqualify = new ts.Map())).set(parent, ts.factory.createIdentifier(importDefaultName));
                    }
                    else {
                        ts.Debug.assert(parent.expression === use, "Didn't expect expression === use"); // Else shouldn't have been in `collectIdentifiers`
                        var idName = namedBindingsNames.get(propertyName);
                        if (idName === undefined) {
                            idName = makeUniqueName(propertyName, identifiers);
                            namedBindingsNames.set(propertyName, idName);
                        }
                        (useSitesToUnqualify !== null && useSitesToUnqualify !== void 0 ? useSitesToUnqualify : (useSitesToUnqualify = new ts.Map())).set(parent, ts.factory.createIdentifier(idName));
                    }
                }
                else {
                    needDefaultImport = true;
                }
            }
            var namedBindings = namedBindingsNames.size === 0 ? undefined : ts.arrayFrom(ts.mapIterator(namedBindingsNames.entries(), function (_a) {
                var propertyName = _a[0], idName = _a[1];
                return ts.factory.createImportSpecifier(propertyName === idName ? undefined : ts.factory.createIdentifier(propertyName), ts.factory.createIdentifier(idName));
            }));
            if (!namedBindings) {
                // If it was unused, ensure that we at least import *something*.
                needDefaultImport = true;
            }
            return convertedImports([ts.makeImport(needDefaultImport ? ts.getSynthesizedDeepClone(name) : undefined, namedBindings, moduleSpecifier, quotePreference)], useSitesToUnqualify);
        }
        // Identifiers helpers
        function makeUniqueName(name, identifiers) {
            while (identifiers.original.has(name) || identifiers.additional.has(name)) {
                name = "_" + name;
            }
            identifiers.additional.add(name);
            return name;
        }
        function collectFreeIdentifiers(file) {
            var map = ts.createMultiMap();
            forEachFreeIdentifier(file, function (id) { return map.add(id.text, id); });
            return map;
        }
        /**
         * A free identifier is an identifier that can be accessed through name lookup as a local variable.
         * In the expression `x.y`, `x` is a free identifier, but `y` is not.
         */
        function forEachFreeIdentifier(node, cb) {
            if (ts.isIdentifier(node) && isFreeIdentifier(node))
                cb(node);
            node.forEachChild(function (child) { return forEachFreeIdentifier(child, cb); });
        }
        function isFreeIdentifier(node) {
            var parent = node.parent;
            switch (parent.kind) {
                case 204 /* PropertyAccessExpression */:
                    return parent.name !== node;
                case 201 /* BindingElement */:
                    return parent.propertyName !== node;
                case 268 /* ImportSpecifier */:
                    return parent.propertyName !== node;
                default:
                    return true;
            }
        }
        // Node helpers
        function functionExpressionToDeclaration(name, additionalModifiers, fn, useSitesToUnqualify) {
            return ts.factory.createFunctionDeclaration(ts.getSynthesizedDeepClones(fn.decorators), // TODO: GH#19915 Don't think this is even legal.
            ts.concatenate(additionalModifiers, ts.getSynthesizedDeepClones(fn.modifiers)), ts.getSynthesizedDeepClone(fn.asteriskToken), name, ts.getSynthesizedDeepClones(fn.typeParameters), ts.getSynthesizedDeepClones(fn.parameters), ts.getSynthesizedDeepClone(fn.type), ts.factory.converters.convertToFunctionBlock(replaceImportUseSites(fn.body, useSitesToUnqualify)));
        }
        function classExpressionToDeclaration(name, additionalModifiers, cls, useSitesToUnqualify) {
            return ts.factory.createClassDeclaration(ts.getSynthesizedDeepClones(cls.decorators), // TODO: GH#19915 Don't think this is even legal.
            ts.concatenate(additionalModifiers, ts.getSynthesizedDeepClones(cls.modifiers)), name, ts.getSynthesizedDeepClones(cls.typeParameters), ts.getSynthesizedDeepClones(cls.heritageClauses), replaceImportUseSites(cls.members, useSitesToUnqualify));
        }
        function makeSingleImport(localName, propertyName, moduleSpecifier, quotePreference) {
            return propertyName === "default"
                ? ts.makeImport(ts.factory.createIdentifier(localName), /*namedImports*/ undefined, moduleSpecifier, quotePreference)
                : ts.makeImport(/*name*/ undefined, [makeImportSpecifier(propertyName, localName)], moduleSpecifier, quotePreference);
        }
        function makeImportSpecifier(propertyName, name) {
            return ts.factory.createImportSpecifier(propertyName !== undefined && propertyName !== name ? ts.factory.createIdentifier(propertyName) : undefined, ts.factory.createIdentifier(name));
        }
        function makeConst(modifiers, name, init) {
            return ts.factory.createVariableStatement(modifiers, ts.factory.createVariableDeclarationList([ts.factory.createVariableDeclaration(name, /*exclamationToken*/ undefined, /*type*/ undefined, init)], 2 /* Const */));
        }
        function makeExportDeclaration(exportSpecifiers, moduleSpecifier) {
            return ts.factory.createExportDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*isTypeOnly*/ false, exportSpecifiers && ts.factory.createNamedExports(exportSpecifiers), moduleSpecifier === undefined ? undefined : ts.factory.createStringLiteral(moduleSpecifier));
        }
        function convertedImports(newImports, useSitesToUnqualify) {
            return {
                newImports: newImports,
                useSitesToUnqualify: useSitesToUnqualify
            };
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "correctQualifiedNameToIndexedAccessType";
        var errorCodes = [ts.Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var qualifiedName = getQualifiedName(context.sourceFile, context.span.start);
                if (!qualifiedName)
                    return undefined;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, context.sourceFile, qualifiedName); });
                var newText = qualifiedName.left.text + "[\"" + qualifiedName.right.text + "\"]";
                return [codefix.createCodeFixAction(fixId, changes, [ts.Diagnostics.Rewrite_as_the_indexed_access_type_0, newText], fixId, ts.Diagnostics.Rewrite_all_as_indexed_access_types)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var q = getQualifiedName(diag.file, diag.start);
                if (q) {
                    doChange(changes, diag.file, q);
                }
            }); },
        });
        function getQualifiedName(sourceFile, pos) {
            var qualifiedName = ts.findAncestor(ts.getTokenAtPosition(sourceFile, pos), ts.isQualifiedName);
            ts.Debug.assert(!!qualifiedName, "Expected position to be owned by a qualified name.");
            return ts.isIdentifier(qualifiedName.left) ? qualifiedName : undefined;
        }
        function doChange(changeTracker, sourceFile, qualifiedName) {
            var rightText = qualifiedName.right.text;
            var replacement = ts.factory.createIndexedAccessTypeNode(ts.factory.createTypeReferenceNode(qualifiedName.left, /*typeArguments*/ undefined), ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(rightText)));
            changeTracker.replaceNode(sourceFile, qualifiedName, replacement);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var errorCodes = [ts.Diagnostics.Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type.code];
        var fixId = "convertToTypeOnlyExport";
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return fixSingleExportDeclaration(t, getExportSpecifierForDiagnosticSpan(context.span, context.sourceFile), context); });
                if (changes.length) {
                    return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Convert_to_type_only_export, fixId, ts.Diagnostics.Convert_all_re_exported_types_to_type_only_exports)];
                }
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) {
                var fixedExportDeclarations = new ts.Map();
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                    var exportSpecifier = getExportSpecifierForDiagnosticSpan(diag, context.sourceFile);
                    if (exportSpecifier && ts.addToSeen(fixedExportDeclarations, ts.getNodeId(exportSpecifier.parent.parent))) {
                        fixSingleExportDeclaration(changes, exportSpecifier, context);
                    }
                });
            }
        });
        function getExportSpecifierForDiagnosticSpan(span, sourceFile) {
            return ts.tryCast(ts.getTokenAtPosition(sourceFile, span.start).parent, ts.isExportSpecifier);
        }
        function fixSingleExportDeclaration(changes, exportSpecifier, context) {
            if (!exportSpecifier) {
                return;
            }
            var exportClause = exportSpecifier.parent;
            var exportDeclaration = exportClause.parent;
            var typeExportSpecifiers = getTypeExportSpecifiers(exportSpecifier, context);
            if (typeExportSpecifiers.length === exportClause.elements.length) {
                changes.insertModifierBefore(context.sourceFile, 150 /* TypeKeyword */, exportClause);
            }
            else {
                var valueExportDeclaration = ts.factory.updateExportDeclaration(exportDeclaration, exportDeclaration.decorators, exportDeclaration.modifiers, 
                /*isTypeOnly*/ false, ts.factory.updateNamedExports(exportClause, ts.filter(exportClause.elements, function (e) { return !ts.contains(typeExportSpecifiers, e); })), exportDeclaration.moduleSpecifier);
                var typeExportDeclaration = ts.factory.createExportDeclaration(
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, 
                /*isTypeOnly*/ true, ts.factory.createNamedExports(typeExportSpecifiers), exportDeclaration.moduleSpecifier);
                changes.replaceNode(context.sourceFile, exportDeclaration, valueExportDeclaration, {
                    leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,
                    trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude
                });
                changes.insertNodeAfter(context.sourceFile, exportDeclaration, typeExportDeclaration);
            }
        }
        function getTypeExportSpecifiers(originExportSpecifier, context) {
            var exportClause = originExportSpecifier.parent;
            if (exportClause.elements.length === 1) {
                return exportClause.elements;
            }
            var diagnostics = ts.getDiagnosticsWithinSpan(ts.createTextSpanFromNode(exportClause), context.program.getSemanticDiagnostics(context.sourceFile, context.cancellationToken));
            return ts.filter(exportClause.elements, function (element) {
                var _a;
                return element === originExportSpecifier || ((_a = ts.findDiagnosticForNode(element, diagnostics)) === null || _a === void 0 ? void 0 : _a.code) === errorCodes[0];
            });
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var errorCodes = [ts.Diagnostics.This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set_to_error.code];
        var fixId = "convertToTypeOnlyImport";
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) {
                    var importDeclaration = getImportDeclarationForDiagnosticSpan(context.span, context.sourceFile);
                    fixSingleImportDeclaration(t, importDeclaration, context);
                });
                if (changes.length) {
                    return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Convert_to_type_only_import, fixId, ts.Diagnostics.Convert_all_imports_not_used_as_a_value_to_type_only_imports)];
                }
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) {
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                    var importDeclaration = getImportDeclarationForDiagnosticSpan(diag, context.sourceFile);
                    fixSingleImportDeclaration(changes, importDeclaration, context);
                });
            }
        });
        function getImportDeclarationForDiagnosticSpan(span, sourceFile) {
            return ts.tryCast(ts.getTokenAtPosition(sourceFile, span.start).parent, ts.isImportDeclaration);
        }
        function fixSingleImportDeclaration(changes, importDeclaration, context) {
            if (!(importDeclaration === null || importDeclaration === void 0 ? void 0 : importDeclaration.importClause)) {
                return;
            }
            var importClause = importDeclaration.importClause;
            // `changes.insertModifierBefore` produces a range that might overlap further changes
            changes.insertText(context.sourceFile, importDeclaration.getStart() + "import".length, " type");
            // `import type foo, { Bar }` is not allowed, so move `foo` to new declaration
            if (importClause.name && importClause.namedBindings) {
                changes.deleteNodeRangeExcludingEnd(context.sourceFile, importClause.name, importDeclaration.importClause.namedBindings);
                changes.insertNodeBefore(context.sourceFile, importDeclaration, ts.factory.updateImportDeclaration(importDeclaration, 
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, ts.factory.createImportClause(
                /*isTypeOnly*/ true, importClause.name, 
                /*namedBindings*/ undefined), importDeclaration.moduleSpecifier));
            }
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "convertLiteralTypeToMappedType";
        var errorCodes = [ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span;
                var info = getInfo(sourceFile, span.start);
                if (!info) {
                    return undefined;
                }
                var name = info.name, constraint = info.constraint;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, info); });
                return [codefix.createCodeFixAction(fixId, changes, [ts.Diagnostics.Convert_0_to_1_in_0, constraint, name], fixId, ts.Diagnostics.Convert_all_type_literals_to_mapped_type)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var info = getInfo(diag.file, diag.start);
                if (info) {
                    doChange(changes, diag.file, info);
                }
            }); }
        });
        function getInfo(sourceFile, pos) {
            var token = ts.getTokenAtPosition(sourceFile, pos);
            if (ts.isIdentifier(token)) {
                var propertySignature = ts.cast(token.parent.parent, ts.isPropertySignature);
                var propertyName = token.getText(sourceFile);
                return {
                    container: ts.cast(propertySignature.parent, ts.isTypeLiteralNode),
                    typeNode: propertySignature.type,
                    constraint: propertyName,
                    name: propertyName === "K" ? "P" : "K",
                };
            }
            return undefined;
        }
        function doChange(changes, sourceFile, _a) {
            var container = _a.container, typeNode = _a.typeNode, constraint = _a.constraint, name = _a.name;
            changes.replaceNode(sourceFile, container, ts.factory.createMappedTypeNode(/*readonlyToken*/ undefined, ts.factory.createTypeParameterDeclaration(name, ts.factory.createTypeReferenceNode(constraint)), /*nameType*/ undefined, /*questionToken*/ undefined, typeNode));
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var errorCodes = [
            ts.Diagnostics.Class_0_incorrectly_implements_interface_1.code,
            ts.Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code
        ];
        var fixId = "fixClassIncorrectlyImplementsInterface"; // TODO: share a group with fixClassDoesntImplementInheritedAbstractMember?
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span;
                var classDeclaration = getClass(sourceFile, span.start);
                return ts.mapDefined(ts.getEffectiveImplementsTypeNodes(classDeclaration), function (implementedTypeNode) {
                    var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return addMissingDeclarations(context, implementedTypeNode, sourceFile, classDeclaration, t, context.preferences); });
                    return changes.length === 0 ? undefined : codefix.createCodeFixAction(fixId, changes, [ts.Diagnostics.Implement_interface_0, implementedTypeNode.getText(sourceFile)], fixId, ts.Diagnostics.Implement_all_unimplemented_interfaces);
                });
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) {
                var seenClassDeclarations = new ts.Map();
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                    var classDeclaration = getClass(diag.file, diag.start);
                    if (ts.addToSeen(seenClassDeclarations, ts.getNodeId(classDeclaration))) {
                        for (var _i = 0, _a = ts.getEffectiveImplementsTypeNodes(classDeclaration); _i < _a.length; _i++) {
                            var implementedTypeNode = _a[_i];
                            addMissingDeclarations(context, implementedTypeNode, diag.file, classDeclaration, changes, context.preferences);
                        }
                    }
                });
            },
        });
        function getClass(sourceFile, pos) {
            return ts.Debug.checkDefined(ts.getContainingClass(ts.getTokenAtPosition(sourceFile, pos)), "There should be a containing class");
        }
        function symbolPointsToNonPrivateMember(symbol) {
            return !symbol.valueDeclaration || !(ts.getEffectiveModifierFlags(symbol.valueDeclaration) & 8 /* Private */);
        }
        function addMissingDeclarations(context, implementedTypeNode, sourceFile, classDeclaration, changeTracker, preferences) {
            var checker = context.program.getTypeChecker();
            var maybeHeritageClauseSymbol = getHeritageClauseSymbolTable(classDeclaration, checker);
            // Note that this is ultimately derived from a map indexed by symbol names,
            // so duplicates cannot occur.
            var implementedType = checker.getTypeAtLocation(implementedTypeNode);
            var implementedTypeSymbols = checker.getPropertiesOfType(implementedType);
            var nonPrivateAndNotExistedInHeritageClauseMembers = implementedTypeSymbols.filter(ts.and(symbolPointsToNonPrivateMember, function (symbol) { return !maybeHeritageClauseSymbol.has(symbol.escapedName); }));
            var classType = checker.getTypeAtLocation(classDeclaration);
            var constructor = ts.find(classDeclaration.members, function (m) { return ts.isConstructorDeclaration(m); });
            if (!classType.getNumberIndexType()) {
                createMissingIndexSignatureDeclaration(implementedType, 1 /* Number */);
            }
            if (!classType.getStringIndexType()) {
                createMissingIndexSignatureDeclaration(implementedType, 0 /* String */);
            }
            var importAdder = codefix.createImportAdder(sourceFile, context.program, preferences, context.host);
            codefix.createMissingMemberNodes(classDeclaration, nonPrivateAndNotExistedInHeritageClauseMembers, sourceFile, context, preferences, importAdder, function (member) { return insertInterfaceMemberNode(sourceFile, classDeclaration, member); });
            importAdder.writeFixes(changeTracker);
            function createMissingIndexSignatureDeclaration(type, kind) {
                var indexInfoOfKind = checker.getIndexInfoOfType(type, kind);
                if (indexInfoOfKind) {
                    insertInterfaceMemberNode(sourceFile, classDeclaration, checker.indexInfoToIndexSignatureDeclaration(indexInfoOfKind, classDeclaration, /*flags*/ undefined, codefix.getNoopSymbolTrackerWithResolver(context)));
                }
            }
            // Either adds the node at the top of the class, or if there's a constructor right after that
            function insertInterfaceMemberNode(sourceFile, cls, newElement) {
                if (constructor) {
                    changeTracker.insertNodeAfter(sourceFile, constructor, newElement);
                }
                else {
                    changeTracker.insertNodeAtClassStart(sourceFile, cls, newElement);
                }
            }
        }
        function getHeritageClauseSymbolTable(classDeclaration, checker) {
            var heritageClauseNode = ts.getEffectiveBaseTypeNode(classDeclaration);
            if (!heritageClauseNode)
                return ts.createSymbolTable();
            var heritageClauseType = checker.getTypeAtLocation(heritageClauseNode);
            var heritageClauseTypeSymbols = checker.getPropertiesOfType(heritageClauseType);
            return ts.createSymbolTable(heritageClauseTypeSymbols.filter(symbolPointsToNonPrivateMember));
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        codefix.importFixName = "import";
        var importFixId = "fixMissingImport";
        var errorCodes = [
            ts.Diagnostics.Cannot_find_name_0.code,
            ts.Diagnostics.Cannot_find_name_0_Did_you_mean_1.code,
            ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0.code,
            ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0.code,
            ts.Diagnostics.Cannot_find_namespace_0.code,
            ts.Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead.code,
            ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here.code,
            ts.Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer.code
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var errorCode = context.errorCode, preferences = context.preferences, sourceFile = context.sourceFile, span = context.span;
                var info = getFixesInfo(context, errorCode, span.start, /*useAutoImportProvider*/ true);
                if (!info)
                    return undefined;
                var fixes = info.fixes, symbolName = info.symbolName;
                var quotePreference = ts.getQuotePreference(sourceFile, preferences);
                return fixes.map(function (fix) { return codeActionForFix(context, sourceFile, symbolName, fix, quotePreference); });
            },
            fixIds: [importFixId],
            getAllCodeActions: function (context) {
                var sourceFile = context.sourceFile, program = context.program, preferences = context.preferences, host = context.host;
                var importAdder = createImportAdderWorker(sourceFile, program, /*useAutoImportProvider*/ true, preferences, host);
                codefix.eachDiagnostic(context, errorCodes, function (diag) { return importAdder.addImportFromDiagnostic(diag, context); });
                return codefix.createCombinedCodeActions(ts.textChanges.ChangeTracker.with(context, importAdder.writeFixes));
            },
        });
        function createImportAdder(sourceFile, program, preferences, host) {
            return createImportAdderWorker(sourceFile, program, /*useAutoImportProvider*/ false, preferences, host);
        }
        codefix.createImportAdder = createImportAdder;
        function createImportAdderWorker(sourceFile, program, useAutoImportProvider, preferences, host) {
            var compilerOptions = program.getCompilerOptions();
            // Namespace fixes don't conflict, so just build a list.
            var addToNamespace = [];
            var importType = [];
            // Keys are import clause node IDs.
            var addToExisting = new ts.Map();
            var newImports = new ts.Map();
            return { addImportFromDiagnostic: addImportFromDiagnostic, addImportFromExportedSymbol: addImportFromExportedSymbol, writeFixes: writeFixes };
            function addImportFromDiagnostic(diagnostic, context) {
                var info = getFixesInfo(context, diagnostic.code, diagnostic.start, useAutoImportProvider);
                if (!info || !info.fixes.length)
                    return;
                addImport(info);
            }
            function addImportFromExportedSymbol(exportedSymbol, usageIsTypeOnly) {
                var moduleSymbol = ts.Debug.checkDefined(exportedSymbol.parent);
                var symbolName = ts.getNameForExportedSymbol(exportedSymbol, ts.getEmitScriptTarget(compilerOptions));
                var checker = program.getTypeChecker();
                var symbol = checker.getMergedSymbol(ts.skipAlias(exportedSymbol, checker));
                var exportInfos = getAllReExportingModules(sourceFile, symbol, moduleSymbol, symbolName, host, program, preferences, useAutoImportProvider);
                var preferTypeOnlyImport = !!usageIsTypeOnly && compilerOptions.importsNotUsedAsValues === 2 /* Error */;
                var useRequire = shouldUseRequire(sourceFile, program);
                var fix = getImportFixForSymbol(sourceFile, exportInfos, moduleSymbol, symbolName, program, /*position*/ undefined, preferTypeOnlyImport, useRequire, host, preferences);
                if (fix) {
                    addImport({ fixes: [fix], symbolName: symbolName });
                }
            }
            function addImport(info) {
                var fixes = info.fixes, symbolName = info.symbolName;
                var fix = ts.first(fixes);
                switch (fix.kind) {
                    case 0 /* UseNamespace */:
                        addToNamespace.push(fix);
                        break;
                    case 1 /* ImportType */:
                        importType.push(fix);
                        break;
                    case 2 /* AddToExisting */: {
                        var importClauseOrBindingPattern = fix.importClauseOrBindingPattern, importKind = fix.importKind, canUseTypeOnlyImport = fix.canUseTypeOnlyImport;
                        var key = String(ts.getNodeId(importClauseOrBindingPattern));
                        var entry = addToExisting.get(key);
                        if (!entry) {
                            addToExisting.set(key, entry = { importClauseOrBindingPattern: importClauseOrBindingPattern, defaultImport: undefined, namedImports: [], canUseTypeOnlyImport: canUseTypeOnlyImport });
                        }
                        if (importKind === 0 /* Named */) {
                            ts.pushIfUnique(entry.namedImports, symbolName);
                        }
                        else {
                            ts.Debug.assert(entry.defaultImport === undefined || entry.defaultImport === symbolName, "(Add to Existing) Default import should be missing or match symbolName");
                            entry.defaultImport = symbolName;
                        }
                        break;
                    }
                    case 3 /* AddNew */: {
                        var moduleSpecifier = fix.moduleSpecifier, importKind = fix.importKind, useRequire = fix.useRequire, typeOnly = fix.typeOnly;
                        var entry = newImports.get(moduleSpecifier);
                        if (!entry) {
                            newImports.set(moduleSpecifier, entry = { namedImports: [], namespaceLikeImport: undefined, typeOnly: typeOnly, useRequire: useRequire });
                        }
                        else {
                            // An import clause can only be type-only if every import fix contributing to it can be type-only.
                            entry.typeOnly = entry.typeOnly && typeOnly;
                        }
                        switch (importKind) {
                            case 1 /* Default */:
                                ts.Debug.assert(entry.defaultImport === undefined || entry.defaultImport === symbolName, "(Add new) Default import should be missing or match symbolName");
                                entry.defaultImport = symbolName;
                                break;
                            case 0 /* Named */:
                                ts.pushIfUnique(entry.namedImports || (entry.namedImports = []), symbolName);
                                break;
                            case 3 /* CommonJS */:
                            case 2 /* Namespace */:
                                ts.Debug.assert(entry.namespaceLikeImport === undefined || entry.namespaceLikeImport.name === symbolName, "Namespacelike import shoudl be missing or match symbolName");
                                entry.namespaceLikeImport = { importKind: importKind, name: symbolName };
                                break;
                        }
                        break;
                    }
                    default:
                        ts.Debug.assertNever(fix, "fix wasn't never - got kind " + fix.kind);
                }
            }
            function writeFixes(changeTracker) {
                var quotePreference = ts.getQuotePreference(sourceFile, preferences);
                for (var _i = 0, addToNamespace_1 = addToNamespace; _i < addToNamespace_1.length; _i++) {
                    var fix = addToNamespace_1[_i];
                    addNamespaceQualifier(changeTracker, sourceFile, fix);
                }
                for (var _a = 0, importType_1 = importType; _a < importType_1.length; _a++) {
                    var fix = importType_1[_a];
                    addImportType(changeTracker, sourceFile, fix, quotePreference);
                }
                addToExisting.forEach(function (_a) {
                    var importClauseOrBindingPattern = _a.importClauseOrBindingPattern, defaultImport = _a.defaultImport, namedImports = _a.namedImports, canUseTypeOnlyImport = _a.canUseTypeOnlyImport;
                    doAddExistingFix(changeTracker, sourceFile, importClauseOrBindingPattern, defaultImport, namedImports, canUseTypeOnlyImport);
                });
                var newDeclarations;
                newImports.forEach(function (_a, moduleSpecifier) {
                    var useRequire = _a.useRequire, imports = __rest(_a, ["useRequire"]);
                    var getDeclarations = useRequire ? getNewRequires : getNewImports;
                    newDeclarations = ts.combine(newDeclarations, getDeclarations(moduleSpecifier, quotePreference, imports));
                });
                if (newDeclarations) {
                    ts.insertImports(changeTracker, sourceFile, newDeclarations, /*blankLineBetween*/ true);
                }
            }
        }
        // Sorted with the preferred fix coming first.
        var ImportFixKind;
        (function (ImportFixKind) {
            ImportFixKind[ImportFixKind["UseNamespace"] = 0] = "UseNamespace";
            ImportFixKind[ImportFixKind["ImportType"] = 1] = "ImportType";
            ImportFixKind[ImportFixKind["AddToExisting"] = 2] = "AddToExisting";
            ImportFixKind[ImportFixKind["AddNew"] = 3] = "AddNew";
        })(ImportFixKind || (ImportFixKind = {}));
        function getImportCompletionAction(exportedSymbol, moduleSymbol, sourceFile, symbolName, host, program, formatContext, position, preferences) {
            var compilerOptions = program.getCompilerOptions();
            var exportInfos = ts.pathIsBareSpecifier(ts.stripQuotes(moduleSymbol.name))
                ? [getSymbolExportInfoForSymbol(exportedSymbol, moduleSymbol, program, host)]
                : getAllReExportingModules(sourceFile, exportedSymbol, moduleSymbol, symbolName, host, program, preferences, /*useAutoImportProvider*/ true);
            var useRequire = shouldUseRequire(sourceFile, program);
            var preferTypeOnlyImport = compilerOptions.importsNotUsedAsValues === 2 /* Error */ && !ts.isSourceFileJS(sourceFile) && ts.isValidTypeOnlyAliasUseSite(ts.getTokenAtPosition(sourceFile, position));
            var fix = ts.Debug.checkDefined(getImportFixForSymbol(sourceFile, exportInfos, moduleSymbol, symbolName, program, position, preferTypeOnlyImport, useRequire, host, preferences));
            return { moduleSpecifier: fix.moduleSpecifier, codeAction: codeFixActionToCodeAction(codeActionForFix({ host: host, formatContext: formatContext, preferences: preferences }, sourceFile, symbolName, fix, ts.getQuotePreference(sourceFile, preferences))) };
        }
        codefix.getImportCompletionAction = getImportCompletionAction;
        function getImportFixForSymbol(sourceFile, exportInfos, moduleSymbol, symbolName, program, position, preferTypeOnlyImport, useRequire, host, preferences) {
            ts.Debug.assert(exportInfos.some(function (info) { return info.moduleSymbol === moduleSymbol || info.symbol.parent === moduleSymbol; }), "Some exportInfo should match the specified moduleSymbol");
            return getBestFix(getImportFixes(exportInfos, symbolName, position, preferTypeOnlyImport, useRequire, program, sourceFile, host, preferences), sourceFile, program, host, preferences);
        }
        function codeFixActionToCodeAction(_a) {
            var description = _a.description, changes = _a.changes, commands = _a.commands;
            return { description: description, changes: changes, commands: commands };
        }
        function getSymbolExportInfoForSymbol(symbol, moduleSymbol, program, host) {
            var _a, _b;
            var compilerOptions = program.getCompilerOptions();
            var mainProgramInfo = getInfoWithChecker(program.getTypeChecker(), /*isFromPackageJson*/ false);
            if (mainProgramInfo) {
                return mainProgramInfo;
            }
            var autoImportProvider = (_b = (_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host)) === null || _b === void 0 ? void 0 : _b.getTypeChecker();
            return ts.Debug.checkDefined(autoImportProvider && getInfoWithChecker(autoImportProvider, /*isFromPackageJson*/ true), "Could not find symbol in specified module for code actions");
            function getInfoWithChecker(checker, isFromPackageJson) {
                var defaultInfo = ts.getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions);
                if (defaultInfo && ts.skipAlias(defaultInfo.symbol, checker) === symbol) {
                    return { symbol: defaultInfo.symbol, moduleSymbol: moduleSymbol, moduleFileName: undefined, exportKind: defaultInfo.exportKind, targetFlags: ts.skipAlias(symbol, checker).flags, isFromPackageJson: isFromPackageJson };
                }
                var named = checker.tryGetMemberInModuleExportsAndProperties(symbol.name, moduleSymbol);
                if (named && ts.skipAlias(named, checker) === symbol) {
                    return { symbol: named, moduleSymbol: moduleSymbol, moduleFileName: undefined, exportKind: 0 /* Named */, targetFlags: ts.skipAlias(symbol, checker).flags, isFromPackageJson: isFromPackageJson };
                }
            }
        }
        function getAllReExportingModules(importingFile, exportedSymbol, exportingModuleSymbol, symbolName, host, program, preferences, useAutoImportProvider) {
            var result = [];
            var compilerOptions = program.getCompilerOptions();
            var getModuleSpecifierResolutionHost = ts.memoizeOne(function (isFromPackageJson) {
                return ts.createModuleSpecifierResolutionHost(isFromPackageJson ? host.getPackageJsonAutoImportProvider() : program, host);
            });
            ts.forEachExternalModuleToImportFrom(program, host, useAutoImportProvider, function (moduleSymbol, moduleFile, program, isFromPackageJson) {
                var checker = program.getTypeChecker();
                // Don't import from a re-export when looking "up" like to `./index` or `../index`.
                if (moduleFile && moduleSymbol !== exportingModuleSymbol && ts.startsWith(importingFile.fileName, ts.getDirectoryPath(moduleFile.fileName))) {
                    return;
                }
                var defaultInfo = ts.getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions);
                if (defaultInfo && (defaultInfo.name === symbolName || moduleSymbolToValidIdentifier(moduleSymbol, compilerOptions.target) === symbolName) && ts.skipAlias(defaultInfo.symbol, checker) === exportedSymbol && isImportable(program, moduleFile, isFromPackageJson)) {
                    result.push({ symbol: defaultInfo.symbol, moduleSymbol: moduleSymbol, moduleFileName: moduleFile === null || moduleFile === void 0 ? void 0 : moduleFile.fileName, exportKind: defaultInfo.exportKind, targetFlags: ts.skipAlias(defaultInfo.symbol, checker).flags, isFromPackageJson: isFromPackageJson });
                }
                for (var _i = 0, _a = checker.getExportsAndPropertiesOfModule(moduleSymbol); _i < _a.length; _i++) {
                    var exported = _a[_i];
                    if (exported.name === symbolName && ts.skipAlias(exported, checker) === exportedSymbol && isImportable(program, moduleFile, isFromPackageJson)) {
                        result.push({ symbol: exported, moduleSymbol: moduleSymbol, moduleFileName: moduleFile === null || moduleFile === void 0 ? void 0 : moduleFile.fileName, exportKind: 0 /* Named */, targetFlags: ts.skipAlias(exported, checker).flags, isFromPackageJson: isFromPackageJson });
                    }
                }
            });
            return result;
            function isImportable(program, moduleFile, isFromPackageJson) {
                var _a;
                return !moduleFile || ts.isImportableFile(program, importingFile, moduleFile, preferences, /*packageJsonFilter*/ undefined, getModuleSpecifierResolutionHost(isFromPackageJson), (_a = host.getModuleSpecifierCache) === null || _a === void 0 ? void 0 : _a.call(host));
            }
        }
        function getModuleSpecifierForBestExportInfo(exportInfo, importingFile, program, host, preferences, fromCacheOnly) {
            var _a = getNewImportFixes(program, importingFile, 
            /*position*/ undefined, 
            /*preferTypeOnlyImport*/ false, 
            /*useRequire*/ false, exportInfo, host, preferences, fromCacheOnly), fixes = _a.fixes, computedWithoutCacheCount = _a.computedWithoutCacheCount;
            var result = getBestFix(fixes, importingFile, program, host, preferences);
            return result && __assign(__assign({}, result), { computedWithoutCacheCount: computedWithoutCacheCount });
        }
        codefix.getModuleSpecifierForBestExportInfo = getModuleSpecifierForBestExportInfo;
        function isTypeOnlyPosition(sourceFile, position) {
            return ts.isValidTypeOnlyAliasUseSite(ts.getTokenAtPosition(sourceFile, position));
        }
        function getImportFixes(exportInfos, symbolName, 
        /** undefined only for missing JSX namespace */
        position, preferTypeOnlyImport, useRequire, program, sourceFile, host, preferences) {
            var checker = program.getTypeChecker();
            var existingImports = ts.flatMap(exportInfos, function (info) { return getExistingImportDeclarations(info, checker, sourceFile, program.getCompilerOptions()); });
            var useNamespace = position === undefined ? undefined : tryUseExistingNamespaceImport(existingImports, symbolName, position, checker);
            var addToExisting = tryAddToExistingImport(existingImports, position !== undefined && isTypeOnlyPosition(sourceFile, position));
            // Don't bother providing an action to add a new import if we can add to an existing one.
            var addImport = addToExisting ? [addToExisting] : getFixesForAddImport(exportInfos, existingImports, program, sourceFile, position, preferTypeOnlyImport, useRequire, host, preferences);
            return __spreadArray(__spreadArray([], (useNamespace ? [useNamespace] : ts.emptyArray), true), addImport, true);
        }
        function tryUseExistingNamespaceImport(existingImports, symbolName, position, checker) {
            // It is possible that multiple import statements with the same specifier exist in the file.
            // e.g.
            //
            //     import * as ns from "foo";
            //     import { member1, member2 } from "foo";
            //
            //     member3/**/ <-- cusor here
            //
            // in this case we should provie 2 actions:
            //     1. change "member3" to "ns.member3"
            //     2. add "member3" to the second import statement's import list
            // and it is up to the user to decide which one fits best.
            return ts.firstDefined(existingImports, function (_a) {
                var declaration = _a.declaration;
                var namespacePrefix = getNamespaceLikeImportText(declaration);
                var moduleSpecifier = ts.tryGetModuleSpecifierFromDeclaration(declaration);
                if (namespacePrefix && moduleSpecifier) {
                    var moduleSymbol = getTargetModuleFromNamespaceLikeImport(declaration, checker);
                    if (moduleSymbol && moduleSymbol.exports.has(ts.escapeLeadingUnderscores(symbolName))) {
                        return { kind: 0 /* UseNamespace */, namespacePrefix: namespacePrefix, position: position, moduleSpecifier: moduleSpecifier };
                    }
                }
            });
        }
        function getTargetModuleFromNamespaceLikeImport(declaration, checker) {
            var _a;
            switch (declaration.kind) {
                case 252 /* VariableDeclaration */:
                    return checker.resolveExternalModuleName(declaration.initializer.arguments[0]);
                case 263 /* ImportEqualsDeclaration */:
                    return checker.getAliasedSymbol(declaration.symbol);
                case 264 /* ImportDeclaration */:
                    var namespaceImport = ts.tryCast((_a = declaration.importClause) === null || _a === void 0 ? void 0 : _a.namedBindings, ts.isNamespaceImport);
                    return namespaceImport && checker.getAliasedSymbol(namespaceImport.symbol);
                default:
                    return ts.Debug.assertNever(declaration);
            }
        }
        function getNamespaceLikeImportText(declaration) {
            var _a, _b, _c;
            switch (declaration.kind) {
                case 252 /* VariableDeclaration */:
                    return (_a = ts.tryCast(declaration.name, ts.isIdentifier)) === null || _a === void 0 ? void 0 : _a.text;
                case 263 /* ImportEqualsDeclaration */:
                    return declaration.name.text;
                case 264 /* ImportDeclaration */:
                    return (_c = ts.tryCast((_b = declaration.importClause) === null || _b === void 0 ? void 0 : _b.namedBindings, ts.isNamespaceImport)) === null || _c === void 0 ? void 0 : _c.name.text;
                default:
                    return ts.Debug.assertNever(declaration);
            }
        }
        function tryAddToExistingImport(existingImports, canUseTypeOnlyImport) {
            return ts.firstDefined(existingImports, function (_a) {
                var declaration = _a.declaration, importKind = _a.importKind;
                if (declaration.kind === 263 /* ImportEqualsDeclaration */)
                    return undefined;
                if (declaration.kind === 252 /* VariableDeclaration */) {
                    return (importKind === 0 /* Named */ || importKind === 1 /* Default */) && declaration.name.kind === 199 /* ObjectBindingPattern */
                        ? { kind: 2 /* AddToExisting */, importClauseOrBindingPattern: declaration.name, importKind: importKind, moduleSpecifier: declaration.initializer.arguments[0].text, canUseTypeOnlyImport: false }
                        : undefined;
                }
                var importClause = declaration.importClause;
                if (!importClause || !ts.isStringLiteralLike(declaration.moduleSpecifier))
                    return undefined;
                var name = importClause.name, namedBindings = importClause.namedBindings;
                // A type-only import may not have both a default and named imports, so the only way a name can
                // be added to an existing type-only import is adding a named import to existing named bindings.
                if (importClause.isTypeOnly && !(importKind === 0 /* Named */ && namedBindings))
                    return undefined;
                return importKind === 1 /* Default */ && !name || importKind === 0 /* Named */ && (!namedBindings || namedBindings.kind === 267 /* NamedImports */)
                    ? { kind: 2 /* AddToExisting */, importClauseOrBindingPattern: importClause, importKind: importKind, moduleSpecifier: declaration.moduleSpecifier.text, canUseTypeOnlyImport: canUseTypeOnlyImport }
                    : undefined;
            });
        }
        function getExistingImportDeclarations(_a, checker, importingFile, compilerOptions) {
            var moduleSymbol = _a.moduleSymbol, exportKind = _a.exportKind, targetFlags = _a.targetFlags;
            // Can't use an es6 import for a type in JS.
            if (!(targetFlags & 111551 /* Value */) && ts.isSourceFileJS(importingFile))
                return ts.emptyArray;
            var importKind = getImportKind(importingFile, exportKind, compilerOptions);
            return ts.mapDefined(importingFile.imports, function (moduleSpecifier) {
                var i = ts.importFromModuleSpecifier(moduleSpecifier);
                if (ts.isRequireVariableDeclaration(i.parent)) {
                    return checker.resolveExternalModuleName(moduleSpecifier) === moduleSymbol ? { declaration: i.parent, importKind: importKind } : undefined;
                }
                if (i.kind === 264 /* ImportDeclaration */ || i.kind === 263 /* ImportEqualsDeclaration */) {
                    return checker.getSymbolAtLocation(moduleSpecifier) === moduleSymbol ? { declaration: i, importKind: importKind } : undefined;
                }
            });
        }
        function shouldUseRequire(sourceFile, program) {
            // 1. TypeScript files don't use require variable declarations
            if (!ts.isSourceFileJS(sourceFile)) {
                return false;
            }
            // 2. If the current source file is unambiguously CJS or ESM, go with that
            if (sourceFile.commonJsModuleIndicator && !sourceFile.externalModuleIndicator)
                return true;
            if (sourceFile.externalModuleIndicator && !sourceFile.commonJsModuleIndicator)
                return false;
            // 3. If there's a tsconfig/jsconfig, use its module setting
            var compilerOptions = program.getCompilerOptions();
            if (compilerOptions.configFile) {
                return ts.getEmitModuleKind(compilerOptions) < ts.ModuleKind.ES2015;
            }
            // 4. Match the first other JS file in the program that's unambiguously CJS or ESM
            for (var _i = 0, _a = program.getSourceFiles(); _i < _a.length; _i++) {
                var otherFile = _a[_i];
                if (otherFile === sourceFile || !ts.isSourceFileJS(otherFile) || program.isSourceFileFromExternalLibrary(otherFile))
                    continue;
                if (otherFile.commonJsModuleIndicator && !otherFile.externalModuleIndicator)
                    return true;
                if (otherFile.externalModuleIndicator && !otherFile.commonJsModuleIndicator)
                    return false;
            }
            // 5. Literally nothing to go on
            return true;
        }
        function getNewImportFixes(program, sourceFile, position, preferTypeOnlyImport, useRequire, moduleSymbols, host, preferences, fromCacheOnly) {
            var isJs = ts.isSourceFileJS(sourceFile);
            var compilerOptions = program.getCompilerOptions();
            var moduleSpecifierResolutionHost = ts.createModuleSpecifierResolutionHost(program, host);
            var checker = program.getTypeChecker();
            var getModuleSpecifiers = fromCacheOnly
                ? function (moduleSymbol) { return ({ moduleSpecifiers: ts.moduleSpecifiers.tryGetModuleSpecifiersFromCache(moduleSymbol, sourceFile, moduleSpecifierResolutionHost, preferences), computedWithoutCache: false }); }
                : function (moduleSymbol) { return ts.moduleSpecifiers.getModuleSpecifiersWithCacheInfo(moduleSymbol, checker, compilerOptions, sourceFile, moduleSpecifierResolutionHost, preferences); };
            var computedWithoutCacheCount = 0;
            var fixes = ts.flatMap(moduleSymbols, function (exportInfo) {
                var _a = getModuleSpecifiers(exportInfo.moduleSymbol), computedWithoutCache = _a.computedWithoutCache, moduleSpecifiers = _a.moduleSpecifiers;
                computedWithoutCacheCount += computedWithoutCache ? 1 : 0;
                return moduleSpecifiers === null || moduleSpecifiers === void 0 ? void 0 : moduleSpecifiers.map(function (moduleSpecifier) {
                    // `position` should only be undefined at a missing jsx namespace, in which case we shouldn't be looking for pure types.
                    return !(exportInfo.targetFlags & 111551 /* Value */) && isJs && position !== undefined
                        ? { kind: 1 /* ImportType */, moduleSpecifier: moduleSpecifier, position: position, exportInfo: exportInfo }
                        : {
                            kind: 3 /* AddNew */,
                            moduleSpecifier: moduleSpecifier,
                            importKind: getImportKind(sourceFile, exportInfo.exportKind, compilerOptions),
                            useRequire: useRequire,
                            typeOnly: preferTypeOnlyImport,
                            exportInfo: exportInfo,
                        };
                });
            });
            return { computedWithoutCacheCount: computedWithoutCacheCount, fixes: fixes };
        }
        function getFixesForAddImport(exportInfos, existingImports, program, sourceFile, position, preferTypeOnlyImport, useRequire, host, preferences) {
            var existingDeclaration = ts.firstDefined(existingImports, function (info) { return newImportInfoFromExistingSpecifier(info, preferTypeOnlyImport, useRequire); });
            return existingDeclaration ? [existingDeclaration] : getNewImportFixes(program, sourceFile, position, preferTypeOnlyImport, useRequire, exportInfos, host, preferences).fixes;
        }
        function newImportInfoFromExistingSpecifier(_a, preferTypeOnlyImport, useRequire) {
            var declaration = _a.declaration, importKind = _a.importKind;
            var moduleSpecifier = ts.tryGetModuleSpecifierFromDeclaration(declaration);
            return moduleSpecifier
                ? { kind: 3 /* AddNew */, moduleSpecifier: moduleSpecifier, importKind: importKind, typeOnly: preferTypeOnlyImport, useRequire: useRequire }
                : undefined;
        }
        function getFixesInfo(context, errorCode, pos, useAutoImportProvider) {
            var symbolToken = ts.getTokenAtPosition(context.sourceFile, pos);
            var info = errorCode === ts.Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead.code
                ? getFixesInfoForUMDImport(context, symbolToken)
                : ts.isIdentifier(symbolToken) ? getFixesInfoForNonUMDImport(context, symbolToken, useAutoImportProvider) : undefined;
            return info && __assign(__assign({}, info), { fixes: sortFixes(info.fixes, context.sourceFile, context.program, context.host, context.preferences) });
        }
        function sortFixes(fixes, sourceFile, program, host, preferences) {
            var allowsImportingSpecifier = ts.createPackageJsonImportFilter(sourceFile, preferences, host).allowsImportingSpecifier;
            return ts.sort(fixes, function (a, b) { return ts.compareValues(a.kind, b.kind) || compareModuleSpecifiers(a, b, sourceFile, program, allowsImportingSpecifier); });
        }
        function getBestFix(fixes, sourceFile, program, host, preferences) {
            if (!ts.some(fixes))
                return;
            // These will always be placed first if available, and are better than other kinds
            if (fixes[0].kind === 0 /* UseNamespace */ || fixes[0].kind === 2 /* AddToExisting */) {
                return fixes[0];
            }
            var allowsImportingSpecifier = ts.createPackageJsonImportFilter(sourceFile, preferences, host).allowsImportingSpecifier;
            return fixes.reduce(function (best, fix) {
                return compareModuleSpecifiers(fix, best, sourceFile, program, allowsImportingSpecifier) === -1 /* LessThan */ ? fix : best;
            });
        }
        function compareModuleSpecifiers(a, b, importingFile, program, allowsImportingSpecifier) {
            if (a.kind !== 0 /* UseNamespace */ && b.kind !== 0 /* UseNamespace */) {
                return ts.compareBooleans(allowsImportingSpecifier(a.moduleSpecifier), allowsImportingSpecifier(b.moduleSpecifier))
                    || compareNodeCoreModuleSpecifiers(a.moduleSpecifier, b.moduleSpecifier, importingFile, program)
                    || ts.compareNumberOfDirectorySeparators(a.moduleSpecifier, b.moduleSpecifier);
            }
            return 0 /* EqualTo */;
        }
        function compareNodeCoreModuleSpecifiers(a, b, importingFile, program) {
            if (ts.startsWith(a, "node:") && !ts.startsWith(b, "node:"))
                return ts.shouldUseUriStyleNodeCoreModules(importingFile, program) ? -1 /* LessThan */ : 1 /* GreaterThan */;
            if (ts.startsWith(b, "node:") && !ts.startsWith(a, "node:"))
                return ts.shouldUseUriStyleNodeCoreModules(importingFile, program) ? 1 /* GreaterThan */ : -1 /* LessThan */;
            return 0 /* EqualTo */;
        }
        function getFixesInfoForUMDImport(_a, token) {
            var sourceFile = _a.sourceFile, program = _a.program, host = _a.host, preferences = _a.preferences;
            var checker = program.getTypeChecker();
            var umdSymbol = getUmdSymbol(token, checker);
            if (!umdSymbol)
                return undefined;
            var symbol = checker.getAliasedSymbol(umdSymbol);
            var symbolName = umdSymbol.name;
            var exportInfos = [{ symbol: umdSymbol, moduleSymbol: symbol, moduleFileName: undefined, exportKind: 3 /* UMD */, targetFlags: symbol.flags, isFromPackageJson: false }];
            var useRequire = shouldUseRequire(sourceFile, program);
            var fixes = getImportFixes(exportInfos, symbolName, ts.isIdentifier(token) ? token.getStart(sourceFile) : undefined, /*preferTypeOnlyImport*/ false, useRequire, program, sourceFile, host, preferences);
            return { fixes: fixes, symbolName: symbolName };
        }
        function getUmdSymbol(token, checker) {
            // try the identifier to see if it is the umd symbol
            var umdSymbol = ts.isIdentifier(token) ? checker.getSymbolAtLocation(token) : undefined;
            if (ts.isUMDExportSymbol(umdSymbol))
                return umdSymbol;
            // The error wasn't for the symbolAtLocation, it was for the JSX tag itself, which needs access to e.g. `React`.
            var parent = token.parent;
            return (ts.isJsxOpeningLikeElement(parent) && parent.tagName === token) || ts.isJsxOpeningFragment(parent)
                ? ts.tryCast(checker.resolveName(checker.getJsxNamespace(parent), ts.isJsxOpeningLikeElement(parent) ? token : parent, 111551 /* Value */, /*excludeGlobals*/ false), ts.isUMDExportSymbol)
                : undefined;
        }
        /**
         * @param forceImportKeyword Indicates that the user has already typed `import`, so the result must start with `import`.
         * (In other words, do not allow `const x = require("...")` for JS files.)
         */
        function getImportKind(importingFile, exportKind, compilerOptions, forceImportKeyword) {
            switch (exportKind) {
                case 0 /* Named */: return 0 /* Named */;
                case 1 /* Default */: return 1 /* Default */;
                case 2 /* ExportEquals */: return getExportEqualsImportKind(importingFile, compilerOptions, !!forceImportKeyword);
                case 3 /* UMD */: return getUmdImportKind(importingFile, compilerOptions, !!forceImportKeyword);
                default: return ts.Debug.assertNever(exportKind);
            }
        }
        codefix.getImportKind = getImportKind;
        function getUmdImportKind(importingFile, compilerOptions, forceImportKeyword) {
            // Import a synthetic `default` if enabled.
            if (ts.getAllowSyntheticDefaultImports(compilerOptions)) {
                return 1 /* Default */;
            }
            // When a synthetic `default` is unavailable, use `import..require` if the module kind supports it.
            var moduleKind = ts.getEmitModuleKind(compilerOptions);
            switch (moduleKind) {
                case ts.ModuleKind.AMD:
                case ts.ModuleKind.CommonJS:
                case ts.ModuleKind.UMD:
                    if (ts.isInJSFile(importingFile)) {
                        return ts.isExternalModule(importingFile) || forceImportKeyword ? 2 /* Namespace */ : 3 /* CommonJS */;
                    }
                    return 3 /* CommonJS */;
                case ts.ModuleKind.System:
                case ts.ModuleKind.ES2015:
                case ts.ModuleKind.ES2020:
                case ts.ModuleKind.ESNext:
                case ts.ModuleKind.None:
                    // Fall back to the `import * as ns` style import.
                    return 2 /* Namespace */;
                default:
                    return ts.Debug.assertNever(moduleKind, "Unexpected moduleKind " + moduleKind);
            }
        }
        function getFixesInfoForNonUMDImport(_a, symbolToken, useAutoImportProvider) {
            var sourceFile = _a.sourceFile, program = _a.program, cancellationToken = _a.cancellationToken, host = _a.host, preferences = _a.preferences;
            var checker = program.getTypeChecker();
            var compilerOptions = program.getCompilerOptions();
            var symbolName = getSymbolName(sourceFile, checker, symbolToken, compilerOptions);
            // "default" is a keyword and not a legal identifier for the import, so we don't expect it here
            ts.Debug.assert(symbolName !== "default" /* Default */, "'default' isn't a legal identifier and couldn't occur here");
            var preferTypeOnlyImport = compilerOptions.importsNotUsedAsValues === 2 /* Error */ && ts.isValidTypeOnlyAliasUseSite(symbolToken);
            var useRequire = shouldUseRequire(sourceFile, program);
            var exportInfos = getExportInfos(symbolName, ts.getMeaningFromLocation(symbolToken), cancellationToken, sourceFile, program, useAutoImportProvider, host, preferences);
            var fixes = ts.arrayFrom(ts.flatMapIterator(exportInfos.entries(), function (_a) {
                var _ = _a[0], exportInfos = _a[1];
                return getImportFixes(exportInfos, symbolName, symbolToken.getStart(sourceFile), preferTypeOnlyImport, useRequire, program, sourceFile, host, preferences);
            }));
            return { fixes: fixes, symbolName: symbolName };
        }
        function getSymbolName(sourceFile, checker, symbolToken, compilerOptions) {
            var parent = symbolToken.parent;
            if ((ts.isJsxOpeningLikeElement(parent) || ts.isJsxClosingElement(parent)) && parent.tagName === symbolToken && compilerOptions.jsx !== 4 /* ReactJSX */ && compilerOptions.jsx !== 5 /* ReactJSXDev */) {
                var jsxNamespace = checker.getJsxNamespace(sourceFile);
                if (ts.isIntrinsicJsxName(symbolToken.text) || !checker.resolveName(jsxNamespace, parent, 111551 /* Value */, /*excludeGlobals*/ true)) {
                    return jsxNamespace;
                }
            }
            return symbolToken.text;
        }
        // Returns a map from an exported symbol's ID to a list of every way it's (re-)exported.
        function getExportInfos(symbolName, currentTokenMeaning, cancellationToken, fromFile, program, useAutoImportProvider, host, preferences) {
            var _a;
            // For each original symbol, keep all re-exports of that symbol together so we can call `getCodeActionsForImport` on the whole group at once.
            // Maps symbol id to info for modules providing that symbol (original export + re-exports).
            var originalSymbolToExportInfos = ts.createMultiMap();
            var packageJsonFilter = ts.createPackageJsonImportFilter(fromFile, preferences, host);
            var moduleSpecifierCache = (_a = host.getModuleSpecifierCache) === null || _a === void 0 ? void 0 : _a.call(host);
            var getModuleSpecifierResolutionHost = ts.memoizeOne(function (isFromPackageJson) {
                return ts.createModuleSpecifierResolutionHost(isFromPackageJson ? host.getPackageJsonAutoImportProvider() : program, host);
            });
            function addSymbol(moduleSymbol, toFile, exportedSymbol, exportKind, program, isFromPackageJson) {
                var moduleSpecifierResolutionHost = getModuleSpecifierResolutionHost(isFromPackageJson);
                if (toFile && ts.isImportableFile(program, fromFile, toFile, preferences, packageJsonFilter, moduleSpecifierResolutionHost, moduleSpecifierCache) ||
                    !toFile && packageJsonFilter.allowsImportingAmbientModule(moduleSymbol, moduleSpecifierResolutionHost)) {
                    var checker = program.getTypeChecker();
                    originalSymbolToExportInfos.add(ts.getUniqueSymbolId(exportedSymbol, checker).toString(), { symbol: exportedSymbol, moduleSymbol: moduleSymbol, moduleFileName: toFile === null || toFile === void 0 ? void 0 : toFile.fileName, exportKind: exportKind, targetFlags: ts.skipAlias(exportedSymbol, checker).flags, isFromPackageJson: isFromPackageJson });
                }
            }
            ts.forEachExternalModuleToImportFrom(program, host, useAutoImportProvider, function (moduleSymbol, sourceFile, program, isFromPackageJson) {
                var checker = program.getTypeChecker();
                cancellationToken.throwIfCancellationRequested();
                var compilerOptions = program.getCompilerOptions();
                var defaultInfo = ts.getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions);
                if (defaultInfo && (defaultInfo.name === symbolName || moduleSymbolToValidIdentifier(moduleSymbol, compilerOptions.target) === symbolName) && symbolHasMeaning(defaultInfo.symbolForMeaning, currentTokenMeaning)) {
                    addSymbol(moduleSymbol, sourceFile, defaultInfo.symbol, defaultInfo.exportKind, program, isFromPackageJson);
                }
                // check exports with the same name
                var exportSymbolWithIdenticalName = checker.tryGetMemberInModuleExportsAndProperties(symbolName, moduleSymbol);
                if (exportSymbolWithIdenticalName && symbolHasMeaning(exportSymbolWithIdenticalName, currentTokenMeaning)) {
                    addSymbol(moduleSymbol, sourceFile, exportSymbolWithIdenticalName, 0 /* Named */, program, isFromPackageJson);
                }
            });
            return originalSymbolToExportInfos;
        }
        function getExportEqualsImportKind(importingFile, compilerOptions, forceImportKeyword) {
            var allowSyntheticDefaults = ts.getAllowSyntheticDefaultImports(compilerOptions);
            var isJS = ts.isInJSFile(importingFile);
            // 1. 'import =' will not work in es2015+ TS files, so the decision is between a default
            //    and a namespace import, based on allowSyntheticDefaultImports/esModuleInterop.
            if (!isJS && ts.getEmitModuleKind(compilerOptions) >= ts.ModuleKind.ES2015) {
                return allowSyntheticDefaults ? 1 /* Default */ : 2 /* Namespace */;
            }
            // 2. 'import =' will not work in JavaScript, so the decision is between a default import,
            //    a namespace import, and const/require.
            if (isJS) {
                return ts.isExternalModule(importingFile) || forceImportKeyword
                    ? allowSyntheticDefaults ? 1 /* Default */ : 2 /* Namespace */
                    : 3 /* CommonJS */;
            }
            // 3. At this point the most correct choice is probably 'import =', but people
            //    really hate that, so look to see if the importing file has any precedent
            //    on how to handle it.
            for (var _i = 0, _a = importingFile.statements; _i < _a.length; _i++) {
                var statement = _a[_i];
                // `import foo` parses as an ImportEqualsDeclaration even though it could be an ImportDeclaration
                if (ts.isImportEqualsDeclaration(statement) && !ts.nodeIsMissing(statement.moduleReference)) {
                    return 3 /* CommonJS */;
                }
            }
            // 4. We have no precedent to go on, so just use a default import if
            //    allowSyntheticDefaultImports/esModuleInterop is enabled.
            return allowSyntheticDefaults ? 1 /* Default */ : 3 /* CommonJS */;
        }
        function codeActionForFix(context, sourceFile, symbolName, fix, quotePreference) {
            var diag;
            var changes = ts.textChanges.ChangeTracker.with(context, function (tracker) {
                diag = codeActionForFixWorker(tracker, sourceFile, symbolName, fix, quotePreference);
            });
            return codefix.createCodeFixAction(codefix.importFixName, changes, diag, importFixId, ts.Diagnostics.Add_all_missing_imports);
        }
        function codeActionForFixWorker(changes, sourceFile, symbolName, fix, quotePreference) {
            switch (fix.kind) {
                case 0 /* UseNamespace */:
                    addNamespaceQualifier(changes, sourceFile, fix);
                    return [ts.Diagnostics.Change_0_to_1, symbolName, fix.namespacePrefix + "." + symbolName];
                case 1 /* ImportType */:
                    addImportType(changes, sourceFile, fix, quotePreference);
                    return [ts.Diagnostics.Change_0_to_1, symbolName, getImportTypePrefix(fix.moduleSpecifier, quotePreference) + symbolName];
                case 2 /* AddToExisting */: {
                    var importClauseOrBindingPattern = fix.importClauseOrBindingPattern, importKind = fix.importKind, canUseTypeOnlyImport = fix.canUseTypeOnlyImport, moduleSpecifier = fix.moduleSpecifier;
                    doAddExistingFix(changes, sourceFile, importClauseOrBindingPattern, importKind === 1 /* Default */ ? symbolName : undefined, importKind === 0 /* Named */ ? [symbolName] : ts.emptyArray, canUseTypeOnlyImport);
                    var moduleSpecifierWithoutQuotes = ts.stripQuotes(moduleSpecifier);
                    return [importKind === 1 /* Default */ ? ts.Diagnostics.Add_default_import_0_to_existing_import_declaration_from_1 : ts.Diagnostics.Add_0_to_existing_import_declaration_from_1, symbolName, moduleSpecifierWithoutQuotes]; // you too!
                }
                case 3 /* AddNew */: {
                    var importKind = fix.importKind, moduleSpecifier = fix.moduleSpecifier, typeOnly = fix.typeOnly, useRequire = fix.useRequire;
                    var getDeclarations = useRequire ? getNewRequires : getNewImports;
                    var importsCollection = importKind === 1 /* Default */ ? { defaultImport: symbolName, typeOnly: typeOnly } :
                        importKind === 0 /* Named */ ? { namedImports: [symbolName], typeOnly: typeOnly } :
                            { namespaceLikeImport: { importKind: importKind, name: symbolName }, typeOnly: typeOnly };
                    ts.insertImports(changes, sourceFile, getDeclarations(moduleSpecifier, quotePreference, importsCollection), /*blankLineBetween*/ true);
                    return [importKind === 1 /* Default */ ? ts.Diagnostics.Import_default_0_from_module_1 : ts.Diagnostics.Import_0_from_module_1, symbolName, moduleSpecifier];
                }
                default:
                    return ts.Debug.assertNever(fix, "Unexpected fix kind " + fix.kind);
            }
        }
        function doAddExistingFix(changes, sourceFile, clause, defaultImport, namedImports, canUseTypeOnlyImport) {
            if (clause.kind === 199 /* ObjectBindingPattern */) {
                if (defaultImport) {
                    addElementToBindingPattern(clause, defaultImport, "default");
                }
                for (var _i = 0, namedImports_1 = namedImports; _i < namedImports_1.length; _i++) {
                    var specifier = namedImports_1[_i];
                    addElementToBindingPattern(clause, specifier, /*propertyName*/ undefined);
                }
                return;
            }
            var convertTypeOnlyToRegular = !canUseTypeOnlyImport && clause.isTypeOnly;
            if (defaultImport) {
                ts.Debug.assert(!clause.name, "Cannot add a default import to an import clause that already has one");
                changes.insertNodeAt(sourceFile, clause.getStart(sourceFile), ts.factory.createIdentifier(defaultImport), { suffix: ", " });
            }
            if (namedImports.length) {
                var existingSpecifiers = clause.namedBindings && ts.cast(clause.namedBindings, ts.isNamedImports).elements;
                var newSpecifiers = ts.stableSort(namedImports.map(function (name) { return ts.factory.createImportSpecifier(/*propertyName*/ undefined, ts.factory.createIdentifier(name)); }), ts.OrganizeImports.compareImportOrExportSpecifiers);
                if ((existingSpecifiers === null || existingSpecifiers === void 0 ? void 0 : existingSpecifiers.length) && ts.OrganizeImports.importSpecifiersAreSorted(existingSpecifiers)) {
                    for (var _a = 0, newSpecifiers_1 = newSpecifiers; _a < newSpecifiers_1.length; _a++) {
                        var spec = newSpecifiers_1[_a];
                        var insertionIndex = ts.OrganizeImports.getImportSpecifierInsertionIndex(existingSpecifiers, spec);
                        var prevSpecifier = clause.namedBindings.elements[insertionIndex - 1];
                        if (prevSpecifier) {
                            changes.insertNodeInListAfter(sourceFile, prevSpecifier, spec);
                        }
                        else {
                            changes.insertNodeBefore(sourceFile, existingSpecifiers[0], spec, !ts.positionsAreOnSameLine(existingSpecifiers[0].getStart(), clause.parent.getStart(), sourceFile));
                        }
                    }
                }
                else if (existingSpecifiers === null || existingSpecifiers === void 0 ? void 0 : existingSpecifiers.length) {
                    for (var _b = 0, newSpecifiers_2 = newSpecifiers; _b < newSpecifiers_2.length; _b++) {
                        var spec = newSpecifiers_2[_b];
                        changes.insertNodeInListAfter(sourceFile, ts.last(existingSpecifiers), spec, existingSpecifiers);
                    }
                }
                else {
                    if (newSpecifiers.length) {
                        var namedImports_2 = ts.factory.createNamedImports(newSpecifiers);
                        if (clause.namedBindings) {
                            changes.replaceNode(sourceFile, clause.namedBindings, namedImports_2);
                        }
                        else {
                            changes.insertNodeAfter(sourceFile, ts.Debug.checkDefined(clause.name, "Import clause must have either named imports or a default import"), namedImports_2);
                        }
                    }
                }
            }
            if (convertTypeOnlyToRegular) {
                changes.delete(sourceFile, ts.getTypeKeywordOfTypeOnlyImport(clause, sourceFile));
            }
            function addElementToBindingPattern(bindingPattern, name, propertyName) {
                var element = ts.factory.createBindingElement(/*dotDotDotToken*/ undefined, propertyName, name);
                if (bindingPattern.elements.length) {
                    changes.insertNodeInListAfter(sourceFile, ts.last(bindingPattern.elements), element);
                }
                else {
                    changes.replaceNode(sourceFile, bindingPattern, ts.factory.createObjectBindingPattern([element]));
                }
            }
        }
        function addNamespaceQualifier(changes, sourceFile, _a) {
            var namespacePrefix = _a.namespacePrefix, position = _a.position;
            changes.insertText(sourceFile, position, namespacePrefix + ".");
        }
        function addImportType(changes, sourceFile, _a, quotePreference) {
            var moduleSpecifier = _a.moduleSpecifier, position = _a.position;
            changes.insertText(sourceFile, position, getImportTypePrefix(moduleSpecifier, quotePreference));
        }
        function getImportTypePrefix(moduleSpecifier, quotePreference) {
            var quote = ts.getQuoteFromPreference(quotePreference);
            return "import(" + quote + moduleSpecifier + quote + ").";
        }
        function getNewImports(moduleSpecifier, quotePreference, imports) {
            var _a, _b;
            var quotedModuleSpecifier = ts.makeStringLiteral(moduleSpecifier, quotePreference);
            var statements;
            if (imports.defaultImport !== undefined || ((_a = imports.namedImports) === null || _a === void 0 ? void 0 : _a.length)) {
                statements = ts.combine(statements, ts.makeImport(imports.defaultImport === undefined ? undefined : ts.factory.createIdentifier(imports.defaultImport), (_b = imports.namedImports) === null || _b === void 0 ? void 0 : _b.map(function (n) { return ts.factory.createImportSpecifier(/*propertyName*/ undefined, ts.factory.createIdentifier(n)); }), moduleSpecifier, quotePreference, imports.typeOnly));
            }
            var namespaceLikeImport = imports.namespaceLikeImport, typeOnly = imports.typeOnly;
            if (namespaceLikeImport) {
                var declaration = namespaceLikeImport.importKind === 3 /* CommonJS */
                    ? ts.factory.createImportEqualsDeclaration(
                    /*decorators*/ undefined, 
                    /*modifiers*/ undefined, typeOnly, ts.factory.createIdentifier(namespaceLikeImport.name), ts.factory.createExternalModuleReference(quotedModuleSpecifier))
                    : ts.factory.createImportDeclaration(
                    /*decorators*/ undefined, 
                    /*modifiers*/ undefined, ts.factory.createImportClause(typeOnly, 
                    /*name*/ undefined, ts.factory.createNamespaceImport(ts.factory.createIdentifier(namespaceLikeImport.name))), quotedModuleSpecifier);
                statements = ts.combine(statements, declaration);
            }
            return ts.Debug.checkDefined(statements);
        }
        function getNewRequires(moduleSpecifier, quotePreference, imports) {
            var _a, _b;
            var quotedModuleSpecifier = ts.makeStringLiteral(moduleSpecifier, quotePreference);
            var statements;
            // const { default: foo, bar, etc } = require('./mod');
            if (imports.defaultImport || ((_a = imports.namedImports) === null || _a === void 0 ? void 0 : _a.length)) {
                var bindingElements = ((_b = imports.namedImports) === null || _b === void 0 ? void 0 : _b.map(function (name) { return ts.factory.createBindingElement(/*dotDotDotToken*/ undefined, /*propertyName*/ undefined, name); })) || [];
                if (imports.defaultImport) {
                    bindingElements.unshift(ts.factory.createBindingElement(/*dotDotDotToken*/ undefined, "default", imports.defaultImport));
                }
                var declaration = createConstEqualsRequireDeclaration(ts.factory.createObjectBindingPattern(bindingElements), quotedModuleSpecifier);
                statements = ts.combine(statements, declaration);
            }
            // const foo = require('./mod');
            if (imports.namespaceLikeImport) {
                var declaration = createConstEqualsRequireDeclaration(imports.namespaceLikeImport.name, quotedModuleSpecifier);
                statements = ts.combine(statements, declaration);
            }
            return ts.Debug.checkDefined(statements);
        }
        function createConstEqualsRequireDeclaration(name, quotedModuleSpecifier) {
            return ts.factory.createVariableStatement(
            /*modifiers*/ undefined, ts.factory.createVariableDeclarationList([
                ts.factory.createVariableDeclaration(typeof name === "string" ? ts.factory.createIdentifier(name) : name, 
                /*exclamationToken*/ undefined, 
                /*type*/ undefined, ts.factory.createCallExpression(ts.factory.createIdentifier("require"), /*typeArguments*/ undefined, [quotedModuleSpecifier]))
            ], 2 /* Const */));
        }
        function symbolHasMeaning(_a, meaning) {
            var declarations = _a.declarations;
            return ts.some(declarations, function (decl) { return !!(ts.getMeaningFromDeclaration(decl) & meaning); });
        }
        function moduleSymbolToValidIdentifier(moduleSymbol, target) {
            return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);
        }
        codefix.moduleSymbolToValidIdentifier = moduleSymbolToValidIdentifier;
        function moduleSpecifierToValidIdentifier(moduleSpecifier, target) {
            var baseName = ts.getBaseFileName(ts.removeSuffix(moduleSpecifier, "/index"));
            var res = "";
            var lastCharWasValid = true;
            var firstCharCode = baseName.charCodeAt(0);
            if (ts.isIdentifierStart(firstCharCode, target)) {
                res += String.fromCharCode(firstCharCode);
            }
            else {
                lastCharWasValid = false;
            }
            for (var i = 1; i < baseName.length; i++) {
                var ch = baseName.charCodeAt(i);
                var isValid = ts.isIdentifierPart(ch, target);
                if (isValid) {
                    var char = String.fromCharCode(ch);
                    if (!lastCharWasValid) {
                        char = char.toUpperCase();
                    }
                    res += char;
                }
                lastCharWasValid = isValid;
            }
            // Need `|| "_"` to ensure result isn't empty.
            return !ts.isStringANonContextualKeyword(res) ? res || "_" : "_" + res;
        }
        codefix.moduleSpecifierToValidIdentifier = moduleSpecifierToValidIdentifier;
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var _a;
        var fixName = "fixOverrideModifier";
        var fixAddOverrideId = "fixAddOverrideModifier";
        var fixRemoveOverrideId = "fixRemoveOverrideModifier";
        var errorCodes = [
            ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0.code,
            ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class.code,
            ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0.code,
            ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0.code,
            ts.Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0.code
        ];
        var errorCodeFixIdMap = (_a = {},
            _a[ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0.code] = [
                ts.Diagnostics.Add_override_modifier, fixAddOverrideId, ts.Diagnostics.Add_all_missing_override_modifiers,
            ],
            _a[ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class.code] = [
                ts.Diagnostics.Remove_override_modifier, fixRemoveOverrideId, ts.Diagnostics.Remove_all_unnecessary_override_modifiers
            ],
            _a[ts.Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0.code] = [
                ts.Diagnostics.Add_override_modifier, fixAddOverrideId, ts.Diagnostics.Add_all_missing_override_modifiers,
            ],
            _a[ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0.code] = [
                ts.Diagnostics.Add_override_modifier, fixAddOverrideId, ts.Diagnostics.Remove_all_unnecessary_override_modifiers
            ],
            _a[ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0.code] = [
                ts.Diagnostics.Remove_override_modifier, fixRemoveOverrideId, ts.Diagnostics.Remove_all_unnecessary_override_modifiers
            ],
            _a);
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var errorCode = context.errorCode, span = context.span, sourceFile = context.sourceFile;
                var info = errorCodeFixIdMap[errorCode];
                if (!info)
                    return ts.emptyArray;
                var descriptions = info[0], fixId = info[1], fixAllDescriptions = info[2];
                if (ts.isSourceFileJS(sourceFile))
                    return ts.emptyArray;
                var changes = ts.textChanges.ChangeTracker.with(context, function (changes) { return dispatchChanges(changes, context, errorCode, span.start); });
                return [
                    codefix.createCodeFixActionMaybeFixAll(fixName, changes, descriptions, fixId, fixAllDescriptions)
                ];
            },
            fixIds: [fixName, fixAddOverrideId, fixRemoveOverrideId],
            getAllCodeActions: function (context) {
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                    var code = diag.code, start = diag.start, file = diag.file;
                    var info = errorCodeFixIdMap[code];
                    if (!info || info[1] !== context.fixId || ts.isSourceFileJS(file)) {
                        return;
                    }
                    dispatchChanges(changes, context, code, start);
                });
            }
        });
        function dispatchChanges(changeTracker, context, errorCode, pos) {
            switch (errorCode) {
                case ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0.code:
                case ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0.code:
                case ts.Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0.code:
                    return doAddOverrideModifierChange(changeTracker, context.sourceFile, pos);
                case ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0.code:
                case ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class.code:
                    return doRemoveOverrideModifierChange(changeTracker, context.sourceFile, pos);
                default:
                    ts.Debug.fail("Unexpected error code: " + errorCode);
            }
        }
        function doAddOverrideModifierChange(changeTracker, sourceFile, pos) {
            var classElement = findContainerClassElementLike(sourceFile, pos);
            var modifiers = classElement.modifiers || ts.emptyArray;
            var staticModifier = ts.find(modifiers, ts.isStaticModifier);
            var abstractModifier = ts.find(modifiers, ts.isAbstractModifier);
            var accessibilityModifier = ts.find(modifiers, function (m) { return ts.isAccessibilityModifier(m.kind); });
            var modifierPos = abstractModifier ? abstractModifier.end :
                staticModifier ? staticModifier.end :
                    accessibilityModifier ? accessibilityModifier.end :
                        classElement.decorators ? ts.skipTrivia(sourceFile.text, classElement.decorators.end) : classElement.getStart(sourceFile);
            var options = accessibilityModifier || staticModifier || abstractModifier ? { prefix: " " } : { suffix: " " };
            changeTracker.insertModifierAt(sourceFile, modifierPos, 157 /* OverrideKeyword */, options);
        }
        function doRemoveOverrideModifierChange(changeTracker, sourceFile, pos) {
            var classElement = findContainerClassElementLike(sourceFile, pos);
            var overrideModifier = classElement.modifiers && ts.find(classElement.modifiers, function (modifier) { return modifier.kind === 157 /* OverrideKeyword */; });
            ts.Debug.assertIsDefined(overrideModifier);
            changeTracker.deleteModifier(sourceFile, overrideModifier);
        }
        function isClassElementLikeHasJSDoc(node) {
            switch (node.kind) {
                case 169 /* Constructor */:
                case 165 /* PropertyDeclaration */:
                case 167 /* MethodDeclaration */:
                case 170 /* GetAccessor */:
                case 171 /* SetAccessor */:
                    return true;
                case 162 /* Parameter */:
                    return ts.isParameterPropertyDeclaration(node, node.parent);
                default:
                    return false;
            }
        }
        function findContainerClassElementLike(sourceFile, pos) {
            var token = ts.getTokenAtPosition(sourceFile, pos);
            var classElement = ts.findAncestor(token, function (node) {
                if (ts.isClassLike(node))
                    return "quit";
                return isClassElementLikeHasJSDoc(node);
            });
            ts.Debug.assert(classElement && isClassElementLikeHasJSDoc(classElement));
            return classElement;
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "fixNoPropertyAccessFromIndexSignature";
        var errorCodes = [
            ts.Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0.code
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            fixIds: [fixId],
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span, preferences = context.preferences;
                var property = getPropertyAccessExpression(sourceFile, span.start);
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, context.sourceFile, property, preferences); });
                return [codefix.createCodeFixAction(fixId, changes, [ts.Diagnostics.Use_element_access_for_0, property.name.text], fixId, ts.Diagnostics.Use_element_access_for_all_undeclared_properties)];
            },
            getAllCodeActions: function (context) {
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) { return doChange(changes, diag.file, getPropertyAccessExpression(diag.file, diag.start), context.preferences); });
            }
        });
        function doChange(changes, sourceFile, node, preferences) {
            var quotePreference = ts.getQuotePreference(sourceFile, preferences);
            var argumentsExpression = ts.factory.createStringLiteral(node.name.text, quotePreference === 0 /* Single */);
            changes.replaceNode(sourceFile, node, ts.isPropertyAccessChain(node) ?
                ts.factory.createElementAccessChain(node.expression, node.questionDotToken, argumentsExpression) :
                ts.factory.createElementAccessExpression(node.expression, argumentsExpression));
        }
        function getPropertyAccessExpression(sourceFile, pos) {
            return ts.cast(ts.getTokenAtPosition(sourceFile, pos).parent, ts.isPropertyAccessExpression);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "fixImplicitThis";
        var errorCodes = [ts.Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, program = context.program, span = context.span;
                var diagnostic;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) {
                    diagnostic = doChange(t, sourceFile, span.start, program.getTypeChecker());
                });
                return diagnostic ? [codefix.createCodeFixAction(fixId, changes, diagnostic, fixId, ts.Diagnostics.Fix_all_implicit_this_errors)] : ts.emptyArray;
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                doChange(changes, diag.file, diag.start, context.program.getTypeChecker());
            }); },
        });
        function doChange(changes, sourceFile, pos, checker) {
            var token = ts.getTokenAtPosition(sourceFile, pos);
            ts.Debug.assert(token.kind === 108 /* ThisKeyword */);
            var fn = ts.getThisContainer(token, /*includeArrowFunctions*/ false);
            if (!ts.isFunctionDeclaration(fn) && !ts.isFunctionExpression(fn))
                return undefined;
            if (!ts.isSourceFile(ts.getThisContainer(fn, /*includeArrowFunctions*/ false))) { // 'this' is defined outside, convert to arrow function
                var fnKeyword = ts.Debug.assertDefined(ts.findChildOfKind(fn, 98 /* FunctionKeyword */, sourceFile));
                var name = fn.name;
                var body = ts.Debug.assertDefined(fn.body); // Should be defined because the function contained a 'this' expression
                if (ts.isFunctionExpression(fn)) {
                    if (name && ts.FindAllReferences.Core.isSymbolReferencedInFile(name, checker, sourceFile, body)) {
                        // Function expression references itself. To fix we would have to extract it to a const.
                        return undefined;
                    }
                    // `function() {}` --> `() => {}`
                    changes.delete(sourceFile, fnKeyword);
                    if (name) {
                        changes.delete(sourceFile, name);
                    }
                    changes.insertText(sourceFile, body.pos, " =>");
                    return [ts.Diagnostics.Convert_function_expression_0_to_arrow_function, name ? name.text : ts.ANONYMOUS];
                }
                else {
                    // `function f() {}` => `const f = () => {}`
                    // `name` should be defined because we only do this in inner contexts, and name is only undefined for `export default function() {}`.
                    changes.replaceNode(sourceFile, fnKeyword, ts.factory.createToken(85 /* ConstKeyword */));
                    changes.insertText(sourceFile, name.end, " = ");
                    changes.insertText(sourceFile, body.pos, " =>");
                    return [ts.Diagnostics.Convert_function_declaration_0_to_arrow_function, name.text];
                }
            }
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "fixIncorrectNamedTupleSyntax";
        var errorCodes = [
            ts.Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type.code,
            ts.Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type.code
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span;
                var namedTupleMember = getNamedTupleMember(sourceFile, span.start);
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, namedTupleMember); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Move_labeled_tuple_element_modifiers_to_labels, fixId, ts.Diagnostics.Move_labeled_tuple_element_modifiers_to_labels)];
            },
            fixIds: [fixId]
        });
        function getNamedTupleMember(sourceFile, pos) {
            var token = ts.getTokenAtPosition(sourceFile, pos);
            return ts.findAncestor(token, function (t) { return t.kind === 195 /* NamedTupleMember */; });
        }
        function doChange(changes, sourceFile, namedTupleMember) {
            if (!namedTupleMember) {
                return;
            }
            var unwrappedType = namedTupleMember.type;
            var sawOptional = false;
            var sawRest = false;
            while (unwrappedType.kind === 183 /* OptionalType */ || unwrappedType.kind === 184 /* RestType */ || unwrappedType.kind === 189 /* ParenthesizedType */) {
                if (unwrappedType.kind === 183 /* OptionalType */) {
                    sawOptional = true;
                }
                else if (unwrappedType.kind === 184 /* RestType */) {
                    sawRest = true;
                }
                unwrappedType = unwrappedType.type;
            }
            var updated = ts.factory.updateNamedTupleMember(namedTupleMember, namedTupleMember.dotDotDotToken || (sawRest ? ts.factory.createToken(25 /* DotDotDotToken */) : undefined), namedTupleMember.name, namedTupleMember.questionToken || (sawOptional ? ts.factory.createToken(57 /* QuestionToken */) : undefined), unwrappedType);
            if (updated === namedTupleMember) {
                return;
            }
            changes.replaceNode(sourceFile, namedTupleMember, updated);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "fixSpelling";
        var errorCodes = [
            ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2.code,
            ts.Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code,
            ts.Diagnostics.Cannot_find_name_0_Did_you_mean_1.code,
            ts.Diagnostics.Could_not_find_name_0_Did_you_mean_1.code,
            ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0.code,
            ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0.code,
            ts.Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2.code,
            ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1.code,
            // for JSX class components
            ts.Diagnostics.No_overload_matches_this_call.code,
            // for JSX FC
            ts.Diagnostics.Type_0_is_not_assignable_to_type_1.code,
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, errorCode = context.errorCode;
                var info = getInfo(sourceFile, context.span.start, context, errorCode);
                if (!info)
                    return undefined;
                var node = info.node, suggestedSymbol = info.suggestedSymbol;
                var target = context.host.getCompilationSettings().target;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, node, suggestedSymbol, target); });
                return [codefix.createCodeFixAction("spelling", changes, [ts.Diagnostics.Change_spelling_to_0, ts.symbolName(suggestedSymbol)], fixId, ts.Diagnostics.Fix_all_detected_spelling_errors)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var info = getInfo(diag.file, diag.start, context, diag.code);
                var target = context.host.getCompilationSettings().target;
                if (info)
                    doChange(changes, context.sourceFile, info.node, info.suggestedSymbol, target);
            }); },
        });
        function getInfo(sourceFile, pos, context, errorCode) {
            // This is the identifier of the misspelled word. eg:
            // this.speling = 1;
            //      ^^^^^^^
            var node = ts.getTokenAtPosition(sourceFile, pos);
            var parent = node.parent;
            // Only fix spelling for No_overload_matches_this_call emitted on the React class component
            if ((errorCode === ts.Diagnostics.No_overload_matches_this_call.code ||
                errorCode === ts.Diagnostics.Type_0_is_not_assignable_to_type_1.code) &&
                !ts.isJsxAttribute(parent))
                return undefined;
            var checker = context.program.getTypeChecker();
            var suggestedSymbol;
            if (ts.isPropertyAccessExpression(parent) && parent.name === node) {
                ts.Debug.assert(ts.isMemberName(node), "Expected an identifier for spelling (property access)");
                var containingType = checker.getTypeAtLocation(parent.expression);
                if (parent.flags & 32 /* OptionalChain */) {
                    containingType = checker.getNonNullableType(containingType);
                }
                suggestedSymbol = checker.getSuggestedSymbolForNonexistentProperty(node, containingType);
            }
            else if (ts.isQualifiedName(parent) && parent.right === node) {
                var symbol = checker.getSymbolAtLocation(parent.left);
                if (symbol && symbol.flags & 1536 /* Module */) {
                    suggestedSymbol = checker.getSuggestedSymbolForNonexistentModule(parent.right, symbol);
                }
            }
            else if (ts.isImportSpecifier(parent) && parent.name === node) {
                ts.Debug.assertNode(node, ts.isIdentifier, "Expected an identifier for spelling (import)");
                var importDeclaration = ts.findAncestor(node, ts.isImportDeclaration);
                var resolvedSourceFile = getResolvedSourceFileFromImportDeclaration(sourceFile, context, importDeclaration);
                if (resolvedSourceFile && resolvedSourceFile.symbol) {
                    suggestedSymbol = checker.getSuggestedSymbolForNonexistentModule(node, resolvedSourceFile.symbol);
                }
            }
            else if (ts.isJsxAttribute(parent) && parent.name === node) {
                ts.Debug.assertNode(node, ts.isIdentifier, "Expected an identifier for JSX attribute");
                var tag = ts.findAncestor(node, ts.isJsxOpeningLikeElement);
                var props = checker.getContextualTypeForArgumentAtIndex(tag, 0);
                suggestedSymbol = checker.getSuggestedSymbolForNonexistentJSXAttribute(node, props);
            }
            else if (ts.hasSyntacticModifier(parent, 16384 /* Override */) && ts.isClassElement(parent) && parent.name === node) {
                var baseDeclaration = ts.findAncestor(node, ts.isClassLike);
                var baseTypeNode = baseDeclaration ? ts.getEffectiveBaseTypeNode(baseDeclaration) : undefined;
                var baseType = baseTypeNode ? checker.getTypeAtLocation(baseTypeNode) : undefined;
                if (baseType) {
                    suggestedSymbol = checker.getSuggestedSymbolForNonexistentClassMember(ts.getTextOfNode(node), baseType);
                }
            }
            else {
                var meaning = ts.getMeaningFromLocation(node);
                var name = ts.getTextOfNode(node);
                ts.Debug.assert(name !== undefined, "name should be defined");
                suggestedSymbol = checker.getSuggestedSymbolForNonexistentSymbol(node, name, convertSemanticMeaningToSymbolFlags(meaning));
            }
            return suggestedSymbol === undefined ? undefined : { node: node, suggestedSymbol: suggestedSymbol };
        }
        function doChange(changes, sourceFile, node, suggestedSymbol, target) {
            var suggestion = ts.symbolName(suggestedSymbol);
            if (!ts.isIdentifierText(suggestion, target) && ts.isPropertyAccessExpression(node.parent)) {
                var valDecl = suggestedSymbol.valueDeclaration;
                if (valDecl && ts.isNamedDeclaration(valDecl) && ts.isPrivateIdentifier(valDecl.name)) {
                    changes.replaceNode(sourceFile, node, ts.factory.createIdentifier(suggestion));
                }
                else {
                    changes.replaceNode(sourceFile, node.parent, ts.factory.createElementAccessExpression(node.parent.expression, ts.factory.createStringLiteral(suggestion)));
                }
            }
            else {
                changes.replaceNode(sourceFile, node, ts.factory.createIdentifier(suggestion));
            }
        }
        function convertSemanticMeaningToSymbolFlags(meaning) {
            var flags = 0;
            if (meaning & 4 /* Namespace */) {
                flags |= 1920 /* Namespace */;
            }
            if (meaning & 2 /* Type */) {
                flags |= 788968 /* Type */;
            }
            if (meaning & 1 /* Value */) {
                flags |= 111551 /* Value */;
            }
            return flags;
        }
        function getResolvedSourceFileFromImportDeclaration(sourceFile, context, importDeclaration) {
            if (!importDeclaration || !ts.isStringLiteralLike(importDeclaration.moduleSpecifier))
                return undefined;
            var resolvedModule = ts.getResolvedModule(sourceFile, importDeclaration.moduleSpecifier.text);
            if (!resolvedModule)
                return undefined;
            return context.program.getSourceFile(resolvedModule.resolvedFileName);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "returnValueCorrect";
        var fixIdAddReturnStatement = "fixAddReturnStatement";
        var fixRemoveBracesFromArrowFunctionBody = "fixRemoveBracesFromArrowFunctionBody";
        var fixIdWrapTheBlockWithParen = "fixWrapTheBlockWithParen";
        var errorCodes = [
            ts.Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value.code,
            ts.Diagnostics.Type_0_is_not_assignable_to_type_1.code,
            ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1.code
        ];
        var ProblemKind;
        (function (ProblemKind) {
            ProblemKind[ProblemKind["MissingReturnStatement"] = 0] = "MissingReturnStatement";
            ProblemKind[ProblemKind["MissingParentheses"] = 1] = "MissingParentheses";
        })(ProblemKind || (ProblemKind = {}));
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            fixIds: [fixIdAddReturnStatement, fixRemoveBracesFromArrowFunctionBody, fixIdWrapTheBlockWithParen],
            getCodeActions: function (context) {
                var program = context.program, sourceFile = context.sourceFile, start = context.span.start, errorCode = context.errorCode;
                var info = getInfo(program.getTypeChecker(), sourceFile, start, errorCode);
                if (!info)
                    return undefined;
                if (info.kind === ProblemKind.MissingReturnStatement) {
                    return ts.append([getActionForfixAddReturnStatement(context, info.expression, info.statement)], ts.isArrowFunction(info.declaration) ? getActionForFixRemoveBracesFromArrowFunctionBody(context, info.declaration, info.expression, info.commentSource) : undefined);
                }
                else {
                    return [getActionForfixWrapTheBlockWithParen(context, info.declaration, info.expression)];
                }
            },
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                var info = getInfo(context.program.getTypeChecker(), diag.file, diag.start, diag.code);
                if (!info)
                    return undefined;
                switch (context.fixId) {
                    case fixIdAddReturnStatement:
                        addReturnStatement(changes, diag.file, info.expression, info.statement);
                        break;
                    case fixRemoveBracesFromArrowFunctionBody:
                        if (!ts.isArrowFunction(info.declaration))
                            return undefined;
                        removeBlockBodyBrace(changes, diag.file, info.declaration, info.expression, info.commentSource, /* withParen */ false);
                        break;
                    case fixIdWrapTheBlockWithParen:
                        if (!ts.isArrowFunction(info.declaration))
                            return undefined;
                        wrapBlockWithParen(changes, diag.file, info.declaration, info.expression);
                        break;
                    default:
                        ts.Debug.fail(JSON.stringify(context.fixId));
                }
            }); },
        });
        function createObjectTypeFromLabeledExpression(checker, label, expression) {
            var member = checker.createSymbol(4 /* Property */, label.escapedText);
            member.type = checker.getTypeAtLocation(expression);
            var members = ts.createSymbolTable([member]);
            return checker.createAnonymousType(/*symbol*/ undefined, members, [], [], []);
        }
        function getFixInfo(checker, declaration, expectType, isFunctionType) {
            if (!declaration.body || !ts.isBlock(declaration.body) || ts.length(declaration.body.statements) !== 1)
                return undefined;
            var firstStatement = ts.first(declaration.body.statements);
            if (ts.isExpressionStatement(firstStatement) && checkFixedAssignableTo(checker, declaration, checker.getTypeAtLocation(firstStatement.expression), expectType, isFunctionType)) {
                return {
                    declaration: declaration,
                    kind: ProblemKind.MissingReturnStatement,
                    expression: firstStatement.expression,
                    statement: firstStatement,
                    commentSource: firstStatement.expression
                };
            }
            else if (ts.isLabeledStatement(firstStatement) && ts.isExpressionStatement(firstStatement.statement)) {
                var node = ts.factory.createObjectLiteralExpression([ts.factory.createPropertyAssignment(firstStatement.label, firstStatement.statement.expression)]);
                var nodeType = createObjectTypeFromLabeledExpression(checker, firstStatement.label, firstStatement.statement.expression);
                if (checkFixedAssignableTo(checker, declaration, nodeType, expectType, isFunctionType)) {
                    return ts.isArrowFunction(declaration) ? {
                        declaration: declaration,
                        kind: ProblemKind.MissingParentheses,
                        expression: node,
                        statement: firstStatement,
                        commentSource: firstStatement.statement.expression
                    } : {
                        declaration: declaration,
                        kind: ProblemKind.MissingReturnStatement,
                        expression: node,
                        statement: firstStatement,
                        commentSource: firstStatement.statement.expression
                    };
                }
            }
            else if (ts.isBlock(firstStatement) && ts.length(firstStatement.statements) === 1) {
                var firstBlockStatement = ts.first(firstStatement.statements);
                if (ts.isLabeledStatement(firstBlockStatement) && ts.isExpressionStatement(firstBlockStatement.statement)) {
                    var node = ts.factory.createObjectLiteralExpression([ts.factory.createPropertyAssignment(firstBlockStatement.label, firstBlockStatement.statement.expression)]);
                    var nodeType = createObjectTypeFromLabeledExpression(checker, firstBlockStatement.label, firstBlockStatement.statement.expression);
                    if (checkFixedAssignableTo(checker, declaration, nodeType, expectType, isFunctionType)) {
                        return {
                            declaration: declaration,
                            kind: ProblemKind.MissingReturnStatement,
                            expression: node,
                            statement: firstStatement,
                            commentSource: firstBlockStatement
                        };
                    }
                }
            }
            return undefined;
        }
        function checkFixedAssignableTo(checker, declaration, exprType, type, isFunctionType) {
            if (isFunctionType) {
                var sig = checker.getSignatureFromDeclaration(declaration);
                if (sig) {
                    if (ts.hasSyntacticModifier(declaration, 256 /* Async */)) {
                        exprType = checker.createPromiseType(exprType);
                    }
                    var newSig = checker.createSignature(declaration, sig.typeParameters, sig.thisParameter, sig.parameters, exprType, 
                    /*typePredicate*/ undefined, sig.minArgumentCount, sig.flags);
                    exprType = checker.createAnonymousType(
                    /*symbol*/ undefined, ts.createSymbolTable(), [newSig], [], []);
                }
                else {
                    exprType = checker.getAnyType();
                }
            }
            return checker.isTypeAssignableTo(exprType, type);
        }
        function getInfo(checker, sourceFile, position, errorCode) {
            var node = ts.getTokenAtPosition(sourceFile, position);
            if (!node.parent)
                return undefined;
            var declaration = ts.findAncestor(node.parent, ts.isFunctionLikeDeclaration);
            switch (errorCode) {
                case ts.Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value.code:
                    if (!declaration || !declaration.body || !declaration.type || !ts.rangeContainsRange(declaration.type, node))
                        return undefined;
                    return getFixInfo(checker, declaration, checker.getTypeFromTypeNode(declaration.type), /* isFunctionType */ false);
                case ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1.code:
                    if (!declaration || !ts.isCallExpression(declaration.parent) || !declaration.body)
                        return undefined;
                    var pos = declaration.parent.arguments.indexOf(declaration);
                    var type = checker.getContextualTypeForArgumentAtIndex(declaration.parent, pos);
                    if (!type)
                        return undefined;
                    return getFixInfo(checker, declaration, type, /* isFunctionType */ true);
                case ts.Diagnostics.Type_0_is_not_assignable_to_type_1.code:
                    if (!ts.isDeclarationName(node) || !ts.isVariableLike(node.parent) && !ts.isJsxAttribute(node.parent))
                        return undefined;
                    var initializer = getVariableLikeInitializer(node.parent);
                    if (!initializer || !ts.isFunctionLikeDeclaration(initializer) || !initializer.body)
                        return undefined;
                    return getFixInfo(checker, initializer, checker.getTypeAtLocation(node.parent), /* isFunctionType */ true);
            }
            return undefined;
        }
        function getVariableLikeInitializer(declaration) {
            switch (declaration.kind) {
                case 252 /* VariableDeclaration */:
                case 162 /* Parameter */:
                case 201 /* BindingElement */:
                case 165 /* PropertyDeclaration */:
                case 291 /* PropertyAssignment */:
                    return declaration.initializer;
                case 283 /* JsxAttribute */:
                    return declaration.initializer && (ts.isJsxExpression(declaration.initializer) ? declaration.initializer.expression : undefined);
                case 292 /* ShorthandPropertyAssignment */:
                case 164 /* PropertySignature */:
                case 294 /* EnumMember */:
                case 342 /* JSDocPropertyTag */:
                case 335 /* JSDocParameterTag */:
                    return undefined;
            }
        }
        function addReturnStatement(changes, sourceFile, expression, statement) {
            ts.suppressLeadingAndTrailingTrivia(expression);
            var probablyNeedSemi = ts.probablyUsesSemicolons(sourceFile);
            changes.replaceNode(sourceFile, statement, ts.factory.createReturnStatement(expression), {
                leadingTriviaOption: ts.textChanges.LeadingTriviaOption.Exclude,
                trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude,
                suffix: probablyNeedSemi ? ";" : undefined
            });
        }
        function removeBlockBodyBrace(changes, sourceFile, declaration, expression, commentSource, withParen) {
            var newBody = (withParen || ts.needsParentheses(expression)) ? ts.factory.createParenthesizedExpression(expression) : expression;
            ts.suppressLeadingAndTrailingTrivia(commentSource);
            ts.copyComments(commentSource, newBody);
            changes.replaceNode(sourceFile, declaration.body, newBody);
        }
        function wrapBlockWithParen(changes, sourceFile, declaration, expression) {
            changes.replaceNode(sourceFile, declaration.body, ts.factory.createParenthesizedExpression(expression));
        }
        function getActionForfixAddReturnStatement(context, expression, statement) {
            var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return addReturnStatement(t, context.sourceFile, expression, statement); });
            return codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Add_a_return_statement, fixIdAddReturnStatement, ts.Diagnostics.Add_all_missing_return_statement);
        }
        function getActionForFixRemoveBracesFromArrowFunctionBody(context, declaration, expression, commentSource) {
            var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return removeBlockBodyBrace(t, context.sourceFile, declaration, expression, commentSource, /* withParen */ false); });
            return codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Remove_braces_from_arrow_function_body, fixRemoveBracesFromArrowFunctionBody, ts.Diagnostics.Remove_braces_from_all_arrow_function_bodies_with_relevant_issues);
        }
        function getActionForfixWrapTheBlockWithParen(context, declaration, expression) {
            var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return wrapBlockWithParen(t, context.sourceFile, declaration, expression); });
            return codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal, fixIdWrapTheBlockWithParen, ts.Diagnostics.Wrap_all_object_literal_with_parentheses);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixMissingMember = "fixMissingMember";
        var fixMissingProperties = "fixMissingProperties";
        var fixMissingAttributes = "fixMissingAttributes";
        var fixMissingFunctionDeclaration = "fixMissingFunctionDeclaration";
        var errorCodes = [
            ts.Diagnostics.Property_0_does_not_exist_on_type_1.code,
            ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2.code,
            ts.Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2.code,
            ts.Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2.code,
            ts.Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more.code,
            ts.Diagnostics.Cannot_find_name_0.code
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var typeChecker = context.program.getTypeChecker();
                var info = getInfo(context.sourceFile, context.span.start, typeChecker, context.program);
                if (!info) {
                    return undefined;
                }
                if (info.kind === 3 /* ObjectLiteral */) {
                    var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return addObjectLiteralProperties(t, context, info); });
                    return [codefix.createCodeFixAction(fixMissingProperties, changes, ts.Diagnostics.Add_missing_properties, fixMissingProperties, ts.Diagnostics.Add_all_missing_properties)];
                }
                if (info.kind === 4 /* JsxAttributes */) {
                    var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return addJsxAttributes(t, context, info); });
                    return [codefix.createCodeFixAction(fixMissingAttributes, changes, ts.Diagnostics.Add_missing_attributes, fixMissingAttributes, ts.Diagnostics.Add_all_missing_attributes)];
                }
                if (info.kind === 2 /* Function */) {
                    var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return addFunctionDeclaration(t, context, info); });
                    return [codefix.createCodeFixAction(fixMissingFunctionDeclaration, changes, [ts.Diagnostics.Add_missing_function_declaration_0, info.token.text], fixMissingFunctionDeclaration, ts.Diagnostics.Add_all_missing_function_declarations)];
                }
                if (info.kind === 0 /* Enum */) {
                    var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return addEnumMemberDeclaration(t, context.program.getTypeChecker(), info); });
                    return [codefix.createCodeFixAction(fixMissingMember, changes, [ts.Diagnostics.Add_missing_enum_member_0, info.token.text], fixMissingMember, ts.Diagnostics.Add_all_missing_members)];
                }
                return ts.concatenate(getActionsForMissingMethodDeclaration(context, info), getActionsForMissingMemberDeclaration(context, info));
            },
            fixIds: [fixMissingMember, fixMissingFunctionDeclaration, fixMissingProperties, fixMissingAttributes],
            getAllCodeActions: function (context) {
                var program = context.program, fixId = context.fixId;
                var checker = program.getTypeChecker();
                var seen = new ts.Map();
                var typeDeclToMembers = new ts.Map();
                return codefix.createCombinedCodeActions(ts.textChanges.ChangeTracker.with(context, function (changes) {
                    codefix.eachDiagnostic(context, errorCodes, function (diag) {
                        var info = getInfo(diag.file, diag.start, checker, context.program);
                        if (!info || !ts.addToSeen(seen, ts.getNodeId(info.parentDeclaration) + "#" + info.token.text)) {
                            return;
                        }
                        if (fixId === fixMissingFunctionDeclaration && info.kind === 2 /* Function */) {
                            addFunctionDeclaration(changes, context, info);
                        }
                        else if (fixId === fixMissingProperties && info.kind === 3 /* ObjectLiteral */) {
                            addObjectLiteralProperties(changes, context, info);
                        }
                        else if (fixId === fixMissingAttributes && info.kind === 4 /* JsxAttributes */) {
                            addJsxAttributes(changes, context, info);
                        }
                        else {
                            if (info.kind === 0 /* Enum */) {
                                addEnumMemberDeclaration(changes, checker, info);
                            }
                            if (info.kind === 1 /* ClassOrInterface */) {
                                var parentDeclaration = info.parentDeclaration, token_1 = info.token;
                                var infos = ts.getOrUpdate(typeDeclToMembers, parentDeclaration, function () { return []; });
                                if (!infos.some(function (i) { return i.token.text === token_1.text; })) {
                                    infos.push(info);
                                }
                            }
                        }
                    });
                    typeDeclToMembers.forEach(function (infos, classDeclaration) {
                        var supers = codefix.getAllSupers(classDeclaration, checker);
                        var _loop_14 = function (info) {
                            // If some superclass added this property, don't add it again.
                            if (supers.some(function (superClassOrInterface) {
                                var superInfos = typeDeclToMembers.get(superClassOrInterface);
                                return !!superInfos && superInfos.some(function (_a) {
                                    var token = _a.token;
                                    return token.text === info.token.text;
                                });
                            }))
                                return "continue";
                            var parentDeclaration = info.parentDeclaration, declSourceFile = info.declSourceFile, modifierFlags = info.modifierFlags, token = info.token, call = info.call, isJSFile = info.isJSFile;
                            // Always prefer to add a method declaration if possible.
                            if (call && !ts.isPrivateIdentifier(token)) {
                                addMethodDeclaration(context, changes, call, token, modifierFlags & 32 /* Static */, parentDeclaration, declSourceFile);
                            }
                            else {
                                if (isJSFile && !ts.isInterfaceDeclaration(parentDeclaration)) {
                                    addMissingMemberInJs(changes, declSourceFile, parentDeclaration, token, !!(modifierFlags & 32 /* Static */));
                                }
                                else {
                                    var typeNode = getTypeNode(program.getTypeChecker(), parentDeclaration, token);
                                    addPropertyDeclaration(changes, declSourceFile, parentDeclaration, token.text, typeNode, modifierFlags & 32 /* Static */);
                                }
                            }
                        };
                        for (var _i = 0, infos_1 = infos; _i < infos_1.length; _i++) {
                            var info = infos_1[_i];
                            _loop_14(info);
                        }
                    });
                }));
            },
        });
        var InfoKind;
        (function (InfoKind) {
            InfoKind[InfoKind["Enum"] = 0] = "Enum";
            InfoKind[InfoKind["ClassOrInterface"] = 1] = "ClassOrInterface";
            InfoKind[InfoKind["Function"] = 2] = "Function";
            InfoKind[InfoKind["ObjectLiteral"] = 3] = "ObjectLiteral";
            InfoKind[InfoKind["JsxAttributes"] = 4] = "JsxAttributes";
        })(InfoKind || (InfoKind = {}));
        function getInfo(sourceFile, tokenPos, checker, program) {
            // The identifier of the missing property. eg:
            // this.missing = 1;
            //      ^^^^^^^
            var token = ts.getTokenAtPosition(sourceFile, tokenPos);
            if (!ts.isIdentifier(token) && !ts.isPrivateIdentifier(token)) {
                return undefined;
            }
            var parent = token.parent;
            if (ts.isIdentifier(token) && ts.hasInitializer(parent) && parent.initializer && ts.isObjectLiteralExpression(parent.initializer)) {
                var properties = ts.arrayFrom(checker.getUnmatchedProperties(checker.getTypeAtLocation(parent.initializer), checker.getTypeAtLocation(token), /* requireOptionalProperties */ false, /* matchDiscriminantProperties */ false));
                if (ts.length(properties)) {
                    return { kind: 3 /* ObjectLiteral */, token: token, properties: properties, parentDeclaration: parent.initializer };
                }
            }
            if (ts.isIdentifier(token) && ts.isJsxOpeningLikeElement(token.parent)) {
                var attributes = getUnmatchedAttributes(checker, token.parent);
                if (ts.length(attributes)) {
                    return { kind: 4 /* JsxAttributes */, token: token, attributes: attributes, parentDeclaration: token.parent };
                }
            }
            if (ts.isIdentifier(token) && ts.isCallExpression(parent)) {
                return { kind: 2 /* Function */, token: token, call: parent, sourceFile: sourceFile, modifierFlags: 0 /* None */, parentDeclaration: sourceFile };
            }
            if (!ts.isPropertyAccessExpression(parent)) {
                return undefined;
            }
            var leftExpressionType = ts.skipConstraint(checker.getTypeAtLocation(parent.expression));
            var symbol = leftExpressionType.symbol;
            if (!symbol || !symbol.declarations) {
                return undefined;
            }
            if (ts.isIdentifier(token) && ts.isCallExpression(parent.parent)) {
                var moduleDeclaration = ts.find(symbol.declarations, ts.isModuleDeclaration);
                var moduleDeclarationSourceFile = moduleDeclaration === null || moduleDeclaration === void 0 ? void 0 : moduleDeclaration.getSourceFile();
                if (moduleDeclaration && moduleDeclarationSourceFile && !isSourceFileFromLibrary(program, moduleDeclarationSourceFile)) {
                    return { kind: 2 /* Function */, token: token, call: parent.parent, sourceFile: sourceFile, modifierFlags: 1 /* Export */, parentDeclaration: moduleDeclaration };
                }
                var moduleSourceFile = ts.find(symbol.declarations, ts.isSourceFile);
                if (sourceFile.commonJsModuleIndicator) {
                    return;
                }
                if (moduleSourceFile && !isSourceFileFromLibrary(program, moduleSourceFile)) {
                    return { kind: 2 /* Function */, token: token, call: parent.parent, sourceFile: moduleSourceFile, modifierFlags: 1 /* Export */, parentDeclaration: moduleSourceFile };
                }
            }
            var classDeclaration = ts.find(symbol.declarations, ts.isClassLike);
            // Don't suggest adding private identifiers to anything other than a class.
            if (!classDeclaration && ts.isPrivateIdentifier(token)) {
                return undefined;
            }
            // Prefer to change the class instead of the interface if they are merged
            var classOrInterface = classDeclaration || ts.find(symbol.declarations, ts.isInterfaceDeclaration);
            if (classOrInterface && !isSourceFileFromLibrary(program, classOrInterface.getSourceFile())) {
                var makeStatic = (leftExpressionType.target || leftExpressionType) !== checker.getDeclaredTypeOfSymbol(symbol);
                if (makeStatic && (ts.isPrivateIdentifier(token) || ts.isInterfaceDeclaration(classOrInterface))) {
                    return undefined;
                }
                var declSourceFile = classOrInterface.getSourceFile();
                var modifierFlags = (makeStatic ? 32 /* Static */ : 0) | (ts.startsWithUnderscore(token.text) ? 8 /* Private */ : 0);
                var isJSFile = ts.isSourceFileJS(declSourceFile);
                var call = ts.tryCast(parent.parent, ts.isCallExpression);
                return { kind: 1 /* ClassOrInterface */, token: token, call: call, modifierFlags: modifierFlags, parentDeclaration: classOrInterface, declSourceFile: declSourceFile, isJSFile: isJSFile };
            }
            var enumDeclaration = ts.find(symbol.declarations, ts.isEnumDeclaration);
            if (enumDeclaration && !ts.isPrivateIdentifier(token) && !isSourceFileFromLibrary(program, enumDeclaration.getSourceFile())) {
                return { kind: 0 /* Enum */, token: token, parentDeclaration: enumDeclaration };
            }
            return undefined;
        }
        function isSourceFileFromLibrary(program, node) {
            return program.isSourceFileFromExternalLibrary(node) || program.isSourceFileDefaultLibrary(node);
        }
        function getActionsForMissingMemberDeclaration(context, info) {
            return info.isJSFile ? ts.singleElementArray(createActionForAddMissingMemberInJavascriptFile(context, info)) :
                createActionsForAddMissingMemberInTypeScriptFile(context, info);
        }
        function createActionForAddMissingMemberInJavascriptFile(context, _a) {
            var parentDeclaration = _a.parentDeclaration, declSourceFile = _a.declSourceFile, modifierFlags = _a.modifierFlags, token = _a.token;
            if (ts.isInterfaceDeclaration(parentDeclaration)) {
                return undefined;
            }
            var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return addMissingMemberInJs(t, declSourceFile, parentDeclaration, token, !!(modifierFlags & 32 /* Static */)); });
            if (changes.length === 0) {
                return undefined;
            }
            var diagnostic = modifierFlags & 32 /* Static */ ? ts.Diagnostics.Initialize_static_property_0 :
                ts.isPrivateIdentifier(token) ? ts.Diagnostics.Declare_a_private_field_named_0 : ts.Diagnostics.Initialize_property_0_in_the_constructor;
            return codefix.createCodeFixAction(fixMissingMember, changes, [diagnostic, token.text], fixMissingMember, ts.Diagnostics.Add_all_missing_members);
        }
        function addMissingMemberInJs(changeTracker, declSourceFile, classDeclaration, token, makeStatic) {
            var tokenName = token.text;
            if (makeStatic) {
                if (classDeclaration.kind === 224 /* ClassExpression */) {
                    return;
                }
                var className = classDeclaration.name.getText();
                var staticInitialization = initializePropertyToUndefined(ts.factory.createIdentifier(className), tokenName);
                changeTracker.insertNodeAfter(declSourceFile, classDeclaration, staticInitialization);
            }
            else if (ts.isPrivateIdentifier(token)) {
                var property = ts.factory.createPropertyDeclaration(
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, tokenName, 
                /*questionToken*/ undefined, 
                /*type*/ undefined, 
                /*initializer*/ undefined);
                var lastProp = getNodeToInsertPropertyAfter(classDeclaration);
                if (lastProp) {
                    changeTracker.insertNodeAfter(declSourceFile, lastProp, property);
                }
                else {
                    changeTracker.insertNodeAtClassStart(declSourceFile, classDeclaration, property);
                }
            }
            else {
                var classConstructor = ts.getFirstConstructorWithBody(classDeclaration);
                if (!classConstructor) {
                    return;
                }
                var propertyInitialization = initializePropertyToUndefined(ts.factory.createThis(), tokenName);
                changeTracker.insertNodeAtConstructorEnd(declSourceFile, classConstructor, propertyInitialization);
            }
        }
        function initializePropertyToUndefined(obj, propertyName) {
            return ts.factory.createExpressionStatement(ts.factory.createAssignment(ts.factory.createPropertyAccessExpression(obj, propertyName), createUndefined()));
        }
        function createActionsForAddMissingMemberInTypeScriptFile(context, _a) {
            var parentDeclaration = _a.parentDeclaration, declSourceFile = _a.declSourceFile, modifierFlags = _a.modifierFlags, token = _a.token;
            var memberName = token.text;
            var isStatic = modifierFlags & 32 /* Static */;
            var typeNode = getTypeNode(context.program.getTypeChecker(), parentDeclaration, token);
            var addPropertyDeclarationChanges = function (modifierFlags) { return ts.textChanges.ChangeTracker.with(context, function (t) { return addPropertyDeclaration(t, declSourceFile, parentDeclaration, memberName, typeNode, modifierFlags); }); };
            var actions = [codefix.createCodeFixAction(fixMissingMember, addPropertyDeclarationChanges(modifierFlags & 32 /* Static */), [isStatic ? ts.Diagnostics.Declare_static_property_0 : ts.Diagnostics.Declare_property_0, memberName], fixMissingMember, ts.Diagnostics.Add_all_missing_members)];
            if (isStatic || ts.isPrivateIdentifier(token)) {
                return actions;
            }
            if (modifierFlags & 8 /* Private */) {
                actions.unshift(codefix.createCodeFixActionWithoutFixAll(fixMissingMember, addPropertyDeclarationChanges(8 /* Private */), [ts.Diagnostics.Declare_private_property_0, memberName]));
            }
            actions.push(createAddIndexSignatureAction(context, declSourceFile, parentDeclaration, token.text, typeNode));
            return actions;
        }
        function getTypeNode(checker, classDeclaration, token) {
            var typeNode;
            if (token.parent.parent.kind === 219 /* BinaryExpression */) {
                var binaryExpression = token.parent.parent;
                var otherExpression = token.parent === binaryExpression.left ? binaryExpression.right : binaryExpression.left;
                var widenedType = checker.getWidenedType(checker.getBaseTypeOfLiteralType(checker.getTypeAtLocation(otherExpression)));
                typeNode = checker.typeToTypeNode(widenedType, classDeclaration, 1 /* NoTruncation */);
            }
            else {
                var contextualType = checker.getContextualType(token.parent);
                typeNode = contextualType ? checker.typeToTypeNode(contextualType, /*enclosingDeclaration*/ undefined, 1 /* NoTruncation */) : undefined;
            }
            return typeNode || ts.factory.createKeywordTypeNode(129 /* AnyKeyword */);
        }
        function addPropertyDeclaration(changeTracker, declSourceFile, classDeclaration, tokenName, typeNode, modifierFlags) {
            var property = ts.factory.createPropertyDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ modifierFlags ? ts.factory.createNodeArray(ts.factory.createModifiersFromModifierFlags(modifierFlags)) : undefined, tokenName, 
            /*questionToken*/ undefined, typeNode, 
            /*initializer*/ undefined);
            var lastProp = getNodeToInsertPropertyAfter(classDeclaration);
            if (lastProp) {
                changeTracker.insertNodeAfter(declSourceFile, lastProp, property);
            }
            else {
                changeTracker.insertNodeAtClassStart(declSourceFile, classDeclaration, property);
            }
        }
        // Gets the last of the first run of PropertyDeclarations, or undefined if the class does not start with a PropertyDeclaration.
        function getNodeToInsertPropertyAfter(cls) {
            var res;
            for (var _i = 0, _a = cls.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (!ts.isPropertyDeclaration(member))
                    break;
                res = member;
            }
            return res;
        }
        function createAddIndexSignatureAction(context, declSourceFile, classDeclaration, tokenName, typeNode) {
            // Index signatures cannot have the static modifier.
            var stringTypeNode = ts.factory.createKeywordTypeNode(148 /* StringKeyword */);
            var indexingParameter = ts.factory.createParameterDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*dotDotDotToken*/ undefined, "x", 
            /*questionToken*/ undefined, stringTypeNode, 
            /*initializer*/ undefined);
            var indexSignature = ts.factory.createIndexSignature(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, [indexingParameter], typeNode);
            var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return t.insertNodeAtClassStart(declSourceFile, classDeclaration, indexSignature); });
            // No fixId here because code-fix-all currently only works on adding individual named properties.
            return codefix.createCodeFixActionWithoutFixAll(fixMissingMember, changes, [ts.Diagnostics.Add_index_signature_for_property_0, tokenName]);
        }
        function getActionsForMissingMethodDeclaration(context, info) {
            var parentDeclaration = info.parentDeclaration, declSourceFile = info.declSourceFile, modifierFlags = info.modifierFlags, token = info.token, call = info.call;
            if (call === undefined) {
                return undefined;
            }
            // Private methods are not implemented yet.
            if (ts.isPrivateIdentifier(token)) {
                return undefined;
            }
            var methodName = token.text;
            var addMethodDeclarationChanges = function (modifierFlags) { return ts.textChanges.ChangeTracker.with(context, function (t) { return addMethodDeclaration(context, t, call, token, modifierFlags, parentDeclaration, declSourceFile); }); };
            var actions = [codefix.createCodeFixAction(fixMissingMember, addMethodDeclarationChanges(modifierFlags & 32 /* Static */), [modifierFlags & 32 /* Static */ ? ts.Diagnostics.Declare_static_method_0 : ts.Diagnostics.Declare_method_0, methodName], fixMissingMember, ts.Diagnostics.Add_all_missing_members)];
            if (modifierFlags & 8 /* Private */) {
                actions.unshift(codefix.createCodeFixActionWithoutFixAll(fixMissingMember, addMethodDeclarationChanges(8 /* Private */), [ts.Diagnostics.Declare_private_method_0, methodName]));
            }
            return actions;
        }
        function addMethodDeclaration(context, changes, callExpression, name, modifierFlags, parentDeclaration, sourceFile) {
            var importAdder = codefix.createImportAdder(sourceFile, context.program, context.preferences, context.host);
            var methodDeclaration = codefix.createSignatureDeclarationFromCallExpression(167 /* MethodDeclaration */, context, importAdder, callExpression, name, modifierFlags, parentDeclaration);
            var containingMethodDeclaration = ts.findAncestor(callExpression, function (n) { return ts.isMethodDeclaration(n) || ts.isConstructorDeclaration(n); });
            if (containingMethodDeclaration && containingMethodDeclaration.parent === parentDeclaration) {
                changes.insertNodeAfter(sourceFile, containingMethodDeclaration, methodDeclaration);
            }
            else {
                changes.insertNodeAtClassStart(sourceFile, parentDeclaration, methodDeclaration);
            }
            importAdder.writeFixes(changes);
        }
        function addEnumMemberDeclaration(changes, checker, _a) {
            var token = _a.token, parentDeclaration = _a.parentDeclaration;
            /**
             * create initializer only literal enum that has string initializer.
             * value of initializer is a string literal that equal to name of enum member.
             * numeric enum or empty enum will not create initializer.
             */
            var hasStringInitializer = ts.some(parentDeclaration.members, function (member) {
                var type = checker.getTypeAtLocation(member);
                return !!(type && type.flags & 402653316 /* StringLike */);
            });
            var enumMember = ts.factory.createEnumMember(token, hasStringInitializer ? ts.factory.createStringLiteral(token.text) : undefined);
            changes.replaceNode(parentDeclaration.getSourceFile(), parentDeclaration, ts.factory.updateEnumDeclaration(parentDeclaration, parentDeclaration.decorators, parentDeclaration.modifiers, parentDeclaration.name, ts.concatenate(parentDeclaration.members, ts.singleElementArray(enumMember))), {
                leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,
                trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude
            });
        }
        function addFunctionDeclaration(changes, context, info) {
            var importAdder = codefix.createImportAdder(context.sourceFile, context.program, context.preferences, context.host);
            var functionDeclaration = codefix.createSignatureDeclarationFromCallExpression(254 /* FunctionDeclaration */, context, importAdder, info.call, ts.idText(info.token), info.modifierFlags, info.parentDeclaration);
            changes.insertNodeAtEndOfScope(info.sourceFile, info.parentDeclaration, functionDeclaration);
        }
        function addJsxAttributes(changes, context, info) {
            var importAdder = codefix.createImportAdder(context.sourceFile, context.program, context.preferences, context.host);
            var quotePreference = ts.getQuotePreference(context.sourceFile, context.preferences);
            var checker = context.program.getTypeChecker();
            var jsxAttributesNode = info.parentDeclaration.attributes;
            var hasSpreadAttribute = ts.some(jsxAttributesNode.properties, ts.isJsxSpreadAttribute);
            var attrs = ts.map(info.attributes, function (attr) {
                var value = attr.valueDeclaration ? tryGetValueFromType(context, checker, importAdder, quotePreference, checker.getTypeAtLocation(attr.valueDeclaration)) : createUndefined();
                return ts.factory.createJsxAttribute(ts.factory.createIdentifier(attr.name), ts.factory.createJsxExpression(/*dotDotDotToken*/ undefined, value));
            });
            var jsxAttributes = ts.factory.createJsxAttributes(hasSpreadAttribute ? __spreadArray(__spreadArray([], attrs, true), jsxAttributesNode.properties, true) : __spreadArray(__spreadArray([], jsxAttributesNode.properties, true), attrs, true));
            var options = { prefix: jsxAttributesNode.pos === jsxAttributesNode.end ? " " : undefined };
            changes.replaceNode(context.sourceFile, jsxAttributesNode, jsxAttributes, options);
        }
        function addObjectLiteralProperties(changes, context, info) {
            var importAdder = codefix.createImportAdder(context.sourceFile, context.program, context.preferences, context.host);
            var quotePreference = ts.getQuotePreference(context.sourceFile, context.preferences);
            var checker = context.program.getTypeChecker();
            var props = ts.map(info.properties, function (prop) {
                var initializer = prop.valueDeclaration ? tryGetValueFromType(context, checker, importAdder, quotePreference, checker.getTypeAtLocation(prop.valueDeclaration)) : createUndefined();
                return ts.factory.createPropertyAssignment(prop.name, initializer);
            });
            changes.replaceNode(context.sourceFile, info.parentDeclaration, ts.factory.createObjectLiteralExpression(__spreadArray(__spreadArray([], info.parentDeclaration.properties, true), props, true), /*multiLine*/ true));
        }
        function tryGetValueFromType(context, checker, importAdder, quotePreference, type) {
            if (type.flags & 3 /* AnyOrUnknown */) {
                return createUndefined();
            }
            if (type.flags & (4 /* String */ | 134217728 /* TemplateLiteral */)) {
                return ts.factory.createStringLiteral("", /* isSingleQuote */ quotePreference === 0 /* Single */);
            }
            if (type.flags & 8 /* Number */) {
                return ts.factory.createNumericLiteral(0);
            }
            if (type.flags & 64 /* BigInt */) {
                return ts.factory.createBigIntLiteral("0n");
            }
            if (type.flags & 16 /* Boolean */) {
                return ts.factory.createFalse();
            }
            if (type.flags & 1056 /* EnumLike */) {
                var enumMember = type.symbol.exports ? ts.firstOrUndefined(ts.arrayFrom(type.symbol.exports.values())) : type.symbol;
                var name = checker.symbolToExpression(type.symbol.parent ? type.symbol.parent : type.symbol, 111551 /* Value */, /*enclosingDeclaration*/ undefined, /*flags*/ undefined);
                return enumMember === undefined || name === undefined ? ts.factory.createNumericLiteral(0) : ts.factory.createPropertyAccessExpression(name, checker.symbolToString(enumMember));
            }
            if (type.flags & 256 /* NumberLiteral */) {
                return ts.factory.createNumericLiteral(type.value);
            }
            if (type.flags & 2048 /* BigIntLiteral */) {
                return ts.factory.createBigIntLiteral(type.value);
            }
            if (type.flags & 128 /* StringLiteral */) {
                return ts.factory.createStringLiteral(type.value, /* isSingleQuote */ quotePreference === 0 /* Single */);
            }
            if (type.flags & 512 /* BooleanLiteral */) {
                return (type === checker.getFalseType() || type === checker.getFalseType(/*fresh*/ true)) ? ts.factory.createFalse() : ts.factory.createTrue();
            }
            if (type.flags & 65536 /* Null */) {
                return ts.factory.createNull();
            }
            if (type.flags & 1048576 /* Union */) {
                var expression = ts.firstDefined(type.types, function (t) { return tryGetValueFromType(context, checker, importAdder, quotePreference, t); });
                return expression !== null && expression !== void 0 ? expression : createUndefined();
            }
            if (checker.isArrayLikeType(type)) {
                return ts.factory.createArrayLiteralExpression();
            }
            if (isObjectLiteralType(type)) {
                var props = ts.map(checker.getPropertiesOfType(type), function (prop) {
                    var initializer = prop.valueDeclaration ? tryGetValueFromType(context, checker, importAdder, quotePreference, checker.getTypeAtLocation(prop.valueDeclaration)) : createUndefined();
                    return ts.factory.createPropertyAssignment(prop.name, initializer);
                });
                return ts.factory.createObjectLiteralExpression(props, /*multiLine*/ true);
            }
            if (ts.getObjectFlags(type) & 16 /* Anonymous */) {
                var decl = ts.find(type.symbol.declarations || ts.emptyArray, ts.or(ts.isFunctionTypeNode, ts.isMethodSignature, ts.isMethodDeclaration));
                if (decl === undefined)
                    return createUndefined();
                var signature = checker.getSignaturesOfType(type, 0 /* Call */);
                if (signature === undefined)
                    return createUndefined();
                var func = codefix.createSignatureDeclarationFromSignature(211 /* FunctionExpression */, context, quotePreference, signature[0], codefix.createStubbedBody(ts.Diagnostics.Function_not_implemented.message, quotePreference), /*name*/ undefined, /*modifiers*/ undefined, /*optional*/ undefined, /*enclosingDeclaration*/ undefined, importAdder);
                return func !== null && func !== void 0 ? func : createUndefined();
            }
            if (ts.getObjectFlags(type) & 1 /* Class */) {
                var classDeclaration = ts.getClassLikeDeclarationOfSymbol(type.symbol);
                if (classDeclaration === undefined || ts.hasAbstractModifier(classDeclaration))
                    return createUndefined();
                var constructorDeclaration = ts.getFirstConstructorWithBody(classDeclaration);
                if (constructorDeclaration && ts.length(constructorDeclaration.parameters))
                    return createUndefined();
                return ts.factory.createNewExpression(ts.factory.createIdentifier(type.symbol.name), /*typeArguments*/ undefined, /*argumentsArray*/ undefined);
            }
            return createUndefined();
        }
        function createUndefined() {
            return ts.factory.createIdentifier("undefined");
        }
        function isObjectLiteralType(type) {
            return (type.flags & 524288 /* Object */) &&
                ((ts.getObjectFlags(type) & 128 /* ObjectLiteral */) || (type.symbol && ts.tryCast(ts.singleOrUndefined(type.symbol.declarations), ts.isTypeLiteralNode)));
        }
        function getUnmatchedAttributes(checker, source) {
            var attrsType = checker.getContextualType(source.attributes);
            if (attrsType === undefined)
                return ts.emptyArray;
            var targetProps = attrsType.getProperties();
            if (!ts.length(targetProps))
                return ts.emptyArray;
            var seenNames = new ts.Set();
            for (var _i = 0, _a = source.attributes.properties; _i < _a.length; _i++) {
                var sourceProp = _a[_i];
                if (ts.isJsxAttribute(sourceProp)) {
                    seenNames.add(sourceProp.name.escapedText);
                }
                if (ts.isJsxSpreadAttribute(sourceProp)) {
                    var type = checker.getTypeAtLocation(sourceProp.expression);
                    for (var _b = 0, _c = type.getProperties(); _b < _c.length; _b++) {
                        var prop = _c[_b];
                        seenNames.add(prop.escapedName);
                    }
                }
            }
            return ts.filter(targetProps, function (targetProp) {
                return !((targetProp.flags & 16777216 /* Optional */ || ts.getCheckFlags(targetProp) & 48 /* Partial */) || seenNames.has(targetProp.escapedName));
            });
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "addMissingNewOperator";
        var errorCodes = [ts.Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return addMissingNewOperator(t, sourceFile, span); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Add_missing_new_operator_to_call, fixId, ts.Diagnostics.Add_missing_new_operator_to_all_calls)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                return addMissingNewOperator(changes, context.sourceFile, diag);
            }); },
        });
        function addMissingNewOperator(changes, sourceFile, span) {
            var call = ts.cast(findAncestorMatchingSpan(sourceFile, span), ts.isCallExpression);
            var newExpression = ts.factory.createNewExpression(call.expression, call.typeArguments, call.arguments);
            changes.replaceNode(sourceFile, call, newExpression);
        }
        function findAncestorMatchingSpan(sourceFile, span) {
            var token = ts.getTokenAtPosition(sourceFile, span.start);
            var end = ts.textSpanEnd(span);
            while (token.end < end) {
                token = token.parent;
            }
            return token;
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixName = "fixCannotFindModule";
        var fixIdInstallTypesPackage = "installTypesPackage";
        var errorCodeCannotFindModule = ts.Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations.code;
        var errorCodes = [
            errorCodeCannotFindModule,
            ts.Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type.code,
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var host = context.host, sourceFile = context.sourceFile, start = context.span.start;
                var packageName = tryGetImportedPackageName(sourceFile, start);
                if (packageName === undefined)
                    return undefined;
                var typesPackageName = getTypesPackageNameToInstall(packageName, host, context.errorCode);
                return typesPackageName === undefined
                    ? []
                    : [codefix.createCodeFixAction(fixName, /*changes*/ [], [ts.Diagnostics.Install_0, typesPackageName], fixIdInstallTypesPackage, ts.Diagnostics.Install_all_missing_types_packages, getInstallCommand(sourceFile.fileName, typesPackageName))];
            },
            fixIds: [fixIdInstallTypesPackage],
            getAllCodeActions: function (context) {
                return codefix.codeFixAll(context, errorCodes, function (_changes, diag, commands) {
                    var packageName = tryGetImportedPackageName(diag.file, diag.start);
                    if (packageName === undefined)
                        return undefined;
                    switch (context.fixId) {
                        case fixIdInstallTypesPackage: {
                            var pkg = getTypesPackageNameToInstall(packageName, context.host, diag.code);
                            if (pkg) {
                                commands.push(getInstallCommand(diag.file.fileName, pkg));
                            }
                            break;
                        }
                        default:
                            ts.Debug.fail("Bad fixId: " + context.fixId);
                    }
                });
            },
        });
        function getInstallCommand(fileName, packageName) {
            return { type: "install package", file: fileName, packageName: packageName };
        }
        function tryGetImportedPackageName(sourceFile, pos) {
            var moduleSpecifierText = ts.tryCast(ts.getTokenAtPosition(sourceFile, pos), ts.isStringLiteral);
            if (!moduleSpecifierText)
                return undefined;
            var moduleName = moduleSpecifierText.text;
            var packageName = ts.parsePackageName(moduleName).packageName;
            return ts.isExternalModuleNameRelative(packageName) ? undefined : packageName;
        }
        function getTypesPackageNameToInstall(packageName, host, diagCode) {
            var _a;
            return diagCode === errorCodeCannotFindModule
                ? (ts.JsTyping.nodeCoreModules.has(packageName) ? "@types/node" : undefined)
                : (((_a = host.isKnownTypesPackageName) === null || _a === void 0 ? void 0 : _a.call(host, packageName)) ? ts.getTypesPackageName(packageName) : undefined);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var errorCodes = [
            ts.Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2.code,
            ts.Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1.code,
        ];
        var fixId = "fixClassDoesntImplementInheritedAbstractMember";
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) {
                    return addMissingMembers(getClass(sourceFile, span.start), sourceFile, context, t, context.preferences);
                });
                return changes.length === 0 ? undefined : [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Implement_inherited_abstract_class, fixId, ts.Diagnostics.Implement_all_inherited_abstract_classes)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) {
                var seenClassDeclarations = new ts.Map();
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                    var classDeclaration = getClass(diag.file, diag.start);
                    if (ts.addToSeen(seenClassDeclarations, ts.getNodeId(classDeclaration))) {
                        addMissingMembers(classDeclaration, context.sourceFile, context, changes, context.preferences);
                    }
                });
            },
        });
        function getClass(sourceFile, pos) {
            // Token is the identifier in the case of a class declaration
            // or the class keyword token in the case of a class expression.
            var token = ts.getTokenAtPosition(sourceFile, pos);
            return ts.cast(token.parent, ts.isClassLike);
        }
        function addMissingMembers(classDeclaration, sourceFile, context, changeTracker, preferences) {
            var extendsNode = ts.getEffectiveBaseTypeNode(classDeclaration);
            var checker = context.program.getTypeChecker();
            var instantiatedExtendsType = checker.getTypeAtLocation(extendsNode);
            // Note that this is ultimately derived from a map indexed by symbol names,
            // so duplicates cannot occur.
            var abstractAndNonPrivateExtendsSymbols = checker.getPropertiesOfType(instantiatedExtendsType).filter(symbolPointsToNonPrivateAndAbstractMember);
            var importAdder = codefix.createImportAdder(sourceFile, context.program, preferences, context.host);
            codefix.createMissingMemberNodes(classDeclaration, abstractAndNonPrivateExtendsSymbols, sourceFile, context, preferences, importAdder, function (member) { return changeTracker.insertNodeAtClassStart(sourceFile, classDeclaration, member); });
            importAdder.writeFixes(changeTracker);
        }
        function symbolPointsToNonPrivateAndAbstractMember(symbol) {
            // See `codeFixClassExtendAbstractProtectedProperty.ts` in https://github.com/Microsoft/TypeScript/pull/11547/files
            // (now named `codeFixClassExtendAbstractPrivateProperty.ts`)
            var flags = ts.getSyntacticModifierFlags(ts.first(symbol.getDeclarations()));
            return !(flags & 8 /* Private */) && !!(flags & 128 /* Abstract */);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "classSuperMustPrecedeThisAccess";
        var errorCodes = [ts.Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span;
                var nodes = getNodes(sourceFile, span.start);
                if (!nodes)
                    return undefined;
                var constructor = nodes.constructor, superCall = nodes.superCall;
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, constructor, superCall); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Make_super_call_the_first_statement_in_the_constructor, fixId, ts.Diagnostics.Make_all_super_calls_the_first_statement_in_their_constructor)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) {
                var sourceFile = context.sourceFile;
                var seenClasses = new ts.Map(); // Ensure we only do this once per class.
                return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                    var nodes = getNodes(diag.file, diag.start);
                    if (!nodes)
                        return;
                    var constructor = nodes.constructor, superCall = nodes.superCall;
                    if (ts.addToSeen(seenClasses, ts.getNodeId(constructor.parent))) {
                        doChange(changes, sourceFile, constructor, superCall);
                    }
                });
            },
        });
        function doChange(changes, sourceFile, constructor, superCall) {
            changes.insertNodeAtConstructorStart(sourceFile, constructor, superCall);
            changes.delete(sourceFile, superCall);
        }
        function getNodes(sourceFile, pos) {
            var token = ts.getTokenAtPosition(sourceFile, pos);
            if (token.kind !== 108 /* ThisKeyword */)
                return undefined;
            var constructor = ts.getContainingFunction(token);
            var superCall = findSuperCall(constructor.body);
            // figure out if the `this` access is actually inside the supercall
            // i.e. super(this.a), since in that case we won't suggest a fix
            return superCall && !superCall.expression.arguments.some(function (arg) { return ts.isPropertyAccessExpression(arg) && arg.expression === token; }) ? { constructor: constructor, superCall: superCall } : undefined;
        }
        function findSuperCall(n) {
            return ts.isExpressionStatement(n) && ts.isSuperCall(n.expression)
                ? n
                : ts.isFunctionLike(n)
                    ? undefined
                    : ts.forEachChild(n, findSuperCall);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "constructorForDerivedNeedSuperCall";
        var errorCodes = [ts.Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var sourceFile = context.sourceFile, span = context.span;
                var ctr = getNode(sourceFile, span.start);
                var changes = ts.textChanges.ChangeTracker.with(context, function (t) { return doChange(t, sourceFile, ctr); });
                return [codefix.createCodeFixAction(fixId, changes, ts.Diagnostics.Add_missing_super_call, fixId, ts.Diagnostics.Add_all_missing_super_calls)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes, diag) {
                return doChange(changes, context.sourceFile, getNode(diag.file, diag.start));
            }); },
        });
        function getNode(sourceFile, pos) {
            var token = ts.getTokenAtPosition(sourceFile, pos);
            ts.Debug.assert(ts.isConstructorDeclaration(token.parent), "token should be at the constructor declaration");
            return token.parent;
        }
        function doChange(changes, sourceFile, ctr) {
            var superCall = ts.factory.createExpressionStatement(ts.factory.createCallExpression(ts.factory.createSuper(), /*typeArguments*/ undefined, /*argumentsArray*/ ts.emptyArray));
            changes.insertNodeAtConstructorStart(sourceFile, ctr, superCall);
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixId = "enableExperimentalDecorators";
        var errorCodes = [
            ts.Diagnostics.Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_in_your_tsconfig_or_jsconfig_to_remove_this_warning.code
        ];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var configFile = context.program.getCompilerOptions().configFile;
                if (configFile === undefined) {
                    return undefined;
                }
                var changes = ts.textChanges.ChangeTracker.with(context, function (changeTracker) { return doChange(changeTracker, configFile); });
                return [codefix.createCodeFixActionWithoutFixAll(fixId, changes, ts.Diagnostics.Enable_the_experimentalDecorators_option_in_your_configuration_file)];
            },
            fixIds: [fixId],
            getAllCodeActions: function (context) { return codefix.codeFixAll(context, errorCodes, function (changes) {
                var configFile = context.program.getCompilerOptions().configFile;
                if (configFile === undefined) {
                    return undefined;
                }
                doChange(changes, configFile);
            }); },
        });
        function doChange(changeTracker, configFile) {
            codefix.setJsonCompilerOptionValue(changeTracker, configFile, "experimentalDecorators", ts.factory.createTrue());
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        var fixID = "fixEnableJsxFlag";
        var errorCodes = [ts.Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided.code];
        codefix.registerCodeFix({
            errorCodes: errorCodes,
            getCodeActions: function (context) {
                var configFile = context.program.getCompilerOptions().configFile;
                if (configFile === undefined) {
                    return undefined;
                }
                var changes = ts.textChanges.ChangeTracker.with(context, function (changeTracker) {
                    return doChange(changeTracker, configFile);
                });
                return [
                    codefix.createCodeFixActionWithoutFixAll(fixID, changes, ts.Diagnostics.Enable_the_jsx_flag_in_your_configuration_file)
                ];
            },
            fixIds: [fixID],
            getAllCodeActions: function (context) {
                return codefix.codeFixAll(context, errorCodes, function (changes) {
                    var configFile = context.program.getCompilerOptions().configFile;
                    if (configFile === undefined) {
                        return undefined;
                    }
                    doChange(changes, configFile);
                });
            }
        });
        function doChange(changeTracker, configFile) {
            codefix.setJsonCompilerOptionValue(changeTracker, configFile, "jsx", ts.factory.createStringLiteral("react"));
        }
    })(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var codefix;
    (function (codefix) {
        codefix.registerCodeFix({
            errorCodes: [
                ts.Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_esnext_or_system_and_the_target_option_is_set_to_es2017_or_higher.code,
                ts.Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_esnext_or_system_and_the_target_option_is_set_to_es2017_or_higher.code,
            ],
            getCodeActions: function (context) {
                var compilerOptions = context.program.getCompilerOptions();
                var configFile = compilerOptions.configFile;
                if (configFile === undefined) {
                    return undefined;
                }
                var codeFixes = [];
                var moduleKind = ts.getEmitModuleKind(