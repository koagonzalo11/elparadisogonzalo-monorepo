e);
                    if (token && token.kind === 28 /* QuestionDotToken */) {
                        token = findPrecedingToken(token.getFullStart(), sourceFile);
                    }
                    if (!token || !ts.isIdentifier(token))
                        return undefined;
                    if (!remainingLessThanTokens) {
                        return ts.isDeclarationName(token) ? undefined : { called: token, nTypeArguments: nTypeArguments };
                    }
                    remainingLessThanTokens--;
                    break;
                case 49 /* GreaterThanGreaterThanGreaterThanToken */:
                    remainingLessThanTokens = +3;
                    break;
                case 48 /* GreaterThanGreaterThanToken */:
                    remainingLessThanTokens = +2;
                    break;
                case 31 /* GreaterThanToken */:
                    remainingLessThanTokens++;
                    break;
                case 19 /* CloseBraceToken */:
                    // This can be object type, skip until we find the matching open brace token
                    // Skip until the matching open brace token
                    token = findPrecedingMatchingToken(token, 18 /* OpenBraceToken */, sourceFile);
                    if (!token)
                        return undefined;
                    break;
                case 21 /* CloseParenToken */:
                    // This can be object type, skip until we find the matching open brace token
                    // Skip until the matching open brace token
                    token = findPrecedingMatchingToken(token, 20 /* OpenParenToken */, sourceFile);
                    if (!token)
                        return undefined;
                    break;
                case 23 /* CloseBracketToken */:
                    // This can be object type, skip until we find the matching open brace token
                    // Skip until the matching open brace token
                    token = findPrecedingMatchingToken(token, 22 /* OpenBracketToken */, sourceFile);
                    if (!token)
                        return undefined;
                    break;
                // Valid tokens in a type name. Skip.
                case 27 /* CommaToken */:
                    nTypeArguments++;
                    break;
                case 38 /* EqualsGreaterThanToken */:
                // falls through
                case 79 /* Identifier */:
                case 10 /* StringLiteral */:
                case 8 /* NumericLiteral */:
                case 9 /* BigIntLiteral */:
                case 110 /* TrueKeyword */:
                case 95 /* FalseKeyword */:
                // falls through
                case 112 /* TypeOfKeyword */:
                case 94 /* ExtendsKeyword */:
                case 139 /* KeyOfKeyword */:
                case 24 /* DotToken */:
                case 51 /* BarToken */:
                case 57 /* QuestionToken */:
                case 58 /* ColonToken */:
                    break;
                default:
                    if (ts.isTypeNode(token)) {
                        break;
                    }
                    // Invalid token in type
                    return undefined;
            }
            token = findPrecedingToken(token.getFullStart(), sourceFile);
        }
        return undefined;
    }
    ts.getPossibleTypeArgumentsInfo = getPossibleTypeArgumentsInfo;
    /**
     * Returns true if the cursor at position in sourceFile is within a comment.
     *
     * @param tokenAtPosition Must equal `getTokenAtPosition(sourceFile, position)
     * @param predicate Additional predicate to test on the comment range.
     */
    function isInComment(sourceFile, position, tokenAtPosition) {
        return ts.formatting.getRangeOfEnclosingComment(sourceFile, position, /*precedingToken*/ undefined, tokenAtPosition);
    }
    ts.isInComment = isInComment;
    function hasDocComment(sourceFile, position) {
        var token = getTokenAtPosition(sourceFile, position);
        return !!ts.findAncestor(token, ts.isJSDoc);
    }
    ts.hasDocComment = hasDocComment;
    function nodeHasTokens(n, sourceFile) {
        // If we have a token or node that has a non-zero width, it must have tokens.
        // Note: getWidth() does not take trivia into account.
        return n.kind === 1 /* EndOfFileToken */ ? !!n.jsDoc : n.getWidth(sourceFile) !== 0;
    }
    function getNodeModifiers(node, excludeFlags) {
        if (excludeFlags === void 0) { excludeFlags = 0 /* None */; }
        var result = [];
        var flags = ts.isDeclaration(node)
            ? ts.getCombinedNodeFlagsAlwaysIncludeJSDoc(node) & ~excludeFlags
            : 0 /* None */;
        if (flags & 8 /* Private */)
            result.push("private" /* privateMemberModifier */);
        if (flags & 16 /* Protected */)
            result.push("protected" /* protectedMemberModifier */);
        if (flags & 4 /* Public */)
            result.push("public" /* publicMemberModifier */);
        if (flags & 32 /* Static */ || ts.isClassStaticBlockDeclaration(node))
            result.push("static" /* staticModifier */);
        if (flags & 128 /* Abstract */)
            result.push("abstract" /* abstractModifier */);
        if (flags & 1 /* Export */)
            result.push("export" /* exportedModifier */);
        if (flags & 8192 /* Deprecated */)
            result.push("deprecated" /* deprecatedModifier */);
        if (node.flags & 8388608 /* Ambient */)
            result.push("declare" /* ambientModifier */);
        if (node.kind === 269 /* ExportAssignment */)
            result.push("export" /* exportedModifier */);
        return result.length > 0 ? result.join(",") : "" /* none */;
    }
    ts.getNodeModifiers = getNodeModifiers;
    function getTypeArgumentOrTypeParameterList(node) {
        if (node.kind === 176 /* TypeReference */ || node.kind === 206 /* CallExpression */) {
            return node.typeArguments;
        }
        if (ts.isFunctionLike(node) || node.kind === 255 /* ClassDeclaration */ || node.kind === 256 /* InterfaceDeclaration */) {
            return node.typeParameters;
        }
        return undefined;
    }
    ts.getTypeArgumentOrTypeParameterList = getTypeArgumentOrTypeParameterList;
    function isComment(kind) {
        return kind === 2 /* SingleLineCommentTrivia */ || kind === 3 /* MultiLineCommentTrivia */;
    }
    ts.isComment = isComment;
    function isStringOrRegularExpressionOrTemplateLiteral(kind) {
        if (kind === 10 /* StringLiteral */
            || kind === 13 /* RegularExpressionLiteral */
            || ts.isTemplateLiteralKind(kind)) {
            return true;
        }
        return false;
    }
    ts.isStringOrRegularExpressionOrTemplateLiteral = isStringOrRegularExpressionOrTemplateLiteral;
    function isPunctuation(kind) {
        return 18 /* FirstPunctuation */ <= kind && kind <= 78 /* LastPunctuation */;
    }
    ts.isPunctuation = isPunctuation;
    function isInsideTemplateLiteral(node, position, sourceFile) {
        return ts.isTemplateLiteralKind(node.kind)
            && (node.getStart(sourceFile) < position && position < node.end) || (!!node.isUnterminated && position === node.end);
    }
    ts.isInsideTemplateLiteral = isInsideTemplateLiteral;
    function isAccessibilityModifier(kind) {
        switch (kind) {
            case 123 /* PublicKeyword */:
            case 121 /* PrivateKeyword */:
            case 122 /* ProtectedKeyword */:
                return true;
        }
        return false;
    }
    ts.isAccessibilityModifier = isAccessibilityModifier;
    function cloneCompilerOptions(options) {
        var result = ts.clone(options);
        ts.setConfigFileInOptions(result, options && options.configFile);
        return result;
    }
    ts.cloneCompilerOptions = cloneCompilerOptions;
    function isArrayLiteralOrObjectLiteralDestructuringPattern(node) {
        if (node.kind === 202 /* ArrayLiteralExpression */ ||
            node.kind === 203 /* ObjectLiteralExpression */) {
            // [a,b,c] from:
            // [a, b, c] = someExpression;
            if (node.parent.kind === 219 /* BinaryExpression */ &&
                node.parent.left === node &&
                node.parent.operatorToken.kind === 63 /* EqualsToken */) {
                return true;
            }
            // [a, b, c] from:
            // for([a, b, c] of expression)
            if (node.parent.kind === 242 /* ForOfStatement */ &&
                node.parent.initializer === node) {
                return true;
            }
            // [a, b, c] of
            // [x, [a, b, c] ] = someExpression
            // or
            // {x, a: {a, b, c} } = someExpression
            if (isArrayLiteralOrObjectLiteralDestructuringPattern(node.parent.kind === 291 /* PropertyAssignment */ ? node.parent.parent : node.parent)) {
                return true;
            }
        }
        return false;
    }
    ts.isArrayLiteralOrObjectLiteralDestructuringPattern = isArrayLiteralOrObjectLiteralDestructuringPattern;
    function isInReferenceComment(sourceFile, position) {
        return isInReferenceCommentWorker(sourceFile, position, /*shouldBeReference*/ true);
    }
    ts.isInReferenceComment = isInReferenceComment;
    function isInNonReferenceComment(sourceFile, position) {
        return isInReferenceCommentWorker(sourceFile, position, /*shouldBeReference*/ false);
    }
    ts.isInNonReferenceComment = isInNonReferenceComment;
    function isInReferenceCommentWorker(sourceFile, position, shouldBeReference) {
        var range = isInComment(sourceFile, position, /*tokenAtPosition*/ undefined);
        return !!range && shouldBeReference === tripleSlashDirectivePrefixRegex.test(sourceFile.text.substring(range.pos, range.end));
    }
    function getReplacementSpanForContextToken(contextToken) {
        if (!contextToken)
            return undefined;
        switch (contextToken.kind) {
            case 10 /* StringLiteral */:
            case 14 /* NoSubstitutionTemplateLiteral */:
                return createTextSpanFromStringLiteralLikeContent(contextToken);
            default:
                return createTextSpanFromNode(contextToken);
        }
    }
    ts.getReplacementSpanForContextToken = getReplacementSpanForContextToken;
    function createTextSpanFromNode(node, sourceFile, endNode) {
        return ts.createTextSpanFromBounds(node.getStart(sourceFile), (endNode || node).getEnd());
    }
    ts.createTextSpanFromNode = createTextSpanFromNode;
    function createTextSpanFromStringLiteralLikeContent(node) {
        if (node.isUnterminated)
            return undefined;
        return ts.createTextSpanFromBounds(node.getStart() + 1, node.getEnd() - 1);
    }
    ts.createTextSpanFromStringLiteralLikeContent = createTextSpanFromStringLiteralLikeContent;
    function createTextRangeFromNode(node, sourceFile) {
        return ts.createRange(node.getStart(sourceFile), node.end);
    }
    ts.createTextRangeFromNode = createTextRangeFromNode;
    function createTextSpanFromRange(range) {
        return ts.createTextSpanFromBounds(range.pos, range.end);
    }
    ts.createTextSpanFromRange = createTextSpanFromRange;
    function createTextRangeFromSpan(span) {
        return ts.createRange(span.start, span.start + span.length);
    }
    ts.createTextRangeFromSpan = createTextRangeFromSpan;
    function createTextChangeFromStartLength(start, length, newText) {
        return createTextChange(ts.createTextSpan(start, length), newText);
    }
    ts.createTextChangeFromStartLength = createTextChangeFromStartLength;
    function createTextChange(span, newText) {
        return { span: span, newText: newText };
    }
    ts.createTextChange = createTextChange;
    ts.typeKeywords = [
        129 /* AnyKeyword */,
        128 /* AssertsKeyword */,
        156 /* BigIntKeyword */,
        132 /* BooleanKeyword */,
        95 /* FalseKeyword */,
        136 /* InferKeyword */,
        139 /* KeyOfKeyword */,
        142 /* NeverKeyword */,
        104 /* NullKeyword */,
        145 /* NumberKeyword */,
        146 /* ObjectKeyword */,
        143 /* ReadonlyKeyword */,
        148 /* StringKeyword */,
        149 /* SymbolKeyword */,
        110 /* TrueKeyword */,
        114 /* VoidKeyword */,
        151 /* UndefinedKeyword */,
        152 /* UniqueKeyword */,
        153 /* UnknownKeyword */,
    ];
    function isTypeKeyword(kind) {
        return ts.contains(ts.typeKeywords, kind);
    }
    ts.isTypeKeyword = isTypeKeyword;
    function isTypeKeywordToken(node) {
        return node.kind === 150 /* TypeKeyword */;
    }
    ts.isTypeKeywordToken = isTypeKeywordToken;
    /** True if the symbol is for an external module, as opposed to a namespace. */
    function isExternalModuleSymbol(moduleSymbol) {
        return !!(moduleSymbol.flags & 1536 /* Module */) && moduleSymbol.name.charCodeAt(0) === 34 /* doubleQuote */;
    }
    ts.isExternalModuleSymbol = isExternalModuleSymbol;
    function nodeSeenTracker() {
        var seen = [];
        return function (node) {
            var id = ts.getNodeId(node);
            return !seen[id] && (seen[id] = true);
        };
    }
    ts.nodeSeenTracker = nodeSeenTracker;
    function getSnapshotText(snap) {
        return snap.getText(0, snap.getLength());
    }
    ts.getSnapshotText = getSnapshotText;
    function repeatString(str, count) {
        var result = "";
        for (var i = 0; i < count; i++) {
            result += str;
        }
        return result;
    }
    ts.repeatString = repeatString;
    function skipConstraint(type) {
        return type.isTypeParameter() ? type.getConstraint() || type : type;
    }
    ts.skipConstraint = skipConstraint;
    function getNameFromPropertyName(name) {
        return name.kind === 160 /* ComputedPropertyName */
            // treat computed property names where expression is string/numeric literal as just string/numeric literal
            ? ts.isStringOrNumericLiteralLike(name.expression) ? name.expression.text : undefined
            : ts.isPrivateIdentifier(name) ? ts.idText(name) : ts.getTextOfIdentifierOrLiteral(name);
    }
    ts.getNameFromPropertyName = getNameFromPropertyName;
    function programContainsModules(program) {
        return program.getSourceFiles().some(function (s) { return !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s) && !!(s.externalModuleIndicator || s.commonJsModuleIndicator); });
    }
    ts.programContainsModules = programContainsModules;
    function programContainsEs6Modules(program) {
        return program.getSourceFiles().some(function (s) { return !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s) && !!s.externalModuleIndicator; });
    }
    ts.programContainsEs6Modules = programContainsEs6Modules;
    function compilerOptionsIndicateEs6Modules(compilerOptions) {
        return !!compilerOptions.module || compilerOptions.target >= 2 /* ES2015 */ || !!compilerOptions.noEmit;
    }
    ts.compilerOptionsIndicateEs6Modules = compilerOptionsIndicateEs6Modules;
    function createModuleSpecifierResolutionHost(program, host) {
        // Mix in `getSymlinkCache` from Program when host doesn't have it
        // in order for non-Project hosts to have a symlinks cache.
        return {
            fileExists: function (fileName) { return program.fileExists(fileName); },
            getCurrentDirectory: function () { return host.getCurrentDirectory(); },
            readFile: ts.maybeBind(host, host.readFile),
            useCaseSensitiveFileNames: ts.maybeBind(host, host.useCaseSensitiveFileNames),
            getSymlinkCache: ts.maybeBind(host, host.getSymlinkCache) || program.getSymlinkCache,
            getModuleSpecifierCache: ts.maybeBind(host, host.getModuleSpecifierCache),
            getGlobalTypingsCacheLocation: ts.maybeBind(host, host.getGlobalTypingsCacheLocation),
            redirectTargetsMap: program.redirectTargetsMap,
            getProjectReferenceRedirect: function (fileName) { return program.getProjectReferenceRedirect(fileName); },
            isSourceOfProjectReferenceRedirect: function (fileName) { return program.isSourceOfProjectReferenceRedirect(fileName); },
            getNearestAncestorDirectoryWithPackageJson: ts.maybeBind(host, host.getNearestAncestorDirectoryWithPackageJson),
            getFileIncludeReasons: function () { return program.getFileIncludeReasons(); },
        };
    }
    ts.createModuleSpecifierResolutionHost = createModuleSpecifierResolutionHost;
    function getModuleSpecifierResolverHost(program, host) {
        return __assign(__assign({}, createModuleSpecifierResolutionHost(program, host)), { getCommonSourceDirectory: function () { return program.getCommonSourceDirectory(); } });
    }
    ts.getModuleSpecifierResolverHost = getModuleSpecifierResolverHost;
    function makeImportIfNecessary(defaultImport, namedImports, moduleSpecifier, quotePreference) {
        return defaultImport || namedImports && namedImports.length ? makeImport(defaultImport, namedImports, moduleSpecifier, quotePreference) : undefined;
    }
    ts.makeImportIfNecessary = makeImportIfNecessary;
    function makeImport(defaultImport, namedImports, moduleSpecifier, quotePreference, isTypeOnly) {
        return ts.factory.createImportDeclaration(
        /*decorators*/ undefined, 
        /*modifiers*/ undefined, defaultImport || namedImports
            ? ts.factory.createImportClause(!!isTypeOnly, defaultImport, namedImports && namedImports.length ? ts.factory.createNamedImports(namedImports) : undefined)
            : undefined, typeof moduleSpecifier === "string" ? makeStringLiteral(moduleSpecifier, quotePreference) : moduleSpecifier);
    }
    ts.makeImport = makeImport;
    function makeStringLiteral(text, quotePreference) {
        return ts.factory.createStringLiteral(text, quotePreference === 0 /* Single */);
    }
    ts.makeStringLiteral = makeStringLiteral;
    var QuotePreference;
    (function (QuotePreference) {
        QuotePreference[QuotePreference["Single"] = 0] = "Single";
        QuotePreference[QuotePreference["Double"] = 1] = "Double";
    })(QuotePreference = ts.QuotePreference || (ts.QuotePreference = {}));
    function quotePreferenceFromString(str, sourceFile) {
        return ts.isStringDoubleQuoted(str, sourceFile) ? 1 /* Double */ : 0 /* Single */;
    }
    ts.quotePreferenceFromString = quotePreferenceFromString;
    function getQuotePreference(sourceFile, preferences) {
        if (preferences.quotePreference && preferences.quotePreference !== "auto") {
            return preferences.quotePreference === "single" ? 0 /* Single */ : 1 /* Double */;
        }
        else {
            // ignore synthetic import added when importHelpers: true
            var firstModuleSpecifier = sourceFile.imports &&
                ts.find(sourceFile.imports, function (n) { return ts.isStringLiteral(n) && !ts.nodeIsSynthesized(n.parent); });
            return firstModuleSpecifier ? quotePreferenceFromString(firstModuleSpecifier, sourceFile) : 1 /* Double */;
        }
    }
    ts.getQuotePreference = getQuotePreference;
    function getQuoteFromPreference(qp) {
        switch (qp) {
            case 0 /* Single */: return "'";
            case 1 /* Double */: return '"';
            default: return ts.Debug.assertNever(qp);
        }
    }
    ts.getQuoteFromPreference = getQuoteFromPreference;
    function symbolNameNoDefault(symbol) {
        var escaped = symbolEscapedNameNoDefault(symbol);
        return escaped === undefined ? undefined : ts.unescapeLeadingUnderscores(escaped);
    }
    ts.symbolNameNoDefault = symbolNameNoDefault;
    function symbolEscapedNameNoDefault(symbol) {
        if (symbol.escapedName !== "default" /* Default */) {
            return symbol.escapedName;
        }
        return ts.firstDefined(symbol.declarations, function (decl) {
            var name = ts.getNameOfDeclaration(decl);
            return name && name.kind === 79 /* Identifier */ ? name.escapedText : undefined;
        });
    }
    ts.symbolEscapedNameNoDefault = symbolEscapedNameNoDefault;
    function isModuleSpecifierLike(node) {
        return ts.isStringLiteralLike(node) && (ts.isExternalModuleReference(node.parent) ||
            ts.isImportDeclaration(node.parent) ||
            ts.isRequireCall(node.parent, /*requireStringLiteralLikeArgument*/ false) && node.parent.arguments[0] === node ||
            ts.isImportCall(node.parent) && node.parent.arguments[0] === node);
    }
    ts.isModuleSpecifierLike = isModuleSpecifierLike;
    function isObjectBindingElementWithoutPropertyName(bindingElement) {
        return ts.isBindingElement(bindingElement) &&
            ts.isObjectBindingPattern(bindingElement.parent) &&
            ts.isIdentifier(bindingElement.name) &&
            !bindingElement.propertyName;
    }
    ts.isObjectBindingElementWithoutPropertyName = isObjectBindingElementWithoutPropertyName;
    function getPropertySymbolFromBindingElement(checker, bindingElement) {
        var typeOfPattern = checker.getTypeAtLocation(bindingElement.parent);
        return typeOfPattern && checker.getPropertyOfType(typeOfPattern, bindingElement.name.text);
    }
    ts.getPropertySymbolFromBindingElement = getPropertySymbolFromBindingElement;
    function getParentNodeInSpan(node, file, span) {
        if (!node)
            return undefined;
        while (node.parent) {
            if (ts.isSourceFile(node.parent) || !spanContainsNode(span, node.parent, file)) {
                return node;
            }
            node = node.parent;
        }
    }
    ts.getParentNodeInSpan = getParentNodeInSpan;
    function spanContainsNode(span, node, file) {
        return ts.textSpanContainsPosition(span, node.getStart(file)) &&
            node.getEnd() <= ts.textSpanEnd(span);
    }
    function findModifier(node, kind) {
        return node.modifiers && ts.find(node.modifiers, function (m) { return m.kind === kind; });
    }
    ts.findModifier = findModifier;
    function insertImports(changes, sourceFile, imports, blankLineBetween) {
        var decl = ts.isArray(imports) ? imports[0] : imports;
        var importKindPredicate = decl.kind === 235 /* VariableStatement */ ? ts.isRequireVariableStatement : ts.isAnyImportSyntax;
        var existingImportStatements = ts.filter(sourceFile.statements, importKindPredicate);
        var sortedNewImports = ts.isArray(imports) ? ts.stableSort(imports, ts.OrganizeImports.compareImportsOrRequireStatements) : [imports];
        if (!existingImportStatements.length) {
            changes.insertNodesAtTopOfFile(sourceFile, sortedNewImports, blankLineBetween);
        }
        else if (existingImportStatements && ts.OrganizeImports.importsAreSorted(existingImportStatements)) {
            for (var _i = 0, sortedNewImports_1 = sortedNewImports; _i < sortedNewImports_1.length; _i++) {
                var newImport = sortedNewImports_1[_i];
                var insertionIndex = ts.OrganizeImports.getImportDeclarationInsertionIndex(existingImportStatements, newImport);
                if (insertionIndex === 0) {
                    // If the first import is top-of-file, insert after the leading comment which is likely the header.
                    var options = existingImportStatements[0] === sourceFile.statements[0] ?
                        { leadingTriviaOption: ts.textChanges.LeadingTriviaOption.Exclude } : {};
                    changes.insertNodeBefore(sourceFile, existingImportStatements[0], newImport, /*blankLineBetween*/ false, options);
                }
                else {
                    var prevImport = existingImportStatements[insertionIndex - 1];
                    changes.insertNodeAfter(sourceFile, prevImport, newImport);
                }
            }
        }
        else {
            var lastExistingImport = ts.lastOrUndefined(existingImportStatements);
            if (lastExistingImport) {
                changes.insertNodesAfter(sourceFile, lastExistingImport, sortedNewImports);
            }
            else {
                changes.insertNodesAtTopOfFile(sourceFile, sortedNewImports, blankLineBetween);
            }
        }
    }
    ts.insertImports = insertImports;
    function getTypeKeywordOfTypeOnlyImport(importClause, sourceFile) {
        ts.Debug.assert(importClause.isTypeOnly);
        return ts.cast(importClause.getChildAt(0, sourceFile), isTypeKeywordToken);
    }
    ts.getTypeKeywordOfTypeOnlyImport = getTypeKeywordOfTypeOnlyImport;
    function textSpansEqual(a, b) {
        return !!a && !!b && a.start === b.start && a.length === b.length;
    }
    ts.textSpansEqual = textSpansEqual;
    function documentSpansEqual(a, b) {
        return a.fileName === b.fileName && textSpansEqual(a.textSpan, b.textSpan);
    }
    ts.documentSpansEqual = documentSpansEqual;
    /**
     * Iterates through 'array' by index and performs the callback on each element of array until the callback
     * returns a truthy value, then returns that value.
     * If no such value is found, the callback is applied to each element of array and undefined is returned.
     */
    function forEachUnique(array, callback) {
        if (array) {
            for (var i = 0; i < array.length; i++) {
                if (array.indexOf(array[i]) === i) {
                    var result = callback(array[i], i);
                    if (result) {
                        return result;
                    }
                }
            }
        }
        return undefined;
    }
    ts.forEachUnique = forEachUnique;
    function isTextWhiteSpaceLike(text, startPos, endPos) {
        for (var i = startPos; i < endPos; i++) {
            if (!ts.isWhiteSpaceLike(text.charCodeAt(i))) {
                return false;
            }
        }
        return true;
    }
    ts.isTextWhiteSpaceLike = isTextWhiteSpaceLike;
    // #endregion
    // Display-part writer helpers
    // #region
    function isFirstDeclarationOfSymbolParameter(symbol) {
        return symbol.declarations && symbol.declarations.length > 0 && symbol.declarations[0].kind === 162 /* Parameter */;
    }
    ts.isFirstDeclarationOfSymbolParameter = isFirstDeclarationOfSymbolParameter;
    var displayPartWriter = getDisplayPartWriter();
    function getDisplayPartWriter() {
        var absoluteMaximumLength = ts.defaultMaximumTruncationLength * 10; // A hard cutoff to avoid overloading the messaging channel in worst-case scenarios
        var displayParts;
        var lineStart;
        var indent;
        var length;
        resetWriter();
        var unknownWrite = function (text) { return writeKind(text, ts.SymbolDisplayPartKind.text); };
        return {
            displayParts: function () {
                var finalText = displayParts.length && displayParts[displayParts.length - 1].text;
                if (length > absoluteMaximumLength && finalText && finalText !== "...") {
                    if (!ts.isWhiteSpaceLike(finalText.charCodeAt(finalText.length - 1))) {
                        displayParts.push(displayPart(" ", ts.SymbolDisplayPartKind.space));
                    }
                    displayParts.push(displayPart("...", ts.SymbolDisplayPartKind.punctuation));
                }
                return displayParts;
            },
            writeKeyword: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.keyword); },
            writeOperator: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.operator); },
            writePunctuation: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.punctuation); },
            writeTrailingSemicolon: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.punctuation); },
            writeSpace: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.space); },
            writeStringLiteral: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.stringLiteral); },
            writeParameter: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.parameterName); },
            writeProperty: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.propertyName); },
            writeLiteral: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.stringLiteral); },
            writeSymbol: writeSymbol,
            writeLine: writeLine,
            write: unknownWrite,
            writeComment: unknownWrite,
            getText: function () { return ""; },
            getTextPos: function () { return 0; },
            getColumn: function () { return 0; },
            getLine: function () { return 0; },
            isAtStartOfLine: function () { return false; },
            hasTrailingWhitespace: function () { return false; },
            hasTrailingComment: function () { return false; },
            rawWrite: ts.notImplemented,
            getIndent: function () { return indent; },
            increaseIndent: function () { indent++; },
            decreaseIndent: function () { indent--; },
            clear: resetWriter,
            trackSymbol: function () { return false; },
            reportInaccessibleThisError: ts.noop,
            reportInaccessibleUniqueSymbolError: ts.noop,
            reportPrivateInBaseOfClassExpression: ts.noop,
        };
        function writeIndent() {
            if (length > absoluteMaximumLength)
                return;
            if (lineStart) {
                var indentString = ts.getIndentString(indent);
                if (indentString) {
                    length += indentString.length;
                    displayParts.push(displayPart(indentString, ts.SymbolDisplayPartKind.space));
                }
                lineStart = false;
            }
        }
        function writeKind(text, kind) {
            if (length > absoluteMaximumLength)
                return;
            writeIndent();
            length += text.length;
            displayParts.push(displayPart(text, kind));
        }
        function writeSymbol(text, symbol) {
            if (length > absoluteMaximumLength)
                return;
            writeIndent();
            length += text.length;
            displayParts.push(symbolPart(text, symbol));
        }
        function writeLine() {
            if (length > absoluteMaximumLength)
                return;
            length += 1;
            displayParts.push(lineBreakPart());
            lineStart = true;
        }
        function resetWriter() {
            displayParts = [];
            lineStart = true;
            indent = 0;
            length = 0;
        }
    }
    function symbolPart(text, symbol) {
        return displayPart(text, displayPartKind(symbol));
        function displayPartKind(symbol) {
            var flags = symbol.flags;
            if (flags & 3 /* Variable */) {
                return isFirstDeclarationOfSymbolParameter(symbol) ? ts.SymbolDisplayPartKind.parameterName : ts.SymbolDisplayPartKind.localName;
            }
            else if (flags & 4 /* Property */) {
                return ts.SymbolDisplayPartKind.propertyName;
            }
            else if (flags & 32768 /* GetAccessor */) {
                return ts.SymbolDisplayPartKind.propertyName;
            }
            else if (flags & 65536 /* SetAccessor */) {
                return ts.SymbolDisplayPartKind.propertyName;
            }
            else if (flags & 8 /* EnumMember */) {
                return ts.SymbolDisplayPartKind.enumMemberName;
            }
            else if (flags & 16 /* Function */) {
                return ts.SymbolDisplayPartKind.functionName;
            }
            else if (flags & 32 /* Class */) {
                return ts.SymbolDisplayPartKind.className;
            }
            else if (flags & 64 /* Interface */) {
                return ts.SymbolDisplayPartKind.interfaceName;
            }
            else if (flags & 384 /* Enum */) {
                return ts.SymbolDisplayPartKind.enumName;
            }
            else if (flags & 1536 /* Module */) {
                return ts.SymbolDisplayPartKind.moduleName;
            }
            else if (flags & 8192 /* Method */) {
                return ts.SymbolDisplayPartKind.methodName;
            }
            else if (flags & 262144 /* TypeParameter */) {
                return ts.SymbolDisplayPartKind.typeParameterName;
            }
            else if (flags & 524288 /* TypeAlias */) {
                return ts.SymbolDisplayPartKind.aliasName;
            }
            else if (flags & 2097152 /* Alias */) {
                return ts.SymbolDisplayPartKind.aliasName;
            }
            return ts.SymbolDisplayPartKind.text;
        }
    }
    ts.symbolPart = symbolPart;
    function displayPart(text, kind) {
        return { text: text, kind: ts.SymbolDisplayPartKind[kind] };
    }
    ts.displayPart = displayPart;
    function spacePart() {
        return displayPart(" ", ts.SymbolDisplayPartKind.space);
    }
    ts.spacePart = spacePart;
    function keywordPart(kind) {
        return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.keyword);
    }
    ts.keywordPart = keywordPart;
    function punctuationPart(kind) {
        return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.punctuation);
    }
    ts.punctuationPart = punctuationPart;
    function operatorPart(kind) {
        return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.operator);
    }
    ts.operatorPart = operatorPart;
    function parameterNamePart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.parameterName);
    }
    ts.parameterNamePart = parameterNamePart;
    function propertyNamePart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.propertyName);
    }
    ts.propertyNamePart = propertyNamePart;
    function textOrKeywordPart(text) {
        var kind = ts.stringToToken(text);
        return kind === undefined
            ? textPart(text)
            : keywordPart(kind);
    }
    ts.textOrKeywordPart = textOrKeywordPart;
    function textPart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.text);
    }
    ts.textPart = textPart;
    function typeAliasNamePart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.aliasName);
    }
    ts.typeAliasNamePart = typeAliasNamePart;
    function typeParameterNamePart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.typeParameterName);
    }
    ts.typeParameterNamePart = typeParameterNamePart;
    function linkTextPart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.linkText);
    }
    ts.linkTextPart = linkTextPart;
    function linkNamePart(name, target) {
        return {
            text: ts.getTextOfNode(name),
            kind: ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.linkName],
            target: {
                fileName: ts.getSourceFileOfNode(target).fileName,
                textSpan: createTextSpanFromNode(target),
            },
        };
    }
    ts.linkNamePart = linkNamePart;
    function linkPart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.link);
    }
    ts.linkPart = linkPart;
    function buildLinkParts(link, checker) {
        var _a;
        var prefix = ts.isJSDocLink(link) ? "link"
            : ts.isJSDocLinkCode(link) ? "linkcode"
                : "linkplain";
        var parts = [linkPart("{@" + prefix + " ")];
        if (!link.name) {
            if (link.text) {
                parts.push(linkTextPart(link.text));
            }
        }
        else {
            var symbol = checker === null || checker === void 0 ? void 0 : checker.getSymbolAtLocation(link.name);
            var decl = (symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration) || ((_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a[0]);
            if (decl) {
                parts.push(linkNamePart(link.name, decl));
                if (link.text) {
                    parts.push(linkTextPart(link.text));
                }
            }
            else {
                parts.push(linkTextPart(ts.getTextOfNode(link.name) + " " + link.text));
            }
        }
        parts.push(linkPart("}"));
        return parts;
    }
    ts.buildLinkParts = buildLinkParts;
    var carriageReturnLineFeed = "\r\n";
    /**
     * The default is CRLF.
     */
    function getNewLineOrDefaultFromHost(host, formatSettings) {
        var _a;
        return (formatSettings === null || formatSettings === void 0 ? void 0 : formatSettings.newLineCharacter) ||
            ((_a = host.getNewLine) === null || _a === void 0 ? void 0 : _a.call(host)) ||
            carriageReturnLineFeed;
    }
    ts.getNewLineOrDefaultFromHost = getNewLineOrDefaultFromHost;
    function lineBreakPart() {
        return displayPart("\n", ts.SymbolDisplayPartKind.lineBreak);
    }
    ts.lineBreakPart = lineBreakPart;
    function mapToDisplayParts(writeDisplayParts) {
        try {
            writeDisplayParts(displayPartWriter);
            return displayPartWriter.displayParts();
        }
        finally {
            displayPartWriter.clear();
        }
    }
    ts.mapToDisplayParts = mapToDisplayParts;
    function typeToDisplayParts(typechecker, type, enclosingDeclaration, flags) {
        if (flags === void 0) { flags = 0 /* None */; }
        return mapToDisplayParts(function (writer) {
            typechecker.writeType(type, enclosingDeclaration, flags | 1024 /* MultilineObjectLiterals */ | 16384 /* UseAliasDefinedOutsideCurrentScope */, writer);
        });
    }
    ts.typeToDisplayParts = typeToDisplayParts;
    function symbolToDisplayParts(typeChecker, symbol, enclosingDeclaration, meaning, flags) {
        if (flags === void 0) { flags = 0 /* None */; }
        return mapToDisplayParts(function (writer) {
            typeChecker.writeSymbol(symbol, enclosingDeclaration, meaning, flags | 8 /* UseAliasDefinedOutsideCurrentScope */, writer);
        });
    }
    ts.symbolToDisplayParts = symbolToDisplayParts;
    function signatureToDisplayParts(typechecker, signature, enclosingDeclaration, flags) {
        if (flags === void 0) { flags = 0 /* None */; }
        flags |= 16384 /* UseAliasDefinedOutsideCurrentScope */ | 1024 /* MultilineObjectLiterals */ | 32 /* WriteTypeArgumentsOfSignature */ | 8192 /* OmitParameterModifiers */;
        return mapToDisplayParts(function (writer) {
            typechecker.writeSignature(signature, enclosingDeclaration, flags, /*signatureKind*/ undefined, writer);
        });
    }
    ts.signatureToDisplayParts = signatureToDisplayParts;
    function isImportOrExportSpecifierName(location) {
        return !!location.parent && ts.isImportOrExportSpecifier(location.parent) && location.parent.propertyName === location;
    }
    ts.isImportOrExportSpecifierName = isImportOrExportSpecifierName;
    function getScriptKind(fileName, host) {
        // First check to see if the script kind was specified by the host. Chances are the host
        // may override the default script kind for the file extension.
        return ts.ensureScriptKind(fileName, host.getScriptKind && host.getScriptKind(fileName));
    }
    ts.getScriptKind = getScriptKind;
    function getSymbolTarget(symbol, checker) {
        var next = symbol;
        while (isAliasSymbol(next) || (isTransientSymbol(next) && next.target)) {
            if (isTransientSymbol(next) && next.target) {
                next = next.target;
            }
            else {
                next = ts.skipAlias(next, checker);
            }
        }
        return next;
    }
    ts.getSymbolTarget = getSymbolTarget;
    function isTransientSymbol(symbol) {
        return (symbol.flags & 33554432 /* Transient */) !== 0;
    }
    function isAliasSymbol(symbol) {
        return (symbol.flags & 2097152 /* Alias */) !== 0;
    }
    function getUniqueSymbolId(symbol, checker) {
        return ts.getSymbolId(ts.skipAlias(symbol, checker));
    }
    ts.getUniqueSymbolId = getUniqueSymbolId;
    function getFirstNonSpaceCharacterPosition(text, position) {
        while (ts.isWhiteSpaceLike(text.charCodeAt(position))) {
            position += 1;
        }
        return position;
    }
    ts.getFirstNonSpaceCharacterPosition = getFirstNonSpaceCharacterPosition;
    function getPrecedingNonSpaceCharacterPosition(text, position) {
        while (position > -1 && ts.isWhiteSpaceSingleLine(text.charCodeAt(position))) {
            position -= 1;
        }
        return position + 1;
    }
    ts.getPrecedingNonSpaceCharacterPosition = getPrecedingNonSpaceCharacterPosition;
    /**
     * Creates a deep, memberwise clone of a node with no source map location.
     *
     * WARNING: This is an expensive operation and is only intended to be used in refactorings
     * and code fixes (because those are triggered by explicit user actions).
     */
    function getSynthesizedDeepClone(node, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = true; }
        var clone = node && getSynthesizedDeepCloneWorker(node);
        if (clone && !includeTrivia)
            suppressLeadingAndTrailingTrivia(clone);
        return clone;
    }
    ts.getSynthesizedDeepClone = getSynthesizedDeepClone;
    function getSynthesizedDeepCloneWithReplacements(node, includeTrivia, replaceNode) {
        var clone = replaceNode(node);
        if (clone) {
            ts.setOriginalNode(clone, node);
        }
        else {
            clone = getSynthesizedDeepCloneWorker(node, replaceNode);
        }
        if (clone && !includeTrivia)
            suppressLeadingAndTrailingTrivia(clone);
        return clone;
    }
    ts.getSynthesizedDeepCloneWithReplacements = getSynthesizedDeepCloneWithReplacements;
    function getSynthesizedDeepCloneWorker(node, replaceNode) {
        var nodeClone = replaceNode
            ? function (n) { return getSynthesizedDeepCloneWithReplacements(n, /*includeTrivia*/ true, replaceNode); }
            : getSynthesizedDeepClone;
        var nodesClone = replaceNode
            ? function (ns) { return ns && getSynthesizedDeepClonesWithReplacements(ns, /*includeTrivia*/ true, replaceNode); }
            : function (ns) { return ns && getSynthesizedDeepClones(ns); };
        var visited = ts.visitEachChild(node, nodeClone, ts.nullTransformationContext, nodesClone, nodeClone);
        if (visited === node) {
            // This only happens for leaf nodes - internal nodes always see their children change.
            var clone_1 = ts.isStringLiteral(node) ? ts.setOriginalNode(ts.factory.createStringLiteralFromNode(node), node) :
                ts.isNumericLiteral(node) ? ts.setOriginalNode(ts.factory.createNumericLiteral(node.text, node.numericLiteralFlags), node) :
                    ts.factory.cloneNode(node);
            return ts.setTextRange(clone_1, node);
        }
        // PERF: As an optimization, rather than calling factory.cloneNode, we'll update
        // the new node created by visitEachChild with the extra changes factory.cloneNode
        // would have made.
        visited.parent = undefined;
        return visited;
    }
    function getSynthesizedDeepClones(nodes, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = true; }
        return nodes && ts.factory.createNodeArray(nodes.map(function (n) { return getSynthesizedDeepClone(n, includeTrivia); }), nodes.hasTrailingComma);
    }
    ts.getSynthesizedDeepClones = getSynthesizedDeepClones;
    function getSynthesizedDeepClonesWithReplacements(nodes, includeTrivia, replaceNode) {
        return ts.factory.createNodeArray(nodes.map(function (n) { return getSynthesizedDeepCloneWithReplacements(n, includeTrivia, replaceNode); }), nodes.hasTrailingComma);
    }
    ts.getSynthesizedDeepClonesWithReplacements = getSynthesizedDeepClonesWithReplacements;
    /**
     * Sets EmitFlags to suppress leading and trailing trivia on the node.
     */
    function suppressLeadingAndTrailingTrivia(node) {
        suppressLeadingTrivia(node);
        suppressTrailingTrivia(node);
    }
    ts.suppressLeadingAndTrailingTrivia = suppressLeadingAndTrailingTrivia;
    /**
     * Sets EmitFlags to suppress leading trivia on the node.
     */
    function suppressLeadingTrivia(node) {
        addEmitFlagsRecursively(node, 512 /* NoLeadingComments */, getFirstChild);
    }
    ts.suppressLeadingTrivia = suppressLeadingTrivia;
    /**
     * Sets EmitFlags to suppress trailing trivia on the node.
     */
    function suppressTrailingTrivia(node) {
        addEmitFlagsRecursively(node, 1024 /* NoTrailingComments */, ts.getLastChild);
    }
    ts.suppressTrailingTrivia = suppressTrailingTrivia;
    function copyComments(sourceNode, targetNode) {
        var sourceFile = sourceNode.getSourceFile();
        var text = sourceFile.text;
        if (hasLeadingLineBreak(sourceNode, text)) {
            copyLeadingComments(sourceNode, targetNode, sourceFile);
        }
        else {
            copyTrailingAsLeadingComments(sourceNode, targetNode, sourceFile);
        }
        copyTrailingComments(sourceNode, targetNode, sourceFile);
    }
    ts.copyComments = copyComments;
    function hasLeadingLineBreak(node, text) {
        var start = node.getFullStart();
        var end = node.getStart();
        for (var i = start; i < end; i++) {
            if (text.charCodeAt(i) === 10 /* lineFeed */)
                return true;
        }
        return false;
    }
    function addEmitFlagsRecursively(node, flag, getChild) {
        ts.addEmitFlags(node, flag);
        var child = getChild(node);
        if (child)
            addEmitFlagsRecursively(child, flag, getChild);
    }
    function getFirstChild(node) {
        return node.forEachChild(function (child) { return child; });
    }
    function getUniqueName(baseName, sourceFile) {
        var nameText = baseName;
        for (var i = 1; !ts.isFileLevelUniqueName(sourceFile, nameText); i++) {
            nameText = baseName + "_" + i;
        }
        return nameText;
    }
    ts.getUniqueName = getUniqueName;
    /**
     * @return The index of the (only) reference to the extracted symbol.  We want the cursor
     * to be on the reference, rather than the declaration, because it's closer to where the
     * user was before extracting it.
     */
    function getRenameLocation(edits, renameFilename, name, preferLastLocation) {
        var delta = 0;
        var lastPos = -1;
        for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
            var _a = edits_1[_i], fileName = _a.fileName, textChanges_2 = _a.textChanges;
            ts.Debug.assert(fileName === renameFilename);
            for (var _b = 0, textChanges_1 = textChanges_2; _b < textChanges_1.length; _b++) {
                var change = textChanges_1[_b];
                var span = change.span, newText = change.newText;
                var index = indexInTextChange(newText, name);
                if (index !== -1) {
                    lastPos = span.start + delta + index;
                    // If the reference comes first, return immediately.
                    if (!preferLastLocation) {
                        return lastPos;
                    }
                }
                delta += newText.length - span.length;
            }
        }
        // If the declaration comes first, return the position of the last occurrence.
        ts.Debug.assert(preferLastLocation);
        ts.Debug.assert(lastPos >= 0);
        return lastPos;
    }
    ts.getRenameLocation = getRenameLocation;
    function copyLeadingComments(sourceNode, targetNode, sourceFile, commentKind, hasTrailingNewLine) {
        ts.forEachLeadingCommentRange(sourceFile.text, sourceNode.pos, getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, ts.addSyntheticLeadingComment));
    }
    ts.copyLeadingComments = copyLeadingComments;
    function copyTrailingComments(sourceNode, targetNode, sourceFile, commentKind, hasTrailingNewLine) {
        ts.forEachTrailingCommentRange(sourceFile.text, sourceNode.end, getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, ts.addSyntheticTrailingComment));
    }
    ts.copyTrailingComments = copyTrailingComments;
    /**
     * This function copies the trailing comments for the token that comes before `sourceNode`, as leading comments of `targetNode`.
     * This is useful because sometimes a comment that refers to `sourceNode` will be a leading comment for `sourceNode`, according to the
     * notion of trivia ownership, and instead will be a trailing comment for the token before `sourceNode`, e.g.:
     * `function foo(\* not leading comment for a *\ a: string) {}`
     * The comment refers to `a` but belongs to the `(` token, but we might want to copy it.
     */
    function copyTrailingAsLeadingComments(sourceNode, targetNode, sourceFile, commentKind, hasTrailingNewLine) {
        ts.forEachTrailingCommentRange(sourceFile.text, sourceNode.pos, getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, ts.addSyntheticLeadingComment));
    }
    ts.copyTrailingAsLeadingComments = copyTrailingAsLeadingComments;
    function getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, cb) {
        return function (pos, end, kind, htnl) {
            if (kind === 3 /* MultiLineCommentTrivia */) {
                // Remove leading /*
                pos += 2;
                // Remove trailing */
                end -= 2;
            }
            else {
                // Remove leading //
                pos += 2;
            }
            cb(targetNode, commentKind || kind, sourceFile.text.slice(pos, end), hasTrailingNewLine !== undefined ? hasTrailingNewLine : htnl);
        };
    }
    function indexInTextChange(change, name) {
        if (ts.startsWith(change, name))
            return 0;
        // Add a " " to avoid references inside words
        var idx = change.indexOf(" " + name);
        if (idx === -1)
            idx = change.indexOf("." + name);
        if (idx === -1)
            idx = change.indexOf('"' + name);
        return idx === -1 ? -1 : idx + 1;
    }
    /* @internal */
    function needsParentheses(expression) {
        return ts.isBinaryExpression(expression) && expression.operatorToken.kind === 27 /* CommaToken */
            || ts.isObjectLiteralExpression(expression)
            || ts.isAsExpression(expression) && ts.isObjectLiteralExpression(expression.expression);
    }
    ts.needsParentheses = needsParentheses;
    function getContextualTypeFromParent(node, checker) {
        var parent = node.parent;
        switch (parent.kind) {
            case 207 /* NewExpression */:
                return checker.getContextualType(parent);
            case 219 /* BinaryExpression */: {
                var _a = parent, left = _a.left, operatorToken = _a.operatorToken, right = _a.right;
                return isEqualityOperatorKind(operatorToken.kind)
                    ? checker.getTypeAtLocation(node === right ? left : right)
                    : checker.getContextualType(node);
            }
            case 287 /* CaseClause */:
                return parent.expression === node ? getSwitchedType(parent, checker) : undefined;
            default:
                return checker.getContextualType(node);
        }
    }
    ts.getContextualTypeFromParent = getContextualTypeFromParent;
    function quote(sourceFile, preferences, text) {
        // Editors can pass in undefined or empty string - we want to infer the preference in those cases.
        var quotePreference = getQuotePreference(sourceFile, preferences);
        var quoted = JSON.stringify(text);
        return quotePreference === 0 /* Single */ ? "'" + ts.stripQuotes(quoted).replace(/'/g, "\\'").replace(/\\"/g, '"') + "'" : quoted;
    }
    ts.quote = quote;
    function isEqualityOperatorKind(kind) {
        switch (kind) {
            case 36 /* EqualsEqualsEqualsToken */:
            case 34 /* EqualsEqualsToken */:
            case 37 /* ExclamationEqualsEqualsToken */:
            case 35 /* ExclamationEqualsToken */:
                return true;
            default:
                return false;
        }
    }
    ts.isEqualityOperatorKind = isEqualityOperatorKind;
    function isStringLiteralOrTemplate(node) {
        switch (node.kind) {
            case 10 /* StringLiteral */:
            case 14 /* NoSubstitutionTemplateLiteral */:
            case 221 /* TemplateExpression */:
            case 208 /* TaggedTemplateExpression */:
                return true;
            default:
                return false;
        }
    }
    ts.isStringLiteralOrTemplate = isStringLiteralOrTemplate;
    function hasIndexSignature(type) {
        return !!type.getStringIndexType() || !!type.getNumberIndexType();
    }
    ts.hasIndexSignature = hasIndexSignature;
    function getSwitchedType(caseClause, checker) {
        return checker.getTypeAtLocation(caseClause.parent.parent.expression);
    }
    ts.getSwitchedType = getSwitchedType;
    ts.ANONYMOUS = "anonymous function";
    function getTypeNodeIfAccessible(type, enclosingScope, program, host) {
        var checker = program.getTypeChecker();
        var typeIsAccessible = true;
        var notAccessible = function () { typeIsAccessible = false; };
        var res = checker.typeToTypeNode(type, enclosingScope, 1 /* NoTruncation */, {
            trackSymbol: function (symbol, declaration, meaning) {
                typeIsAccessible = typeIsAccessible && checker.isSymbolAccessible(symbol, declaration, meaning, /*shouldComputeAliasToMarkVisible*/ false).accessibility === 0 /* Accessible */;
                return !typeIsAccessible;
            },
            reportInaccessibleThisError: notAccessible,
            reportPrivateInBaseOfClassExpression: notAccessible,
            reportInaccessibleUniqueSymbolError: notAccessible,
            moduleResolverHost: getModuleSpecifierResolverHost(program, host)
        });
        return typeIsAccessible ? res : undefined;
    }
    ts.getTypeNodeIfAccessible = getTypeNodeIfAccessible;
    function syntaxRequiresTrailingCommaOrSemicolonOrASI(kind) {
        return kind === 172 /* CallSignature */
            || kind === 173 /* ConstructSignature */
            || kind === 174 /* IndexSignature */
            || kind === 164 /* PropertySignature */
            || kind === 166 /* MethodSignature */;
    }
    ts.syntaxRequiresTrailingCommaOrSemicolonOrASI = syntaxRequiresTrailingCommaOrSemicolonOrASI;
    function syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI(kind) {
        return kind === 254 /* FunctionDeclaration */
            || kind === 169 /* Constructor */
            || kind === 167 /* MethodDeclaration */
            || kind === 170 /* GetAccessor */
            || kind === 171 /* SetAccessor */;
    }
    ts.syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI = syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI;
    function syntaxRequiresTrailingModuleBlockOrSemicolonOrASI(kind) {
        return kind === 259 /* ModuleDeclaration */;
    }
    ts.syntaxRequiresTrailingModuleBlockOrSemicolonOrASI = syntaxRequiresTrailingModuleBlockOrSemicolonOrASI;
    function syntaxRequiresTrailingSemicolonOrASI(kind) {
        return kind === 235 /* VariableStatement */
            || kind === 236 /* ExpressionStatement */
            || kind === 238 /* DoStatement */
            || kind === 243 /* ContinueStatement */
            || kind === 244 /* BreakStatement */
            || kind === 245 /* ReturnStatement */
            || kind === 249 /* ThrowStatement */
            || kind === 251 /* DebuggerStatement */
            || kind === 165 /* PropertyDeclaration */
            || kind === 257 /* TypeAliasDeclaration */
            || kind === 264 /* ImportDeclaration */
            || kind === 263 /* ImportEqualsDeclaration */
            || kind === 270 /* ExportDeclaration */
            || kind === 262 /* NamespaceExportDeclaration */
            || kind === 269 /* ExportAssignment */;
    }
    ts.syntaxRequiresTrailingSemicolonOrASI = syntaxRequiresTrailingSemicolonOrASI;
    ts.syntaxMayBeASICandidate = ts.or(syntaxRequiresTrailingCommaOrSemicolonOrASI, syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI, syntaxRequiresTrailingModuleBlockOrSemicolonOrASI, syntaxRequiresTrailingSemicolonOrASI);
    function nodeIsASICandidate(node, sourceFile) {
        var lastToken = node.getLastToken(sourceFile);
        if (lastToken && lastToken.kind === 26 /* SemicolonToken */) {
            return false;
        }
        if (syntaxRequiresTrailingCommaOrSemicolonOrASI(node.kind)) {
            if (lastToken && lastToken.kind === 27 /* CommaToken */) {
                return false;
            }
        }
        else if (syntaxRequiresTrailingModuleBlockOrSemicolonOrASI(node.kind)) {
            var lastChild = ts.last(node.getChildren(sourceFile));
            if (lastChild && ts.isModuleBlock(lastChild)) {
                return false;
            }
        }
        else if (syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI(node.kind)) {
            var lastChild = ts.last(node.getChildren(sourceFile));
            if (lastChild && ts.isFunctionBlock(lastChild)) {
                return false;
            }
        }
        else if (!syntaxRequiresTrailingSemicolonOrASI(node.kind)) {
            return false;
        }
        // See comment in parsers `parseDoStatement`
        if (node.kind === 238 /* DoStatement */) {
            return true;
        }
        var topNode = ts.findAncestor(node, function (ancestor) { return !ancestor.parent; });
        var nextToken = findNextToken(node, topNode, sourceFile);
        if (!nextToken || nextToken.kind === 19 /* CloseBraceToken */) {
            return true;
        }
        var startLine = sourceFile.getLineAndCharacterOfPosition(node.getEnd()).line;
        var endLine = sourceFile.getLineAndCharacterOfPosition(nextToken.getStart(sourceFile)).line;
        return startLine !== endLine;
    }
    function positionIsASICandidate(pos, context, sourceFile) {
        var contextAncestor = ts.findAncestor(context, function (ancestor) {
            if (ancestor.end !== pos) {
                return "quit";
            }
            return ts.syntaxMayBeASICandidate(ancestor.kind);
        });
        return !!contextAncestor && nodeIsASICandidate(contextAncestor, sourceFile);
    }
    ts.positionIsASICandidate = positionIsASICandidate;
    function probablyUsesSemicolons(sourceFile) {
        var withSemicolon = 0;
        var withoutSemicolon = 0;
        var nStatementsToObserve = 5;
        ts.forEachChild(sourceFile, function visit(node) {
            if (syntaxRequiresTrailingSemicolonOrASI(node.kind)) {
                var lastToken = node.getLastToken(sourceFile);
                if (lastToken && lastToken.kind === 26 /* SemicolonToken */) {
                    withSemicolon++;
                }
                else {
                    withoutSemicolon++;
                }
            }
            if (withSemicolon + withoutSemicolon >= nStatementsToObserve) {
                return true;
            }
            return ts.forEachChild(node, visit);
        });
        // One statement missing a semicolon isnt sufficient evidence to say the user
        // doesnt want semicolons, because they may not even be done writing that statement.
        if (withSemicolon === 0 && withoutSemicolon <= 1) {
            return true;
        }
        // If even 2/5 places have a semicolon, the user probably wants semicolons
        return withSemicolon / withoutSemicolon > 1 / nStatementsToObserve;
    }
    ts.probablyUsesSemicolons = probablyUsesSemicolons;
    function tryGetDirectories(host, directoryName) {
        return tryIOAndConsumeErrors(host, host.getDirectories, directoryName) || [];
    }
    ts.tryGetDirectories = tryGetDirectories;
    function tryReadDirectory(host, path, extensions, exclude, include) {
        return tryIOAndConsumeErrors(host, host.readDirectory, path, extensions, exclude, include) || ts.emptyArray;
    }
    ts.tryReadDirectory = tryReadDirectory;
    function tryFileExists(host, path) {
        return tryIOAndConsumeErrors(host, host.fileExists, path);
    }
    ts.tryFileExists = tryFileExists;
    function tryDirectoryExists(host, path) {
        return tryAndIgnoreErrors(function () { return ts.directoryProbablyExists(path, host); }) || false;
    }
    ts.tryDirectoryExists = tryDirectoryExists;
    function tryAndIgnoreErrors(cb) {
        try {
            return cb();
        }
        catch (_a) {
            return undefined;
        }
    }
    ts.tryAndIgnoreErrors = tryAndIgnoreErrors;
    function tryIOAndConsumeErrors(host, toApply) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return tryAndIgnoreErrors(function () { return toApply && toApply.apply(host, args); });
    }
    ts.tryIOAndConsumeErrors = tryIOAndConsumeErrors;
    function findPackageJsons(startDirectory, host, stopDirectory) {
        var paths = [];
        ts.forEachAncestorDirectory(startDirectory, function (ancestor) {
            if (ancestor === stopDirectory) {
                return true;
            }
            var currentConfigPath = ts.combinePaths(ancestor, "package.json");
            if (tryFileExists(host, currentConfigPath)) {
                paths.push(currentConfigPath);
            }
        });
        return paths;
    }
    ts.findPackageJsons = findPackageJsons;
    function findPackageJson(directory, host) {
        var packageJson;
        ts.forEachAncestorDirectory(directory, function (ancestor) {
            if (ancestor === "node_modules")
                return true;
            packageJson = ts.findConfigFile(ancestor, function (f) { return tryFileExists(host, f); }, "package.json");
            if (packageJson) {
                return true; // break out
            }
        });
        return packageJson;
    }
    ts.findPackageJson = findPackageJson;
    function getPackageJsonsVisibleToFile(fileName, host) {
        if (!host.fileExists) {
            return [];
        }
        var packageJsons = [];
        ts.forEachAncestorDirectory(ts.getDirectoryPath(fileName), function (ancestor) {
            var packageJsonFileName = ts.combinePaths(ancestor, "package.json");
            if (host.fileExists(packageJsonFileName)) {
                var info = createPackageJsonInfo(packageJsonFileName, host);
                if (info) {
                    packageJsons.push(info);
                }
            }
        });
        return packageJsons;
    }
    ts.getPackageJsonsVisibleToFile = getPackageJsonsVisibleToFile;
    function createPackageJsonInfo(fileName, host) {
        if (!host.readFile) {
            return undefined;
        }
        var dependencyKeys = ["dependencies", "devDependencies", "optionalDependencies", "peerDependencies"];
        var stringContent = host.readFile(fileName) || "";
        var content = tryParseJson(stringContent);
        var info = {};
        if (content) {
            for (var _i = 0, dependencyKeys_1 = dependencyKeys; _i < dependencyKeys_1.length; _i++) {
                var key = dependencyKeys_1[_i];
                var dependencies = content[key];
                if (!dependencies) {
                    continue;
                }
                var dependencyMap = new ts.Map();
                for (var packageName in dependencies) {
                    dependencyMap.set(packageName, dependencies[packageName]);
                }
                info[key] = dependencyMap;
            }
        }
        var dependencyGroups = [
            [1 /* Dependencies */, info.dependencies],
            [2 /* DevDependencies */, info.devDependencies],
            [8 /* OptionalDependencies */, info.optionalDependencies],
            [4 /* PeerDependencies */, info.peerDependencies],
        ];
        return __assign(__assign({}, info), { parseable: !!content, fileName: fileName, get: get, has: function (dependencyName, inGroups) {
                return !!get(dependencyName, inGroups);
            } });
        function get(dependencyName, inGroups) {
            if (inGroups === void 0) { inGroups = 15 /* All */; }
            for (var _i = 0, dependencyGroups_1 = dependencyGroups; _i < dependencyGroups_1.length; _i++) {
                var _a = dependencyGroups_1[_i], group_1 = _a[0], deps = _a[1];
                if (deps && (inGroups & group_1)) {
                    var dep = deps.get(dependencyName);
                    if (dep !== undefined) {
                        return dep;
                    }
                }
            }
        }
    }
    ts.createPackageJsonInfo = createPackageJsonInfo;
    function createPackageJsonImportFilter(fromFile, preferences, host) {
        var packageJsons = ((host.getPackageJsonsVisibleToFile && host.getPackageJsonsVisibleToFile(fromFile.fileName)) || getPackageJsonsVisibleToFile(fromFile.fileName, host)).filter(function (p) { return p.parseable; });
        var usesNodeCoreModules;
        return { allowsImportingAmbientModule: allowsImportingAmbientModule, allowsImportingSourceFile: allowsImportingSourceFile, allowsImportingSpecifier: allowsImportingSpecifier };
        function moduleSpecifierIsCoveredByPackageJson(specifier) {
            var packageName = getNodeModuleRootSpecifier(specifier);
            for (var _i = 0, packageJsons_1 = packageJsons; _i < packageJsons_1.length; _i++) {
                var packageJson = packageJsons_1[_i];
                if (packageJson.has(packageName) || packageJson.has(ts.getTypesPackageName(packageName))) {
                    return true;
                }
            }
            return false;
        }
        function allowsImportingAmbientModule(moduleSymbol, moduleSpecifierResolutionHost) {
            if (!packageJsons.length || !moduleSymbol.valueDeclaration) {
                return true;
            }
            var declaringSourceFile = moduleSymbol.valueDeclaration.getSourceFile();
            var declaringNodeModuleName = getNodeModulesPackageNameFromFileName(declaringSourceFile.fileName, moduleSpecifierResolutionHost);
            if (typeof declaringNodeModuleName === "undefined") {
                return true;
            }
            var declaredModuleSpecifier = ts.stripQuotes(moduleSymbol.getName());
            if (isAllowedCoreNodeModulesImport(declaredModuleSpecifier)) {
                return true;
            }
            return moduleSpecifierIsCoveredByPackageJson(declaringNodeModuleName)
                || moduleSpecifierIsCoveredByPackageJson(declaredModuleSpecifier);
        }
        function allowsImportingSourceFile(sourceFile, moduleSpecifierResolutionHost) {
            if (!packageJsons.length) {
                return true;
            }
            var moduleSpecifier = getNodeModulesPackageNameFromFileName(sourceFile.fileName, moduleSpecifierResolutionHost);
            if (!moduleSpecifier) {
                return true;
            }
            return moduleSpecifierIsCoveredByPackageJson(moduleSpecifier);
        }
        function allowsImportingSpecifier(moduleSpecifier) {
            if (!packageJsons.length || isAllowedCoreNodeModulesImport(moduleSpecifier)) {
                return true;
            }
            if (ts.pathIsRelative(moduleSpecifier) || ts.isRootedDiskPath(moduleSpecifier)) {
                return true;
            }
            return moduleSpecifierIsCoveredByPackageJson(moduleSpecifier);
        }
        function isAllowedCoreNodeModulesImport(moduleSpecifier) {
            // If were in JavaScript, it can be difficult to tell whether the user wants to import
            // from Node core modules or not. We can start by seeing if the user is actually using
            // any node core modules, as opposed to simply having @types/node accidentally as a
            // dependency of a dependency.
            if (ts.isSourceFileJS(fromFile) && ts.JsTyping.nodeCoreModules.has(moduleSpecifier)) {
                if (usesNodeCoreModules === undefined) {
                    usesNodeCoreModules = consumesNodeCoreModules(fromFile);
                }
                if (usesNodeCoreModules) {
                    return true;
                }
            }
            return false;
        }
        function getNodeModulesPackageNameFromFileName(importedFileName, moduleSpecifierResolutionHost) {
            if (!ts.stringContains(importedFileName, "node_modules")) {
                return undefined;
            }
            var specifier = ts.moduleSpecifiers.getNodeModulesPackageName(host.getCompilationSettings(), fromFile.path, importedFileName, moduleSpecifierResolutionHost, preferences);
            if (!specifier) {
                return undefined;
            }
            // Paths here are not node_modules, so we dont care about them;
            // returning anything will trigger a lookup in package.json.
            if (!ts.pathIsRelative(specifier) && !ts.isRootedDiskPath(specifier)) {
                return getNodeModuleRootSpecifier(specifier);
            }
        }
        function getNodeModuleRootSpecifier(fullSpecifier) {
            var components = ts.getPathComponents(ts.getPackageNameFromTypesPackageName(fullSpecifier)).slice(1);
            // Scoped packages
            if (ts.startsWith(components[0], "@")) {
                return components[0] + "/" + components[1];
            }
            return components[0];
        }
    }
    ts.createPackageJsonImportFilter = createPackageJsonImportFilter;
    function tryParseJson(text) {
        try {
            return JSON.parse(text);
        }
        catch (_a) {
            return undefined;
        }
    }
    function consumesNodeCoreModules(sourceFile) {
        return ts.some(sourceFile.imports, function (_a) {
            var text = _a.text;
            return ts.JsTyping.nodeCoreModules.has(text);
        });
    }
    ts.consumesNodeCoreModules = consumesNodeCoreModules;
    function isInsideNodeModules(fileOrDirectory) {
        return ts.contains(ts.getPathComponents(fileOrDirectory), "node_modules");
    }
    ts.isInsideNodeModules = isInsideNodeModules;
    function isDiagnosticWithLocation(diagnostic) {
        return diagnostic.file !== undefined && diagnostic.start !== undefined && diagnostic.length !== undefined;
    }
    ts.isDiagnosticWithLocation = isDiagnosticWithLocation;
    function findDiagnosticForNode(node, sortedFileDiagnostics) {
        var span = createTextSpanFromNode(node);
        var index = ts.binarySearchKey(sortedFileDiagnostics, span, ts.identity, ts.compareTextSpans);
        if (index >= 0) {
            var diagnostic = sortedFileDiagnostics[index];
            ts.Debug.assertEqual(diagnostic.file, node.getSourceFile(), "Diagnostics proided to 'findDiagnosticForNode' must be from a single SourceFile");
            return ts.cast(diagnostic, isDiagnosticWithLocation);
        }
    }
    ts.findDiagnosticForNode = findDiagnosticForNode;
    function getDiagnosticsWithinSpan(span, sortedFileDiagnostics) {
        var _a;
        var index = ts.binarySearchKey(sortedFileDiagnostics, span.start, function (diag) { return diag.start; }, ts.compareValues);
        if (index < 0) {
            index = ~index;
        }
        while (((_a = sortedFileDiagnostics[index - 1]) === null || _a === void 0 ? void 0 : _a.start) === span.start) {
            index--;
        }
        var result = [];
        var end = ts.textSpanEnd(span);
        while (true) {
            var diagnostic = ts.tryCast(sortedFileDiagnostics[index], isDiagnosticWithLocation);
            if (!diagnostic || diagnostic.start > end) {
                break;
            }
            if (ts.textSpanContainsTextSpan(span, diagnostic)) {
                result.push(diagnostic);
            }
            index++;
        }
        return result;
    }
    ts.getDiagnosticsWithinSpan = getDiagnosticsWithinSpan;
    /* @internal */
    function getRefactorContextSpan(_a) {
        var startPosition = _a.startPosition, endPosition = _a.endPosition;
        return ts.createTextSpanFromBounds(startPosition, endPosition === undefined ? startPosition : endPosition);
    }
    ts.getRefactorContextSpan = getRefactorContextSpan;
    function mapOneOrMany(valueOrArray, f, resultSelector) {
        if (resultSelector === void 0) { resultSelector = ts.identity; }
        return valueOrArray ? ts.isArray(valueOrArray) ? resultSelector(ts.map(valueOrArray, f)) : f(valueOrArray, 0) : undefined;
    }
    ts.mapOneOrMany = mapOneOrMany;
    /**
     * If the provided value is an array, the first element of the array is returned; otherwise, the provided value is returned instead.
     */
    function firstOrOnly(valueOrArray) {
        return ts.isArray(valueOrArray) ? ts.first(valueOrArray) : valueOrArray;
    }
    ts.firstOrOnly = firstOrOnly;
    function getNameForExportedSymbol(symbol, scriptTarget) {
        if (!(symbol.flags & 33554432 /* Transient */) && (symbol.escapedName === "export=" /* ExportEquals */ || symbol.escapedName === "default" /* Default */)) {
            // Name of "export default foo;" is "foo". Name of "export default 0" is the filename converted to camelCase.
            return ts.firstDefined(symbol.declarations, function (d) { var _a; return ts.isExportAssignment(d) ? (_a = ts.tryCast(ts.skipOuterExpressions(d.expression), ts.isIdentifier)) === null || _a === void 0 ? void 0 : _a.text : undefined; })
                || ts.codefix.moduleSymbolToValidIdentifier(getSymbolParentOrFail(symbol), scriptTarget);
        }
        return symbol.name;
    }
    ts.getNameForExportedSymbol = getNameForExportedSymbol;
    function getSymbolParentOrFail(symbol) {
        var _a;
        return ts.Debug.checkDefined(symbol.parent, "Symbol parent was undefined. Flags: " + ts.Debug.formatSymbolFlags(symbol.flags) + ". " +
            ("Declarations: " + ((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.map(function (d) {
                var kind = ts.Debug.formatSyntaxKind(d.kind);
                var inJS = ts.isInJSFile(d);
                var expression = d.expression;
                return (inJS ? "[JS]" : "") + kind + (expression ? " (expression: " + ts.Debug.formatSyntaxKind(expression.kind) + ")" : "");
            }).join(", ")) + "."));
    }
    /**
     * Useful to check whether a string contains another string at a specific index
     * without allocating another string or traversing the entire contents of the outer string.
     *
     * This function is useful in place of either of the following:
     *
     * ```ts
     * // Allocates
     * haystack.substr(startIndex, needle.length) === needle
     *
     * // Full traversal
     * haystack.indexOf(needle, startIndex) === startIndex
     * ```
     *
     * @param haystack The string that potentially contains `needle`.
     * @param needle The string whose content might sit within `haystack`.
     * @param startIndex The index within `haystack` to start searching for `needle`.
     */
    function stringContainsAt(haystack, needle, startIndex) {
        var needleLength = needle.length;
        if (needleLength + startIndex > haystack.length) {
            return false;
        }
        for (var i = 0; i < needleLength; i++) {
            if (needle.charCodeAt(i) !== haystack.charCodeAt(i + startIndex))
                return false;
        }
        return true;
    }
    ts.stringContainsAt = stringContainsAt;
    function startsWithUnderscore(name) {
        return name.charCodeAt(0) === 95 /* _ */;
    }
    ts.startsWithUnderscore = startsWithUnderscore;
    function isGlobalDeclaration(declaration) {
        return !isNonGlobalDeclaration(declaration);
    }
    ts.isGlobalDeclaration = isGlobalDeclaration;
    function isNonGlobalDeclaration(declaration) {
        var sourceFile = declaration.getSourceFile();
        // If the file is not a module, the declaration is global
        if (!sourceFile.externalModuleIndicator && !sourceFile.commonJsModuleIndicator) {
            return false;
        }
        // If the file is a module written in TypeScript, it still might be in a `declare global` augmentation
        return ts.isInJSFile(declaration) || !ts.findAncestor(declaration, ts.isGlobalScopeAugmentation);
    }
    ts.isNonGlobalDeclaration = isNonGlobalDeclaration;
    function isDeprecatedDeclaration(decl) {
        return !!(ts.getCombinedNodeFlagsAlwaysIncludeJSDoc(decl) & 8192 /* Deprecated */);
    }
    ts.isDeprecatedDeclaration = isDeprecatedDeclaration;
    function shouldUseUriStyleNodeCoreModules(file, program) {
        var decisionFromFile = ts.firstDefined(file.imports, function (node) {
            if (ts.JsTyping.nodeCoreModules.has(node.text)) {
                return ts.startsWith(node.text, "node:");
            }
        });
        return decisionFromFile !== null && decisionFromFile !== void 0 ? decisionFromFile : program.usesUriStyleNodeCoreModules;
    }
    ts.shouldUseUriStyleNodeCoreModules = shouldUseUriStyleNodeCoreModules;
    // #endregion
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ImportKind;
    (function (ImportKind) {
        ImportKind[ImportKind["Named"] = 0] = "Named";
        ImportKind[ImportKind["Default"] = 1] = "Default";
        ImportKind[ImportKind["Namespace"] = 2] = "Namespace";
        ImportKind[ImportKind["CommonJS"] = 3] = "CommonJS";
    })(ImportKind = ts.ImportKind || (ts.ImportKind = {}));
    var ExportKind;
    (function (ExportKind) {
        ExportKind[ExportKind["Named"] = 0] = "Named";
        ExportKind[ExportKind["Default"] = 1] = "Default";
        ExportKind[ExportKind["ExportEquals"] = 2] = "ExportEquals";
        ExportKind[ExportKind["UMD"] = 3] = "UMD";
    })(ExportKind = ts.ExportKind || (ts.ExportKind = {}));
    function createCacheableExportInfoMap(host) {
        var exportInfoId = 1;
        var exportInfo = ts.createMultiMap();
        var symbols = new ts.Map();
        var usableByFileName;
        var cache = {
            isUsableByFile: function (importingFile) { return importingFile === usableByFileName; },
            isEmpty: function () { return !exportInfo.size; },
            clear: function () {
                exportInfo.clear();
                symbols.clear();
                usableByFileName = undefined;
            },
            add: function (importingFile, symbol, symbolTableKey, moduleSymbol, moduleFile, exportKind, isFromPackageJson, scriptTarget, checker) {
                if (importingFile !== usableByFileName) {
                    cache.clear();
                    usableByFileName = importingFile;
                }
                var isDefault = exportKind === 1 /* Default */;
                var namedSymbol = isDefault && ts.getLocalSymbolForExportDefault(symbol) || symbol;
                // A re-export merged with an export from a module augmentation can result in `symbol`
                // being an external module symbol; the name it is re-exported by will be `symbolTableKey`
                // (which comes from the keys of `moduleSymbol.exports`.)
                var importedName = ts.isExternalModuleSymbol(namedSymbol)
                    ? ts.unescapeLeadingUnderscores(symbolTableKey)
                    : ts.getNameForExportedSymbol(namedSymbol, scriptTarget);
                var moduleName = ts.stripQuotes(moduleSymbol.name);
                var id = exportInfoId++;
                var storedSymbol = symbol.flags & 33554432 /* Transient */ ? undefined : symbol;
                var storedModuleSymbol = moduleSymbol.flags & 33554432 /* Transient */ ? undefined : moduleSymbol;
                if (!storedSymbol || !storedModuleSymbol)
                    symbols.set(id, [symbol, moduleSymbol]);
                exportInfo.add(key(importedName, symbol, moduleName, checker), {
                    id: id,
                    symbolTableKey: symbolTableKey,
                    symbolName: importedName,
                    moduleName: moduleName,
                    moduleFile: moduleFile,
                    moduleFileName: moduleFile === null || moduleFile === void 0 ? void 0 : moduleFile.fileName,
                    exportKind: exportKind,
                    targetFlags: ts.skipAlias(symbol, checker).flags,
                    isFromPackageJson: isFromPackageJson,
                    symbol: storedSymbol,
                    moduleSymbol: storedModuleSymbol,
                });
            },
            get: function (importingFile, importedName, symbol, moduleName, checker) {
                if (importingFile !== usableByFileName)
                    return;
                var result = exportInfo.get(key(importedName, symbol, moduleName, checker));
                return result === null || result === void 0 ? void 0 : result.map(rehydrateCachedInfo);
            },
            forEach: function (importingFile, action) {
                if (importingFile !== usableByFileName)
                    return;
                exportInfo.forEach(function (info, key) {
                    var _a = parseKey(key), symbolName = _a.symbolName, ambientModuleName = _a.ambientModuleName;
                    action(info.map(rehydrateCachedInfo), symbolName, !!ambientModuleName);
                });
            },
            releaseSymbols: function () {
                symbols.clear();
            },
            onFileChanged: function (oldSourceFile, newSourceFile, typeAcquisitionEnabled) {
                if (fileIsGlobalOnly(oldSourceFile) && fileIsGlobalOnly(newSourceFile)) {
                    // File is purely global; doesn't affect export map
                    return false;
                }
                if (usableByFileName && usableByFileName !== newSourceFile.path ||
                    // If ATA is enabled, auto-imports uses existing imports to guess whether you want auto-imports from node.
                    // Adding or removing imports from node could change the outcome of that guess, so could change the suggestions list.
                    typeAcquisitionEnabled && ts.consumesNodeCoreModules(oldSourceFile) !== ts.consumesNodeCoreModules(newSourceFile) ||
                    // Module agumentation and ambient module changes can add or remove exports available to be auto-imported.
                    // Changes elsewhere in the file can change the *type* of an export in a module augmentation,
                    // but type info is gathered in getCompletionEntryDetails, which doesnt use the cache.
                    !ts.arrayIsEqualTo(oldSourceFile.moduleAugmentations, newSourceFile.moduleAugmentations) ||
                    !ambientModuleDeclarationsAreEqual(oldSourceFile, newSourceFile)) {
                    cache.clear();
                    return true;
                }
                usableByFileName = newSourceFile.path;
                return false;
            },
        };
        if (ts.Debug.isDebugging) {
            Object.defineProperty(cache, "__cache", { get: function () { return exportInfo; } });
        }
        return cache;
        function rehydrateCachedInfo(info) {
            if (info.symbol && info.moduleSymbol)
                return info;
            var id = info.id, exportKind = info.exportKind, targetFlags = info.targetFlags, isFromPackageJson = info.isFromPackageJson, moduleFileName = info.moduleFileName;
            var _a = symbols.get(id) || ts.emptyArray, cachedSymbol = _a[0], cachedModuleSymbol = _a[1];
            if (cachedSymbol && cachedModuleSymbol) {
                return {
                    symbol: cachedSymbol,
                    moduleSymbol: cachedModuleSymbol,
                    moduleFileName: moduleFileName,
                    exportKind: exportKind,
                    targetFlags: targetFlags,
                    isFromPackageJson: isFromPackageJson,
                };
            }
            var checker = (isFromPackageJson
                ? host.getPackageJsonAutoImportProvider()
                : host.getCurrentProgram()).getTypeChecker();
            var moduleSymbol = info.moduleSymbol || cachedModuleSymbol || ts.Debug.checkDefined(info.moduleFile
                ? checker.getMergedSymbol(info.moduleFile.symbol)
                : checker.tryFindAmbientModule(info.moduleName));
            var symbol = info.symbol || cachedSymbol || ts.Debug.checkDefined(exportKind === 2 /* ExportEquals */
                ? checker.resolveExternalModuleSymbol(moduleSymbol)
                : checker.tryGetMemberInModuleExportsAndProperties(ts.unescapeLeadingUnderscores(info.symbolTableKey), moduleSymbol), "Could not find symbol '" + info.symbolName + "' by key '" + info.symbolTableKey + "' in module " + moduleSymbol.name);
            symbols.set(id, [symbol, moduleSymbol]);
            return {
                symbol: symbol,
                moduleSymbol: moduleSymbol,
                moduleFileName: moduleFileName,
                exportKind: exportKind,
                targetFlags: targetFlags,
                isFromPackageJson: isFromPackageJson,
            };
        }
        function key(importedName, symbol, moduleName, checker) {
            var unquoted = ts.stripQuotes(moduleName);
            var moduleKey = ts.isExternalModuleNameRelative(unquoted) ? "/" : unquoted;
            var target = ts.skipAlias(symbol, checker);
            return importedName + "|" + createSymbolKey(target) + "|" + moduleKey;
        }
        function parseKey(key) {
            var symbolName = key.substring(0, key.indexOf("|"));
            var moduleKey = key.substring(key.lastIndexOf("|") + 1);
            var ambientModuleName = moduleKey === "/" ? undefined : moduleKey;
            return { symbolName: symbolName, ambientModuleName: ambientModuleName };
        }
        function createSymbolKey(symbol) {
            var key = symbol.name;
            while (symbol.parent) {
                key += "," + symbol.parent.name;
                symbol = symbol.parent;
            }
            return key;
        }
        function fileIsGlobalOnly(file) {
            return !file.commonJsModuleIndicator && !file.externalModuleIndicator && !file.moduleAugmentations && !file.ambientModuleNames;
        }
        function ambientModuleDeclarationsAreEqual(oldSourceFile, newSourceFile) {
            if (!ts.arrayIsEqualTo(oldSourceFile.ambientModuleNames, newSourceFile.ambientModuleNames)) {
                return false;
            }
            var oldFileStatementIndex = -1;
            var newFileStatementIndex = -1;
            var _loop_1 = function (ambientModuleName) {
                var isMatchingModuleDeclaration = function (node) { return ts.isNonGlobalAmbientModule(node) && node.name.text === ambientModuleName; };
                oldFileStatementIndex = ts.findIndex(oldSourceFile.statements, isMatchingModuleDeclaration, oldFileStatementIndex + 1);
                newFileStatementIndex = ts.findIndex(newSourceFile.statements, isMatchingModuleDeclaration, newFileStatementIndex + 1);
                if (oldSourceFile.statements[oldFileStatementIndex] !== newSourceFile.statements[newFileStatementIndex]) {
                    return { value: false };
                }
            };
            for (var _i = 0, _a = newSourceFile.ambientModuleNames; _i < _a.length; _i++) {
                var ambientModuleName = _a[_i];
                var state_1 = _loop_1(ambientModuleName);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
            return true;
        }
    }
    ts.createCacheableExportInfoMap = createCacheableExportInfoMap;
    function isImportableFile(program, from, to, preferences, packageJsonFilter, moduleSpecifierResolutionHost, moduleSpecifierCache) {
        var _a;
        if (from === to)
            return false;
        var cachedResult = moduleSpecifierCache === null || moduleSpecifierCache === void 0 ? void 0 : moduleSpecifierCache.get(from.path, to.path, preferences);
        if ((cachedResult === null || cachedResult === void 0 ? void 0 : cachedResult.isAutoImportable) !== undefined) {
            return cachedResult.isAutoImportable;
        }
        var getCanonicalFileName = ts.hostGetCanonicalFileName(moduleSpecifierResolutionHost);
        var globalTypingsCache = (_a = moduleSpecifierResolutionHost.getGlobalTypingsCacheLocation) === null || _a === void 0 ? void 0 : _a.call(moduleSpecifierResolutionHost);
        var hasImportablePath = !!ts.moduleSpecifiers.forEachFileNameOfModule(from.fileName, to.fileName, moduleSpecifierResolutionHost, 
        /*preferSymlinks*/ false, function (toPath) {
            var toFile = program.getSourceFile(toPath);
            // Determine to import using toPath only if toPath is what we were looking at
            // or there doesnt exist the file in the program by the symlink
            return (toFile === to || !toFile) &&
                isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);
        });
        if (packageJsonFilter) {
            var isAutoImportable = hasImportablePath && packageJsonFilter.allowsImportingSourceFile(to, moduleSpecifierResolutionHost);
            moduleSpecifierCache === null || moduleSpecifierCache === void 0 ? void 0 : moduleSpecifierCache.setIsAutoImportable(from.path, to.path, preferences, isAutoImportable);
            return isAutoImportable;
        }
        return hasImportablePath;
    }
    ts.isImportableFile = isImportableFile;
    /**
     * Don't include something from a `node_modules` that isn't actually reachable by a global import.
     * A relative import to node_modules is usually a bad idea.
     */
    function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {
        // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.
        var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });
        var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));
        return toNodeModulesParent === undefined
            || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)
            || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));
    }
    function forEachExternalModuleToImportFrom(program, host, useAutoImportProvider, cb) {
        var _a, _b;
        forEachExternalModule(program.getTypeChecker(), program.getSourceFiles(), function (module, file) { return cb(module, file, program, /*isFromPackageJson*/ false); });
        var autoImportProvider = useAutoImportProvider && ((_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host));
        if (autoImportProvider) {
            var start = ts.timestamp();
            forEachExternalModule(autoImportProvider.getTypeChecker(), autoImportProvider.getSourceFiles(), function (module, file) { return cb(module, file, autoImportProvider, /*isFromPackageJson*/ true); });
            (_b = host.log) === null || _b === void 0 ? void 0 : _b.call(host, "forEachExternalModuleToImportFrom autoImportProvider: " + (ts.timestamp() - start));
        }
    }
    ts.forEachExternalModuleToImportFrom = forEachExternalModuleToImportFrom;
    function forEachExternalModule(checker, allSourceFiles, cb) {
        for (var _i = 0, _a = checker.getAmbientModules(); _i < _a.length; _i++) {
            var ambient = _a[_i];
            if (!ts.stringContains(ambient.name, "*")) {
                cb(ambient, /*sourceFile*/ undefined);
            }
        }
        for (var _b = 0, allSourceFiles_1 = allSourceFiles; _b < allSourceFiles_1.length; _b++) {
            var sourceFile = allSourceFiles_1[_b];
            if (ts.isExternalOrCommonJsModule(sourceFile)) {
                cb(checker.getMergedSymbol(sourceFile.symbol), sourceFile);
            }
        }
    }
    function getExportInfoMap(importingFile, host, program, cancellationToken) {
        var _a, _b, _c, _d, _e;
        var start = ts.timestamp();
        // Pulling the AutoImportProvider project will trigger its updateGraph if pending,
        // which will invalidate the export map cache if things change, so pull it before
        // checking the cache.
        (_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host);
        var cache = ((_b = host.getCachedExportInfoMap) === null || _b === void 0 ? void 0 : _b.call(host)) || createCacheableExportInfoMap({
            getCurrentProgram: function () { return program; },
            getPackageJsonAutoImportProvider: function () { var _a; return (_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host); },
        });
        if (cache.isUsableByFile(importingFile.path)) {
            (_c = host.log) === null || _c === void 0 ? void 0 : _c.call(host, "getExportInfoMap: cache hit");
            return cache;
        }
        (_d = host.log) === null || _d === void 0 ? void 0 : _d.call(host, "getExportInfoMap: cache miss or empty; calculating new results");
        var compilerOptions = program.getCompilerOptions();
        var scriptTarget = ts.getEmitScriptTarget(compilerOptions);
        var moduleCount = 0;
        forEachExternalModuleToImportFrom(program, host, /*useAutoImportProvider*/ true, function (moduleSymbol, moduleFile, program, isFromPackageJson) {
            if (++moduleCount % 100 === 0)
                cancellationToken === null || cancellationToken === void 0 ? void 0 : cancellationToken.throwIfCancellationRequested();
            var seenExports = new ts.Map();
            var checker = program.getTypeChecker();
            var defaultInfo = getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions);
            // Note: I think we shouldn't actually see resolved module symbols here, but weird merges
            // can cause it to happen: see 'completionsImport_mergedReExport.ts'
            if (defaultInfo && isImportableSymbol(defaultInfo.symbol, checker)) {
                cache.add(importingFile.path, defaultInfo.symbol, defaultInfo.exportKind === 1 /* Default */ ? "default" /* Default */ : "export=" /* ExportEquals */, moduleSymbol, moduleFile, defaultInfo.exportKind, isFromPackageJson, scriptTarget, checker);
            }
            checker.forEachExportAndPropertyOfModule(moduleSymbol, function (exported, key) {
                if (exported !== (defaultInfo === null || defaultInfo === void 0 ? void 0 : defaultInfo.symbol) && isImportableSymbol(exported, checker) && ts.addToSeen(seenExports, exported)) {
                    cache.add(importingFile.path, exported, key, moduleSymbol, moduleFile, 0 /* Named */, isFromPackageJson, scriptTarget, checker);
                }
            });
        });
        (_e = host.log) === null || _e === void 0 ? void 0 : _e.call(host, "getExportInfoMap: done in " + (ts.timestamp() - start) + " ms");
        return cache;
    }
    ts.getExportInfoMap = getExportInfoMap;
    function getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions) {
        var exported = getDefaultLikeExportWorker(moduleSymbol, checker);
        if (!exported)
            return undefined;
        var symbol = exported.symbol, exportKind = exported.exportKind;
        var info = getDefaultExportInfoWorker(symbol, checker, compilerOptions);
        return info && __assign({ symbol: symbol, exportKind: exportKind }, info);
    }
    ts.getDefaultLikeExportInfo = getDefaultLikeExportInfo;
    function isImportableSymbol(symbol, checker) {
        return !checker.isUndefinedSymbol(symbol) && !checker.isUnknownSymbol(symbol) && !ts.isKnownSymbol(symbol) && !ts.isPrivateIdentifierSymbol(symbol);
    }
    function getDefaultLikeExportWorker(moduleSymbol, checker) {
        var exportEquals = checker.resolveExternalModuleSymbol(moduleSymbol);
        if (exportEquals !== moduleSymbol)
            return { symbol: exportEquals, exportKind: 2 /* ExportEquals */ };
        var defaultExport = checker.tryGetMemberInModuleExports("default" /* Default */, moduleSymbol);
        if (defaultExport)
            return { symbol: defaultExport, exportKind: 1 /* Default */ };
    }
    function getDefaultExportInfoWorker(defaultExport, checker, compilerOptions) {
        var localSymbol = ts.getLocalSymbolForExportDefault(defaultExport);
        if (localSymbol)
            return { symbolForMeaning: localSymbol, name: localSymbol.name };
        var name = getNameForExportDefault(defaultExport);
        if (name !== undefined)
            return { symbolForMeaning: defaultExport, name: name };
        if (defaultExport.flags & 2097152 /* Alias */) {
            var aliased = checker.getImmediateAliasedSymbol(defaultExport);
            if (aliased && aliased.parent) {
                // - `aliased` will be undefined if the module is exporting an unresolvable name,
                //    but we can still offer completions for it.
                // - `aliased.parent` will be undefined if the module is exporting `globalThis.something`,
                //    or another expression that resolves to a global.
                return getDefaultExportInfoWorker(aliased, checker, compilerOptions);
            }
        }
        if (defaultExport.escapedName !== "default" /* Default */ &&
            defaultExport.escapedName !== "export=" /* ExportEquals */) {
            return { symbolForMeaning: defaultExport, name: defaultExport.getName() };
        }
        return { symbolForMeaning: defaultExport, name: ts.getNameForExportedSymbol(defaultExport, compilerOptions.target) };
    }
    function getNameForExportDefault(symbol) {
        return symbol.declarations && ts.firstDefined(symbol.declarations, function (declaration) {
            var _a;
            if (ts.isExportAssignment(declaration)) {
                return (_a = ts.tryCast(ts.skipOuterExpressions(declaration.expression), ts.isIdentifier)) === null || _a === void 0 ? void 0 : _a.text;
            }
            else if (ts.isExportSpecifier(declaration)) {
                ts.Debug.assert(declaration.name.text === "default" /* Default */, "Expected the specifier to be a default export");
                return declaration.propertyName && declaration.propertyName.text;
            }
        });
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    /** The classifier is used for syntactic highlighting in editors via the TSServer */
    function createClassifier() {
        var scanner = ts.createScanner(99 /* Latest */, /*skipTrivia*/ false);
        function getClassificationsForLine(text, lexState, syntacticClassifierAbsent) {
            return convertClassificationsToResult(getEncodedLexicalClassifications(text, lexState, syntacticClassifierAbsent), text);
        }
        // If there is a syntactic classifier ('syntacticClassifierAbsent' is false),
        // we will be more conservative in order to avoid conflicting with the syntactic classifier.
        function getEncodedLexicalClassifications(text, lexState, syntacticClassifierAbsent) {
            var token = 0 /* Unknown */;
            var lastNonTriviaToken = 0 /* Unknown */;
            // Just a stack of TemplateHeads and OpenCurlyBraces, used to perform rudimentary (inexact)
            // classification on template strings. Because of the context free nature of templates,
            // the only precise way to classify a template portion would be by propagating the stack across
            // lines, just as we do with the end-of-line state. However, this is a burden for implementers,
            // and the behavior is entirely subsumed by the syntactic classifier anyway, so we instead
            // flatten any nesting when the template stack is non-empty and encode it in the end-of-line state.
            // Situations in which this fails are
            //  1) When template strings are nested across different lines:
            //          `hello ${ `world
            //          ` }`
            //
            //     Where on the second line, you will get the closing of a template,
            //     a closing curly, and a new template.
            //
            //  2) When substitution expressions have curly braces and the curly brace falls on the next line:
            //          `hello ${ () => {
            //          return "world" } } `
            //
            //     Where on the second line, you will get the 'return' keyword,
            //     a string literal, and a template end consisting of '} } `'.
            var templateStack = [];
            var _a = getPrefixFromLexState(lexState), prefix = _a.prefix, pushTemplate = _a.pushTemplate;
            text = prefix + text;
            var offset = prefix.length;
            if (pushTemplate) {
                templateStack.push(15 /* TemplateHead */);
            }
            scanner.setText(text);
            var endOfLineState = 0 /* None */;
            var spans = [];
            // We can run into an unfortunate interaction between the lexical and syntactic classifier
            // when the user is typing something generic.  Consider the case where the user types:
            //
            //      Foo<number
            //
            // From the lexical classifier's perspective, 'number' is a keyword, and so the word will
            // be classified as such.  However, from the syntactic classifier's tree-based perspective
            // this is simply an expression with the identifier 'number' on the RHS of the less than
            // token.  So the classification will go back to being an identifier.  The moment the user
            // types again, number will become a keyword, then an identifier, etc. etc.
            //
            // To try to avoid this problem, we avoid classifying contextual keywords as keywords
            // when the user is potentially typing something generic.  We just can't do a good enough
            // job at the lexical level, and so well leave it up to the syntactic classifier to make
            // the determination.
            //
            // In order to determine if the user is potentially typing something generic, we use a
            // weak heuristic where we track < and > tokens.  It's a weak heuristic, but should
            // work well enough in practice.
            var angleBracketStack = 0;
            do {
                token = scanner.scan();
                if (!ts.isTrivia(token)) {
                    handleToken();
                    lastNonTriviaToken = token;
                }
                var end = scanner.getTextPos();
                pushEncodedClassification(scanner.getTokenPos(), end, offset, classFromKind(token), spans);
                if (end >= text.length) {
                    var end_1 = getNewEndOfLineState(scanner, token, ts.lastOrUndefined(templateStack));
                    if (end_1 !== undefined) {
                        endOfLineState = end_1;
                    }
                }
            } while (token !== 1 /* EndOfFileToken */);
            function handleToken() {
                switch (token) {
                    case 43 /* SlashToken */:
                    case 68 /* SlashEqualsToken */:
                        if (!noRegexTable[lastNonTriviaToken] && scanner.reScanSlashToken() === 13 /* RegularExpressionLiteral */) {
                            token = 13 /* RegularExpressionLiteral */;
                        }
                        break;
                    case 29 /* LessThanToken */:
                        if (lastNonTriviaToken === 79 /* Identifier */) {
                            // Could be the start of something generic.  Keep track of that by bumping
                            // up the current count of generic contexts we may be in.
                            angleBracketStack++;
                        }
                        break;
                    case 31 /* GreaterThanToken */:
                        if (angleBracketStack > 0) {
                            // If we think we're currently in something generic, then mark that that
                            // generic entity is complete.
                            angleBracketStack--;
                        }
                        break;
                    case 129 /* AnyKeyword */:
                    case 148 /* StringKeyword */:
                    case 145 /* NumberKeyword */:
                    case 132 /* BooleanKeyword */:
                    case 149 /* SymbolKeyword */:
                        if (angleBracketStack > 0 && !syntacticClassifierAbsent) {
                            // If it looks like we're could be in something generic, don't classify this
                            // as a keyword.  We may just get overwritten by the syntactic classifier,
                            // causing a noisy experience for the user.
                            token = 79 /* Identifier */;
                        }
                        break;
                    case 15 /* TemplateHead */:
                        templateStack.push(token);
                        break;
                    case 18 /* OpenBraceToken */:
                        // If we don't have anything on the template stack,
                        // then we aren't trying to keep track of a previously scanned template head.
                        if (templateStack.length > 0) {
                            templateStack.push(token);
                        }
                        break;
                    case 19 /* CloseBraceToken */:
                        // If we don't have anything on the template stack,
                        // then we aren't trying to keep track of a previously scanned template head.
                        if (templateStack.length > 0) {
                            var lastTemplateStackToken = ts.lastOrUndefined(templateStack);
                            if (lastTemplateStackToken === 15 /* TemplateHead */) {
                                token = scanner.reScanTemplateToken(/* isTaggedTemplate */ false);
                                // Only pop on a TemplateTail; a TemplateMiddle indicates there is more for us.
                                if (token === 17 /* TemplateTail */) {
                                    templateStack.pop();
                                }
                                else {
                                    ts.Debug.assertEqual(token, 16 /* TemplateMiddle */, "Should have been a template middle.");
                                }
                            }
                            else {
                                ts.Debug.assertEqual(lastTemplateStackToken, 18 /* OpenBraceToken */, "Should have been an open brace");
                                templateStack.pop();
                            }
                        }
                        break;
                    default:
                        if (!ts.isKeyword(token)) {
                            break;
                        }
                        if (lastNonTriviaToken === 24 /* DotToken */) {
                            token = 79 /* Identifier */;
                        }
                        else if (ts.isKeyword(lastNonTriviaToken) && ts.isKeyword(token) && !canFollow(lastNonTriviaToken, token)) {
                            // We have two keywords in a row.  Only treat the second as a keyword if
                            // it's a sequence that could legally occur in the language.  Otherwise
                            // treat it as an identifier.  This way, if someone writes "private var"
                            // we recognize that 'var' is actually an identifier here.
                            token = 79 /* Identifier */;
                        }
                }
            }
            return { endOfLineState: endOfLineState, spans: spans };
        }
        return { getClassificationsForLine: getClassificationsForLine, getEncodedLexicalClassifications: getEncodedLexicalClassifications };
    }
    ts.createClassifier = createClassifier;
    /// We do not have a full parser support to know when we should parse a regex or not
    /// If we consider every slash token to be a regex, we could be missing cases like "1/2/3", where
    /// we have a series of divide operator. this list allows us to be more accurate by ruling out
    /// locations where a regexp cannot exist.
    var noRegexTable = ts.arrayToNumericMap([
        79 /* Identifier */,
        10 /* StringLiteral */,
        8 /* NumericLiteral */,
        9 /* BigIntLiteral */,
        13 /* RegularExpressionLiteral */,
        108 /* ThisKeyword */,
        45 /* PlusPlusToken */,
        46 /* MinusMinusToken */,
        21 /* CloseParenToken */,
        23 /* CloseBracketToken */,
        19 /* CloseBraceToken */,
        110 /* TrueKeyword */,
        95 /* FalseKeyword */,
    ], function (token) { return token; }, function () { return true; });
    function getNewEndOfLineState(scanner, token, lastOnTemplateStack) {
        switch (token) {
            case 10 /* StringLiteral */: {
                // Check to see if we finished up on a multiline string literal.
                if (!scanner.isUnterminated())
                    return undefined;
                var tokenText = scanner.getTokenText();
                var lastCharIndex = tokenText.length - 1;
                var numBackslashes = 0;
                while (tokenText.charCodeAt(lastCharIndex - numBackslashes) === 92 /* backslash */) {
                    numBackslashes++;
                }
                // If we have an odd number of backslashes, then the multiline string is unclosed
                if ((numBackslashes & 1) === 0)
                    return undefined;
                return tokenText.charCodeAt(0) === 34 /* doubleQuote */ ? 3 /* InDoubleQuoteStringLiteral */ : 2 /* InSingleQuoteStringLiteral */;
            }
            case 3 /* MultiLineCommentTrivia */:
                // Check to see if the multiline comment was unclosed.
                return scanner.isUnterminated() ? 1 /* InMultiLineCommentTrivia */ : undefined;
            default:
                if (ts.isTemplateLiteralKind(token)) {
                    if (!scanner.isUnterminated()) {
                        return undefined;
                    }
                    switch (token) {
                        case 17 /* TemplateTail */:
                            return 5 /* InTemplateMiddleOrTail */;
                        case 14 /* NoSubstitutionTemplateLiteral */:
                            return 4 /* InTemplateHeadOrNoSubstitutionTemplate */;
                        default:
                            return ts.Debug.fail("Only 'NoSubstitutionTemplateLiteral's and 'TemplateTail's can be unterminated; got SyntaxKind #" + token);
                    }
                }
                return lastOnTemplateStack === 15 /* TemplateHead */ ? 6 /* InTemplateSubstitutionPosition */ : undefined;
        }
    }
    function pushEncodedClassification(start, end, offset, classification, result) {
        if (classification === 8 /* whiteSpace */) {
            // Don't bother with whitespace classifications.  They're not needed.
            return;
        }
        if (start === 0 && offset > 0) {
            // We're classifying the first token, and this was a case where we prepended text.
            // We should consider the start of this token to be at the start of the original text.
            start += offset;
        }
        var length = end - start;
        if (length > 0) {
            // All our tokens are in relation to the augmented text.  Move them back to be
            // relative to the original text.
            result.push(start - offset, length, classification);
        }
    }
    function convertClassificationsToResult(classifications, text) {
        var entries = [];
        var dense = classifications.spans;
        var lastEnd = 0;
        for (var i = 0; i < dense.length; i += 3) {
            var start = dense[i];
            var length_1 = dense[i + 1];
            var type = dense[i + 2];
            // Make a whitespace entry between the last item and this one.
            if (lastEnd >= 0) {
                var whitespaceLength_1 = start - lastEnd;
                if (whitespaceLength_1 > 0) {
                    entries.push({ length: whitespaceLength_1, classification: ts.TokenClass.Whitespace });
                }
            }
            entries.push({ length: length_1, classification: convertClassification(type) });
            lastEnd = start + length_1;
        }
        var whitespaceLength = text.length - lastEnd;
        if (whitespaceLength > 0) {
            entries.push({ length: whitespaceLength, classification: ts.TokenClass.Whitespace });
        }
        return { entries: entries, finalLexState: classifications.endOfLineState };
    }
    function convertClassification(type) {
        switch (type) {
            case 1 /* comment */: return ts.TokenClass.Comment;
            case 3 /* keyword */: return ts.TokenClass.Keyword;
            case 4 /* numericLiteral */: return ts.TokenClass.NumberLiteral;
            case 25 /* bigintLiteral */: return ts.TokenClass.BigIntLiteral;
            case 5 /* operator */: return ts.TokenClass.Operator;
            case 6 /* stringLiteral */: return ts.TokenClass.StringLiteral;
            case 8 /* whiteSpace */: return ts.TokenClass.Whitespace;
            case 10 /* punctuation */: return ts.TokenClass.Punctuation;
            case 2 /* identifier */:
            case 11 /* className */:
            case 12 /* enumName */:
            case 13 /* interfaceName */:
            case 14 /* moduleName */:
            case 15 /* typeParameterName */:
            case 16 /* typeAliasName */:
            case 9 /* text */:
            case 17 /* parameterName */:
                return ts.TokenClass.Identifier;
            default:
                return undefined; // TODO: GH#18217 Debug.assertNever(type);
        }
    }
    /** Returns true if 'keyword2' can legally follow 'keyword1' in any language construct. */
    function canFollow(keyword1, keyword2) {
        if (!ts.isAccessibilityModifier(keyword1)) {
            // Assume any other keyword combination is legal.
            // This can be refined in the future if there are more cases we want the classifier to be better at.
            return true;
        }
        switch (keyword2) {
            case 135 /* GetKeyword */:
            case 147 /* SetKeyword */:
            case 133 /* ConstructorKeyword */:
            case 124 /* StaticKeyword */:
                return true; // Allow things like "public get", "public constructor" and "public static".
            default:
                return false; // Any other keyword following "public" is actually an identifier, not a real keyword.
        }
    }
    function getPrefixFromLexState(lexState) {
        // If we're in a string literal, then prepend: "\
        // (and a newline).  That way when we lex we'll think we're still in a string literal.
        //
        // If we're in a multiline comment, then prepend: /*
        // (and a newline).  That way when we lex we'll think we're still in a multiline comment.
        switch (lexState) {
            case 3 /* InDoubleQuoteStringLiteral */:
                return { prefix: "\"\\\n" };
            case 2 /* InSingleQuoteStringLiteral */:
                return { prefix: "'\\\n" };
            case 1 /* InMultiLineCommentTrivia */:
                return { prefix: "/*\n" };
            case 4 /* InTemplateHeadOrNoSubstitutionTemplate */:
                return { prefix: "`\n" };
            case 5 /* InTemplateMiddleOrTail */:
                return { prefix: "}\n", pushTemplate: true };
            case 6 /* InTemplateSubstitutionPosition */:
                return { prefix: "", pushTemplate: true };
            case 0 /* None */:
                return { prefix: "" };
            default:
                return ts.Debug.assertNever(lexState);
        }
    }
    function isBinaryExpressionOperatorToken(token) {
        switch (token) {
            case 41 /* AsteriskToken */:
            case 43 /* SlashToken */:
            case 44 /* PercentToken */:
            case 39 /* PlusToken */:
            case 40 /* MinusToken */:
            case 47 /* LessThanLessThanToken */:
            case 48 /* GreaterThanGreaterThanToken */:
            case 49 /* GreaterThanGreaterThanGreaterThanToken */:
            case 29 /* LessThanToken */:
            case 31 /* GreaterThanToken */:
            case 32 /* LessThanEqualsToken */:
            case 33 /* GreaterThanEqualsToken */:
            case 102 /* InstanceOfKeyword */:
            case 101 /* InKeyword */:
            case 127 /* AsKeyword */:
            case 34 /* EqualsEqualsToken */:
            case 35 /* ExclamationEqualsToken */:
            case 36 /* EqualsEqualsEqualsToken */:
            case 37 /* ExclamationEqualsEqualsToken */:
            case 50 /* AmpersandToken */:
            case 52 /* CaretToken */:
            case 51 /* BarToken */:
            case 55 /* AmpersandAmpersandToken */:
            case 56 /* BarBarToken */:
            case 74 /* BarEqualsToken */:
            case 73 /* AmpersandEqualsToken */:
            case 78 /* CaretEqualsToken */:
            case 70 /* LessThanLessThanEqualsToken */:
            case 71 /* GreaterThanGreaterThanEqualsToken */:
            case 72 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
            case 64 /* PlusEqualsToken */:
            case 65 /* MinusEqualsToken */:
            case 66 /* AsteriskEqualsToken */:
            case 68 /* SlashEqualsToken */:
            case 69 /* PercentEqualsToken */:
            case 63 /* EqualsToken */:
            case 27 /* CommaToken */:
            case 60 /* QuestionQuestionToken */:
            case 75 /* BarBarEqualsToken */:
            case 76 /* AmpersandAmpersandEqualsToken */:
            case 77 /* QuestionQuestionEqualsToken */:
                return true;
            default:
                return false;
        }
    }
    function isPrefixUnaryExpressionOperatorToken(token) {
        switch (token) {
            case 39 /* PlusToken */:
            case 40 /* MinusToken */:
            case 54 /* TildeToken */:
            case 53 /* ExclamationToken */:
            case 45 /* PlusPlusToken */:
            case 46 /* MinusMinusToken */:
                return true;
            default:
                return false;
        }
    }
    function classFromKind(token) {
        if (ts.isKeyword(token)) {
            return 3 /* keyword */;
        }
        else if (isBinaryExpressionOperatorToken(token) || isPrefixUnaryExpressionOperatorToken(token)) {
            return 5 /* operator */;
        }
        else if (token >= 18 /* FirstPunctuation */ && token <= 78 /* LastPunctuation */) {
            return 10 /* punctuation */;
        }
        switch (token) {
            case 8 /* NumericLiteral */:
                return 4 /* numericLiteral */;
            case 9 /* BigIntLiteral */:
                return 25 /* bigintLiteral */;
            case 10 /* StringLiteral */:
                return 6 /* stringLiteral */;
            case 13 /* RegularExpressionLiteral */:
                return 7 /* regularExpressionLiteral */;
            case 7 /* ConflictMarkerTrivia */:
            case 3 /* MultiLineCommentTrivia */:
            case 2 /* SingleLineCommentTrivia */:
                return 1 /* comment */;
            case 5 /* WhitespaceTrivia */:
            case 4 /* NewLineTrivia */:
                return 8 /* whiteSpace */;
            case 79 /* Identifier */:
            default:
                if (ts.isTemplateLiteralKind(token)) {
                    return 6 /* stringLiteral */;
                }
                return 2 /* identifier */;
        }
    }
    /* @internal */
    function getSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span) {
        return convertClassificationsToSpans(getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span));
    }
    ts.getSemanticClassifications = getSemanticClassifications;
    function checkForClassificationCancellation(cancellationToken, kind) {
        // We don't want to actually call back into our host on every node to find out if we've
        // been canceled.  That would be an enormous amount of chattyness, along with the all
        // the overhead of marshalling the data to/from the host.  So instead we pick a few
        // reasonable node kinds to bother checking on.  These node kinds represent high level
        // constructs that we would expect to see commonly, but just at a far less frequent
        // interval.
        //
        // For example, in checker.ts (around 750k) we only have around 600 of these constructs.
        // That means we're calling back into the host around every 1.2k of the file we process.
        // Lib.d.ts has similar numbers.
        switch (kind) {
            case 259 /* ModuleDeclaration */:
            case 255 /* ClassDeclaration */:
            case 256 /* InterfaceDeclaration */:
            case 254 /* FunctionDeclaration */:
            case 224 /* ClassExpression */:
            case 211 /* FunctionExpression */:
            case 212 /* ArrowFunction */:
                cancellationToken.throwIfCancellationRequested();
        }
    }
    /* @internal */
    function getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span) {
        var spans = [];
        sourceFile.forEachChild(function cb(node) {
            // Only walk into nodes that intersect the requested span.
            if (!node || !ts.textSpanIntersectsWith(span, node.pos, node.getFullWidth())) {
                return;
            }
            checkForClassificationCancellation(cancellationToken, node.kind);
            // Only bother calling into the typechecker if this is an identifier that
            // could possibly resolve to a type name.  This makes classification run
            // in a third of the time it would normally take.
            if (ts.isIdentifier(node) && !ts.nodeIsMissing(node) && classifiableNames.has(node.escapedText)) {
                var symbol = typeChecker.getSymbolAtLocation(node);
                var type = symbol && classifySymbol(symbol, ts.getMeaningFromLocation(node), typeChecker);
                if (type) {
                    pushClassification(node.getStart(sourceFile), node.getEnd(), type);
                }
            }
            node.forEachChild(cb);
        });
        return { spans: spans, endOfLineState: 0 /* None */ };
        function pushClassification(start, end, type) {
            var length = end - start;
            ts.Debug.assert(length > 0, "Classification had non-positive length of " + length);
            spans.push(start);
            spans.push(length);
            spans.push(type);
        }
    }
    ts.getEncodedSemanticClassifications = getEncodedSemanticClassifications;
    function classifySymbol(symbol, meaningAtPosition, checker) {
        var flags = symbol.getFlags();
        if ((flags & 2885600 /* Classifiable */) === 0 /* None */) {
            return undefined;
        }
        else if (flags & 32 /* Class */) {
            return 11 /* className */;
        }
        else if (flags & 384 /* Enum */) {
            return 12 /* enumName */;
        }
        else if (flags & 524288 /* TypeAlias */) {
            return 16 /* typeAliasName */;
        }
        else if (flags & 1536 /* Module */) {
            // Only classify a module as such if
            //  - It appears in a namespace context.
            //  - There exists a module declaration which actually impacts the value side.
            return meaningAtPosition & 4 /* Namespace */ || meaningAtPosition & 1 /* Value */ && hasValueSideModule(symbol) ? 14 /* moduleName */ : undefined;
        }
        else if (flags & 2097152 /* Alias */) {
            return classifySymbol(checker.getAliasedSymbol(symbol), meaningAtPosition, checker);
        }
        else if (meaningAtPosition & 2 /* Type */) {
            return flags & 64 /* Interface */ ? 13 /* interfaceName */ : flags & 262144 /* TypeParameter */ ? 15 /* typeParameterName */ : undefined;
        }
        else {
            return undefined;
        }
    }
    /** Returns true if there exists a module that introduces entities on the value side. */
    function hasValueSideModule(symbol) {
        return ts.some(symbol.declarations, function (declaration) {
            return ts.isModuleDeclaration(declaration) && ts.getModuleInstanceState(declaration) === 1 /* Instantiated */;
        });
    }
    function getClassificationTypeName(type) {
        switch (type) {
            case 1 /* comment */: return "comment" /* comment */;
            case 2 /* identifier */: return "identifier" /* identifier */;
            case 3 /* keyword */: return "keyword" /* keyword */;
            case 4 /* numericLiteral */: return "number" /* numericLiteral */;
            case 25 /* bigintLiteral */: return "bigint" /* bigintLiteral */;
            case 5 /* operator */: return "operator" /* operator */;
            case 6 /* stringLiteral */: return "string" /* stringLiteral */;
            case 8 /* whiteSpace */: return "whitespace" /* whiteSpace */;
            case 9 /* text */: return "text" /* text */;
            case 10 /* punctuation */: return "punctuation" /* punctuation */;
            case 11 /* className */: return "class name" /* className */;
            case 12 /* enumName */: return "enum name" /* enumName */;
            case 13 /* interfaceName */: return "interface name" /* interfaceName */;
            case 14 /* moduleName */: return "module name" /* moduleName */;
            case 15 /* typeParameterName */: return "type parameter name" /* typeParameterName */;
            case 16 /* typeAliasName */: return "type alias name" /* typeAliasName */;
            case 17 /* parameterName */: return "parameter name" /* parameterName */;
            case 18 /* docCommentTagName */: return "doc comment tag name" /* docCommentTagName */;
            case 19 /* jsxOpenTagName */: return "jsx open tag name" /* jsxOpenTagName */;
            case 20 /* jsxCloseTagName */: return "jsx close tag name" /* jsxCloseTagName */;
            case 21 /* jsxSelfClosingTagName */: return "jsx self closing tag name" /* jsxSelfClosingTagName */;
            case 22 /* jsxAttribute */: return "jsx attribute" /* jsxAttribute */;
            case 23 /* jsxText */: return "jsx text" /* jsxText */;
            case 24 /* jsxAttributeStringLiteralValue */: return "jsx attribute string literal value" /* jsxAttributeStringLiteralValue */;
            default: return undefined; // TODO: GH#18217 throw Debug.assertNever(type);
        }
    }
    function convertClassificationsToSpans(classifications) {
        ts.Debug.assert(classifications.spans.length % 3 === 0);
        var dense = classifications.spans;
        var result = [];
        for (var i = 0; i < dense.length; i += 3) {
            result.push({
                textSpan: ts.createTextSpan(dense[i], dense[i + 1]),
                classificationType: getClassificationTypeName(dense[i + 2])
            });
        }
        return result;
    }
    /* @internal */
    function getSyntacticClassifications(cancellationToken, sourceFile, span) {
        return convertClassificationsToSpans(getEncodedSyntacticClassifications(cancellationToken, sourceFile, span));
    }
    ts.getSyntacticClassifications = getSyntacticClassifications;
    /* @internal */
    function getEncodedSyntacticClassifications(cancellationToken, sourceFile, span) {
        var spanStart = span.start;
        var spanLength = span.length;
        // Make a scanner we can get trivia from.
        var triviaScanner = ts.createScanner(99 /* Latest */, /*skipTrivia*/ false, sourceFile.languageVariant, sourceFile.text);
        var mergeConflictScanner = ts.createScanner(99 /* Latest */, /*skipTrivia*/ false, sourceFile.languageVariant, sourceFile.text);
        var result = [];
        processElement(sourceFile);
        return { spans: result, endOfLineState: 0 /* None */ };
        function pushClassification(start, length, type) {
            result.push(start);
            result.push(length);
            result.push(type);
        }
        function classifyLeadingTriviaAndGetTokenStart(token) {
            triviaScanner.setTextPos(token.pos);
            while (true) {
                var start = triviaScanner.getTextPos();
                // only bother scanning if we have something that could be trivia.
                if (!ts.couldStartTrivia(sourceFile.text, start)) {
                    return start;
                }
                var kind = triviaScanner.scan();
                var end = triviaScanner.getTextPos();
                var width = end - start;
                // The moment we get something that isn't trivia, then stop processing.
                if (!ts.isTrivia(kind)) {
                    return start;
                }
                switch (kind) {
                    case 4 /* NewLineTrivia */:
                    case 5 /* WhitespaceTrivia */:
                        // Don't bother with newlines/whitespace.
                        continue;
                    case 2 /* SingleLineCommentTrivia */:
                    case 3 /* MultiLineCommentTrivia */:
                        // Only bother with the trivia if it at least intersects the span of interest.
                        classifyComment(token, kind, start, width);
                        // Classifying a comment might cause us to reuse the trivia scanner
                        // (because of jsdoc comments).  So after we classify the comment make
                        // sure we set the scanner position back to where it needs to be.
                        triviaScanner.setTextPos(end);
                        continue;
                    case 7 /* ConflictMarkerTrivia */:
                        var text = sourceFile.text;
                        var ch = text.charCodeAt(start);
                        // for the <<<<<<< and >>>>>>> markers, we just add them in as comments
                        // in the classification stream.
                        if (ch === 60 /* lessThan */ || ch === 62 /* greaterThan */) {
                            pushClassification(start, width, 1 /* comment */);
                            continue;
                        }
                        // for the ||||||| and ======== markers, add a comment for the first line,
                        // and then lex all subsequent lines up until the end of the conflict marker.
                        ts.Debug.assert(ch === 124 /* bar */ || ch === 61 /* equals */);
                        classifyDisabledMergeCode(text, start, end);
                        break;
                    case 6 /* ShebangTrivia */:
                        // TODO: Maybe we should classify these.
                        break;
                    default:
                        ts.Debug.assertNever(kind);
                }
            }
        }
        function classifyComment(token, kind, start, width) {
            if (kind === 3 /* MultiLineCommentTrivia */) {
                // See if this is a doc comment.  If so, we'll classify certain portions of it
                // specially.
                var docCommentAndDiagnostics = ts.parseIsolatedJSDocComment(sourceFile.text, start, width);
                if (docCommentAndDiagnostics && docCommentAndDiagnostics.jsDoc) {
                    // TODO: This should be predicated on `token["kind"]` being compatible with `HasJSDoc["kind"]`
                    ts.setParent(docCommentAndDiagnostics.jsDoc, token);
                    classifyJSDocComment(docCommentAndDiagnostics.jsDoc);
                    return;
                }
            }
            else if (kind === 2 /* SingleLineCommentTrivia */) {
                if (tryClassifyTripleSlashComment(start, width)) {
                    return;
                }
            }
            // Simple comment.  Just add as is.
            pushCommentRange(start, width);
        }
        function pushCommentRange(start, width) {
            pushClassification(start, width, 1 /* comment */);
        }
        function classifyJSDocComment(docComment) {
            var _a, _b, _c, _d, _e, _f, _g;
            var pos = docComment.pos;
            if (docComment.tags) {
                for (var _i = 0, _h = docComment.tags; _i < _h.length; _i++) {
                    var tag = _h[_i];
                    // As we walk through each tag, classify the portion of text from the end of
                    // the last tag (or the start of the entire doc comment) as 'comment'.
                    if (tag.pos !== pos) {
                        pushCommentRange(pos, tag.pos - pos);
                    }
                    pushClassification(tag.pos, 1, 10 /* punctuation */); // "@"
                    pushClassification(tag.tagName.pos, tag.tagName.end - tag.tagName.pos, 18 /* docCommentTagName */); // e.g. "param"
                    pos = tag.tagName.end;
                    var commentStart = tag.tagName.end;
                    switch (tag.kind) {
                        case 335 /* JSDocParameterTag */:
                            var param = tag;
                            processJSDocParameterTag(param);
                            commentStart = param.isNameFirst && ((_a = param.typeExpression) === null || _a === void 0 ? void 0 : _a.end) || param.name.end;
                            break;
                        case 342 /* JSDocPropertyTag */:
                            var prop = tag;
                            commentStart = prop.isNameFirst && ((_b = prop.typeExpression) === null || _b === void 0 ? void 0 : _b.end) || prop.name.end;
                            break;
                        case 339 /* JSDocTemplateTag */:
                            processJSDocTemplateTag(tag);
                            pos = tag.end;
                            commentStart = tag.typeParameters.end;
                            break;
                        case 340 /* JSDocTypedefTag */:
                            var type = tag;
                            commentStart = ((_c = type.typeExpression) === null || _c === void 0 ? void 0 : _c.kind) === 304 /* JSDocTypeExpression */ && ((_d = type.fullName) === null || _d === void 0 ? void 0 : _d.end) || ((_e = type.typeExpression) === null || _e === void 0 ? void 0 : _e.end) || commentStart;
                            break;
                        case 333 /* JSDocCallbackTag */:
                            commentStart = tag.typeExpression.end;
                            break;
                        case 338 /* JSDocTypeTag */:
                            processElement(tag.typeExpression);
                            pos = tag.end;
                            commentStart = tag.typeExpression.end;
                            break;
                        case 337 /* JSDocThisTag */:
                        case 334 /* JSDocEnumTag */:
                            commentStart = tag.typeExpression.end;
                            break;
                        case 336 /* JSDocReturnTag */:
                            processElement(tag.typeExpression);
                            pos = tag.end;
                            commentStart = ((_f = tag.typeExpression) === null || _f === void 0 ? void 0 : _f.end) || commentStart;
                            break;
                        case 341 /* JSDocSeeTag */:
                            commentStart = ((_g = tag.name) === null || _g === void 0 ? void 0 : _g.end) || commentStart;
                            break;
                        case 323 /* JSDocAugmentsTag */:
                        case 324 /* JSDocImplementsTag */:
                            commentStart = tag.class.end;
                            break;
                    }
                    if (typeof tag.comment === "object") {
                        pushCommentRange(tag.comment.pos, tag.comment.end - tag.comment.pos);
                    }
                    else if (typeof tag.comment === "string") {
                        pushCommentRange(commentStart, tag.end - commentStart);
                    }
                }
            }
            if (pos !== docComment.end) {
                pushCommentRange(pos, docComment.end - pos);
            }
            return;
            function processJSDocParameterTag(tag) {
                if (tag.isNameFirst) {
                    pushCommentRange(pos, tag.name.pos - pos);
                    pushClassification(tag.name.pos, tag.name.end - tag.name.pos, 17 /* parameterName */);
                    pos = tag.name.end;
                }
                if (tag.typeExpression) {
                    pushCommentRange(pos, tag.typeExpression.pos - pos);
                    processElement(tag.typeExpression);
                    pos = tag.typeExpression.end;
                }
                if (!tag.isNameFirst) {
                    pushCommentRange(pos, tag.name.pos - pos);
                    pushClassification(tag.name.pos, tag.name.end - tag.name.pos, 17 /* parameterName */);
                    pos = tag.name.end;
                }
            }
        }
        function tryClassifyTripleSlashComment(start, width) {
            var tripleSlashXMLCommentRegEx = /^(\/\/\/\s*)(<)(?:(\S+)((?:[^/]|\/[^>])*)(\/>)?)?/im;
            // Require a leading whitespace character (the parser already does) to prevent terrible backtracking performance
            var attributeRegex = /(\s)(\S+)(\s*)(=)(\s*)('[^']+'|"[^"]+")/img;
            var text = sourceFile.text.substr(start, width);
            var match = tripleSlashXMLCommentRegEx.exec(text);
            if (!match) {
                return false;
            }
            // Limiting classification to exactly the elements and attributes
            // defined in `ts.commentPragmas` would be excessive, but we can avoid
            // some obvious false positives (e.g. in XML-like doc comments) by
            // checking the element name.
            // eslint-disable-next-line no-in-operator
            if (!match[3] || !(match[3] in ts.commentPragmas)) {
                return false;
            }
            var pos = start;
            pushCommentRange(pos, match[1].length); // ///
            pos += match[1].length;
            pushClassification(pos, match[2].length, 10 /* punctuation */); // <
            pos += match[2].length;
            pushClassification(pos, match[3].length, 21 /* jsxSelfClosingTagName */); // element name
            pos += match[3].length;
            var attrText = match[4];
            var attrPos = pos;
            while (true) {
                var attrMatch = attributeRegex.exec(attrText);
                if (!attrMatch) {
                    break;
                }
                var newAttrPos = pos + attrMatch.index + attrMatch[1].length; // whitespace
                if (newAttrPos > attrPos) {
                    pushCommentRange(attrPos, newAttrPos - attrPos);
                    attrPos = newAttrPos;
                }
                pushClassification(attrPos, attrMatch[2].length, 22 /* jsxAttribute */); // attribute name
                attrPos += attrMatch[2].length;
                if (attrMatch[3].length) {
                    pushCommentRange(attrPos, attrMatch[3].length); // whitespace
                    attrPos += attrMatch[3].length;
                }
                pushClassification(attrPos, attrMatch[4].length, 5 /* operator */); // =
                attrPos += attrMatch[4].length;
                if (attrMatch[5].length) {
                    pushCommentRange(attrPos, attrMatch[5].length); // whitespace
                    attrPos += attrMatch[5].length;
                }
                pushClassification(attrPos, attrMatch[6].length, 24 /* jsxAttributeStringLiteralValue */); // attribute value
                attrPos += attrMatch[6].length;
            }
            pos += match[4].length;
            if (pos > attrPos) {
                pushCommentRange(attrPos, pos - attrPos);
            }
            if (match[5]) {
                pushClassification(pos, match[5].length, 10 /* punctuation */); // />
                pos += match[5].length;
            }
            var end = start + width;
            if (pos < end) {
                pushCommentRange(pos, end - pos);
            }
            return true;
        }
        function processJSDocTemplateTag(tag) {
            for (var _i = 0, _a = tag.getChildren(); _i < _a.length; _i++) {
                var child = _a[_i];
                processElement(child);
            }
        }
        function classifyDisabledMergeCode(text, start, end) {
            // Classify the line that the ||||||| or ======= marker is on as a comment.
            // Then just lex all further tokens and add them to the result.
            var i;
            for (i = start; i < end; i++) {
                if (ts.isLineBreak(text.charCodeAt(i))) {
                    break;
                }
            }
            pushClassification(start, i - start, 1 /* comment */);
            mergeConflictScanner.setTextPos(i);
            while (mergeConflictScanner.getTextPos() < end) {
                classifyDisabledCodeToken();
            }
        }
        function classifyDisabledCodeToken() {
            var start = mergeConflictScanner.getTextPos();
            var tokenKind = mergeConflictScanner.scan();
            var end = mergeConflictScanner.getTextPos();
            var type = classifyTokenType(tokenKind);
            if (type) {
                pushClassification(start, end - start, type);
            }
        }
        /**
         * Returns true if node should be treated as classified and no further processing is required.
         * False will mean that node is not classified and traverse routine should recurse into node contents.
         */
        function tryClassifyNode(node) {
            if (ts.isJSDoc(node)) {
                return true;
            }
            if (ts.nodeIsMissing(node)) {
                return true;
            }
            var classifiedElementName = tryClassifyJsxElementName(node);
            if (!ts.isToken(node) && node.kind !== 11 /* JsxText */ && classifiedElementName === undefined) {
                return false;
            }
            var tokenStart = node.kind === 11 /* JsxText */ ? node.pos : classifyLeadingTriviaAndGetTokenStart(node);
            var tokenWidth = node.end - tokenStart;
            ts.Debug.assert(tokenWidth >= 0);
            if (tokenWidth > 0) {
                var type = classifiedElementName || classifyTokenType(node.kind, node);
                if (type) {
                    pushClassification(tokenStart, tokenWidth, type);
                }
            }
            return true;
        }
        function tryClassifyJsxElementName(token) {
            switch (token.parent && token.parent.kind) {
                case 278 /* JsxOpeningElement */:
                    if (token.parent.tagName === token) {
                        return 19 /* jsxOpenTagName */;
                    }
                    break;
                case 279 /* JsxClosingElement */:
                    if (token.parent.tagName === token) {
                        return 20 /* jsxCloseTagName */;
                    }
                    break;
                case 277 /* JsxSelfClosingElement */:
                    if (token.parent.tagName === token) {
                        return 21 /* jsxSelfClosingTagName */;
                    }
                    break;
                case 283 /* JsxAttribute */:
                    if (token.parent.name === token) {
                        return 22 /* jsxAttribute */;
                    }
                    break;
            }
            return undefined;
        }
        // for accurate classification, the actual token should be passed in.  however, for
        // cases like 'disabled merge code' classification, we just get the token kind and
        // classify based on that instead.
        function classifyTokenType(tokenKind, token) {
            if (ts.isKeyword(tokenKind)) {
                return 3 /* keyword */;
            }
            // Special case `<` and `>`: If they appear in a generic context they are punctuation,
            // not operators.
            if (tokenKind === 29 /* LessThanToken */ || tokenKind === 31 /* GreaterThanToken */) {
                // If the node owning the token has a type argument list or type parameter list, then
                // we can effectively assume that a '<' and '>' belong to those lists.
                if (token && ts.getTypeArgumentOrTypeParameterList(token.parent)) {
                    return 10 /* punctuation */;
                }
            }
            if (ts.isPunctuation(tokenKind)) {
                if (token) {
                    var parent = token.parent;
                    if (tokenKind === 63 /* EqualsToken */) {
                        // the '=' in a variable declaration is special cased here.
                        if (parent.kind === 252 /* VariableDeclaration */ ||
                            parent.kind === 165 /* PropertyDeclaration */ ||
                            parent.kind === 162 /* Parameter */ ||
                            parent.kind === 283 /* JsxAttribute */) {
                            return 5 /* operator */;
                        }
                    }
                    if (parent.kind === 219 /* BinaryExpression */ ||
                        parent.kind === 217 /* PrefixUnaryExpression */ ||
                        parent.kind === 218 /* PostfixUnaryExpression */ ||
                        parent.kind === 220 /* ConditionalExpression */) {
                        return 5 /* operator */;
                    }
                }
                return 10 /* punctuation */;
            }
            else if (tokenKind === 8 /* NumericLiteral */) {
                return 4 /* numericLiteral */;
            }
            else if (tokenKind === 9 /* BigIntLiteral */) {
                return 25 /* bigintLiteral */;
            }
            else if (tokenKind === 10 /* StringLiteral */) {
                return token && token.parent.kind === 283 /* JsxAttribute */ ? 24 /* jsxAttributeStringLiteralValue */ : 6 /* stringLiteral */;
            }
            else if (tokenKind === 13 /* RegularExpressionLiteral */) {
                // TODO: we should get another classification type for these literals.
                return 6 /* stringLiteral */;
            }
            else if (ts.isTemplateLiteralKind(tokenKind)) {
                // TODO (drosen): we should *also* get another classification type for these literals.
                return 6 /* stringLiteral */;
            }
            else if (tokenKind === 11 /* JsxText */) {
                return 23 /* jsxText */;
            }
            else if (tokenKind === 79 /* Identifier */) {
                if (token) {
                    switch (token.parent.kind) {
                        case 255 /* ClassDeclaration */:
                            if (token.parent.name === token) {
                                return 11 /* className */;
                            }
                            return;
                        case 161 /* TypeParameter */:
                            if (token.parent.name === token) {
                                return 15 /* typeParameterName */;
                            }
                            return;
                        case 256 /* InterfaceDeclaration */:
                            if (token.parent.name === token) {
                                return 13 /* interfaceName */;
                            }
                            return;
                        case 258 /* EnumDeclaration */:
                            if (token.parent.name === token) {
                                return 12 /* enumName */;
                            }
                            return;
                        case 259 /* ModuleDeclaration */:
                            if (token.parent.name === token) {
                                return 14 /* moduleName */;
                            }
                            return;
                        case 162 /* Parameter */:
                            if (token.parent.name === token) {
                                return ts.isThisIdentifier(token) ? 3 /* keyword */ : 17 /* parameterName */;
                            }
                            return;
                    }
                }
                return 2 /* identifier */;
            }
        }
        function processElement(element) {
            if (!element) {
                return;
            }
            // Ignore nodes that don't intersect the original span to classify.
            if (ts.decodedTextSpanIntersectsWith(spanStart, spanLength, element.pos, element.getFullWidth())) {
                checkForClassificationCancellation(cancellationToken, element.kind);
                for (var _i = 0, _a = element.getChildren(sourceFile); _i < _a.length; _i++) {
                    var child = _a[_i];
                    if (!tryClassifyNode(child)) {
                        // Recurse into our child nodes.
                        processElement(child);
                    }
                }
            }
        }
    }
    ts.getEncodedSyntacticClassifications = getEncodedSyntacticClassifications;
})(ts || (ts = {}));
/** @internal */
var ts;
(function (ts) {
    var classifier;
    (function (classifier) {
        var v2020;
        (function (v2020) {
            var TokenEncodingConsts;
            (function (TokenEncodingConsts) {
                TokenEncodingConsts[TokenEncodingConsts["typeOffset"] = 8] = "typeOffset";
                TokenEncodingConsts[TokenEncodingConsts["modifierMask"] = 255] = "modifierMask";
            })(TokenEncodingConsts = v2020.TokenEncodingConsts || (v2020.TokenEncodingConsts = {}));
            var TokenType;
            (function (TokenType) {
                TokenType[TokenType["class"] = 0] = "class";
                TokenType[TokenType["enum"] = 1] = "enum";
                TokenType[TokenType["interface"] = 2] = "interface";
                TokenType[TokenType["namespace"] = 3] = "namespace";
                TokenType[TokenType["typeParameter"] = 4] = "typeParameter";
                TokenType[TokenType["type"] = 5] = "type";
                TokenType[TokenType["parameter"] = 6] = "parameter";
                TokenType[TokenType["variable"] = 7] = "variable";
                TokenType[TokenType["enumMember"] = 8] = "enumMember";
                TokenType[TokenType["property"] = 9] = "property";
                TokenType[TokenType["function"] = 10] = "function";
                TokenType[TokenType["member"] = 11] = "member";
            })(TokenType = v2020.TokenType || (v2020.TokenType = {}));
            var TokenModifier;
            (function (TokenModifier) {
                TokenModifier[TokenModifier["declaration"] = 0] = "declaration";
                TokenModifier[TokenModifier["static"] = 1] = "static";
                TokenModifier[TokenModifier["async"] = 2] = "async";
                TokenModifier[TokenModifier["readonly"] = 3] = "readonly";
                TokenModifier[TokenModifier["defaultLibrary"] = 4] = "defaultLibrary";
                TokenModifier[TokenModifier["local"] = 5] = "local";
            })(TokenModifier = v2020.TokenModifier || (v2020.TokenModifier = {}));
            /** This is mainly used internally for testing */
            function getSemanticClassifications(program, cancellationToken, sourceFile, span) {
                var classifications = getEncodedSemanticClassifications(program, cancellationToken, sourceFile, span);
                ts.Debug.assert(classifications.spans.length % 3 === 0);
                var dense = classifications.spans;
                var result = [];
                for (var i = 0; i < dense.length; i += 3) {
                    result.push({
                        textSpan: ts.createTextSpan(dense[i], dense[i + 1]),
                        classificationType: dense[i + 2]
                    });
                }
                return result;
            }
            v2020.getSemanticClassifications = getSemanticClassifications;
            function getEncodedSemanticClassifications(program, cancellationToken, sourceFile, span) {
                return {
                    spans: getSemanticTokens(program, sourceFile, span, cancellationToken),
                    endOfLineState: 0 /* None */
                };
            }
            v2020.getEncodedSemanticClassifications = getEncodedSemanticClassifications;
            function getSemanticTokens(program, sourceFile, span, cancellationToken) {
                var resultTokens = [];
                var collector = function (node, typeIdx, modifierSet) {
                    resultTokens.push(node.getStart(sourceFile), node.getWidth(sourceFile), ((typeIdx + 1) << 8 /* typeOffset */) + modifierSet);
                };
                if (program && sourceFile) {
                    collectTokens(program, sourceFile, span, collector, cancellationToken);
                }
                return resultTokens;
            }
            function collectTokens(program, sourceFile, span, collector, cancellationToken) {
                var typeChecker = program.getTypeChecker();
                var inJSXElement = false;
                function visit(node) {
                    switch (node.kind) {
                        case 259 /* ModuleDeclaration */:
                        case 255 /* ClassDeclaration */:
                        case 256 /* InterfaceDeclaration */:
                        case 254 /* FunctionDeclaration */:
                        case 224 /* ClassExpression */:
                        case 211 /* FunctionExpression */:
                        case 212 /* ArrowFunction */:
                            cancellationToken.throwIfCancellationRequested();
                    }
                    if (!node || !ts.textSpanIntersectsWith(span, node.pos, node.getFullWidth()) || node.getFullWidth() === 0) {
                        return;
                    }
                    var prevInJSXElement = inJSXElement;
                    if (ts.isJsxElement(node) || ts.isJsxSelfClosingElement(node)) {
                        inJSXElement = true;
                    }
                    if (ts.isJsxExpression(node)) {
                        inJSXElement = false;
                    }
                    if (ts.isIdentifier(node) && !inJSXElement && !inImportClause(node) && !ts.isInfinityOrNaNString(node.escapedText)) {
                        var symbol = typeChecker.getSymbolAtLocation(node);
                        if (symbol) {
                            if (symbol.flags & 2097152 /* Alias */) {
                                symbol = typeChecker.getAliasedSymbol(symbol);
                            }
                            var typeIdx = classifySymbol(symbol, ts.getMeaningFromLocation(node));
                            if (typeIdx !== undefined) {
                                var modifierSet = 0;
                                if (node.parent) {
                                    var parentIsDeclaration = (ts.isBindingElement(node.parent) || tokenFromDeclarationMapping.get(node.parent.kind) === typeIdx);
                                    if (parentIsDeclaration && node.parent.name === node) {
                                        modifierSet = 1 << 0 /* declaration */;
                                    }
                                }
                                // property declaration in constructor
                                if (typeIdx === 6 /* parameter */ && isRightSideOfQualifiedNameOrPropertyAccess(node)) {
                                    typeIdx = 9 /* property */;
                                }
                                typeIdx = reclassifyByType(typeChecker, node, typeIdx);
                                var decl = symbol.valueDeclaration;
                                if (decl) {
                                    var modifiers = ts.getCombinedModifierFlags(decl);
                                    var nodeFlags = ts.getCombinedNodeFlags(decl);
                                    if (modifiers & 32 /* Static */) {
                                        modifierSet |= 1 << 1 /* static */;
                                    }
                                    if (modifiers & 256 /* Async */) {
                                        modifierSet |= 1 << 2 /* async */;
                                    }
                                    if (typeIdx !== 0 /* class */ && typeIdx !== 2 /* interface */) {
                                        if ((modifiers & 64 /* Readonly */) || (nodeFlags & 2 /* Const */) || (symbol.getFlags() & 8 /* EnumMember */)) {
                                            modifierSet |= 1 << 3 /* readonly */;
                                        }
                                    }
                                    if ((typeIdx === 7 /* variable */ || typeIdx === 10 /* function */) && isLocalDeclaration(decl, sourceFile)) {
                                        modifierSet |= 1 << 5 /* local */;
                                    }
                                    if (program.isSourceFileDefaultLibrary(decl.getSourceFile())) {
                                        modifierSet |= 1 << 4 /* defaultLibrary */;
                                    }
                                }
                                else if (symbol.declarations && symbol.declarations.some(function (d) { return program.isSourceFileDefaultLibrary(d.getSourceFile()); })) {
                                    modifierSet |= 1 << 4 /* defaultLibrary */;
                                }
                                collector(node, typeIdx, modifierSet);
                            }
                        }
                    }
                    ts.forEachChild(node, visit);
                    inJSXElement = prevInJSXElement;
                }
                visit(sourceFile);
            }
            function classifySymbol(symbol, meaning) {
                var flags = symbol.getFlags();
                if (flags & 32 /* Class */) {
                    return 0 /* class */;
                }
                else if (flags & 384 /* Enum */) {
                    return 1 /* enum */;
                }
                else if (flags & 524288 /* TypeAlias */) {
                    return 5 /* type */;
                }
                else if (flags & 64 /* Interface */) {
                    if (meaning & 2 /* Type */) {
                        return 2 /* interface */;
                    }
                }
                else if (flags & 262144 /* TypeParameter */) {
                    return 4 /* typeParameter */;
                }
                var decl = symbol.valueDeclaration || symbol.declarations && symbol.declarations[0];
                if (decl && ts.isBindingElement(decl)) {
                    decl = getDeclarationForBindingElement(decl);
                }
                return decl && tokenFromDeclarationMapping.get(decl.kind);
            }
            function reclassifyByType(typeChecker, node, typeIdx) {
                // type based classifications
                if (typeIdx === 7 /* variable */ || typeIdx === 9 /* property */ || typeIdx === 6 /* parameter */) {
                    var type_1 = typeChecker.getTypeAtLocation(node);
                    if (type_1) {
                        var test = function (condition) {
                            return condition(type_1) || type_1.isUnion() && type_1.types.some(condition);
                        };
                        if (typeIdx !== 6 /* parameter */ && test(function (t) { return t.getConstructSignatures().length > 0; })) {
                            return 0 /* class */;
                        }
                        if (test(function (t) { return t.getCallSignatures().length > 0; }) && !test(function (t) { return t.getProperties().length > 0; }) || isExpressionInCallExpression(node)) {
                            return typeIdx === 9 /* property */ ? 11 /* member */ : 10 /* function */;
                        }
                    }
                }
                return typeIdx;
            }
            function isLocalDeclaration(decl, sourceFile) {
                if (ts.isBindingElement(decl)) {
                    decl = getDeclarationForBindingElement(decl);
                }
                if (ts.isVariableDeclaration(decl)) {
                    return (!ts.isSourceFile(decl.parent.parent.parent) || ts.isCatchClause(decl.parent)) && decl.getSourceFile() === sourceFile;
                }
                else if (ts.isFunctionDeclaration(decl)) {
                    return !ts.isSourceFile(decl.parent) && decl.getSourceFile() === sourceFile;
                }
                return false;
            }
            function getDeclarationForBindingElement(element) {
                while (true) {
                    if (ts.isBindingElement(element.parent.parent)) {
                        element = element.parent.parent;
                    }
                    else {
                        return element.parent.parent;
                    }
                }
            }
            function inImportClause(node) {
                var parent = node.parent;
                return parent && (ts.isImportClause(parent) || ts.isImportSpecifier(parent) || ts.isNamespaceImport(parent));
            }
            function isExpressionInCallExpression(node) {
                while (isRightSideOfQualifiedNameOrPropertyAccess(node)) {
                    node = node.parent;
                }
                return ts.isCallExpression(node.parent) && node.parent.expression === node;
            }
            function isRightSideOfQualifiedNameOrPropertyAccess(node) {
                return (ts.isQualifiedName(node.parent) && node.parent.right === node) || (ts.isPropertyAccessExpression(node.parent) && node.parent.name === node);
            }
            var tokenFromDeclarationMapping = new ts.Map([
                [252 /* VariableDeclaration */, 7 /* variable */],
                [162 /* Parameter */, 6 /* parameter */],
                [165 /* PropertyDeclaration */, 9 /* property */],
                [259 /* ModuleDeclaration */, 3 /* namespace */],
                [258 /* EnumDeclaration */, 1 /* enum */],
                [294 /* EnumMember */, 8 /* enumMember */],
                [255 /* ClassDeclaration */, 0 /* class */],
                [167 /* MethodDeclaration */, 11 /* member */],
                [254 /* FunctionDeclaration */, 10 /* function */],
                [211 /* FunctionExpression */, 10 /* function */],
                [166 /* MethodSignature */, 11 /* member */],
                [170 /* GetAccessor */, 9 /* property */],
                [171 /* SetAccessor */, 9 /* property */],
                [164 /* PropertySignature */, 9 /* property */],
                [256 /* InterfaceDeclaration */, 2 /* interface */],
                [257 /* TypeAliasDeclaration */, 5 /* type */],
                [161 /* TypeParameter */, 4 /* typeParameter */],
                [291 /* PropertyAssignment */, 9 /* property */],
                [292 /* ShorthandPropertyAssignment */, 9 /* property */]
            ]);
        })(v2020 = classifier.v2020 || (classifier.v2020 = {}));
    })(classifier = ts.classifier || (ts.classifier = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var Completions;
    (function (Completions) {
        var StringCompletions;
        (function (StringCompletions) {
            function getStringLiteralCompletions(sourceFile, position, contextToken, checker, options, host, log, preferences) {
                if (ts.isInReferenceComment(sourceFile, position)) {
                    var entries = getTripleSlashReferenceCompletion(sourceFile, position, options, host);
                    return entries && convertPathCompletions(entries);
                }
                if (ts.isInString(sourceFile, position, contextToken)) {
                    if (!contextToken || !ts.isStringLiteralLike(contextToken))
                        return undefined;
                    var entries = getStringLiteralCompletionEntries(sourceFile, contextToken, position, checker, options, host, preferences);
                    return convertStringLiteralCompletions(entries, contextToken, sourceFile, checker, log, options, preferences);
                }
            }
            StringCompletions.getStringLiteralCompletions = getStringLiteralCompletions;
            function convertStringLiteralCompletions(completion, contextToken, sourceFile, checker, log, options, preferences) {
                if (completion === undefined) {
                    return undefined;
                }
                var optionalReplacementSpan = ts.createTextSpanFromStringLiteralLikeContent(contextToken);
                switch (completion.kind) {
                    case 0 /* Paths */:
                        return convertPathCompletions(completion.paths);
                    case 1 /* Properties */: {
                        var entries = [];
                        Completions.getCompletionEntriesFromSymbols(completion.symbols, entries, contextToken, sourceFile, sourceFile, checker, 99 /* ESNext */, log, 4 /* String */, preferences, options); // Target will not be used, so arbitrary
                        return { isGlobalCompletion: false, isMemberCompletion: true, isNewIdentifierLocation: completion.hasIndexSignature, optionalReplacementSpan: optionalReplacementSpan, entries: entries };
                    }
                    case 2 /* Types */: {
                        var entries = completion.types.map(function (type) { return ({
                            name: type.value,
                            kindModifiers: "" /* none */,
                            kind: "string" /* string */,
                            sortText: Completions.SortText.LocationPriority,
                            replacementSpan: ts.getReplacementSpanForContextToken(contextToken)
                        }); });
                        return { isGlobalCompletion: false, isMemberCompletion: false, isNewIdentifierLocation: completion.isNewIdentifier, optionalReplacementSpan: optionalReplacementSpan, entries: entries };
                    }
                    default:
                        return ts.Debug.assertNever(completion);
                }
            }
            function getStringLiteralCompletionDetails(name, sourceFile, position, contextToken, checker, options, host, cancellationToken, preferences) {
                if (!contextToken || !ts.isStringLiteralLike(contextToken))
                    return undefined;
                var completions = getStringLiteralCompletionEntries(sourceFile, contextToken, position, checker, options, host, preferences);
                return completions && stringLiteralCompletionDetails(name, contextToken, completions, sourceFile, checker, cancellationToken);
            }
            StringCompletions.getStringLiteralCompletionDetails = getStringLiteralCompletionDetails;
            function stringLiteralCompletionDetails(name, location, completion, sourceFile, checker, cancellationToken) {
                switch (completion.kind) {
                    case 0 /* Paths */: {
                        var match = ts.find(completion.paths, function (p) { return p.name === name; });
                        return match && Completions.createCompletionDetails(name, kindModifiersFromExtension(match.extension), match.kind, [ts.textPart(name)]);
                    }
                    case 1 /* Properties */: {
                        var match = ts.find(completion.symbols, function (s) { return s.name === name; });
                        return match && Completions.createCompletionDetailsForSymbol(match, checker, sourceFile, location, cancellationToken);
                    }
                    case 2 /* Types */:
                        return ts.find(completion.types, function (t) { return t.value === name; }) ? Completions.createCompletionDetails(name, "" /* none */, "type" /* typeElement */, [ts.textPart(name)]) : undefined;
                    default:
                        return ts.Debug.assertNever(completion);
                }
            }
            function convertPathCompletions(pathCompletions) {
                var isGlobalCompletion = false; // We don't want the editor to offer any other completions, such as snippets, inside a comment.
                var isNewIdentifierLocation = true; // The user may type in a path that doesn't yet exist, creating a "new identifier" with respect to the collection of identifiers the server is aware of.
                var entries = pathCompletions.map(function (_a) {
                    var name = _a.name, kind = _a.kind, span = _a.span, extension = _a.extension;
                    return ({ name: name, kind: kind, kindModifiers: kindModifiersFromExtension(extension), sortText: Completions.SortText.LocationPriority, replacementSpan: span });
                });
                return { isGlobalCompletion: isGlobalCompletion, isMemberCompletion: false, isNewIdentifierLocation: isNewIdentifierLocation, entries: entries };
            }
            function kindModifiersFromExtension(extension) {
                switch (extension) {
                    case ".d.ts" /* Dts */: return ".d.ts" /* dtsModifier */;
                    case ".js" /* Js */: return ".js" /* jsModifier */;
                    case ".json" /* Json */: return ".json" /* jsonModifier */;
                    case ".jsx" /* Jsx */: return ".jsx" /* jsxModifier */;
                    case ".ts" /* Ts */: return ".ts" /* tsModifier */;
                    case ".tsx" /* Tsx */: return ".tsx" /* tsxModifier */;
                    case ".tsbuildinfo" /* TsBuildInfo */: return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported.");
                    case undefined: return "" /* none */;
                    default:
                        return ts.Debug.assertNever(extension);
                }
            }
            var StringLiteralCompletionKind;
            (function (StringLiteralCompletionKind) {
                StringLiteralCompletionKind[StringLiteralCompletionKind["Paths"] = 0] = "Paths";
                StringLiteralCompletionKind[StringLiteralCompletionKind["Properties"] = 1] = "Properties";
                StringLiteralCompletionKind[StringLiteralCompletionKind["Types"] = 2] = "Types";
            })(StringLiteralCompletionKind || (StringLiteralCompletionKind = {}));
            function getStringLiteralCompletionEntries(sourceFile, node, position, typeChecker, compilerOptions, host, preferences) {
                var parent = walkUpParentheses(node.parent);
                switch (parent.kind) {
                    case 194 /* LiteralType */: {
                        var grandParent = walkUpParentheses(parent.parent);
                        switch (grandParent.kind) {
                            case 176 /* TypeReference */: {
                                var typeReference_1 = grandParent;
                                var typeArgument = ts.findAncestor(parent, function (n) { return n.parent === typeReference_1; });
                                if (typeArgument) {
                                    return { kind: 2 /* Types */, types: getStringLiteralTypes(typeChecker.getTypeArgumentConstraint(typeArgument)), isNewIdentifier: false };
                                }
                                return undefined;
                            }
                            case 192 /* IndexedAccessType */:
                                // Get all apparent property names
                                // i.e. interface Foo {
                                //          foo: string;
                                //          bar: string;
                                //      }
                                //      let x: Foo["/*completion position*/"]
                                var _a = grandParent, indexType = _a.indexType, objectType = _a.objectType;
                                if (!ts.rangeContainsPosition(indexType, position)) {
                                    return undefined;
                                }
                                return stringLiteralCompletionsFromProperties(typeChecker.getTypeFromTypeNode(objectType));
                            case 198 /* ImportType */:
                                return { kind: 0 /* Paths */, paths: getStringLiteralCompletionsFromModuleNames(sourceFile, node, compilerOptions, host, typeChecker, preferences) };
                            case 185 /* UnionType */: {
                                if (!ts.isTypeReferenceNode(grandParent.parent)) {
                                    return undefined;
                                }
                                var alreadyUsedTypes_1 = getAlreadyUsedTypesInStringLiteralUnion(grandParent, parent);
                                var types = getStringLiteralTypes(typeChecker.getTypeArgumentConstraint(grandParent)).filter(function (t) { return !ts.contains(alreadyUsedTypes_1, t.value); });
                                return { kind: 2 /* Types */, types: types, isNewIdentifier: false };
                            }
                            default:
                                return undefined;
                        }
                    }
                    case 291 /* PropertyAssignment */:
                        if (ts.isObjectLiteralExpression(parent.parent) && parent.name === node) {
                            // Get quoted name of properties of the object literal expression
                            // i.e. interface ConfigFiles {
                            //          'jspm:dev': string
                            //      }
                            //      let files: ConfigFiles = {
                            //          '/*completion position*/'
                            //      }
                            //
                            //      function foo(c: ConfigFiles) {}
                            //      foo({
                            //          '/*completion position*/'
                            //      });
                            return stringLiteralCompletionsForObjectLiteral(typeChecker, parent.parent);
                        }
                        return fromContextualType();
                    case 205 /* ElementAccessExpression */: {
                        var _b = parent, expression = _b.expression, argumentExpression = _b.argumentExpression;
                        if (node === ts.skipParentheses(argumentExpression)) {
                            // Get all names of properties on the expression
                            // i.e. interface A {
                            //      'prop1': string
                            // }
                            // let a: A;
                            // a['/*completion position*/']
                            return stringLiteralCompletionsFromProperties(typeChecker.getTypeAtLocation(expression));
                        }
                        return undefined;
                    }
                    case 206 /* CallExpression */:
                    case 207 /* NewExpression */:
                        if (!isRequireCallArgument(node) && !ts.isImportCall(parent)) {
                            var argumentInfo = ts.SignatureHelp.getArgumentInfoForCompletions(node, position, sourceFile);
                            // Get string literal completions from specialized signatures of the target
                            // i.e. declare function f(a: 'A');
                            // f("/*completion position*/")
                            return argumentInfo ? getStringLiteralCompletionsFromSignature(argumentInfo, typeChecker) : fromContextualType();
                        }
                    // falls through (is `require("")` or `require(""` or `import("")`)
                    case 264 /* ImportDeclaration */:
                    case 270 /* ExportDeclaration */:
                    case 275 /* ExternalModuleReference */:
                        // Get all known external module names or complete a path to a module
                        // i.e. import * as ns from "/*completion position*/";
                        //      var y = import("/*completion position*/");
                        //      import x = require("/*completion position*/");
                        //      var y = require("/*completion position*/");
                        //      export * from "/*completion position*/";
                        return { kind: 0 /* Paths */, paths: getStringLiteralCompletionsFromModuleNames(sourceFile, node, compilerOptions, host, typeChecker, preferences) };
                    default:
                        return fromContextualType();
                }
                function fromContextualType() {
                    // Get completion for string literal from string literal type
                    // i.e. var x: "hi" | "hello" = "/*completion position*/"
                    return { kind: 2 /* Types */, types: getStringLiteralTypes(ts.getContextualTypeFromParent(node, typeChecker)), isNewIdentifier: false };
                }
            }
            function walkUpParentheses(node) {
                switch (node.kind) {
                    case 189 /* ParenthesizedType */:
                        return ts.walkUpParenthesizedTypes(node);
                    case 210 /* ParenthesizedExpression */:
                        return ts.walkUpParenthesizedExpressions(node);
                    default:
                        return node;
                }
            }
            function getAlreadyUsedTypesInStringLiteralUnion(union, current) {
                return ts.mapDefined(union.types, function (type) {
                    return type !== current && ts.isLiteralTypeNode(type) && ts.isStringLiteral(type.literal) ? type.literal.text : undefined;
                });
            }
            function getStringLiteralCompletionsFromSignature(argumentInfo, checker) {
                var isNewIdentifier = false;
                var uniques = new ts.Map();
                var candidates = [];
                checker.getResolvedSignature(argumentInfo.invocation, candidates, argumentInfo.argumentCount);
                var types = ts.flatMap(candidates, function (candidate) {
                    if (!ts.signatureHasRestParameter(candidate) && argumentInfo.argumentCount > candidate.parameters.length)
                        return;
                    var type = checker.getParameterType(candidate, argumentInfo.argumentIndex);
                    isNewIdentifier = isNewIdentifier || !!(type.flags & 4 /* String */);
                    return getStringLiteralTypes(type, uniques);
                });
                return { kind: 2 /* Types */, types: types, isNewIdentifier: isNewIdentifier };
            }
            function stringLiteralCompletionsFromProperties(type) {
                return type && {
                    kind: 1 /* Properties */,
                    symbols: ts.filter(type.getApparentProperties(), function (prop) { return !(prop.valueDeclaration && ts.isPrivateIdentifierClassElementDeclaration(prop.valueDeclaration)); }),
                    hasIndexSignature: ts.hasIndexSignature(type)
                };
            }
            function stringLiteralCompletionsForObjectLiteral(checker, objectLiteralExpression) {
                var contextualType = checker.getContextualType(objectLiteralExpression);
                if (!contextualType)
                    return undefined;
                var completionsType = checker.getContextualType(objectLiteralExpression, 4 /* Completions */);
                var symbols = Completions.getPropertiesForObjectExpression(contextualType, completionsType, objectLiteralExpression, checker);
                return {
                    kind: 1 /* Properties */,
                    symbols: symbols,
                    hasIndexSignature: ts.hasIndexSignature(contextualType)
                };
            }
            function getStringLiteralTypes(type, uniques) {
                if (uniques === void 0) { uniques = new ts.Map(); }
                if (!type)
                    return ts.emptyArray;
                type = ts.skipConstraint(type);
                return type.isUnion() ? ts.flatMap(type.types, function (t) { return getStringLiteralTypes(t, uniques); }) :
                    type.isStringLiteral() && !(type.flags & 1024 /* EnumLiteral */) && ts.addToSeen(uniques, type.value) ? [type] : ts.emptyArray;
            }
            function nameAndKind(name, kind, extension) {
                return { name: name, kind: kind, extension: extension };
            }
            function directoryResult(name) {
                return nameAndKind(name, "directory" /* directory */, /*extension*/ undefined);
            }
            function addReplacementSpans(text, textStart, names) {
                var span = getDirectoryFragmentTextSpan(text, textStart);
                var wholeSpan = text.length === 0 ? undefined : ts.createTextSpan(textStart, text.length);
                return names.map(function (_a) {
                    var name = _a.name, kind = _a.kind, extension = _a.extension;
                    return Math.max(name.indexOf(ts.directorySeparator), name.indexOf(ts.altDirectorySeparator)) !== -1 ? { name: name, kind: kind, extension: extension, span: wholeSpan } : { name: name, kind: kind, extension: extension, span: span };
                });
            }
            function getStringLiteralCompletionsFromModuleNames(sourceFile, node, compilerOptions, host, typeChecker, preferences) {
                return addReplacementSpans(node.text, node.getStart(sourceFile) + 1, getStringLiteralCompletionsFromModuleNamesWorker(sourceFile, node, compilerOptions, host, typeChecker, preferences));
            }
            function getStringLiteralCompletionsFromModuleNamesWorker(sourceFile, node, compilerOptions, host, typeChecker, preferences) {
                var literalValue = ts.normalizeSlashes(node.text);
                var scriptPath = sourceFile.path;
                var scriptDirectory = ts.getDirectoryPath(scriptPath);
                return isPathRelativeToScript(literalValue) || !compilerOptions.baseUrl && (ts.isRootedDiskPath(literalValue) || ts.isUrl(literalValue))
                    ? getCompletionEntriesForRelativeModules(literalValue, scriptDirectory, compilerOptions, host, scriptPath, preferences)
                    : getCompletionEntriesForNonRelativeModules(literalValue, scriptDirectory, compilerOptions, host, typeChecker);
            }
            function getExtensionOptions(compilerOptions, includeExtensionsOption) {
                if (includeExtensionsOption === void 0) { includeExtensionsOption = 0 /* Exclude */; }
                return { extensions: getSupportedExtensionsForModuleResolution(compilerOptions), includeExtensionsOption: includeExtensionsOption };
            }
            function getCompletionEntriesForRelativeModules(literalValue, scriptDirectory, compilerOptions, host, scriptPath, preferences) {
                var includeExtensions = preferences.importModuleSpecifierEnding === "js" ? 2 /* ModuleSpecifierCompletion */ : 0 /* Exclude */;
                var extensionOptions = getExtensionOptions(compilerOptions, includeExtensions);
                if (compilerOptions.rootDirs) {
                    return getCompletionEntriesForDirectoryFragmentWithRootDirs(compilerOptions.rootDirs, literalValue, scriptDirectory, extensionOptions, compilerOptions, host, scriptPath);
                }
                else {
                    return getCompletionEntriesForDirectoryFragment(literalValue, scriptDirectory, extensionOptions, host, scriptPath);
                }
            }
            function getSupportedExtensionsForModuleResolution(compilerOptions) {
                var extensions = ts.getSupportedExtensions(compilerOptions);
                return compilerOptions.resolveJsonModule && ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeJs ?
                    extensions.concat(".json" /* Json */) :
                    extensions;
            }
            /**
             * Takes a script path and returns paths for all potential folders that could be merged with its
             * containing folder via the "rootDirs" compiler option
             */
            function getBaseDirectoriesFromRootDirs(rootDirs, basePath, scriptDirectory, ignoreCase) {
                // Make all paths absolute/normalized if they are not already
                rootDirs = rootDirs.map(function (rootDirectory) { return ts.normalizePath(ts.isRootedDiskPath(rootDirectory) ? rootDirectory : ts.combinePaths(basePath, rootDirectory)); });
                // Determine the path to the directory containing the script relative to the root directory it is contained within
                var relativeDirectory = ts.firstDefined(rootDirs, function (rootDirectory) {
                    return ts.containsPath(rootDirectory, scriptDirectory, basePath, ignoreCase) ? scriptDirectory.substr(rootDirectory.length) : undefined;
                }); // TODO: GH#18217
                // Now find a path for each potential directory that is to be merged with the one containing the script
                return ts.deduplicate(__spreadArray(__spreadArray([], rootDirs.map(function (rootDirectory) { return ts.combinePaths(rootDirectory, relativeDirectory); }), true), [scriptDirectory], false), ts.equateStringsCaseSensitive, ts.compareStringsCaseSensitive);
            }
            function getCompletionEntriesForDirectoryFragmentWithRootDirs(rootDirs, fragment, scriptDirectory, extensionOptions, compilerOptions, host, exclude) {
                var basePath = compilerOptions.project || host.getCurrentDirectory();
                var ignoreCase = !(host.useCaseSensitiveFileNames && host.useCaseSensitiveFileNames());
                var baseDirectories = getBaseDirectoriesFromRootDirs(rootDirs, basePath, scriptDirectory, ignoreCase);
                return ts.flatMap(baseDirectories, function (baseDirectory) { return getCompletionEntriesForDirectoryFragment(fragment, baseDirectory, extensionOptions, host, exclude); });
            }
            var IncludeExtensionsOption;
            (function (IncludeExtensionsOption) {
                IncludeExtensionsOption[IncludeExtensionsOption["Exclude"] = 0] = "Exclude";
                IncludeExtensionsOption[IncludeExtensionsOption["Include"] = 1] = "Include";
                IncludeExtensionsOption[IncludeExtensionsOption["ModuleSpecifierCompletion"] = 2] = "ModuleSpecifierCompletion";
            })(IncludeExtensionsOption || (IncludeExtensionsOption = {}));
            /**
             * Given a path ending at a directory, gets the completions for the path, and filters for those entries containing the basename.
             */
            function getCompletionEntriesForDirectoryFragment(fragment, scriptPath, _a, host, exclude, result) {
                var extensions = _a.extensions, includeExtensionsOption = _a.includeExtensionsOption;
                if (result === void 0) { result = []; }
                if (fragment === undefined) {
                    fragment = "";
                }
                fragment = ts.normalizeSlashes(fragment);
                /**
                 * Remove the basename from the path. Note that we don't use the basename to filter completions;
                 * the client is responsible for refining completions.
                 */
                if (!ts.hasTrailingDirectorySeparator(fragment)) {
                    fragment = ts.getDirectoryPath(fragment);
                }
                if (fragment === "") {
                    fragment = "." + ts.directorySeparator;
                }
                fragment = ts.ensureTrailingDirectorySeparator(fragment);
                // const absolutePath = normalizeAndPreserveTrailingSlash(isRootedDiskPath(fragment) ? fragment : combinePaths(scriptPath, fragment)); // TODO(rbuckton): should use resolvePaths
                var absolutePath = ts.resolvePath(scriptPath, fragment);
                var baseDirectory = ts.hasTrailingDirectorySeparator(absolutePath) ? absolutePath : ts.getDirectoryPath(absolutePath);
                var ignoreCase = !(host.useCaseSensitiveFileNames && host.useCaseSensitiveFileNames());
                if (!ts.tryDirectoryExists(host, baseDirectory))
                    return result;
                // Enumerate the available files if possible
                var files = ts.tryReadDirectory(host, baseDirectory, extensions, /*exclude*/ undefined, /*include*/ ["./*"]);
                if (files) {
                    /**
                     * Multiple file entries might map to the same truncated name once we remove extensions
                     * (happens iff includeExtensionsOption === includeExtensionsOption.Exclude) so we use a set-like data structure. Eg:
                     *
                     * both foo.ts and foo.tsx become foo
                     */
                    var foundFiles = new ts.Map(); // maps file to its extension
                    for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                        var filePath = files_1[_i];
                        filePath = ts.normalizePath(filePath);
                        if (exclude && ts.comparePaths(filePath, exclude, scriptPath, ignoreCase) === 0 /* EqualTo */) {
                            continue;
                        }
                        var foundFileName = void 0;
                        var outputExtension = ts.moduleSpecifiers.tryGetJSExtensionForFile(filePath, host.getCompilationSettings());
                        if (includeExtensionsOption === 0 /* Exclude */ && !ts.fileExtensionIs(filePath, ".json" /* Json */)) {
                            foundFileName = ts.removeFileExtension(ts.getBaseFileName(filePath));
                            foundFiles.set(foundFileName, ts.tryGetExtensionFromPath(filePath));
                        }
                        else if (includeExtensionsOption === 2 /* ModuleSpecifierCompletion */ && outputExtension) {
                            foundFileName = ts.changeExtension(ts.getBaseFileName(filePath), outputExtension);
                            foundFiles.set(foundFileName, outputExtension);
                        }
                        else {
                            foundFileName = ts.getBaseFileName(filePath);
                            foundFiles.set(foundFileName, ts.tryGetExtensionFromPath(filePath));
                        }
                    }
                    foundFiles.forEach(function (ext, foundFile) {
                        result.push(nameAndKind(foundFile, "script" /* scriptElement */, ext));
                    });
                }
                // If possible, get folder completion as well
                var directories = ts.tryGetDirectories(host, baseDirectory);
                if (directories) {
                    for (var _b = 0, directories_1 = directories; _b < directories_1.length; _b++) {
                        var directory = directories_1[_b];
                        var directoryName = ts.getBaseFileName(ts.normalizePath(directory));
                        if (directoryName !== "@types") {
                            result.push(directoryResult(directoryName));
                        }
                    }
                }
                // check for a version redirect
                var packageJsonPath = ts.findPackageJson(baseDirectory, host);
                if (packageJsonPath) {
                    var packageJson = ts.readJson(packageJsonPath, host);
                    var typesVersions = packageJson.typesVersions;
                    if (typeof typesVersions === "object") {
                        var versionResult = ts.getPackageJsonTypesVersionsPaths(typesVersions);
                        var versionPaths = versionResult && versionResult.paths;
                        var rest = absolutePath.slice(ts.ensureTrailingDirectorySeparator(baseDirectory).length);
                        if (versionPaths) {
                            addCompletionEntriesFromPaths(result, rest, baseDirectory, extensions, versionPaths, host);
                        }
                    }
                }
                return result;
            }
            function addCompletionEntriesFromPaths(result, fragment, baseDirectory, fileExtensions, paths, host) {
                for (var path in paths) {
                    if (!ts.hasProperty(paths, path))
                        continue;
                    var patterns = paths[path];
                    if (patterns) {
                        var _loop_2 = function (name, kind, extension) {
                            // Path mappings may provide a duplicate way to get to something we've already added, so don't add again.
                            if (!result.some(function (entry) { return entry.name === name; })) {
                                result.push(nameAndKind(name, kind, extension));
                            }
                        };
                        for (var _i = 0, _a = getCompletionsForPathMapping(path, patterns, fragment, baseDirectory, fileExtensions, host); _i < _a.length; _i++) {
                            var _b = _a[_i], name = _b.name, kind = _b.kind, extension = _b.extension;
                            _loop_2(name, kind, extension);
                        }
                    }
                }
            }
            /**
             * Check all of the declared modules and those in node modules. Possible sources of modules:
             *      Modules that are found by the type checker
             *      Modules found relative to "baseUrl" compliler options (including patterns from "paths" compiler option)
             *      Modules from node_modules (i.e. those listed in package.json)
             *          This includes all files that are found in node_modules/moduleName/ with acceptable file extensions
             */
            function getCompletionEntriesForNonRelativeModules(fragment, scriptPath, compilerOptions, host, typeChecker) {
                var baseUrl = compilerOptions.baseUrl, paths = compilerOptions.paths;
                var result = [];
                var extensionOptions = getExtensionOptions(compilerOptions);
                if (baseUrl) {
                    var projectDir = compilerOptions.project || host.getCurrentDirectory();
                    var absolute = ts.normalizePath(ts.combinePaths(projectDir, baseUrl));
                    getCompletionEntriesForDirectoryFragment(fragment, absolute, extensionOptions, host, /*exclude*/ undefined, result);
                    if (paths) {
                        addCompletionEntriesFromPaths(result, fragment, absolute, extensionOptions.extensions, paths, host);
                    }
                }
                var fragmentDirectory = getFragmentDirectory(fragment);
                for (var _i = 0, _a = getAmbientModuleCompletions(fragment, fragmentDirectory, typeChecker); _i < _a.length; _i++) {
                    var ambientName = _a[_i];
                    result.push(nameAndKind(ambientName, "external module name" /* externalModuleName */, /*extension*/ undefined));
                }
                getCompletionEntriesFromTypings(host, compilerOptions, scriptPath, fragmentDirectory, extensionOptions, result);
                if (ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeJs) {
                    // If looking for a global package name, don't just include everything in `node_modules` because that includes dependencies' own dependencies.
                    // (But do if we didn't find anything, e.g. 'package.json' missing.)
                    var foundGlobal = false;
                    if (fragmentDirectory === undefined) {
                        var _loop_3 = function (moduleName) {
                            if (!result.some(function (entry) { return entry.name === moduleName; })) {
                                foundGlobal = true;
                                result.push(nameAndKind(moduleName, "external module name" /* externalModuleName */, /*extension*/ undefined));
                            }
                        };
                        for (var _b = 0, _c = enumerateNodeModulesVisibleToScript(host, scriptPath); _b < _c.length; _b++) {
                            var moduleName = _c[_b];
                            _loop_3(moduleName);
                        }
                    }
                    if (!foundGlobal) {
                        ts.forEachAncestorDirectory(scriptPath, function (ancestor) {
                            var nodeModules = ts.combinePaths(ancestor, "node_modules");
                            if (ts.tryDirectoryExists(host, nodeModules)) {
                                getCompletionEntriesForDirectoryFragment(fragment, nodeModules, extensionOptions, host, /*exclude*/ undefined, result);
                            }
                        });
                    }
                }
                return result;
            }
            function getFragmentDirectory(fragment) {
                return containsSlash(fragment) ? ts.hasTrailingDirectorySeparator(fragment) ? fragment : ts.getDirectoryPath(fragment) : undefined;
            }
            function getCompletionsForPathMapping(path, patterns, fragment, baseUrl, fileExtensions, host) {
                if (!ts.endsWith(path, "*")) {
                    // For a path mapping "foo": ["/x/y/z.ts"], add "foo" itself as a completion.
                    return !ts.stringContains(path, "*") ? justPathMappingName(path) : ts.emptyArray;
                }
                var pathPrefix = path.slice(0, path.length - 1);
                var remainingFragment = ts.tryRemovePrefix(fragment, pathPrefix);
                return remainingFragment === undefined ? justPathMappingName(pathPrefix) : ts.flatMap(patterns, function (pattern) {
                    return getModulesForPathsPattern(remainingFragment, baseUrl, pattern, fileExtensions, host);
                });
                function justPathMappingName(name) {
                    return ts.startsWith(name, fragment) ? [directoryResult(name)] : ts.emptyArray;
                }
            }
            function getModulesForPathsPattern(fragment, baseUrl, pattern, fileExtensions, host) {
                if (!host.readDirectory) {
                    return undefined;
                }
                var parsed = ts.tryParsePattern(pattern);
                if (parsed === undefined || ts.isString(parsed)) {
                    return undefined;
                }
                // The prefix has two effective parts: the directory path and the base component after the filepath that is not a
                // full directory component. For example: directory/path/of/prefix/base*
                var normalizedPrefix = ts.resolvePath(parsed.prefix);
                var normalizedPrefixDirectory = ts.hasTrailingDirectorySeparator(parsed.prefix) ? normalizedPrefix : ts.getDirectoryPath(normalizedPrefix);
                var normalizedPrefixBase = ts.hasTrailingDirectorySeparator(parsed.prefix) ? "" : ts.getBaseFileName(normalizedPrefix);
                var fragmentHasPath = containsSlash(fragment);
                var fragmentDirectory = fragmentHasPath ? ts.hasTrailingDirectorySeparator(fragment) ? fragment : ts.getDirectoryPath(fragment) : undefined;
                // Try and expand the prefix to include any path from the fragment so that we can limit the readDirectory call
                var expandedPrefixDirectory = fragmentHasPath ? ts.combinePaths(normalizedPrefixDirectory, normalizedPrefixBase + fragmentDirectory) : normalizedPrefixDirectory;
                var normalizedSuffix = ts.normalizePath(parsed.suffix);
                // Need to normalize after combining: If we combinePaths("a", "../b"), we want "b" and not "a/../b".
                var baseDirectory = ts.normalizePath(ts.combinePaths(baseUrl, expandedPrefixDirectory));
                var completePrefix = fragmentHasPath ? baseDirectory : ts.ensureTrailingDirectorySeparator(baseDirectory) + normalizedPrefixBase;
                // If we have a suffix, then we need to read the directory all the way down. We could create a glob
                // that encodes the suffix, but we would have to escape the character "?" which readDirectory
                // doesn't support. For now, this is safer but slower
                var includeGlob = normalizedSuffix ? "**/*" : "./*";
                var matches = ts.mapDefined(ts.tryReadDirectory(host, baseDirectory, fileExtensions, /*exclude*/ undefined, [includeGlob]), function (match) {
                    var extension = ts.tryGetExtensionFromPath(match);
                    var name = trimPrefixAndSuffix(match);
                    return name === undefined ? undefined : nameAndKind(ts.removeFileExtension(name), "script" /* scriptElement */, extension);
                });
                var directories = ts.mapDefined(ts.tryGetDirectories(host, baseDirectory).map(function (d) { return ts.combinePaths(baseDirectory, d); }), function (dir) {
                    var name = trimPrefixAndSuffix(dir);
                    return name === undefined ? undefined : directoryResult(name);
                });
                return __spreadArray(__spreadArray([], matches, true), directories, true);
                function trimPrefixAndSuffix(path) {
                    var inner = withoutStartAndEnd(ts.normalizePath(path), completePrefix, normalizedSuffix);
                    return inner === undefined ? undefined : removeLeadingDirectorySeparator(inner);
                }
            }
            function withoutStartAndEnd(s, start, end) {
                return ts.startsWith(s, start) && ts.endsWith(s, end) ? s.slice(start.length, s.length - end.length) : undefined;
            }
            function removeLeadingDirectorySeparator(path) {
                return path[0] === ts.directorySeparator ? path.slice(1) : path;
            }
            function getAmbientModuleCompletions(fragment, fragmentDirectory, checker) {
                // Get modules that the type checker picked up
                var ambientModules = checker.getAmbientModules().map(function (sym) { return ts.stripQuotes(sym.name); });
                var nonRelativeModuleNames = ambientModules.filter(function (moduleName) { return ts.startsWith(moduleName, fragment); });
                // Nested modules of the form "module-name/sub" need to be adjusted to only return the string
                // after the last '/' that appears in the fragment because that's where the replacement span
                // starts
                if (fragmentDirectory !== undefined) {
                    var moduleNameWithSeparator_1 = ts.ensureTrailingDirectorySeparator(fragmentDirectory);
                    return nonRelativeModuleNames.map(function (nonRelativeModuleName) { return ts.removePrefix(nonRelativeModuleName, moduleNameWithSeparator_1); });
                }
                return nonRelativeModuleNames;
            }
            function getTripleSlashReferenceCompletion(sourceFile, position, compilerOptions, host) {
                var token = ts.getTokenAtPosition(sourceFile, position);
                var commentRanges = ts.getLeadingCommentRanges(sourceFile.text, token.pos);
                var range = commentRanges && ts.find(commentRanges, function (commentRange) { return position >= commentRange.pos && position <= commentRange.end; });
                if (!range) {
                    return undefined;
                }
                var text = sourceFile.text.slice(range.pos, position);
                var match = tripleSlashDirectiveFragmentRegex.exec(text);
                if (!match) {
                    return undefined;
                }
                var prefix = match[1], kind = match[2], toComplete = match[3];
                var scriptPath = ts.getDirectoryPath(sourceFile.path);
                var names = kind === "path" ? getCompletionEntriesForDirectoryFragment(toComplete, scriptPath, getExtensionOptions(compilerOptions, 1 /* Include */), host, sourceFile.path)
                    : kind === "types" ? getCompletionEntriesFromTypings(host, compilerOptions, scriptPath, getFragmentDirectory(toComplete), getExtensionOptions(compilerOptions))
                        : ts.Debug.fail();
                return addReplacementSpans(toComplete, range.pos + prefix.length, names);
            }
            function getCompletionEntriesFromTypings(host, options, scriptPath, fragmentDirectory, extensionOptions, result) {
                if (result === void 0) { result = []; }
                // Check for typings specified in compiler options
                var seen = new ts.Map();
                var typeRoots = ts.tryAndIgnoreErrors(function () { return ts.getEffectiveTypeRoots(options, host); }) || ts.emptyArray;
                for (var _i = 0, typeRoots_1 = typeRoots; _i < typeRoots_1.length; _i++) {
                    var root = typeRoots_1[_i];
                    getCompletionEntriesFromDirectories(root);
                }
                // Also get all @types typings installed in visible node_modules directories
                for (var _a = 0, _b = ts.findPackageJsons(scriptPath, host); _a < _b.length; _a++) {
                    var packageJson = _b[_a];
                    var typesDir = ts.combinePaths(ts.getDirectoryPath(packageJson), "node_modules/@types");
                    getCompletionEntriesFromDirectories(typesDir);
                }
                return result;
                function getCompletionEntriesFromDirectories(directory) {
                    if (!ts.tryDirectoryExists(host, directory))
                        return;
                    for (var _i = 0, _a = ts.tryGetDirectories(host, directory); _i < _a.length; _i++) {
                        var typeDirectoryName = _a[_i];
                        var packageName = ts.unmangleScopedPackageName(typeDirectoryName);
                        if (options.types && !ts.contains(options.types, packageName))
                            continue;
                        if (fragmentDirectory === undefined) {
                            if (!seen.has(packageName)) {
                                result.push(nameAndKind(packageName, "external module name" /* externalModuleName */, /*extension*/ undefined));
                                seen.set(packageName, true);
                            }
                        }
                        else {
                            var baseDirectory = ts.combinePaths(directory, typeDirectoryName);
                            var remainingFragment = ts.tryRemoveDirectoryPrefix(fragmentDirectory, packageName, ts.hostGetCanonicalFileName(host));
                            if (remainingFragment !== undefined) {
                                getCompletionEntriesForDirectoryFragment(remainingFragment, baseDirectory, extensionOptions, host, /*exclude*/ undefined, result);
                            }
                        }
                    }
                }
            }
            function enumerateNodeModulesVisibleToScript(host, scriptPath) {
                if (!host.readFile || !host.fileExists)
                    return ts.emptyArray;
                var result = [];
                for (var _i = 0, _a = ts.findPackageJsons(scriptPath, host); _i < _a.length; _i++) {
                    var packageJson = _a[_i];
                    var contents = ts.readJson(packageJson, host); // Cast to assert that readFile is defined
                    // Provide completions for all non @types dependencies
                    for (var _b = 0, nodeModulesDependencyKeys_1 = nodeModulesDependencyKeys; _b < nodeModulesDependencyKeys_1.length; _b++) {
                        var key = nodeModulesDependencyKeys_1[_b];
                        var dependencies = contents[key];
                        if (!dependencies)
                            continue;
                        for (var dep in dependencies) {
                            if (dependencies.hasOwnProperty(dep) && !ts.startsWith(dep, "@types/")) {
                                result.push(dep);
                            }
                        }
                    }
                }
                return result;
            }
            // Replace everything after the last directory separator that appears
            function getDirectoryFragmentTextSpan(text, textStart) {
                var index = Math.max(text.lastIndexOf(ts.directorySeparator), text.lastIndexOf(ts.altDirectorySeparator));
                var offset = index !== -1 ? index + 1 : 0;
                // If the range is an identifier, span is unnecessary.
                var length = text.length - offset;
                return length === 0 || ts.isIdentifierText(text.substr(offset, length), 99 /* ESNext */) ? undefined : ts.createTextSpan(textStart + offset, length);
            }
            // Returns true if the path is explicitly relative to the script (i.e. relative to . or ..)
            function isPathRelativeToScript(path) {
                if (path && path.length >= 2 && path.charCodeAt(0) === 46 /* dot */) {
                    var slashIndex = path.length >= 3 && path.charCodeAt(1) === 46 /* dot */ ? 2 : 1;
                    var slashCharCode = path.charCodeAt(slashIndex);
                    return slashCharCode === 47 /* slash */ || slashCharCode === 92 /* backslash */;
                }
                return false;
            }
            /**
             * Matches a triple slash reference directive with an incomplete string literal for its path. Used
             * to determine if the caret is currently within the string literal and capture the literal fragment
             * for completions.
             * For example, this matches
             *
             * /// <reference path="fragment
             *
             * but not
             *
             * /// <reference path="fragment"
             */
            var tripleSlashDirectiveFragmentRegex = /^(\/\/\/\s*<reference\s+(path|types)\s*=\s*(?:'|"))([^\3"]*)$/;
            var nodeModulesDependencyKeys = ["dependencies", "devDependencies", "peerDependencies", "optionalDependencies"];
            function containsSlash(fragment) {
                return ts.stringContains(fragment, ts.directorySeparator);
            }
            /**
             * Matches
             *   require(""
             *   require("")
             */
            function isRequireCallArgument(node) {
                return ts.isCallExpression(node.parent) && ts.firstOrUndefined(node.parent.arguments) === node
                    && ts.isIdentifier(node.parent.expression) && node.parent.expression.escapedText === "require";
            }
        })(StringCompletions = Completions.StringCompletions || (Completions.StringCompletions = {}));
    })(Completions = ts.Completions || (ts.Completions = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var Completions;
    (function (Completions) {
        // Exported only for tests
        Completions.moduleSpecifierResolutionLimit = 100;
        Completions.moduleSpecifierResolutionCacheAttemptLimit = 1000;
        // NOTE: Make sure that each entry has the exact same number of digits
        //       since many implementations will sort by string contents,
        //       where "10" is considered less than "2".
        var SortText;
        (function (SortText) {
            SortText["LocalDeclarationPriority"] = "10";
            SortText["LocationPriority"] = "11";
            SortText["OptionalMember"] = "12";
            SortText["MemberDeclaredBySpreadAssignment"] = "13";
            SortText["SuggestedClassMembers"] = "14";
            SortText["GlobalsOrKeywords"] = "15";
            SortText["AutoImportSuggestions"] = "16";
            SortText["JavascriptIdentifiers"] = "17";
            SortText["DeprecatedLocalDeclarationPriority"] = "18";
            SortText["DeprecatedLocationPriority"] = "19";
            SortText["DeprecatedOptionalMember"] = "20";
            SortText["DeprecatedMemberDeclaredBySpreadAssignment"] = "21";
            SortText["DeprecatedSuggestedClassMembers"] = "22";
            SortText["DeprecatedGlobalsOrKeywords"] = "23";
            SortText["DeprecatedAutoImportSuggestions"] = "24";
        })(SortText = Completions.SortText || (Completions.SortText = {}));
        var SortTextId;
        (function (SortTextId) {
            SortTextId[SortTextId["LocalDeclarationPriority"] = 10] = "LocalDeclarationPriority";
            SortTextId[SortTextId["LocationPriority"] = 11] = "LocationPriority";
            SortTextId[SortTextId["OptionalMember"] = 12] = "OptionalMember";
            SortTextId[SortTextId["MemberDeclaredBySpreadAssignment"] = 13] = "MemberDeclaredBySpreadAssignment";
            SortTextId[SortTextId["SuggestedClassMembers"] = 14] = "SuggestedClassMembers";
            SortTextId[SortTextId["GlobalsOrKeywords"] = 15] = "GlobalsOrKeywords";
            SortTextId[SortTextId["AutoImportSuggestions"] = 16] = "AutoImportSuggestions";
            // Don't use these directly.
            SortTextId[SortTextId["_JavaScriptIdentifiers"] = 17] = "_JavaScriptIdentifiers";
            SortTextId[SortTextId["_DeprecatedStart"] = 18] = "_DeprecatedStart";
            SortTextId[SortTextId["_First"] = 10] = "_First";
            SortTextId[SortTextId["DeprecatedOffset"] = 8] = "DeprecatedOffset";
        })(SortTextId || (SortTextId = {}));
        /**
         * Special values for `CompletionInfo['source']` used to disambiguate
         * completion items with the same `name`. (Each completion item must
         * have a unique name/source combination, because those two fields
         * comprise `CompletionEntryIdentifier` in `getCompletionEntryDetails`.
         *
         * When the completion item is an auto-import suggestion, the source
         * is the module specifier of the suggestion. To avoid collisions,
         * the values here should not be a module specifier we would ever
         * generate for an auto-import.
         */
        var CompletionSource;
        (function (CompletionSource) {
            /** Completions that require `this.` insertion text */
            CompletionSource["ThisProperty"] = "ThisProperty/";
        })(CompletionSource = Completions.CompletionSource || (Completions.CompletionSource = {}));
        var SymbolOriginInfoKind;
        (function (SymbolOriginInfoKind) {
            SymbolOriginInfoKind[SymbolOriginInfoKind["ThisType"] = 1] = "ThisType";
            SymbolOriginInfoKind[SymbolOriginInfoKind["SymbolMember"] = 2] = "SymbolMember";
            SymbolOriginInfoKind[SymbolOriginInfoKind["Export"] = 4] = "Export";
            SymbolOriginInfoKind[SymbolOriginInfoKind["Promise"] = 8] = "Promise";
            SymbolOriginInfoKind[SymbolOriginInfoKind["Nullable"] = 16] = "Nullable";
            SymbolOriginInfoKind[SymbolOriginInfoKind["ResolvedExport"] = 32] = "ResolvedExport";
            SymbolOriginInfoKind[SymbolOriginInfoKind["SymbolMemberNoExport"] = 2] = "SymbolMemberNoExport";
            SymbolOriginInfoKind[SymbolOriginInfoKind["SymbolMemberExport"] = 6] = "SymbolMemberExport";
        })(SymbolOriginInfoKind || (SymbolOriginInfoKind = {}));
        function originIsThisType(origin) {
            return !!(origin.kind & 1 /* ThisType */);
        }
        function originIsSymbolMember(origin) {
            return !!(origin.kind & 2 /* SymbolMember */);
        }
        function originIsExport(origin) {
            return !!(origin && origin.kind & 4 /* Export */);
        }
        function originIsResolvedExport(origin) {
            return !!(origin && origin.kind === 32 /* ResolvedExport */);
        }
        function originIncludesSymbolName(origin) {
            return originIsExport(origin) || originIsResolvedExport(origin);
        }
        function originIsPackageJsonImport(origin) {
            return (originIsExport(origin) || originIsResolvedExport(origin)) && !!origin.isFromPackageJson;
        }
        function originIsPromise(origin) {
            return !!(origin.kind & 8 /* Promise */);
        }
        function originIsNullableMember(origin) {
            return !!(origin.kind & 16 /* Nullable */);
        }
        var KeywordCompletionFilters;
        (function (KeywordCompletionFilters) {
            KeywordCompletionFilters[KeywordCompletionFilters["None"] = 0] = "None";
            KeywordCompletionFilters[KeywordCompletionFilters["All"] = 1] = "All";
            KeywordCompletionFilters[KeywordCompletionFilters["ClassElementKeywords"] = 2] = "ClassElementKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["InterfaceElementKeywords"] = 3] = "InterfaceElementKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["ConstructorParameterKeywords"] = 4] = "ConstructorParameterKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["FunctionLikeBodyKeywords"] = 5] = "FunctionLikeBodyKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["TypeAssertionKeywords"] = 6] = "TypeAssertionKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["TypeKeywords"] = 7] = "TypeKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["Last"] = 7] = "Last";
        })(KeywordCompletionFilters || (KeywordCompletionFilters = {}));
        var GlobalsSearch;
        (function (GlobalsSearch) {
            GlobalsSearch[GlobalsSearch["Continue"] = 0] = "Continue";
            GlobalsSearch[GlobalsSearch["Success"] = 1] = "Success";
            GlobalsSearch[GlobalsSearch["Fail"] = 2] = "Fail";
        })(GlobalsSearch || (GlobalsSearch = {}));
        function resolvingModuleSpecifiers(logPrefix, host, program, sourceFile, preferences, isForImportStatementCompletion, cb) {
            var _a, _b, _c;
            var start = ts.timestamp();
            var resolutionLimitExceeded = false;
            var ambientCount = 0;
            var resolvedCount = 0;
            var resolvedFromCacheCount = 0;
            var cacheAttemptCount = 0;
            var result = cb({ tryResolve: tryResolve, resolutionLimitExceeded: function () { return resolutionLimitExceeded; } });
            var hitRateMessage = cacheAttemptCount ? " (" + (resolvedFromCacheCount / cacheAttemptCount * 100).toFixed(1) + "% hit rate)" : "";
            (_a = host.log) === null || _a === void 0 ? void 0 : _a.call(host, logPrefix + ": resolved " + resolvedCount + " module specifiers, plus " + ambientCount + " ambient and " + resolvedFromCacheCount + " from cache" + hitRateMessage);
            (_b = host.log) === null || _b === void 0 ? void 0 : _b.call(host, logPrefix + ": response is " + (resolutionLimitExceeded ? "incomplete" : "complete"));
            (_c = host.log) === null || _c === void 0 ? void 0 : _c.call(host, logPrefix + ": " + (ts.timestamp() - start));
            return result;
            function tryResolve(exportInfo, isFromAmbientModule) {
                if (isFromAmbientModule) {
                    var result_1 = ts.codefix.getModuleSpecifierForBestExportInfo(exportInfo, sourceFile, program, host, preferences);
                    if (result_1) {
                        ambientCount++;
                    }
                    return result_1;
                }
                var shouldResolveModuleSpecifier = isForImportStatementCompletion || preferences.allowIncompleteCompletions && resolvedCount < Completions.moduleSpecifierResolutionLimit;
                var shouldGetModuleSpecifierFromCache = !shouldResolveModuleSpecifier && preferences.allowIncompleteCompletions && cacheAttemptCount < Completions.moduleSpecifierResolutionCacheAttemptLimit;
                var result = (shouldResolveModuleSpecifier || shouldGetModuleSpecifierFromCache)
                    ? ts.codefix.getModuleSpecifierForBestExportInfo(exportInfo, sourceFile, program, host, preferences, shouldGetModuleSpecifierFromCache)
                    : undefined;
                if (!shouldResolveModuleSpecifier && !shouldGetModuleSpecifierFromCache || shouldGetModuleSpecifierFromCache && !result) {
                    resolutionLimitExceeded = true;
                }
                resolvedCount += (result === null || result === void 0 ? void 0 : result.computedWithoutCacheCount) || 0;
                resolvedFromCacheCount += exportInfo.length - resolvedCount;
                if (shouldGetModuleSpecifierFromCache) {
                    cacheAttemptCount++;
                }
                return result;
            }
        }
        function getCompletionsAtPosition(host, program, log, sourceFile, position, preferences, triggerCharacter, completionKind, cancellationToken) {
            var _a;
            var previousToken = getRelevantTokens(position, sourceFile).previousToken;
            if (triggerCharacter && !ts.isInString(sourceFile, position, previousToken) && !isValidTrigger(sourceFile, triggerCharacter, previousToken, position)) {
                return undefined;
            }
            if (triggerCharacter === " ") {
                // `isValidTrigger` ensures we are at `import |`
                if (preferences.includeCompletionsForImportStatements && preferences.includeCompletionsWithInsertText) {
                    return { isGlobalCompletion: true, isMemberCompletion: false, isNewIdentifierLocation: true, isIncomplete: true, entries: [] };
                }
                return undefined;
            }
            // If the request is a continuation of an earlier `isIncomplete` response,
            // we can continue it from the cached previous response.
            var typeChecker = program.getTypeChecker();
            var compilerOptions = program.getCompilerOptions();
            var incompleteCompletionsCache = preferences.allowIncompleteCompletions ? (_a = host.getIncompleteCompletionsCache) === null || _a === void 0 ? void 0 : _a.call(host) : undefined;
            if (incompleteCompletionsCache && completionKind === 3 /* TriggerForIncompleteCompletions */ && previousToken && ts.isIdentifier(previousToken)) {
                var incompleteContinuation = continuePreviousIncompleteResponse(incompleteCompletionsCache, sourceFile, previousToken, program, host, preferences, cancellationToken);
                if (incompleteContinuation) {
                    return incompleteContinuation;
                }
            }
            else {
                incompleteCompletionsCache === null || incompleteCompletionsCache === void 0 ? void 0 : incompleteCompletionsCache.clear();
            }
            var stringCompletions = Completions.StringCompletions.getStringLiteralCompletions(sourceFile, position, previousToken, typeChecker, compilerOptions, host, log, preferences);
            if (stringCompletions) {
                return stringCompletions;
            }
            if (previousToken && ts.isBreakOrContinueStatement(previousToken.parent)
                && (previousToken.kind === 81 /* BreakKeyword */ || previousToken.kind === 86 /* ContinueKeyword */ || previousToken.kind === 79 /* Identifier */)) {
                return getLabelCompletionAtPosition(previousToken.parent);
            }
            var completionData = getCompletionData(program, log, sourceFile, isUncheckedFile(sourceFile, compilerOptions), position, preferences, /*detailsEntryId*/ undefined, host, cancellationToken);
            if (!completionData) {
                return undefined;
            }
            switch (completionData.kind) {
                case 0 /* Data */:
                    var response = completionInfoFromData(sourceFile, typeChecker, compilerOptions, log, completionData, preferences);
                    if (response === null || response === void 0 ? void 0 : response.isIncomplete) {
                        incompleteCompletionsCache === null || incompleteCompletionsCache === void 0 ? void 0 : incompleteCompletionsCache.set(response);
                    }
                    return response;
                case 1 /* JsDocTagName */:
                    // If the current position is a jsDoc tag name, only tag names should be provided for completion
                    return jsdocCompletionInfo(ts.JsDoc.getJSDocTagNameCompletions());
                case 2 /* JsDocTag */:
                    // If the current position is a jsDoc tag, only tags should be provided for completion
                    return jsdocCompletionInfo(ts.JsDoc.getJSDocTagCompletions());
                case 3 /* JsDocParameterName */:
                    return jsdocCompletionInfo(ts.JsDoc.getJSDocParameterNameCompletions(completionData.tag));
                case 4 /* Keywords */:
                    return specificKeywordCompletionInfo(completionData.keywords);
                default:
                    return ts.Debug.assertNever(completionData);
            }
        }
        Completions.getCompletionsAtPosition = getCompletionsAtPosition;
        function continuePreviousIncompleteResponse(cache, file, location, program, host, preferences, cancellationToken) {
            var _a;
            var previousResponse = cache.get();
            if (!previousResponse)
                return undefined;
            var lowerCaseTokenText = location.text.toLowerCase();
            var exportMap = ts.getExportInfoMap(file, host, program, cancellationToken);
            var checker = program.getTypeChecker();
            var autoImportProvider = (_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host);
            var autoImportProviderChecker = autoImportProvider === null || autoImportProvider === void 0 ? void 0 : autoImportProvider.getTypeChecker();
            var newEntries = resolvingModuleSpecifiers("continuePreviousIncompleteResponse", host, program, file, preferences, 
            /*isForImportStatementCompletion*/ false, function (context) {
                var entries = ts.mapDefined(previousResponse.entries, function (entry) {
                    if (!entry.hasAction || !entry.source || !entry.data || entry.data.moduleSpecifier) {
                        // Not an auto import or already resolved; keep as is
                        return entry;
                    }
                    if (!charactersFuzzyMatchInString(entry.name, lowerCaseTokenText)) {
                        // No longer matches typed characters; filter out
                        return undefined;
                    }
                    var _a = ts.Debug.checkDefined(getAutoImportSymbolFromCompletionEntryData(entry.name, entry.data, program, host)), symbol = _a.symbol, origin = _a.origin;
                    var info = exportMap.get(file.path, entry.name, symbol, origin.moduleSymbol.name, origin.isFromPackageJson ? autoImportProviderChecker : checker);
                    var result = info && context.tryResolve(info, !ts.isExternalModuleNameRelative(ts.stripQuotes(origin.moduleSymbol.name)));
                    if (!result)
                        return entry;
                    var newOrigin = __assign(__assign({}, origin), { kind: 32 /* ResolvedExport */, moduleSpecifier: result.moduleSpecifier });
                    // Mutating for performance... feels sketchy but nobody else uses the cache,
                    // so why bother allocating a bunch of new objects?
                    entry.data = originToCompletionEntryData(newOrigin);
                    entry.source = getSourceFromOrigin(newOrigin);
                    entry.sourceDisplay = [ts.textPart(newOrigin.moduleSpecifier)];
                    return entry;
                });
                if (!context.resolutionLimitExceeded()) {
                    previousResponse.isIncomplete = undefined;
                }
                return entries;
            });
            previousResponse.entries = newEntries;
            return previousResponse;
        }
        function jsdocCompletionInfo(entries) {
            return { isGlobalCompletion: false, isMemberCompletion: false, isNewIdentifierLocation: false, entries: entries };
        }
        function specificKeywordCompletionInfo(keywords) {
            return {
                isGlobalCompletion: false,
                isMemberCompletion: false,
                isNewIdentifierLocation: false,
                entries: keywords.map(function (k) { return ({
                    name: ts.tokenToString(k),
                    kind: "keyword" /* keyword */,
                    kindModifiers: "" /* none */,
                    sortText: SortText.GlobalsOrKeywords,
                }); }),
            };
        }
        function getOptionalReplacementSpan(location) {
            // StringLiteralLike locations are handled separately in stringCompletions.ts
            return (location === null || location === void 0 ? void 0 : location.kind) === 79 /* Identifier */ ? ts.createTextSpanFromNode(location) : undefined;
        }
        function completionInfoFromData(sourceFile, typeChecker, compilerOptions, log, completionData, preferences) {
            var symbols = completionData.symbols, completionKind = completionData.completionKind, isInSnippetScope = completionData.isInSnippetScope, isNewIdentifierLocation = completionData.isNewIdentifierLocation, location = completionData.location, propertyAccessToConvert = completionData.propertyAccessToConvert, keywordFilters = completionData.keywordFilters, literals = completionData.literals, symbolToOriginInfoMap = completionData.symbolToOriginInfoMap, recommendedCompletion = completionData.recommendedCompletion, isJsxInitializer = completionData.isJsxInitializer, isTypeOnlyLocation = completionData.isTypeOnlyLocation, isJsxIdentifierExpected = completionData.isJsxIdentifierExpected, importCompletionNode = completionData.importCompletionNode, insideJsDocTagTypeExpression = completionData.insideJsDocTagTypeExpression, symbolToSortTextIdMap = completionData.symbolToSortTextIdMap, hasUnresolvedAutoImports = completionData.hasUnresolvedAutoImports;
            // Verify if the file is JSX language variant
            if (ts.getLanguageVariant(sourceFile.scriptKind) === 1 /* JSX */) {
                var completionInfo = getJsxClosingTagCompletion(location, sourceFile);
                if (completionInfo) {
                    return completionInfo;
                }
            }
            var entries = [];
            if (isUncheckedFile(sourceFile, compilerOptions)) {
                var uniqueNames = getCompletionEntriesFromSymbols(symbols, entries, 
                /* contextToken */ undefined, location, sourceFile, typeChecker, compilerOptions.target, log, completionKind, preferences, compilerOptions, isTypeOnlyLocation, propertyAccessToConvert, isJsxIdentifierExpected, isJsxInitializer, importCompletionNode, recommendedCompletion, symbolToOriginInfoMap, symbolToSortTextIdMap);
                getJSCompletionEntries(sourceFile, location.pos, uniqueNames, compilerOptions.target, entries); // TODO: GH#18217
            }
            else {
                if (!isNewIdentifierLocation && (!symbols || symbols.length === 0) && keywordFilters === 0 /* None */) {
                    return undefined;
                }
                getCompletionEntriesFromSymbols(symbols, entries, 
                /* contextToken */ undefined, location, sourceFile, typeChecker, compilerOptions.target, log, completionKind, preferences, compilerOptions, isTypeOnlyLocation, propertyAccessToConvert, isJsxIdentifierExpected, isJsxInitializer, importCompletionNode, recommendedCompletion, symbolToOriginInfoMap, symbolToSortTextIdMap);
            }
            if (keywordFilters !== 0 /* None */) {
                var entryNames = new ts.Set(entries.map(function (e) { return e.name; }));
                for (var _i = 0, _a = getKeywordCompletions(keywordFilters, !insideJsDocTagTypeExpression && ts.isSourceFileJS(sourceFile)); _i < _a.length; _i++) {
                    var keywordEntry = _a[_i];
                    if (!entryNames.has(keywordEntry.name)) {
                        entries.push(keywordEntry);
                    }
                }
            }
            for (var _b = 0, literals_1 = literals; _b < literals_1.length; _b++) {
                var literal = literals_1[_b];
                entries.push(createCompletionEntryForLiteral(sourceFile, preferences, literal));
            }
            return {
                isGlobalCompletion: isInSnippetScope,
                isIncomplete: preferences.allowIncompleteCompletions && hasUnresolvedAutoImports ? true : undefined,
                isMemberCompletion: isMemberCompletionKind(completionKind),
                isNewIdentifierLocation: isNewIdentifierLocation,
                optionalReplacementSpan: getOptionalReplacementSpan(location),
                entries: entries
            };
        }
        function isUncheckedFile(sourceFile, compilerOptions) {
            return ts.isSourceFileJS(sourceFile) && !ts.isCheckJsEnabledForFile(sourceFile, compilerOptions);
        }
        function isMemberCompletionKind(kind) {
            switch (kind) {
                case 0 /* ObjectPropertyDeclaration */:
                case 3 /* MemberLike */:
                case 2 /* PropertyAccess */:
                    return true;
                default:
                    return false;
            }
        }
        function getJsxClosingTagCompletion(location, sourceFile) {
            // We wanna walk up the tree till we find a JSX closing element
            var jsxClosingElement = ts.findAncestor(location, function (node) {
                switch (node.kind) {
                    case 279 /* JsxClosingElement */:
                        return true;
                    case 43 /* SlashToken */:
                    case 31 /* GreaterThanToken */:
                    case 79 /* Identifier */:
                    case 204 /* PropertyAccessExpression */:
                        return false;
                    default:
                        return "quit";
                }
            });
            if (jsxClosingElement) {
                // In the TypeScript JSX element, if such element is not defined. When users query for completion at closing tag,
                // instead of simply giving unknown value, the completion will return the tag-name of an associated opening-element.
                // For example:
                //     var x = <div> </ /*1*/
                // The completion list at "1" will contain "div>" with type any
                // And at `<div> </ /*1*/ >` (with a closing `>`), the completion list will contain "div".
                // And at property access expressions `<MainComponent.Child> </MainComponent. /*1*/ >` the completion will
                // return full closing tag with an optional replacement span
                // For example:
                //     var x = <MainComponent.Child> </     MainComponent /*1*/  >
                //     var y = <MainComponent.Child> </   /*2*/   MainComponent >
                // the completion list at "1" and "2" will contain "MainComponent.Child" with a replacement span of closing tag name
                var hasClosingAngleBracket = !!ts.findChildOfKind(jsxClosingElement, 31 /* GreaterThanToken */, sourceFile);
                var tagName = jsxClosingElement.parent.openingElement.tagName;
                var closingTag = tagName.getText(sourceFile);
                var fullClosingTag = closingTag + (hasClosingAngleBracket ? "" : ">");
                var replacementSpan = ts.createTextSpanFromNode(jsxClosingElement.tagName);
                var entry = {
                    name: fullClosingTag,
                    kind: "class" /* classElement */,
                    kindModifiers: undefined,
                    sortText: SortText.LocationPriority,
                };
                return { isGlobalCompletion: false, isMemberCompletion: true, isNewIdentifierLocation: false, optionalReplacementSpan: replacementSpan, entries: [entry] };
            }
            return;
        }
        function getJSCompletionEntries(sourceFile, position, uniqueNames, target, entries) {
            ts.getNameTable(sourceFile).forEach(function (pos, name) {
                // Skip identifiers produced only from the current location
                if (pos === position) {
                    return;
                }
                var realName = ts.unescapeLeadingUnderscores(name);
                if (!uniqueNames.has(realName) && ts.isIdentifierText(realName, target)) {
                    uniqueNames.add(realName);
                    entries.push({
                        name: realName,
                        kind: "warning" /* warning */,
                        kindModifiers: "",
                        sortText: SortText.JavascriptIdentifiers,
                        isFromUncheckedFile: true
                    });
                }
            });
        }
        function completionNameForLiteral(sourceFile, preferences, literal) {
            return typeof literal === "object" ? ts.pseudoBigIntToString(literal) + "n" :
                ts.isString(literal) ? ts.quote(sourceFile, preferences, literal) : JSON.stringify(literal);
        }
        function createCompletionEntryForLiteral(sourceFile, preferences, literal) {
            return { name: completionNameForLiteral(sourceFile, preferences, literal), kind: "string" /* string */, kindModifiers: "" /* none */, sortText: SortText.LocationPriority };
        }
        function createCompletionEntry(symbol, sortText, contextToken, location, sourceFile, typeChecker, name, needsConvertPropertyAccess, origin, recommendedCompletion, propertyAccessToConvert, isJsxInitializer, importCompletionNode, useSemicolons, options, preferences) {
            var _a;
            var insertText;
            var replacementSpan = ts.getReplacementSpanForContextToken(contextToken);
            var data;
            var isSnippet;
            var sourceDisplay;
            var hasAction;
            var insertQuestionDot = origin && originIsNullableMember(origin);
            var useBraces = origin && originIsSymbolMember(origin) || needsConvertPropertyAccess;
            if (origin && originIsThisType(origin)) {
                insertText = needsConvertPropertyAccess
                    ? "this" + (insertQuestionDot ? "?." : "") + "[" + quotePropertyName(sourceFile, preferences, name) + "]"
                    : "this" + (insertQuestionDot ? "?." : ".") + name;
            }
            // We should only have needsConvertPropertyAccess if there's a property access to convert. But see #21790.
            // Somehow there was a global with a non-identifier name. Hopefully someone will complain about getting a "foo bar" global completion and provide a repro.
            else if ((useBraces || insertQuestionDot) && propertyAccessToConvert) {
                insertText = useBraces ? needsConvertPropertyAccess ? "[" + quotePropertyName(sourceFile, preferences, name) + "]" : "[" + name + "]" : name;
                if (insertQuestionDot || propertyAccessToConvert.questionDotToken) {
                    insertText = "?." + insertText;
                }
                var dot = ts.findChildOfKind(propertyAccessToConvert, 24 /* DotToken */, sourceFile) ||
                    ts.findChildOfKind(propertyAccessToConvert, 28 /* QuestionDotToken */, sourceFile);
                if (!dot) {
                    return undefined;
                }
                // If the text after the '.' starts with this name, write over it. Else, add new text.
                var end = ts.startsWith(name, propertyAccessToConvert.name.text) ? propertyAccessToConvert.name.end : dot.end;
                replacementSpan = ts.createTextSpanFromBounds(dot.getStart(sourceFile), end);
            }
            if (isJsxInitializer) {
                if (insertText === undefined)
                    insertText = name;
                insertText = "{" + insertText + "}";
                if (typeof isJsxInitializer !== "boolean") {
                    replacementSpan = ts.createTextSpanFromNode(isJsxInitializer, sourceFile);
                }
            }
            if (origin && originIsPromise(origin) && propertyAccessToConvert) {
                if (insertText === undefined)
                    insertText = name;
                var precedingToken = ts.findPrecedingToken(propertyAccessToConvert.pos, sourceFile);
                var awaitText = "";
                if (precedingToken && ts.positionIsASICandidate(precedingToken.end, precedingToken.parent, sourceFile)) {
                    awaitText = ";";
                }
                awaitText += "(await " + propertyAccessToConvert.expression.getText() + ")";
                insertText = needsConvertPropertyAccess ? "" + awaitText + insertText : "" + awaitText + (insertQuestionDot ? "?." : ".") + insertText;
                replacementSpan = ts.createTextSpanFromBounds(propertyAccessToConvert.getStart(sourceFile), propertyAccessToConvert.end);
            }
            if (originIsResolvedExport(origin)) {
                sourceDisplay = [ts.textPart(origin.moduleSpecifier)];
                if (importCompletionNode) {
                    (_a = getInsertTextAndReplacementSpanForImportCompletion(name, importCompletionNode, origin, useSemicolons, options, preferences), insertText = _a.insertText, replacementSpan = _a.replacementSpan);
                    isSnippet = preferences.includeCompletionsWithSnippetText ? true : undefined;
                }
            }
            if (insertText !== undefined && !preferences.includeCompletionsWithInsertText) {
                return undefined;
            }
            if (originIsExport(origin) || originIsResolvedExport(origin)) {
                data = originToCompletionEntryData(origin);
                hasAction = !importCompletionNode;
            }
            // TODO(drosen): Right now we just permit *all* semantic meanings when calling
            // 'getSymbolKind' which is permissible given that it is backwards compatible; but
            // really we should consider passing the meaning for the node so that we don't report
            // that a suggestion for a value is an interface.  We COULD also just do what
            // 'getSymbolModifiers' does, which is to use the first declaration.
            // Use a 'sortText' of 0' so that all symbol completion entries come before any other
            // entries (like JavaScript identifier entries).
            return {
                name: name,
                kind: ts.SymbolDisplay.getSymbolKind(typeChecker, symbol, location),
                kindModifiers: ts.SymbolDisplay.getSymbolModifiers(typeChecker, symbol),
                sortText: sortText,
                source: getSourceFromOrigin(origin),
                hasAction: hasAction ? true : undefined,
                isRecommended: isRecommendedCompletionMatch(symbol, recommendedCompletion, typeChecker) || undefined,
                insertText: insertText,
                replacementSpan: replacementSpan,
                sourceDisplay: sourceDisplay,
                isSnippet: isSnippet,
                isPackageJsonImport: originIsPackageJsonImport(origin) || undefined,
                isImportStatementCompletion: !!importCompletionNode || undefined,
                data: data,
            };
        }
        function originToCompletionEntryData(origin) {
            return {
                exportName: origin.exportName,
                fileName: origin.fileName,
                ambientModuleName: origin.fileName ? undefined : ts.stripQuotes(origin.moduleSymbol.name),
                isPackageJsonImport: origin.isFromPackageJson ? true : undefined,
                moduleSpecifier: originIsResolvedExport(origin) ? origin.moduleSpecifier : undefined,
            };
        }
        function getInsertTextAndReplacementSpanForImportCompletion(name, importCompletionNode, origin, useSemicolons, options, preferences) {
            var sourceFile = importCompletionNode.getSourceFile();
            var replacementSpan = ts.createTextSpanFromNode(importCompletionNode, sourceFile);
            var quotedModuleSpecifier = ts.quote(sourceFile, preferences, origin.moduleSpecifier);
            var exportKind = origin.isDefaultExport ? 1 /* Default */ :
                origin.exportName === "export=" /* ExportEquals */ ? 2 /* ExportEquals */ :
                    0 /* Named */;
            var tabStop = preferences.includeCompletionsWithSnippetText ? "$1" : "";
            var importKind = ts.codefix.getImportKind(sourceFile, exportKind, options, /*forceImportKeyword*/ true);
            var suffix = useSemicolons ? ";" : "";
            switch (importKind) {
                case 3 /* CommonJS */: return { replacementSpan: replacementSpan, insertText: "import " + name + tabStop + " = require(" + quotedModuleSpecifier + ")" + suffix };
                case 1 /* Default */: return { replacementSpan: replacementSpan, insertText: "import " + name + tabStop + " from " + quotedModuleSpecifier + suffix };
                case 2 /* Namespace */: return { replacementSpan: replacementSpan, insertText: "import * as " + name + " from " + quotedModuleSpecifier + suffix };
                case 0 /* Named */: return { replacementSpan: replacementSpan, insertText: "import { " + name + tabStop + " } from " + quotedModuleSpecifier + suffix };
            }
        }
        function quotePropertyName(sourceFile, preferences, name) {
            if (/^\d+$/.test(name)) {
                return name;
            }
            return ts.quote(sourceFile, preferences, name);
        }
        function isRecommendedCompletionMatch(localSymbol, recommendedCompletion, checker) {
            return localSymbol === recommendedCompletion ||
                !!(localSymbol.flags & 1048576 /* ExportValue */) && checker.getExportSymbolOfSymbol(localSymbol) === recommendedCompletion;
        }
        function getSourceFromOrigin(origin) {
            if (originIsExport(origin)) {
                return ts.stripQuotes(origin.moduleSymbol.name);
            }
            if (originIsResolvedExport(origin)) {
                return origin.moduleSpecifier;
            }
            if ((origin === null || origin === void 0 ? void 0 : origin.kind) === 1 /* ThisType */) {
                return CompletionSource.ThisProperty;
            }
        }
        function getCompletionEntriesFromSymbols(symbols, entries, contextToken, location, sourceFile, typeChecker, target, log, kind, preferences, compilerOptions, isTypeOnlyLocation, propertyAccessToConvert, jsxIdentifierExpected, isJsxInitializer, importCompletionNode, recommendedCompletion, symbolToOriginInfoMap, symbolToSortTextIdMap) {
            var _a;
            var start = ts.timestamp();
            var variableDeclaration = getVariableDeclaration(location);
            var useSemicolons = ts.probablyUsesSemicolons(sourceFile);
            // Tracks unique names.
            // Value is set to false for global variables or completions from external module exports, because we can have multiple of those;
            // true otherwise. Based on the order we add things we will always see locals first, then globals, then module exports.
            // So adding a completion for a local will prevent us from adding completions for external module exports sharing the same name.
            var uniques = new ts.Map();
            for (var i = 0; i < symbols.length; i++) {
                var symbol = symbols[i];
                var origin = symbolToOriginInfoMap === null || symbolToOriginInfoMap === void 0 ? void 0 : symbolToOriginInfoMap[i];
                var info = getCompletionEntryDisplayNameForSymbol(symbol, target, origin, kind, !!jsxIdentifierExpected);
                if (!info || uniques.get(info.name) || kind === 1 /* Global */ && symbolToSortTextIdMap && !shouldIncludeSymbol(symbol, symbolToSortTextIdMap)) {
                    continue;
                }
                var name = info.name, needsConvertPropertyAccess = info.needsConvertPropertyAccess;
                var sortTextId = (_a = symbolToSortTextIdMap === null || symbolToSortTextIdMap === void 0 ? void 0 : symbolToSortTextIdMap[ts.getSymbolId(symbol)]) !== null && _a !== void 0 ? _a : 11 /* LocationPriority */;
                var sortText = (isDeprecated(symbol, typeChecker) ? 8 /* DeprecatedOffset */ + sortTextId : sortTextId).toString();
                var entry = createCompletionEntry(symbol, sortText, contextToken, location, sourceFile, typeChecker, name, needsConvertPropertyAccess, origin, recommendedCompletion, propertyAccessToConvert, isJsxInitializer, importCompletionNode, useSemicolons, compilerOptions, preferences);
                if (!entry) {
                    continue;
                }
                /** True for locals; false for globals, module exports from other files, `this.` completions. */
                var shouldShadowLaterSymbols = !origin && !(symbol.parent === undefined && !ts.some(symbol.declarations, function (d) { return d.getSourceFile() === location.getSourceFile(); }));
                uniques.set(name, shouldShadowLaterSymbols);
                entries.push(entry);
            }
            log("getCompletionsAtPosition: getCompletionEntriesFromSymbols: " + (ts.timestamp() - start));
            // Prevent consumers of this map from having to worry about
            // the boolean value. Externally, it should be seen as the
            // set of all names.
            return {
                has: function (name) { return uniques.has(name); },
                add: function (name) { return uniques.set(name, true); },
            };
            function shouldIncludeSymbol(symbol, symbolToSortTextIdMap) {
                if (!ts.isSourceFile(location)) {
                    // export = /**/ here we want to get all meanings, so any symbol is ok
                    if (ts.isExportAssignment(location.parent)) {
                        return true;
                    }
                    // Filter out variables from their own initializers
                    // `const a = /* no 'a' here */`
                    if (variableDeclaration && symbol.valueDeclaration === variableDeclaration) {
                        return false;
                    }
                    // External modules can have global export declarations that will be
                    // available as global keywords in all scopes. But if the external module
                    // already has an explicit export and user only wants to user explicit
                    // module imports then the global keywords will be filtered out so auto
                    // import suggestions will win in the completion
                    var symbolOrigin = ts.skipAlias(symbol, typeChecker);
                    // We only want to filter out the global keywords
                    // Auto Imports are not available for scripts so this conditional is always false
                    if (!!sourceFile.externalModuleIndicator
                        && !compilerOptions.allowUmdGlobalAccess
                        && symbolToSortTextIdMap[ts.getSymbolId(symbol)] === 15 /* GlobalsOrKeywords */
                        && (symbolToSortTextIdMap[ts.getSymbolId(symbolOrigin)] === 16 /* AutoImportSuggestions */
                            || symbolToSortTextIdMap[ts.getSymbolId(symbolOrigin)] === 11 /* LocationPriority */)) {
                        return false;
                    }
                    // Continue with origin symbol
                    symbol = symbolOrigin;
                    // import m = /**/ <-- It can only access namespace (if typing import = x. this would get member symbols and not namespace)
                    if (ts.isInRightSideOfInternalImportEqualsDeclaration(location)) {
                        return !!(symbol.flags & 1920 /* Namespace */);
                    }
                    if (isTypeOnlyLocation) {
                        // It's a type, but you can reach it by namespace.type as well
                        return symbolCanBeReferencedAtTypeLocation(symbol, typeChecker);
                    }
                }
                // expressions are value space (which includes the value namespaces)
                return !!(ts.getCombinedLocalAndExportSymbolFlags(symbol) & 111551 /* Value */);
            }
        }
        Completions.getCompletionEntriesFromSymbols = getCompletionEntriesFromSymbols;
        function getLabelCompletionAtPosition(node) {
            var entries = getLabelStatementCompletions(node);
            if (entries.length) {
                return { isGlobalCompletion: false, isMemberCompletion: false, isNewIdentifierLocation: false, entries: entries };
            }
        }
        function getLabelStatementCompletions(node) {
            var entries = [];
            var uniques = new ts.Map();
            var current = node;
            while (current) {
                if (ts.isFunctionLike(current)) {
                    break;
                }
                if (ts.isLabeledStatement(current)) {
                    var name = current.label.text;
                    if (!uniques.has(name)) {
                        uniques.set(name, true);
                        entries.push({
                            name: name,
                            kindModifiers: "" /* none */,
                            kind: "label" /* label */,
                            sortText: SortText.LocationPriority
                        });
                    }
                }
                current = current.parent;
            }
            return entries;
        }
        function getSymbolCompletionFromEntryId(program, log, sourceFile, position, entryId, host, preferences) {
            if (entryId.data) {
                var autoImport = getAutoImportSymbolFromCompletionEntryData(entryId.name, entryId.data, program, host);
                if (autoImport) {
                    return {
                        type: "symbol",
                        symbol: autoImport.symbol,
                        location: ts.getTouchingPropertyName(sourceFile, position),
                        previousToken: ts.findPrecedingToken(position, sourceFile, /*startNode*/ undefined),
                        isJsxInitializer: false,
                        isTypeOnlyLocation: false,
                        origin: autoImport.origin,
                    };
                }
            }
            var compilerOptions = program.getCompilerOptions();
            var completionData = getCompletionData(program, log, sourceFile, isUncheckedFile(sourceFile, compilerOptions), position, { includeCompletionsForModuleExports: true, includeCompletionsWithInsertText: true }, entryId, host);
            if (!completionData) {
                return { type: "none" };
            }
            if (completionData.kind !== 0 /* Data */) {
                return { type: "request", request: completionData };
            }
            var symbols = completionData.symbols, literals = completionData.literals, location = completionData.location, completionKind = completionData.completionKind, symbolToOriginInfoMap = completionData.symbolToOriginInfoMap, previousToken = completionData.previousToken, isJsxInitializer = completionData.isJsxInitializer, isTypeOnlyLocation = completionData.isTypeOnlyLocation;
            var literal = ts.find(literals, function (l) { return completionNameForLiteral(sourceFile, preferences, l) === entryId.name; });
            if (literal !== undefined)
                return { type: "literal", literal: literal };
            // Find the symbol with the matching entry name.
            // We don't need to perform character checks here because we're only comparing the
            // name against 'entryName' (which is known to be good), not building a new
            // completion entry.
            return ts.firstDefined(symbols, function (symbol, index) {
                var origin = symbolToOriginInfoMap[index];
                var info = getCompletionEntryDisplayNameForSymbol(symbol, compilerOptions.target, origin, completionKind, completionData.isJsxIdentifierExpected);
                return info && info.name === entryId.name && getSourceFromOrigin(origin) === entryId.source
                    ? { type: "symbol", symbol: symbol, location: location, origin: origin, previousToken: previousToken, isJsxInitializer: isJsxInitializer, isTypeOnlyLocation: isTypeOnlyLocation }
                    : undefined;
            }) || { type: "none" };
        }
        function getCompletionEntryDetails(program, log, sourceFile, position, entryId, host, formatContext, preferences, cancellationToken) {
            var typeChecker = program.getTypeChecker();
            var compilerOptions = program.getCompilerOptions();
            var name = entryId.name;
            var contextToken = ts.findPrecedingToken(position, sourceFile);
            if (ts.isInString(sourceFile, position, contextToken)) {
                return Completions.StringCompletions.getStringLiteralCompletionDetails(name, sourceFile, position, contextToken, typeChecker, compilerOptions, host, cancellationToken, preferences);
            }
            // Compute all the completion symbols again.
            var symbolCompletion = getSymbolCompletionFromEntryId(program, log, sourceFile, position, entryId, host, preferences);
            switch (symbolCompletion.type) {
                case "request": {
                    var request = symbolCompletion.request;
                    switch (request.kind) {
                        case 1 /* JsDocTagName */:
                            return ts.JsDoc.getJSDocTagNameCompletionDetails(name);
                        case 2 /* JsDocTag */:
                            return ts.JsDoc.getJSDocTagCompletionDetails(name);
                        case 3 /* JsDocParameterName */:
                            return ts.JsDoc.getJSDocParameterNameCompletionDetails(name);
                        case 4 /* Keywords */:
                            return request.keywords.indexOf(ts.stringToToken(name)) > -1 ? createSimpleDetails(name, "keyword" /* keyword */, ts.SymbolDisplayPartKind.keyword) : undefined;
                        default:
                            return ts.Debug.assertNever(request);
                    }
                }
                case "symbol": {
                    var symbol = symbolCompletion.symbol, location = symbolCompletion.location, origin = symbolCompletion.origin, previousToken = symbolCompletion.previousToken;
                    var _a = getCompletionEntryCodeActionsAndSourceDisplay(origin, symbol, program, host, compilerOptions, sourceFile, position, previousToken, formatContext, preferences, entryId.data), codeActions = _a.codeActions, sourceDisplay = _a.sourceDisplay;
                    return createCompletionDetailsForSymbol(symbol, typeChecker, sourceFile, location, cancellationToken, codeActions, sourceDisplay); // TODO: GH#18217
                }
                case "literal": {
                    var literal = symbolCompletion.literal;
                    return createSimpleDetails(completionNameForLiteral(sourceFile, preferences, literal), "string" /* string */, typeof literal === "string" ? ts.SymbolDisplayPartKind.stringLiteral : ts.