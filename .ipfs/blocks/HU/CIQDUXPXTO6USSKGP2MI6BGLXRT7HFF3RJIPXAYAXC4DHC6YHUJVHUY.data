cter_in_an_expression_container_95108": "Заключение недопустимого знака в контейнер выражений",
  "Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal_95113": "Заключить следующий текст в круглые скобки, которые должны быть литералом объекта",
  "You_cannot_rename_a_module_via_a_global_import_8031": "Вы не можете переименовать модуль с помощью глобального импорта.",
  "You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001": "Невозможно переименовать элементы, определенные в стандартной библиотеке TypeScript.",
  "You_cannot_rename_this_element_8000": "Этот элемент переименовать нельзя.",
  "_0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write__1329": "\"{0}\" принимает слишком мало аргументов для использования в качестве декоратора. Вы хотели сначала вызвать его и записать \"@{0}()\"?",
  "_0_and_1_operations_cannot_be_mixed_without_parentheses_5076": "Операции \"{0}\" и \"{1}\" невозможно использовать одновременно без скобок.",
  "_0_are_specified_twice_The_attribute_named_0_will_be_overwritten_2710": "\"{0}\" указаны дважды. Атрибут \"{0}\" будет перезаписан.",
  "_0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import_2596": "Для импорта \"{0}\" необходимо установить флаг \"esModuleInterop\" и использовать импорт по умолчанию.",
  "_0_can_only_be_imported_by_using_a_default_import_2595": "Для импорта \"{0}\" необходимо использовать импорт по умолчанию.",
  "_0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using__2598": "Для импорта \"{0}\" необходимо использовать вызов \"require\" или установить флаг \"esModuleInterop\" и использовать импорт по умолчанию.",
  "_0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import_2597": "Для импорта \"{0}\" необходимо использовать вызов \"require\" или импорт по умолчанию.",
  "_0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import_2616": "Для импорта \"{0}\" необходимо использовать \"import {1} = require({2})\" или импорт по умолчанию.",
  "_0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_us_2617": "Для импорта \"{0}\" необходимо использовать \"import {1} = require({2})\" или установить флаг \"esModuleInterop\" и использовать импорт по умолчанию.",
  "_0_cannot_be_used_as_a_JSX_component_2786": "\"{0}\" невозможно использовать как компонент JSX.",
  "_0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type_1362": "\"{0}\" невозможно использовать как значение, так как он был экспортирован с помощью \"export type\".",
  "_0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type_1361": "\"{0}\" невозможно использовать как значение, так как он был импортирован с помощью \"import type\".",
  "_0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_t_2747": "Компоненты \"{0}\" не принимают текст в виде дочерних элементов. Текст в JSX-файле имеет тип \"string\", однако для \"{1}\" ожидается тип \"{2}\".",
  "_0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1_5082": "Возможно создание экземпляра \"{0}\" с произвольным типом, который может быть не связан с \"{1}\".",
  "_0_declarations_can_only_be_used_in_TypeScript_files_8006": "Объявления \"{0}\" можно использовать только в файлах TypeScript.",
  "_0_expected_1005": "Ожидалось \"{0}\".",
  "_0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage_7050": "\"{0}\" неявно имеет тип возвращаемого значения \"{1}\", но из использования можно определить более подходящий тип.",
  "_0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_reference_7023": "\"{0}\" неявно имеет тип возвращаемого значения any, так как у него нет заметки с типом возвращаемого значения, а также на него прямо или косвенно указана ссылка в одном из его выражений return.",
  "_0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or__7022": "\"{0}\" неявно имеет тип any, так как отсутствует аннотация типа и на \"{0}\" есть прямые или непрямые ссылки в его собственном инициализаторе.",
  "_0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible_2692": "\"{0}\" является примитивом, но \"{1}\" — объект оболочки. Предпочтительно использовать \"{0}\" по мере возможности.",
  "_0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_5075": "\"{0}\" может быть назначен ограничению типа \"{1}\", но можно создать экземпляр \"{1}\" с другим подтипом ограничения \"{2}\".",
  "_0_is_declared_but_its_value_is_never_read_6133": "Свойство \"{0}\" объявлено, но его значение не было прочитано.",
  "_0_is_declared_but_never_used_6196": "\"{0}\" объявлен, но никогда не использовался.",
  "_0_is_declared_here_2728": "Здесь объявлен \"{0}\".",
  "_0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor_2611": "\"{0}\" определен как свойство в классе \"{1}\", но переопределяется здесь в \"{2}\" как метод доступа.",
  "_0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property_2610": "\"{0}\" определен как метод доступа в классе \"{1}\", но переопределяется здесь в \"{2}\" как свойство экземпляра.",
  "_0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2_17012": "\"{0}\" не является допустимым метасвойством для ключевого слова \"{1}\". Вы имели в виду \"{2}\"?",
  "_0_is_referenced_directly_or_indirectly_in_its_own_base_expression_2506": "На \"{0}\" есть прямые или непрямые ссылки в его собственном базовом выражении.",
  "_0_is_referenced_directly_or_indirectly_in_its_own_type_annotation_2502": "На \"{0}\" есть прямые или непрямые ссылки в его собственной аннотации типа.",
  "_0_is_specified_more_than_once_so_this_usage_will_be_overwritten_2783": "\"{0}\" указан несколько раз, поэтому такое использование будет перезаписано.",
  "_0_list_cannot_be_empty_1097": "Список \"{0}\" не может быть пустым.",
  "_0_modifier_already_seen_1030": "Модификатор \"{0}\" уже встречался.",
  "_0_modifier_cannot_appear_on_a_class_element_1031": "Модификатор \"{0}\" не может использоваться в элементе класса.",
  "_0_modifier_cannot_appear_on_a_constructor_declaration_1089": "Модификатор \"{0}\" не может содержаться в объявлении конструктора.",
  "_0_modifier_cannot_appear_on_a_data_property_1043": "Модификатор \"{0}\" не может содержаться в свойстве данных.",
  "_0_modifier_cannot_appear_on_a_module_or_namespace_element_1044": "Модификатор \"{0}\" не может отображаться в модуле или элементе пространства имен.",
  "_0_modifier_cannot_appear_on_a_parameter_1090": "Модификатор \"{0}\" не может содержаться в параметре.",
  "_0_modifier_cannot_appear_on_a_type_member_1070": "Модификатор \"{0}\" не может отображаться в элементе типа.",
  "_0_modifier_cannot_appear_on_an_index_signature_1071": "Модификатор \"{0}\" не может отображаться в сигнатуре индекса.",
  "_0_modifier_cannot_be_used_here_1042": "Модификатор \"{0}\" не может использоваться здесь.",
  "_0_modifier_cannot_be_used_in_an_ambient_context_1040": "Модификатор \"{0}\" не может использоваться в окружающем контексте.",
  "_0_modifier_cannot_be_used_with_1_modifier_1243": "Модификатор \"{0}\" не может использоваться с модификатором \"{1}\".",
  "_0_modifier_cannot_be_used_with_a_class_declaration_1041": "Модификатор \"{0}\" не может использоваться с объявлением класса.",
  "_0_modifier_cannot_be_used_with_a_private_identifier_18019": "Модификатор \"{0}\" запрещено использовать с закрытым идентификатором.",
  "_0_modifier_must_precede_1_modifier_1029": "Модификатор \"{0}\" должен предшествовать модификатору \"{1}\".",
  "_0_needs_an_explicit_type_annotation_2782": "Для \"{0}\" требуется явная заметка с типом.",
  "_0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here_2702": "\"{0}\" относится только к типу, а здесь используется как пространство имен.",
  "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_2693": "\"{0}\" относится только к типу, но используется здесь как значение.",
  "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_2585": "\"{0}\" относится только к типу, но здесь используется как значение. Вы хотите изменить целевую библиотеку? Попробуйте изменить параметр компилятора \"lib\" на es2015 или более поздней версии.",
  "_0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead_2686": "\"{0}\" ссылается на глобальную переменную UMD, но текущий файл является модулем. Рекомендуется добавить импорт.",
  "_0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0_2749": "\"{0}\" относится к значению, но здесь используется как тип. Возможно, вы имели в виду \"typeof {0}\"?",
  "_0_tag_already_specified_1223": "Тег \"{0}\" уже указан.",
  "_0_tag_cannot_be_used_independently_as_a_top_level_JSDoc_tag_1253": "Невозможно использовать тег \"{0}\" независимо в качестве тега верхнего уровня JSDoc.",
  "_0_was_also_declared_here_6203": "Здесь также был объявлен \"{0}\".",
  "_0_was_exported_here_1377": "Здесь был экспортирован \"{0}\".",
  "_0_was_imported_here_1376": "Здесь был импортирован \"{0}\".",
  "_0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type_7010": "\"{0}\", у которого нет аннотации типа возвращаемого значения, неявно имеет тип возвращаемого значения \"{1}\".",
  "_0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type_7055": "\"{0}\", у которого нет заметки с типом возвращаемого значения, неявно имеет тип yield \"{1}\".",
  "abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration_1242": "Модификатор abstract может отображаться только в объявлении класса, метода или свойства.",
  "and_here_6204": "и здесь.",
  "await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_fi_1375": "Выражения \"await\" допускаются только на верхнем уровне файла, если он является модулем, но не имеет импортов и экспортов. Рекомендуется добавить пустой элемент \"export {}\", чтобы сделать этот файл модулем.",
  "await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1308": "Выражения \"await\" допускаются только в асинхронных функциях и на верхних уровнях модулей.",
  "await_expressions_cannot_be_used_in_a_parameter_initializer_2524": "Выражения await не могут быть использованы в инициализаторе параметра.",
  "await_has_no_effect_on_the_type_of_this_expression_80007": "\"await\" не влияет на тип этого выражения.",
  "baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1_6106": "Параметр \"baseUrl\" имеет значение \"{0}\", это значение используется для разрешения безотносительного имени модуля \"{1}\".",
  "can_only_be_used_at_the_start_of_a_file_18026": "\"#!\" можно использовать только в начале файла.",
  "can_only_be_used_in_an_object_literal_property_inside_a_destructuring_assignment_1312": "\"=\" можно использовать только в свойстве объектного литерала в назначении деструктурирования.",
  "case_or_default_expected_1130": "Ожидалось case или default.",
  "class_expressions_are_not_currently_supported_9003": "Выражения class в настоящий момент не поддерживаются.",
  "const_declarations_can_only_be_declared_inside_a_block_1156": "Объявления const можно задать только в блоке.",
  "const_declarations_must_be_initialized_1155": "Объявления \"const\" должны быть инициализированы.",
  "const_enum_member_initializer_was_evaluated_to_a_non_finite_value_2477": "Инициализатор элементов перечисления const был вычислен в неконечное значение.",
  "const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN_2478": "Инициализатор элементов перечисления const был вычислен в запрещенное значение NaN.",
  "const_enum_member_initializers_can_only_contain_literal_values_and_other_computed_enum_values_2474": "Инициализаторы членов перечисления констант могут содержать только литеральные значения и другие вычисляемые значения перечисления.",
  "const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_im_2475": "Перечисления const можно использовать только в выражениях доступа к свойству или индексу, а также в правой части объявления импорта, назначения экспорта или запроса типа.",
  "constructor_cannot_be_used_as_a_parameter_property_name_2398": "Недопустимо использовать constructor как имя свойства параметра.",
  "constructor_is_a_reserved_word_18012": "\"#constructor\" является зарезервированным словом.",
  "delete_cannot_be_called_on_an_identifier_in_strict_mode_1102": "Невозможно вызвать оператор delete с идентификатором в строгом режиме.",
  "delete_this_Project_0_is_up_to_date_because_it_was_previously_built_6360": "удалить это — проект \"{0}\" не требует обновления, так как был собран ранее",
  "export_Asterisk_does_not_re_export_a_default_1195": "\"export *\" не выполняет повторный экспорт элемента по умолчанию.",
  "export_can_only_be_used_in_TypeScript_files_8003": "Элемент \"export =\" можно использовать только в файлах TypeScript.",
  "export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always__2668": "Модификатор export невозможно применить к неоднозначным модулям и улучшениям модулей, так как они всегда видимые.",
  "extends_clause_already_seen_1172": "Предложение extends уже существует.",
  "extends_clause_must_precede_implements_clause_1173": "Предложение extends должно предшествовать предложению implements.",
  "extends_clause_of_exported_class_0_has_or_is_using_private_name_1_4020": "Предложение extends экспортированного класса \"{0}\" имеет или использует закрытое имя \"{1}\".",
  "extends_clause_of_exported_interface_0_has_or_is_using_private_name_1_4022": "Предложение extends экспортированного интерфейса \"{0}\" имеет или использует закрытое имя \"{1}\".",
  "file_6025": "файл",
  "get_and_set_accessor_must_have_the_same_this_type_2682": "Методы доступа \"get\" и \"set\" должны иметь одинаковый тип \"this\".",
  "get_and_set_accessor_must_have_the_same_type_2380": "Методы доступа get и set должны иметь одинаковый тип.",
  "get_and_set_accessors_cannot_declare_this_parameters_2784": "Методы доступа \"get\" и \"set\" не могут объявлять параметры \"this\".",
  "implements_clause_already_seen_1175": "Предложение implements уже существует.",
  "implements_clauses_can_only_be_used_in_TypeScript_files_8005": "Предложения \"implements\" можно использовать только в файлах TypeScript.",
  "import_can_only_be_used_in_TypeScript_files_8002": "Элемент \"import ... =\" можно использовать только в файлах TypeScript.",
  "infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type_1338": "Объявления \"infer\" допустимы только в предложении \"extends\" условного типа.",
  "let_declarations_can_only_be_declared_inside_a_block_1157": "Объявления let можно задать только в блоке.",
  "let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations_2480": "Не допускается использование let в качестве имени в объявлениях let или const.",
  "new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type_7009": "Выражение new, у цели которого нет сигнатуры конструктора, неявно имеет тип any.",
  "options_6024": "параметры",
  "or_expected_1144": "Ожидалось \"{\" или \";\".",
  "package_json_does_not_have_a_0_field_6100": "В package.json нет поля \"{0}\".",
  "package_json_does_not_have_a_typesVersions_entry_that_matches_version_0_6207": "В файле \"package.json\" отсутствует запись \"typesVersions\", соответствующая версии \"{0}\".",
  "package_json_had_a_falsy_0_field_6220": "Файл \"package.json\" содержит поле \"{0}\" со значением false.",
  "package_json_has_0_field_1_that_references_2_6101": "package.json содержит поле \"{0}\" \"{1}\", которое ссылается на \"{2}\".",
  "package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range_6209": "Файл \"package.json\" содержит запись \"typesVersions\" \"{0}\", которая не является допустимым диапазоном semver.",
  "package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_ma_6208": "Файл \"package.json\" содержит запись \"typesVersions\" \"{0}\", которая соответствует версии компилятора \"{1}\", выполняется поиск шаблона для сопоставления имени модуля \"{2}\".",
  "package_json_has_a_typesVersions_field_with_version_specific_path_mappings_6206": "Файл \"package.json\" содержит поле \"typesVersions\" с сопоставлениями путей, зависящих от версии.",
  "paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0_6091": "Параметр paths указан, идет поиск шаблона, соответствующего имени модуля \"{0}\".",
  "readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature_1024": "Модификатор readonly может отображаться только в объявлении свойства или сигнатуре индекса.",
  "readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types_1354": "Модификатор типа \"readonly\" допускается только для типов литерала массива и кортежа.",
  "require_call_may_be_converted_to_an_import_80005": "Вызов \"require\" можно преобразовать в \"import\".",
  "rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0_6107": "Параметр \"rootDirs\" задан; он используется для разрешения относительного имени модуля \"{0}\".",
  "super_can_only_be_referenced_in_a_derived_class_2335": "Ссылка на super может указываться только в производном классе.",
  "super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions_2660": "На super можно ссылаться только в элементах производных классов или литеральных выражениях объекта.",
  "super_cannot_be_referenced_in_a_computed_property_name_2466": "Не допускается ссылка на super в имени вычисляемого свойства.",
  "super_cannot_be_referenced_in_constructor_arguments_2336": "На super невозможно ссылаться в аргументах конструктора.",
  "super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_highe_2659": "super допускается только в элементах литеральных выражений объекта, если параметр target — ES2015 или выше.",
  "super_may_not_use_type_arguments_2754": "\"super\" не может использовать аргументы типа.",
  "super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class_17011": "Перед тем, как получить доступ к свойству \"super\" в конструкторе производного класса, необходимо вызвать \"super\".",
  "super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class_17009": "super следует вызывать перед получением доступа к this в конструкторе производного класса.",
  "super_must_be_followed_by_an_argument_list_or_member_access_1034": "После super должен идти список аргументов или доступ к элементу.",
  "super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_der_2338": "Доступ к свойству super разрешен только в конструкторе, функции-элементе или методе доступа к элементам производного класса.",
  "this_cannot_be_referenced_in_a_computed_property_name_2465": "На this не может указывать ссылка в имени вычисляемого свойства.",
  "this_cannot_be_referenced_in_a_module_or_namespace_body_2331": "На this не могут указывать ссылки в теле модуля или пространства имен.",
  "this_cannot_be_referenced_in_a_static_property_initializer_2334": "На this не могут указывать ссылки в инициализаторе статического свойства.",
  "this_cannot_be_referenced_in_constructor_arguments_2333": "На this не могут указывать ссылки в аргументах конструктора.",
  "this_cannot_be_referenced_in_current_location_2332": "На this не могут указывать ссылки в текущем расположении.",
  "this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_2683": "this неявно содержит тип any, так как он не имеет аннотации типа.",
  "unique_symbol_types_are_not_allowed_here_1335": "Типы \"unique symbol\" здесь запрещены.",
  "unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement_1334": "Типы \"unique symbol\" разрешены только у переменных в операторах с переменными.",
  "unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name_1333": "Типы \"unique symbol\" невозможно использовать в объявлении переменной с именем привязки.",
  "use_strict_directive_cannot_be_used_with_non_simple_parameter_list_1347": "Директиву \"use strict\" запрещено использовать со списком параметров, которые не являются простыми.",
  "use_strict_directive_used_here_1349": "Здесь используется директива \"use strict\".",
  "with_statements_are_not_allowed_in_an_async_function_block_1300": "Операторы with не разрешено использовать в блоке асинхронной функции.",
  "with_statements_are_not_allowed_in_strict_mode_1101": "Операторы with не разрешено использовать в строгом режиме.",
  "yield_expressions_cannot_be_used_in_a_parameter_initializer_2523": "Выражения yield не могут быть использованы в инициализаторе параметра."
}